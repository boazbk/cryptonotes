<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Public key encryption candidates</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Public key encryption candidates" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration"><i class="fa fa-check"></i><b>0.5</b> Concentration</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.1</b> Defining encryptions</a><ul><li class="chapter" data-level="1.1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.1.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.2</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.3</b> Perfect Secrecy</a></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.4</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#advanced-comment-adding-probability-into-the-picture"><i class="fa fa-check"></i><b>1.4.1</b> Advanced comment: Adding probability into the picture</a></li></ul></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#counting-number-of-operations."><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the buffer overflow of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash functions and random oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The bitcoin problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The currency problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The bitcoin ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From proof of work to consensus on ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision resistance hash functions and creating short unique identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical constructions of cryptographic hash functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical random-ish functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some history</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions."><i class="fa fa-check"></i><b>7.4.3</b> The NSA and hash functions.</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs non-cryptographic hash functions:</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#an-lwe-based-encryption-scheme"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> Bonus features of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic escape velocity</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly too ideal definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Public key encryption candidates</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_11_concrete_pkc.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="concrete-candidates-for-public-key-crypto" data-number="11">Concrete candidates for public key crypto</h1>
<p>In the previous lecture we talked about <em>public key cryptography</em> and saw the Diffie Hellman system and the DSA signature scheme. In this lecture, we will see the RSA trapdoor function and how to use it for both encryptions and signatures.</p>
<h2 id="some-number-theory." data-number="11.1">Some number theory.</h2>
<p>(See <a href="http://www.shoup.net/ntb/">Shoup’s excellent and freely available book</a> for extensive coverage of these and many other topics.)</p>
<p>For every number <span><span class="math inline">\(m\)</span></span>, we define <span><span class="math inline">\(\Z_m\)</span></span> to be the set <span><span class="math inline">\(\{0,\ldots,m-1\}\)</span></span> with the addition and multiplication operations modulo <span><span class="math inline">\(m\)</span></span>. When two elements are in <span><span class="math inline">\(\Z_n\)</span></span> then we will always assume that all operations are done modulo <span><span class="math inline">\(m\)</span></span> unless stated otherwise. We let <span><span class="math inline">\(\Z^*_m = \{ a\in \Z_m : gcd(a,m)=1 \}\)</span></span>. Note that <span><span class="math inline">\(m\)</span></span> is prime if and only if <span><span class="math inline">\(|\Z^*_m|=m-1\)</span></span>. For every <span><span class="math inline">\(a \in \Z^*_m\)</span></span> we can find using the extended gcd algorithm an element <span><span class="math inline">\(b\)</span></span> (typically denoted as <span><span class="math inline">\(a^{-1}\)</span></span>) such that <span><span class="math inline">\(ab=1\)</span></span> (can you see why?). The set <span><span class="math inline">\(\Z^*_m\)</span></span> is an abelian group with the multiplication operation, and hence by the observations of the previous lecture, <span><span class="math inline">\(a^{|\Z^*_m|}=1\)</span></span> for every <span><span class="math inline">\(a\in \Z^*_m\)</span></span>. In the case that <span><span class="math inline">\(m\)</span></span> is prime, this result is known as “Fermat’s Little Theorem” and is typically stated as <span><span class="math inline">\(a^{p-1}=1 \pmod{p}\)</span></span> for every <span><span class="math inline">\(a\neq 0\)</span></span>.</p>
<div id="smallvsbigrem" class="remark" title="Note on $n$ bits vs a number $n$" data-number="11.1" name="Remark 11.1 (Note on $n$ bits vs a number $n$) ">
<p>One aspect that is often confusing in number-theoretic based cryptography, is that one needs to always keep track whether we are talking about “big” numbers or “small” numbers. In many cases in crypto, we use <span><span class="math inline">\(n\)</span></span> to talk about our key size or security parameter, in which case we think of <span><span class="math inline">\(n\)</span></span> as a “small” number of size <span><span class="math inline">\(100-1000\)</span></span> or so. However, when we work with <span><span class="math inline">\(\Z^*_m\)</span></span> we often think of <span><span class="math inline">\(m\)</span></span> as a “big” number having about <span><span class="math inline">\(100-1000\)</span></span> <em>digits</em>; that is <span><span class="math inline">\(m\)</span></span> would be roughly <span><span class="math inline">\(2^{100}\)</span></span> to <span><span class="math inline">\(2^{1000}\)</span></span> or so. I will try to reserve the notation <span><span class="math inline">\(n\)</span></span> for “small” numbers but may sometimes forget to do so, and other descriptions of RSA etc.. often use <span><span class="math inline">\(n\)</span></span> for “big” numbers. It is important that whenever you see a number <span><span class="math inline">\(x\)</span></span>, you make sure you have a sense whether it is a “small” number (in which case <span><span class="math inline">\(poly(x)\)</span></span> time is considered efficient) or whether it is a “large” number (in which case only <span><span class="math inline">\(poly(log(x))\)</span></span> time would be considered efficient).</p>
</div>
<div id="numbermvsmessage" class="remark" title="The number $m$ vs the message $m$" data-number="11.1" name="Remark 11.2 (The number $m$ vs the message $m$) ">
<p>In much of this course we use <span><span class="math inline">\(m\)</span></span> to denote a string which is our plaintext message to be encrypted or authenticated. In the context of integer factoring, it is convenient to use <span><span class="math inline">\(m=pq\)</span></span> as the composite number that is to be factored. To keep things interesting (or more honestly, because I keep running out of letters) in this lecture we will have both usages of <span><span class="math inline">\(m\)</span></span> (though hopefully not in the same theorem or definition!). When we talk about factoring, RSA, and Rabin, then we will use <span><span class="math inline">\(m\)</span></span> as the composite number, while in the context of the abstract trapdoor-permutation based encryption and signatures we will use <span><span class="math inline">\(m\)</span></span> for the message. When you see an instance of <span><span class="math inline">\(m\)</span></span>, make sure you understand what is its usage.</p>
</div>
<h3 id="primaliy-testing" data-number="11.1.1">Primaliy testing</h3>
<p>One procedure we often need is to find a prime of <span><span class="math inline">\(n\)</span></span> bits. The typical way people do it is by choosing a random <span><span class="math inline">\(n\)</span></span>-bit number <span><span class="math inline">\(p\)</span></span>, and testing whether it is prime. We showed in the previous lecture that a random <span><span class="math inline">\(n\)</span></span> bit number is prime with probability at least <span><span class="math inline">\(\Omega(1/n^2)\)</span></span> (in fact the probability is <span><span class="math inline">\(\tfrac{1\pm o(1)}{\ln n}\)</span></span> by the <a href="https://goo.gl/ChrXJY">Prime Number Theorem</a>). We now discuss how we can test for primality.</p>
<div id="primalitytesting" class="theorem" title="Primality Testing" data-number="11.1.1" name="Theorem 11.3 (Primality Testing) ">
<p>There is an <span><span class="math inline">\(poly(n)\)</span></span>-time algorithm to test whether a given <span><span class="math inline">\(n\)</span></span>-bit number is prime or composite.</p>
</div>
<p><a href='#primalitytesting'>Theorem 11.3</a> was first shown in 1970’s by Solovay, Strassen, Miller and Rabin via a <em>probabilistic</em> algorithm (that can make a mistake with probability exponentially small in the number of coins it uses), and in a 2002 breakthrough Agrawal, Kayal, and Saxena gave a <em>deterministic</em> polynomial time algorithm for the same problem.</p>
<div id="pseudoprimelem" class="lemma" data-number="11.1.1" name="Lemma 11.4">
<p>There is a probabilistic polynomial time algorithm <span><span class="math inline">\(A\)</span></span> that on input a number <span><span class="math inline">\(m\)</span></span>, if <span><span class="math inline">\(m\)</span></span> is prime <span><span class="math inline">\(A\)</span></span> outputs <code>YES</code> with probability <span><span class="math inline">\(1\)</span></span> and if <span><span class="math inline">\(A\)</span></span> is not even a “pseudoprime” it outputs <code>NO</code> with probability at least <span><span class="math inline">\(1/2\)</span></span>. (The definition of “pseudo-prime” will be clarified in the proof below.)</p>
</div>
<div id="section" class="proof" data-ref="pseudoprimelem" data-number="11.1.1" name="Proof">
<p>The algorithm is very simple and is based on Fermat’s Little Theorem: on input <span><span class="math inline">\(m\)</span></span>, pick a random <span><span class="math inline">\(a\in \{2,\ldots,m-1\}\)</span></span>, and if <span><span class="math inline">\(gcd(a,m)\neq 1\)</span></span> or <span><span class="math inline">\(a^{m-1} \neq 1 \pmod{m}\)</span></span> return <code>NO</code> and otherwise return <code>YES</code>.</p>
<p>By Fermat’s little theorem, the algorithm will always return <code>YES</code> on a prime <span><span class="math inline">\(m\)</span></span>. We define a “pseudoprime” to be a non-prime number <span><span class="math inline">\(m\)</span></span> such that <span><span class="math inline">\(a^{m-1}=1 \pmod{m}\)</span></span> for all <span><span class="math inline">\(a\)</span></span> such that <span><span class="math inline">\(gcd(a,m)=1\)</span></span>.<br />
If <span><span class="math inline">\(n\)</span></span> is <em>not</em> a pseudoprime then the set <span><span class="math inline">\(S = \{ a\in\Z^*_m : a^{m-1}=1 \}\)</span></span> is a strict subset of <span><span class="math inline">\(\Z^*_m\)</span></span>. But it is easy to see that <span><span class="math inline">\(S\)</span></span> is a <em>group</em> and hence <span><span class="math inline">\(|S|\)</span></span> must divide <span><span class="math inline">\(|Z^*_n|\)</span></span> and hence in particular it must be the case that <span><span class="math inline">\(|S| &lt; |\Z^*_n|/2\)</span></span> and so with probability at least <span><span class="math inline">\(1/2\)</span></span> the algorithm will output <code>NO</code>.</p>
</div>
<p><a href='#pseudoprimelem'>Lemma 11.4</a> its own might not seem very meaningful since it’s not clear how many pseudoprimes are there. However, it turns out these pseudoprimes, also known as “Carmichael numbers”, are much less prevalent than the primes, specifically, there are about <span><span class="math inline">\(N/2^{-\Theta(\log N/\log\log N)}\)</span></span> pseudoprimes between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(N\)</span></span>. If we choose a random number <span><span class="math inline">\(m \in [2^n]\)</span></span> and output it if and only if the algorithm of <a href='#pseudoprimelem'>Lemma 11.4</a> algorithm outputs <code>YES</code> (otherwise resampling), then the probability we make a mistake and output a pseudoprime is equal to the ratio of the set of pseudoprimes in <span><span class="math inline">\([2^n]\)</span></span> to the set of primes in <span><span class="math inline">\([2^n]\)</span></span>. Since there are <span><span class="math inline">\(\Omega(2^n/n)\)</span></span> primes in <span><span class="math inline">\([2^n]\)</span></span>, this ratio is <span><span class="math inline">\(\tfrac{n}{2^{-\Omega(n/\log n)}}\)</span></span> which is a negligible quantity. Moreover, as mentioned above, there are better algorithms that succeed for <em>all</em> numbers.</p>
<p>In contrast to <em>testing</em> if a number is prime or composite, there is no known efficient algorithm to actually <em>find</em> the factorization of a composite number. The best known algorithms run in time roughly <span><span class="math inline">\(2^{\tilde{O}(n^{1/3})}\)</span></span> where <span><span class="math inline">\(n\)</span></span> is the number of bits.</p>
<h3 id="fields" data-number="11.1.2">Fields</h3>
<p>If <span><span class="math inline">\(p\)</span></span> is a prime then <span><span class="math inline">\(\Z_p\)</span></span> is a <em>field</em> which means it is closed under addition and multiplication and has <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span> elements. One property of a field is the following:</p>
<div id="bezout" class="theorem" title="Fundamental Theorem of Algebra, mod $p$ version" data-number="11.1.2" name="Theorem 11.5 (Fundamental Theorem of Algebra, mod $p$ version) ">
<p>If <span><span class="math inline">\(f\)</span></span> is a nonzero polynomial of degree <span><span class="math inline">\(d\)</span></span> over <span><span class="math inline">\(\Z_p\)</span></span> then there are at most <span><span class="math inline">\(d\)</span></span> distinct inputs <span><span class="math inline">\(x\)</span></span> such that <span><span class="math inline">\(f(x)=0\)</span></span>.</p>
</div>
<p>(If you’re curious why, you can see that the task of, given <span><span class="math inline">\(x_1,\ldots,x_{d+1}\)</span></span> finding the coefficients for a polynomial vanishing on the <span><span class="math inline">\(x_i\)</span></span>’s amounts to solving a linear system in <span><span class="math inline">\(d+1\)</span></span> variables with <span><span class="math inline">\(d+1\)</span></span> equations that are independent due to the non-singularity of the Vandermonde matrix.)</p>
<p>In particular every <span><span class="math inline">\(x \in \Z_p\)</span></span> has at most two <em>square roots</em> (numbers <span><span class="math inline">\(s\)</span></span> such that <span><span class="math inline">\(s^2 = x \mod p\)</span></span>). In fact, just like over the reals, every <span><span class="math inline">\(x\in\Z_p\)</span></span> either has no square roots or exactly two square roots of the form <span><span class="math inline">\(\pm s\)</span></span>.</p>
<p>We can efficiently find square roots modulo a prime. In fact, the following result is known:</p>
<div id="rootfindingthm" class="theorem" title="Finding roots" data-number="11.1.2" name="Theorem 11.6 (Finding roots) ">
<p>There is a probabilistic <span><span class="math inline">\(poly(\log p,d)\)</span></span> time algorithm to find the roots of a degree <span><span class="math inline">\(d\)</span></span> polynomial over <span><span class="math inline">\(\Z_p\)</span></span>.</p>
</div>
<p>This is a special case of the problem of factoring polynomials over finite fields, shown in 1967 by Berlekamp and on which much other work has been done; see Chapter 20 in <a href="http://www.shoup.net/ntb/">Shoup</a>).</p>
<h3 id="chinese-remainder-theorem" data-number="11.1.3">Chinese remainder theorem</h3>
<p>Suppose that <span><span class="math inline">\(m=pq\)</span></span> is a product of two primes. In this case <span><span class="math inline">\(Z^*_m\)</span></span> does not contain <em>all</em> the numbers from <span><span class="math inline">\(1\)</span></span> to <span><span class="math inline">\(m-1\)</span></span>. Indeed, all the numbers of the form <span><span class="math inline">\(p,2p,3p,\ldots,(q-1)p\)</span></span> and <span><span class="math inline">\(q,2q,\ldots,(p-1)q\)</span></span> will have non-trivial g.c.d. with <span><span class="math inline">\(m\)</span></span>. There are exactly <span><span class="math inline">\(q-1 + p-1\)</span></span> such numbers (because <span><span class="math inline">\(p\)</span></span> and <span><span class="math inline">\(q\)</span></span> are prime all the numbers of the forms above are distinct). Hence <span><span class="math inline">\(|Z^*_m| = m-1 - (p-1) - (q-1) = pq - p - q +1 = (p-1)(q-1)\)</span></span>.</p>
<p>Note that <span><span class="math inline">\(|Z^*_m|=|\Z^*_p|\cdot |\Z^*_q|\)</span></span>. It turns out this is no accident:</p>
<div id="CRTthm" class="theorem" title="Chinese Remainder Theorem (CRT)" data-number="11.1.3" name="Theorem 11.7 (Chinese Remainder Theorem (CRT)) ">
<p>If <span><span class="math inline">\(m=pq\)</span></span> then there is an isomorphism <span><span class="math inline">\(\varphi:\Z^*_m \rightarrow \Z^*_p \times \Z^*_q\)</span></span>. That is, <span><span class="math inline">\(\varphi\)</span></span> is one to one and onto and maps <span><span class="math inline">\(x\in\Z^*_m\)</span></span> into a pair <span><span class="math inline">\((\varphi_1(x),\varphi_2(x)) \in \Z^*_p \times \Z^*_q\)</span></span> such that for every <span><span class="math inline">\(x,y \in \Z^*_m\)</span></span>:<br />
* <span><span class="math inline">\(\varphi_1(x+y) = \varphi_1(x)+\varphi_1(y) \pmod{p}\)</span></span><br />
* <span><span class="math inline">\(\varphi_2(x+y) = \varphi_2(x)+\varphi_2(y) \pmod{q}\)</span></span><br />
* <span><span class="math inline">\(\varphi_1(x\cdot y) = \varphi_1(x)\cdot \varphi_1(y) \pmod{p}\)</span></span><br />
* <span><span class="math inline">\(\varphi_2(x\cdot y) = \varphi_2(x)\cdot \varphi_2(y) \pmod{q}\)</span></span></p>
</div>
<div id="section-1" class="proof" data-ref="CRTthm" data-number="11.1.3" name="Proof">
<p><span><span class="math inline">\(\varphi\)</span></span> simply maps <span><span class="math inline">\(x\in \Z^*_m\)</span></span> to the pair <span><span class="math inline">\((x \mod p, x \mod q)\)</span></span>. Verifying that it satisfies all desired properties is a good exercise. QED</p>
</div>
<p>In particular, for every polynomial <span><span class="math inline">\(f()\)</span></span> and <span><span class="math inline">\(x\in \Z^*_m\)</span></span>, <span><span class="math inline">\(f(x)=0 \pmod{m}\)</span></span> iff <span><span class="math inline">\(f(x)=0 \pmod{p}\)</span></span> and <span><span class="math inline">\(f(x)=0 \pmod{q}\)</span></span>. Therefore finding the roots of a polynomial <span><span class="math inline">\(f()\)</span></span> modulo a composite <span><span class="math inline">\(m\)</span></span> is easy <em>if you know <span><span class="math inline">\(m\)</span></span>’s factorization</em>. However, if you don’t know the factorization then this is hard. In particular, extracting square roots is as hard as finding out the factors:</p>
<div id="squarerootfactthm" class="theorem" title="Square root extraction implies factoring" data-number="11.1.3" name="Theorem 11.8 (Square root extraction implies factoring) ">
<p>Suppose and there is an efficient algorithm <span><span class="math inline">\(A\)</span></span> such that for every <span><span class="math inline">\(m\in \N\)</span></span> and <span><span class="math inline">\(a\in \Z^*_m\)</span></span>, <span><span class="math inline">\(A(m,a^2 \pmod {m})=b\)</span></span> such that <span><span class="math inline">\(a^2 = b^2 \pmod{m}\)</span></span>. Then, there is an efficient algorithm to recover <span><span class="math inline">\(p,q\)</span></span> from <span><span class="math inline">\(m\)</span></span>.</p>
</div>
<div id="section-2" class="proof" data-ref="squarerootfactthm" data-number="11.1.3" name="Proof">
<p>Suppose that there is such an algorithm <span><span class="math inline">\(A\)</span></span>. Using the CRT we can define <span><span class="math inline">\(f:\Z^*_p\times\Z^*_q \rightarrow \Z^*_p\times \Z^*_q\)</span></span> as <span><span class="math inline">\(f(x,y)=\varphi(A(\varphi^{-1}(x^2,y^2)))\)</span></span> for all <span><span class="math inline">\(x\in \Z^*_p\)</span></span> and <span><span class="math inline">\(y\in\Z^*_q\)</span></span>. Now, for any <span><span class="math inline">\(x,y\)</span></span> let <span><span class="math inline">\((x&#39;,y&#39;)=f(x,y)\)</span></span>. Since <span><span class="math inline">\(x^2 = x&#39;^2 \pmod{p}\)</span></span> and <span><span class="math inline">\(y^2 = y&#39;^2 \pmod{q}\)</span></span> we know that <span><span class="math inline">\(x&#39; \in \{\pm x \}\)</span></span> and <span><span class="math inline">\(y&#39; \in \{ \pm y \}\)</span></span>. Since flipping signs doesn’t change the value of <span><span class="math inline">\((x&#39;,y&#39;)=f(x,y)\)</span></span>, by flipping one or both of the signs of <span><span class="math inline">\(x\)</span></span> or <span><span class="math inline">\(y\)</span></span> we can ensure that <span><span class="math inline">\(x&#39;=x\)</span></span> and <span><span class="math inline">\(y&#39;=-y\)</span></span>. Hence <span><span class="math inline">\((x,y)-(x&#39;,y&#39;)=(0,2y)\)</span></span>. In other words, if <span><span class="math inline">\(c = \varphi^{-1}(x-x&#39;,y-y&#39;)\)</span></span> then <span><span class="math inline">\(c= 0 \pmod{p}\)</span></span> but <span><span class="math inline">\(c \neq 0 \pmod{q}\)</span></span> which in particular means that the greatest common divisor of <span><span class="math inline">\(c\)</span></span> and <span><span class="math inline">\(m\)</span></span> is <span><span class="math inline">\(q\)</span></span>. So, by taking <span><span class="math inline">\(gcd(A(\varphi^{-1}(x,y)),m)\)</span></span> we will find <span><span class="math inline">\(q\)</span></span>, from which we can find <span><span class="math inline">\(p=m/q\)</span></span>.</p>
<p>This almost works, but there is a question of how can we find <span><span class="math inline">\(\varphi^{-1}(x,y)\)</span></span>, given that we don’t know <span><span class="math inline">\(p\)</span></span> and <span><span class="math inline">\(q\)</span></span>? The crucial observation is that we don’t need to. We can simply pick a value <span><span class="math inline">\(a\)</span></span> at random in <span><span class="math inline">\(\{1,\ldots,m\}\)</span></span>. With very high probability (namely <span><span class="math inline">\((p-1+q-1)/pq\)</span></span>) <span><span class="math inline">\(a\)</span></span> will be in <span><span class="math inline">\(\Z^*_m\)</span></span>, and so we can imagine this process as equivalent to the process of taking a random <span><span class="math inline">\(x\in\Z^*_p\)</span></span>, a random <span><span class="math inline">\(y\in \Z^*_q\)</span></span> and then flipping the signs of <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span> randomly and taking <span><span class="math inline">\(a=\varphi(x,y)\)</span></span>. By the arguments above with probability at least <span><span class="math inline">\(1/4\)</span></span>, it will hold that <span><span class="math inline">\(gcd(a-A(a^2),m)\)</span></span> will equal <span><span class="math inline">\(q\)</span></span>.</p>
</div>
<p>Note that this argument generalizes to work even if the algorithm <span><span class="math inline">\(A\)</span></span> is an <em>average case</em> algorithm that only succeeds in finding a square root for a significant fraction of the inputs. This observation is crucial for cryptographic applications.</p>
<h3 id="the-rsa-and-rabin-functions" data-number="11.1.4">The RSA and Rabin functions</h3>
<p>We are now ready to describe the RSA and Rabin trapdoor functions:</p>
<div id="RSAfuncdef" class="definition" title="RSA function" data-number="11.1.4" name="Definition 11.9 (RSA function) ">
<p>Given a number <span><span class="math inline">\(m=pq\)</span></span> and <span><span class="math inline">\(e\)</span></span> such that <span><span class="math inline">\(gcd((p-1)(q-1),e)=1\)</span></span>, the <em>RSA function</em> w.r.t <span><span class="math inline">\(m\)</span></span> and <span><span class="math inline">\(e\)</span></span> is the map <span><span class="math inline">\(f_{m,e}:\Z^*_m\rightarrow\Z^*_m\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{RSA}}_{m,e}(x) = x^e \pmod{m}\)</span></span>.</p>
</div>
<div id="Rabinfuncdef" class="definition" title="Rabin function" data-number="11.1.4" name="Definition 11.10 (Rabin function) ">
<p>Given a number <span><span class="math inline">\(m=pq\)</span></span>, the <em>Rabin function</em> w.r.t. <span><span class="math inline">\(m\)</span></span>, is the map <span><span class="math inline">\(Rabin_m:\Z^*_m\rightarrow \Z^*_m\)</span></span> such that <span><span class="math inline">\(Rabin_m(x)=x^2 \pmod{m}\)</span></span>.</p>
</div>
<p>Note that both maps can be computed in polynomial time. Using the Chinese Remainder Theorem and <a href='#rootfindingthm'>Theorem 11.6</a>, we know that both functions can be <em>inverted</em> efficiently if we know the factorization.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><br />
However <a href='#rootfindingthm'>Theorem 11.6</a> is a much too big of a Hammer to invert the RSA and Rabin functions, and there are direct and simple inversion algorithms (see homework exercises). By <a href='#squarerootfactthm'>Theorem 11.8</a>, inverting the Rabin function amounts to factoring <span><span class="math inline">\(m\)</span></span>. No such result is known for the RSA function, but there is no better algorithm known to attack it than proceeding via factorization of <span><span class="math inline">\(m\)</span></span>. The RSA function has the advantage that it is a <em>permutation</em> over <span><span class="math inline">\(\Z^*_m\)</span></span>:</p>
<div id="RSAonetoonelem" class="lemma" data-number="11.1.4" name="Lemma 11.11">
<p><span><span class="math inline">\(\ensuremath{\mathit{RSA}}_{m,e}\)</span></span> is one to one over <span><span class="math inline">\(\Z^*_m\)</span></span>.</p>
</div>
<div id="section-3" class="proof" data-ref="RSAonetoonelem" data-number="11.1.4" name="Proof">
<p>Suppose that <span><span class="math inline">\(\ensuremath{\mathit{RSA}}_{m,e}(a)=\ensuremath{\mathit{RSA}}_{m,e}(a&#39;)\)</span></span>. By the CRT, it means that there is <span><span class="math inline">\((x,y) \neq (x&#39;,y&#39;) \in \Z^*_p \times \Z^*_q\)</span></span> such that <span><span class="math inline">\(x^e = x&#39;^e \pmod{p}\)</span></span> and <span><span class="math inline">\(y^e = y&#39;^e \pmod{q}\)</span></span>. But if that’s the case we get that <span><span class="math inline">\((xx&#39;^{-1})^e = 1 \pmod{p}\)</span></span> and <span><span class="math inline">\((yy&#39;^{-1})^e = 1 \pmod{q}\)</span></span>. But this means that <span><span class="math inline">\(e\)</span></span> has to be a multiple of the <em>order</em> of <span><span class="math inline">\(xx&#39;^{-1}\)</span></span> and <span><span class="math inline">\(yy&#39;^{-1}\)</span></span> (at least one of which is <em>not</em> <span><span class="math inline">\(1\)</span></span> and hence has order <span><span class="math inline">\(&gt;1\)</span></span>). But since the order always divides the group size, this implies that <span><span class="math inline">\(e\)</span></span> has to have non-trivial gcd with either <span><span class="math inline">\(|Z^*_p|\)</span></span> or <span><span class="math inline">\(|\Z^*_q|\)</span></span> and hence with <span><span class="math inline">\((p-1)(q-1)\)</span></span>.</p>
</div>
<div id="plainrsarem" class="remark" title="Plain/Textbook RSA" data-number="11.1.4" name="Remark 11.12 (Plain/Textbook RSA) ">
<p>The RSA trapdoor function is known also as “plain” or “textbook” RSA encryption. This is because initially Diffie and Hellman (and following them, RSA) thought of an encryption scheme as a deterministic procedure and so considered simply encrypting a message <span><span class="math inline">\(x\)</span></span> by applying <span><span class="math inline">\(\ensuremath{\mathit{ESA}}_{m,e}(x)\)</span></span>. Today however we know that it is insecure to use a trapdoor function directly as an encryption scheme without adding some randomization.</p>
</div>
<h3 id="abstraction-trapdoor-permutations" data-number="11.1.5">Abstraction: trapdoor permutations</h3>
<p>We can abstract away the particular construction of the RSA and Rabin functions to talk about a general <em>trapdoor permutation family</em>. We make the following definition</p>
<div id="TDPdef" class="definition" title="Trapdoor permutation" data-number="11.1.5" name="Definition 11.13 (Trapdoor permutation) ">
<p>A <em>trapdoor permutation family (TDP)</em> is a family of functions <span><span class="math inline">\(\{ p_k \}\)</span></span> such that for every <span><span class="math inline">\(k\in\{0,1\}^n\)</span></span>, the function <span><span class="math inline">\(p_k\)</span></span> is a permutation on <span><span class="math inline">\(\{0,1\}^n\)</span></span> and:<br />
* There is a <em>key generation algorithm</em> <span><span class="math inline">\(G\)</span></span> such that on input <span><span class="math inline">\(1^n\)</span></span> it outputs a pair <span><span class="math inline">\((k,\tau)\)</span></span> such that the maps <span><span class="math inline">\(k,x \mapsto p_k(x)\)</span></span> and <span><span class="math inline">\(\tau,y \mapsto p_k^{-1}(y)\)</span></span> are efficiently computable.</p>
<ul>
<li>For every efficient adversary <span><span class="math inline">\(A\)</span></span>, <span><span class="math inline">\(\Pr_{(k,\tau) \leftarrow_R G(1^n), y\in\{0,1\}^n}[ A(k,y)=p_k^{-1}(y) ] &lt; negl(n)\)</span></span>.<br />
</li>
</ul>
</div>
<p><br />
</p>
<p><br />
</p>
<div id="permutationsovergroups" class="remark" title="Domain of permutations" data-number="11.1.5" name="Remark 11.14 (Domain of permutations) ">
<p>The RSA function is not a permutation over the set of strings but rather over <span><span class="math inline">\(\Z^*_m\)</span></span> for some <span><span class="math inline">\(m=pq\)</span></span>. However, if we find primes <span><span class="math inline">\(p,q\)</span></span> in the interval <span><span class="math inline">\([2^{n/2}(1-negl(n)),2^{n/2}]\)</span></span>, then <span><span class="math inline">\(m\)</span></span> will be in the interval <span><span class="math inline">\([2^n(1-negl(n)),2^n]\)</span></span> and hence <span><span class="math inline">\(\Z^*_m\)</span></span> (which has size <span><span class="math inline">\(pq - p - q +1 = 2^n(1-negl(n))\)</span></span>) can be thought of as essentially identical to <span><span class="math inline">\(\{0,1\}^n\)</span></span>, since we will always pick elements from <span><span class="math inline">\(\{0,1\}^n\)</span></span> at random and hence they will be in <span><span class="math inline">\(\Z^*_m\)</span></span> with probability <span><span class="math inline">\(1-negl(n)\)</span></span>. It is widely believed that for every sufficiently large <span><span class="math inline">\(n\)</span></span> there is a prime in the interval <span><span class="math inline">\([2^n-poly(n),2^n]\)</span></span> (this follows from the <em>Extended Reimann Hypothesis</em>) and Baker, Harman and Pintz <em>proved</em> that there is a prime in the interval <span><span class="math inline">\([2^n-2^{0.6n},2^n]\)</span></span>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
</div>
<h3 id="public-key-encryption-from-trapdoor-permutations" data-number="11.1.6">Public key encryption from trapdoor permutations</h3>
<p>Here is how we can get a public key encryption from a trapdoor permutation scheme <span><span class="math inline">\(\{ p_k \}\)</span></span>.</p>
<blockquote>
<p><strong>TDP-based public key encryption (TDPENC):</strong></p>
<ul>
<li><p><em>Key generation:</em> Run the key generation algorithm of the TDP to get <span><span class="math inline">\((k,\tau)\)</span></span>. <span><span class="math inline">\(k\)</span></span> is the <em>public encryption key</em> and <span><span class="math inline">\(\tau\)</span></span> is the <em>secret decryption key</em>.</p></li>
<li><p><em>Encryption:</em> To encrypt a message <span><span class="math inline">\(m\)</span></span> with key <span><span class="math inline">\(k\in\{0,1\}^n\)</span></span>, choose <span><span class="math inline">\(x\in\{0,1\}^n\)</span></span> and output <span><span class="math inline">\((p_k(x),H(x)\oplus m)\)</span></span> where <span><span class="math inline">\(H:\{0,1\}^n\rightarrow\{0,1\}^\ell\)</span></span> is a hash function we model as a random oracle.</p></li>
<li><p><em>Decryption:</em> To decrypt the ciphertext <span><span class="math inline">\((y,z)\)</span></span> with key <span><span class="math inline">\(\tau\)</span></span>, output <span><span class="math inline">\(m=H(p_k^{-1}(y))\oplus z\)</span></span>.</p></li>
</ul>
</blockquote>
<div id="section-4" class="pause" data-number="11.1.6" name="Pause">
<p>Please verify that you understand why TDPENC is a <em>valid</em> encryption scheme, in the sense that decryption of an encryption of <span><span class="math inline">\(m\)</span></span> yields <span><span class="math inline">\(m\)</span></span>.</p>
</div>
<div id="TDPpkcthm" class="theorem" title="Public key encryption from trapdoor permutations" data-number="11.1.6" name="Theorem 11.15 (Public key encryption from trapdoor permutations) ">
<p>If <span><span class="math inline">\(\{ p_k \}\)</span></span> is a secure TDP and <span><span class="math inline">\(H\)</span></span> is a random oracle then TDPENC is a CPA secure public key encryption scheme.</p>
</div>
<div id="section-5" class="proof" data-ref="TDPpkcthm" data-number="11.1.6" name="Proof">
<p>Suppose, towards the sake of contradiction, that there is a polynomial-size adversary <span><span class="math inline">\(A\)</span></span> that succeeds in the CPA game of TDPENC (with access to a random oracle <span><span class="math inline">\(H\)</span></span>) with non-negligible advantage <span><span class="math inline">\(\epsilon\)</span></span> over half. We will use <span><span class="math inline">\(A\)</span></span> to design an algorithm <span><span class="math inline">\(I\)</span></span> that inverts the trapdoor permutation.</p>
<p>Recall that the CPA game works as follows:</p>
<ul>
<li><p>The adversary <span><span class="math inline">\(A\)</span></span> gets as input a key <span><span class="math inline">\(k \in \{0,1\}^n\)</span></span>.</p></li>
<li><p>The algorithm <span><span class="math inline">\(A\)</span></span> makes some polynomial amount of computation and <span><span class="math inline">\(T_1=poly(n)\)</span></span> queries to the random oracle <span><span class="math inline">\(H\)</span></span> and produces a pair of messages <span><span class="math inline">\(m_0,m_1 \in \{0,1\}^\ell\)</span></span>.</p></li>
<li><p>The “challenger” chooses <span><span class="math inline">\(b^* \leftarrow_R \{0,1\}\)</span></span>, chooses <span><span class="math inline">\(x^* \leftarrow_R \{0,1\}^n\)</span></span> and computes the ciphertext <span><span class="math inline">\((y^*=p_k(x^*),z^* = H(x^*) \oplus m_{b^*})\)</span></span> which is an encryption of <span><span class="math inline">\(m_{b^*}\)</span></span>.</p></li>
<li><p>The adversary <span><span class="math inline">\(A\)</span></span> gets <span><span class="math inline">\((y^*,z^*)\)</span></span> as input, makes some additional polynomial amount of computation and <span><span class="math inline">\(T_2=poly(n)\)</span></span> queries to <span><span class="math inline">\(H\)</span></span>, and then outputs <span><span class="math inline">\(b\)</span></span>.</p></li>
<li><p>The adversary <em>wins</em> if <span><span class="math inline">\(b=b^*\)</span></span>.</p></li>
</ul>
<p>We make the following claim:</p>
<p><strong>CLAIM:</strong> With probability at least <span><span class="math inline">\(\epsilon\)</span></span>, the adversary <span><span class="math inline">\(A\)</span></span> will make the query <span><span class="math inline">\(x^*\)</span></span> to the random oracle.</p>
<p><strong>PROOF:</strong> Suppose otherwise. We will prove the claim using the “forgetful gnome” technique as used in the Boneh Shoup book. By the “lazy evaluation” paradigm, we can imagine that queries to <span><span class="math inline">\(H\)</span></span> are answered by a “faithful gnome” that whenever presented with a new query <span><span class="math inline">\(x\)</span></span>, chooses a uniform and independent value <span><span class="math inline">\(w \leftarrow_R \{0,1\}^\ell\)</span></span> as a response, and then records that <span><span class="math inline">\(H(x)=w\)</span></span> to use that as answers for future queries.</p>
<p>Now consider the experiment where in the challenge part we use a “forgetful gnome” that answers <span><span class="math inline">\(H(x^*)\)</span></span> by a uniform and independent string <span><span class="math inline">\(w^* \leftarrow_R \{0,1\}^\ell\)</span></span> and <em>does not</em> record the answer for future queries. In the “forgetful experiment”, the second component of the ciphertext <span><span class="math inline">\(z^* = w^* \oplus m_{b^*}\)</span></span> is distributed uniformly in <span><span class="math inline">\(\{0,1\}^\ell\)</span></span> and independently from all other random choices, regardless of whether <span><span class="math inline">\(b^*=0\)</span></span> or <span><span class="math inline">\(b^*=1\)</span></span>. Hence in this “forgetful experiment” the adversary gets no information about <span><span class="math inline">\(b^*\)</span></span> and its probability of winning is at most <span><span class="math inline">\(1/2\)</span></span>. But the forgetful experiment is identical to the actual experiment if the value <span><span class="math inline">\(x^*\)</span></span> is only queried to <span><span class="math inline">\(H\)</span></span> once. Apart from the query of <span><span class="math inline">\(x^*\)</span></span> by the challenger, all other queries to <span><span class="math inline">\(H\)</span></span> are made by the adversary. Under our assumption, the adversary makes the query <span><span class="math inline">\(x^*\)</span></span> with probability at most <span><span class="math inline">\(\epsilon\)</span></span>, and conditioned on this not happening the two experiments are identical. Since the probability of winning in the forgetful experiment is at most <span><span class="math inline">\(1/2\)</span></span>, the probability of winning in the overall experiment is less than <span><span class="math inline">\(1/2+\epsilon\)</span></span>, thus yielding a contradiction and establishing the claim. (These kind of analyses on sample spaces can be confusing; See <a href='#TDPENCgnomefig'>Figure 11.1</a> for a graphical illustration of this argument.)</p>
<p>Given the claim, we can now construct our inverter algorithm <span><span class="math inline">\(I\)</span></span> as follows:</p>
<ul>
<li><p>The input to <span><span class="math inline">\(I\)</span></span> is the key <span><span class="math inline">\(k\)</span></span> to the trapdoor permutation and <span><span class="math inline">\(y^* = p_k(x^*)\)</span></span>. The goal of <span><span class="math inline">\(I\)</span></span> is to output <span><span class="math inline">\(x^*\)</span></span>.</p></li>
<li><p>The inverter simulates the adversary in a CPA attack, answering all its queries to the oracle <span><span class="math inline">\(H\)</span></span> by random values if they are new or the previously supplied answers if they were asked before. Whenever the adversary makes a query <span><span class="math inline">\(x\)</span></span> to <span><span class="math inline">\(H\)</span></span>, <span><span class="math inline">\(I\)</span></span> checks if <span><span class="math inline">\(p_h(x)=y^*\)</span></span> and if so halts and outputs <span><span class="math inline">\(x\)</span></span>.</p></li>
<li><p>When the time comes to produce the challenge, the inverter <span><span class="math inline">\(I\)</span></span> chooses <span><span class="math inline">\(z^*\)</span></span> at random and provides the adversary with <span><span class="math inline">\((y^*,z^*)\)</span></span> where <span><span class="math inline">\(z^* = w^* \oplus m_{b^*}\)</span></span>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p></li>
<li><p>The inverter continues the simulation again halting an outputting <span><span class="math inline">\(x\)</span></span> if the adversary makes the query <span><span class="math inline">\(x\)</span></span> such that <span><span class="math inline">\(p_k(x)=y^*\)</span></span> to <span><span class="math inline">\(H\)</span></span>.</p></li>
</ul>
<p>We claim that up to the point we halt, the experiment is identical to the actual attack. Indeed, since <span><span class="math inline">\(p_k\)</span></span> is a permutation, we know that if the time came to produce the challenge and we have not halted, then the query <span><span class="math inline">\(x^*\)</span></span> has not been made yet to <span><span class="math inline">\(H\)</span></span>. Therefore we are free to choose an independent random value <span><span class="math inline">\(w^*\)</span></span> as the value <span><span class="math inline">\(H(x^*)\)</span></span>. (Our inverter does not know what the value <span><span class="math inline">\(x^*\)</span></span> is, but this does not matter for this argument: can you see why?) Therefore, since by the claim the adversary will make the query <span><span class="math inline">\(x^*\)</span></span> to <span><span class="math inline">\(H\)</span></span> with probability at least <span><span class="math inline">\(\epsilon\)</span></span>, our inverter will succeed with the same probability.</p>
</div>
<figure>
<img src="../figure/gnomeTDPENC.png" alt="11.1: In the proof of security of TDPENC, we show that if the assumption of the claim is violated, the “forgetful experiment” is identical to the real experiment with probability larger 1-\epsilon. In such a case, even if all that probability mass was on the points in the sample space where the adversary in the forgetful experiment will lose and the adversary of the real experiment will win, the probability of winning in the latter experiment would still be less than 1/2+\epsilon." id="TDPENCgnomefig" class="margin" /><figcaption>11.1: In the proof of security of TDPENC, we show that if the assumption of the claim is violated, the “forgetful experiment” is identical to the real experiment with probability larger <span><span class="math inline">\(1-\epsilon\)</span></span>. In such a case, even if all that probability mass was on the points in the sample space where the adversary in the forgetful experiment will lose and the adversary of the real experiment will win, the probability of winning in the latter experiment would still be less than <span><span class="math inline">\(1/2+\epsilon\)</span></span>.</figcaption>
</figure>
<div id="section-6" class="pause" data-number="11.1.6" name="Pause">
<p>This proof of <a href='#TDPpkcthm'>Theorem 11.15</a> is not very long but it is somewhat subtle. Please re-read it and make sure you understand it. I also recommend you look at the version of the same proof in Boneh Shoup: Theorem 11.2 in Section 11.4 (“Encryption based on a trapdoor function scheme”).</p>
</div>
<div id="noromtdpthm" class="remark" title="Security without random oracles" data-number="11.1.6" name="Remark 11.16 (Security without random oracles) ">
<p>We do <em>not</em> need to use a random oracle to get security in this scheme, especially if <span><span class="math inline">\(\ell\)</span></span> is sufficiently short. We can replace <span><span class="math inline">\(H()\)</span></span> with a hash function of specific properties known as a <em>hard core</em> construction; this was first shown by Goldreich and Levin.</p>
</div>
<h3 id="digital-signatures-from-trapdoor-permutations" data-number="11.1.7">Digital signatures from trapdoor permutations</h3>
<p>Here is how we can get digital signatures from trapdoor permutations <span><span class="math inline">\(\{ p_k \}\)</span></span>. This is known as the “full domain hash” signatures.</p>
<blockquote>
<p><strong>Full domain hash signatures (FDHSIG):</strong></p>
<ul>
<li><p><em>Key generation:</em> Run the key generation algorithm of the TDP to get <span><span class="math inline">\((k,\tau)\)</span></span>. <span><span class="math inline">\(k\)</span></span> is the <em>public verification key</em> and <span><span class="math inline">\(\tau\)</span></span> is the <em>secret signing key</em>.</p></li>
<li><p><em>Signing:</em> To sign a message <span><span class="math inline">\(m\)</span></span> with key <span><span class="math inline">\(\tau\)</span></span>, we output <span><span class="math inline">\(p_{k}^{-1}(H(m))\)</span></span> where <span><span class="math inline">\(H:\{0,1\}^*\rightarrow\{0,1\}^n\)</span></span> is a hash function modeled as a random oracle.</p></li>
<li><p><em>Verification:</em> To verify a message-signature pair <span><span class="math inline">\((m,x)\)</span></span> we check that <span><span class="math inline">\(p_k(x)=H(m)\)</span></span>.</p></li>
</ul>
</blockquote>
<p>We now prove the security of full domain hash:</p>
<div id="FDHthm" class="theorem" title="Full domain hash security" data-number="11.1.7" name="Theorem 11.17 (Full domain hash security) ">
<p>If <span><span class="math inline">\(\{ p_k \}\)</span></span> is a secure TDP and <span><span class="math inline">\(H\)</span></span> is a random oracle then FDHSIG is chosen message attack secure digital signature scheme.</p>
</div>
<div id="section-7" class="proof" data-ref="FDHthm" data-number="11.1.7" name="Proof">
<p>Suppose towards the sake of contradiction that there is a polynomial-sized adversary <span><span class="math inline">\(A\)</span></span> that succeeds in a chosen message attack with non-negligible probability <span><span class="math inline">\(\epsilon&gt;0\)</span></span>. We will construct an inverter <span><span class="math inline">\(I\)</span></span> for the trapdoor permutation collection that succeeds with non-negligible probability as well.</p>
<p>Recall that in a chosen message attack the adversary makes <span><span class="math inline">\(T\)</span></span> queries <span><span class="math inline">\(m_1,\ldots,m_T\)</span></span> to its signing box which are interspersed with <span><span class="math inline">\(T&#39;\)</span></span> queries <span><span class="math inline">\(m&#39;_1,\ldots,m&#39;_{T&#39;}\)</span></span> to the random oracle <span><span class="math inline">\(H\)</span></span>. We can assume without loss of generality (by modifying the adversary and at most doubling the number of queries) that the adversary always queries the message <span><span class="math inline">\(m_i\)</span></span> to the random oracle <em>before</em> it queries it to the signing box, though it can also make additional queries to the random oracle (and hence in particular <span><span class="math inline">\(T&#39; \geq T\)</span></span>). At the end of the attack the adversary outputs with probability <span><span class="math inline">\(\epsilon\)</span></span> a pair <span><span class="math inline">\((x^*,m^*)\)</span></span> such that <span><span class="math inline">\(m^*\)</span></span> was not queried to the signing box and <span><span class="math inline">\(p_k(x^*)=H(m^*)\)</span></span>.</p>
<p>Our inverter <span><span class="math inline">\(I\)</span></span> works as follows:</p>
<ul>
<li><p><strong>Input:</strong> <span><span class="math inline">\(k\)</span></span> and <span><span class="math inline">\(y^*=p_k(y^*)\)</span></span>. Goal is to output <span><span class="math inline">\(x^*\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(I\)</span></span> will guess at random <span><span class="math inline">\(t^*\)</span></span> which is the step in which the adversary will query to <span><span class="math inline">\(H\)</span></span> the message <span><span class="math inline">\(m^*\)</span></span> that it is eventually going to forge in. With probability <span><span class="math inline">\(1/T&#39;\)</span></span> the guess will be correct.</p></li>
<li><p><span><span class="math inline">\(I\)</span></span> simulates the execution of <span><span class="math inline">\(A\)</span></span>. Except for step <span><span class="math inline">\(t^*\)</span></span>, whenever <span><span class="math inline">\(A\)</span></span> makes a new query <span><span class="math inline">\(m\)</span></span> to the random oracle, <span><span class="math inline">\(I\)</span></span> will choose a random <span><span class="math inline">\(x\leftarrow \{0,1\}^n\)</span></span>, compute <span><span class="math inline">\(y=p_k(x)\)</span></span> and designate <span><span class="math inline">\(H(m)=y\)</span></span>. In step <span><span class="math inline">\(t^*\)</span></span>, when the adversary makes the query <span><span class="math inline">\(m^*\)</span></span>, the inverter <span><span class="math inline">\(I\)</span></span> will return <span><span class="math inline">\(H(m^*)=y^*\)</span></span>. <span><span class="math inline">\(I\)</span></span> will record the values <span><span class="math inline">\((x,y)\)</span></span> and so in particular will always know <span><span class="math inline">\(p_k^{-1}(H(m))\)</span></span> for every <span><span class="math inline">\(H(m) \neq y^*\)</span></span> that it returned as answer from its oracle on query <span><span class="math inline">\(m\)</span></span>.</p></li>
<li><p>When <span><span class="math inline">\(A\)</span></span> makes the query <span><span class="math inline">\(m\)</span></span> to the signature box, then since <span><span class="math inline">\(m\)</span></span> was queried before to <span><span class="math inline">\(H\)</span></span>, if <span><span class="math inline">\(m \neq m^*\)</span></span> then <span><span class="math inline">\(I\)</span></span> returns <span><span class="math inline">\(x=p_k^{-1}(H(m))\)</span></span> using its records. If <span><span class="math inline">\(m=m^*\)</span></span> then <span><span class="math inline">\(I\)</span></span> halts and outputs “failure”.</p></li>
<li><p>At the end of the game, the adversary outputs <span><span class="math inline">\((m^*,x^*)\)</span></span>. If <span><span class="math inline">\(p_k(x^*)=y^*\)</span></span> then <span><span class="math inline">\(I\)</span></span> outputs <span><span class="math inline">\(x^*\)</span></span>.</p></li>
</ul>
<p>We claim that, conditioned on the probability <span><span class="math inline">\(\geq \epsilon/T&#39;\)</span></span> event that the adversary is successful and the final message <span><span class="math inline">\(m^*\)</span></span> is the one queried in step <span><span class="math inline">\(t^*\)</span></span>, we provide a perfect simulation of the actual game. Indeed, while in an actual game, the value <span><span class="math inline">\(y=H(m)\)</span></span> will be chosen independently at random in <span><span class="math inline">\(\{0,1\}^n\)</span></span>, this is equivalent to choosing <span><span class="math inline">\(x \leftarrow_R \{0,1\}^n\)</span></span> and letting <span><span class="math inline">\(y=p_k(x)\)</span></span>. After all, a permutation applied to the uniform distribution is uniform.</p>
<p>Therefore with probability at least <span><span class="math inline">\(\epsilon/T&#39;\)</span></span> the inverter <span><span class="math inline">\(I\)</span></span> will output <span><span class="math inline">\(x^*\)</span></span> such that <span><span class="math inline">\(p_k(x^*)=y^*\)</span></span> hence succeeding in the inverter.</p>
</div>
<div id="section-8" class="pause" data-number="11.1.7" name="Pause">
<p>Once again, this proof is somewhat subtle. I recommend you also read the version of this proof in Section 13.4 of Boneh-Shoup.</p>
</div>
<div id="hashandsignrem" class="remark" title="Hash and sign" data-number="11.1.7" name="Remark 11.18 (Hash and sign) ">
<p>There is another reason to use hash functions with signatures. By combining a collision-resistant hash function <span><span class="math inline">\(h:\{0,1\}^* \rightarrow \{0,1\}^\ell\)</span></span> with a signature scheme <span><span class="math inline">\((S,V)\)</span></span> for <span><span class="math inline">\(\ell\)</span></span>-length messages, we can obtain a signature for arbitrary length messages by defining <span><span class="math inline">\(S&#39;_s(m)=S_s(h(m))\)</span></span> and <span><span class="math inline">\(V&#39;_v(m,\sigma)=V_v(h(m),\sigma)\)</span></span>.</p>
</div>
<h2 id="hardcore-bits-and-security-without-random-oracles" data-number="11.2">Hardcore bits and security without random oracles</h2>
<p>To be completed.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>Using <a href='#rootfindingthm'>Theorem 11.6</a> to invert the function requires <span><span class="math inline">\(e\)</span></span> to be not too large. However, as we will see below it turns out that using the factorization we can invert the RSA function for every <span><span class="math inline">\(e\)</span></span>. Also, in practice people often use a small value for <span><span class="math inline">\(e\)</span></span> (sometimes as small as <span><span class="math inline">\(e=3\)</span></span>) for reasons of efficiency.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>Another, more minor issue is that the description of the key might not have the same length as <span><span class="math inline">\(\log m\)</span></span>; I defined them to be the same for simplicity of notation, and this can be ensured via some padding and concatenation tricks.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>It would have been equivalent to answer the adversary with a uniformly chosen <span><span class="math inline">\(z^*\)</span></span> in <span><span class="math inline">\(\{0,1\}^\ell\)</span></span>, can you see why?</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Public key encryption candidates+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/29/2019 17:55:56</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_11_concrete_pkc.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
