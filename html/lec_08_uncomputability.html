<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: Universality and uncomputability</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: Universality and uncomputability" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->



<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.1</b> Exercises</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Universality and uncomputability</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_08_uncomputability.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="chapcomputable" data-number="8">Universality and uncomputability</h1>
<div id="section" class="objectives" name="Objectives">
<ul>
<li>The universal machine/program - “one program to rule them all”</li>
<li>A fundamental result in computer science and mathematics: the existence of uncomputable functions.</li>
<li>The <em>halting problem</em>: the canonical example of an uncomputable function.</li>
<li>Introduction to the technique of <em>reductions</em>.</li>
<li>Rice’s Theorem: A “meta tool” for uncomputability results, and a starting point for much of the research on compilers, programming languages, and software verification.</li>
</ul>
</div>
<blockquote>
<p><em>“A function of a variable quantity is an analytic expression composed in any way whatsoever of the variable quantity and numbers or constant quantities.”</em>, Leonhard Euler, 1748.</p>
</blockquote>
<blockquote>
<p><em>“The importance of the universal machine is clear. We do not need to have an infinity of different machines doing different jobs. … The engineering problem of producing various machines for various jobs is replaced by the office work of ‘programming’ the universal machine”</em>, Alan Turing, 1948</p>
</blockquote>
<p>One of the most significant results we showed for Boolean circuits (or equivalently, straight-line programs) is the notion of <em>universality</em>: there is a single circuit that can evaluate all other circuits. However, this result came with a significant caveat. To evaluate a circuit of <span><span class="math inline">\(s\)</span></span> gates, the universal circuit needed to use a number of gates <em>larger</em> than <span><span class="math inline">\(s\)</span></span>. It turns out that uniform models such as Turing machines or NAND-TM programs allow us to “break out of this cycle” and obtain a truly <em>universal Turing machine</em> <span><span class="math inline">\(U\)</span></span> that can evaluate all other machines, including machines that are more complex (e.g., more states) than <span><span class="math inline">\(U\)</span></span> itself. (Similarly, there is a <em>Universal NAND-TM program</em> <span><span class="math inline">\(U&#39;\)</span></span> that can evaluate all NAND-TM programs, including programs that have more lines than <span><span class="math inline">\(U&#39;\)</span></span>.)</p>
<p>It is no exaggeration to say that the existence of such a universal program/machine underlies the information technology revolution that began in the latter half of the 20th century (and is still ongoing). Up to that point in history, people have produced various special-purpose calculating devices such as the abacus, the slide ruler, and machines that compute various trigonometric series. But as Turing (who was perhaps the one to see most clearly the ramifications of universality) observed, a <em>general purpose computer</em> is much more powerful. Once we build a device that can compute the single universal function, we have the ability, <em>via software</em>, to extend it to do arbitrary computations. For example, if we want to simulate a new Turing machine <span><span class="math inline">\(M\)</span></span>, we do not need to build a new physical machine, but rather can represent <span><span class="math inline">\(M\)</span></span> as a string (i.e., using <em>code</em>) and then input <span><span class="math inline">\(M\)</span></span> to the universal machine <span><span class="math inline">\(U\)</span></span>.</p>
<p>Beyond the practical applications, the existence of a universal algorithm also has surprising theoretical ramifications, and in particular can be used to show the existence of <em>uncomputable functions</em>, upending the intuitions of mathematicians over the centuries from Euler to Hilbert. In this chapter we will prove the existence of the universal program, and also show its implications for uncomputability, see <a href='#universalchapoverviewfig'>Figure 8.1</a></p>
<figure>
<img src="../figure/universalchapoverview.png" alt="8.1: In this chapter we will show the existence of a universal Turing machine and then use this to derive first the existence of some uncomputable function. We then use this to derive the uncomputability of Turing’s famous “halting problem” (i.e., the \ensuremath{\mathit{HALT}} function), from which we a host of other uncomputability results follow. We also introduce reductions, which allow us to use the uncomputability of a function F to derive the uncomputability of a new function G." id="universalchapoverviewfig" /><figcaption>8.1: In this chapter we will show the existence of a <em>universal Turing machine</em> and then use this to derive first the existence of <em>some</em> uncomputable function. We then use this to derive the uncomputability of Turing’s famous “halting problem” (i.e., the <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> function), from which we a host of other uncomputability results follow. We also introduce <em>reductions</em>, which allow us to use the uncomputability of a function <span><span class="math inline">\(F\)</span></span> to derive the uncomputability of a new function <span><span class="math inline">\(G\)</span></span>.</figcaption>
</figure>
<h2 id="universality-or-a-meta-circular-evaluator" data-number="8.1">Universality or a meta-circular evaluator</h2>
<p>We start by proving the existence of a <em>universal Turing machine</em>. This is a single Turing machine <span><span class="math inline">\(U\)</span></span> that can evaluate <em>arbitrary</em> Turing machines <span><span class="math inline">\(M\)</span></span> on <em>arbitrary</em> inputs <span><span class="math inline">\(x\)</span></span>, including machines <span><span class="math inline">\(M\)</span></span> that can have more states and larger alphabet than <span><span class="math inline">\(U\)</span></span> itself. In particular, <span><span class="math inline">\(U\)</span></span> can even be used to evaluate itself! This notion of <em>self reference</em> will appear time and again in this course, and as we will see, leads to several counter-intuitive phenomena in computing.</p>
<div id="universaltmthm" class="theorem" title="Universal Turing Machine" name="Theorem 8.1 (Universal Turing Machine) ">
<p>There exists a Turing machine <span><span class="math inline">\(U\)</span></span> such that on every string <span><span class="math inline">\(M\)</span></span> which represents a Turing machine, and <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(U(M,x)=M(x)\)</span></span>.</p>
<p>That is, if the machine <span><span class="math inline">\(M\)</span></span> halts on <span><span class="math inline">\(x\)</span></span> and outputs some <span><span class="math inline">\(y\in \{0,1\}^*\)</span></span> then <span><span class="math inline">\(U(M,x)=y\)</span></span>, and if <span><span class="math inline">\(M\)</span></span> does not halt on <span><span class="math inline">\(x\)</span></span> (i.e., <span><span class="math inline">\(M(x)=\bot\)</span></span>) then <span><span class="math inline">\(U(M,x)=\bot\)</span></span>.</p>
</div>
<figure>
<img src="../figure/universaltm.png" alt="8.2: A Universal Turing Machine is a single Turing Machine U that can evaluate, given input the (description as a string of) arbitrary Turing machine M and input x, the output of M on x. In contrast to the universal circuit depicted in , the machine M can be much more complex (e.g., more states or tape alphabet symbols) than U." id="universaltmfig" class="margin" /><figcaption>8.2: A <em>Universal Turing Machine</em> is a single Turing Machine <span><span class="math inline">\(U\)</span></span> that can evaluate, given input the (description as a string of) arbitrary Turing machine <span><span class="math inline">\(M\)</span></span> and input <span><span class="math inline">\(x\)</span></span>, the output of <span><span class="math inline">\(M\)</span></span> on <span><span class="math inline">\(x\)</span></span>. In contrast to the universal circuit depicted in <a href='lec_04_code_and_data.html#universalcircfig'>Figure 5.6</a>, the machine <span><span class="math inline">\(M\)</span></span> can be much more complex (e.g., more states or tape alphabet symbols) than <span><span class="math inline">\(U\)</span></span>.</figcaption>
</figure>
<div id="universaltmidea" class="bigidea" name="Bigidea 10">
<p>There is a <em>“universal”</em> algorithm that can evaluate arbitrary algorithms on arbitrary inputs.</p>
</div>
<div class="proofidea" data-ref="universaltmthm" name="Proofidea 8.1">
<p>Once you understand what the theorem says, it is not that hard to prove. The desired program <span><span class="math inline">\(U\)</span></span> is an <em>interpreter</em> for Turing machines. That is, <span><span class="math inline">\(U\)</span></span> gets a representation of the machine <span><span class="math inline">\(M\)</span></span> (think of it as source code), and some input <span><span class="math inline">\(x\)</span></span>, and needs to simulate the execution of <span><span class="math inline">\(M\)</span></span> on <span><span class="math inline">\(x\)</span></span>.</p>
<p>Think of how you would code <span><span class="math inline">\(U\)</span></span> in your favorite programming language. First, you would need to decide on some representation scheme for <span><span class="math inline">\(M\)</span></span>. For example, you can use an array or a dictionary to encode <span><span class="math inline">\(M\)</span></span>’s transition function. Then you would use some data structure, such as a list, to store the contents of <span><span class="math inline">\(M\)</span></span>’s tape. Now you can simulate <span><span class="math inline">\(M\)</span></span> step by step, updating the data structure as you go along. The interpreter will continue the simulation until the machine halts.</p>
<p>Once you do that, translating this interpreter from your favorite programming language to a Turing machine can be done just as we have seen in <a href='lec_07_other_models.html#chapequivalentmodels'>Chapter 7</a>. The end result is what’s known as a “meta-circular evaluator”: an interpreter for a programming language in the same one. This is a concept that has a long history in computer science starting from the original universal Turing machine. See also <a href='#lispinterpreterfig'>Figure 8.3</a>.</p>
</div>
<h3 id="representtmsec" data-number="8.1.1">Proving the existence of a universal Turing Machine</h3>
<p>To prove (and even properly state) <a href='#universaltmthm'>Theorem 8.1</a>, we need to fix some representation for Turing machines as strings. For example, one potential choice for such a representation is to use the equivalence betwen Turing machines and NAND-TM programs and hence represent a Turing machine <span><span class="math inline">\(M\)</span></span> using the ASCII encoding of the source code of the corresponding NAND-TM program <span><span class="math inline">\(P\)</span></span>. However, we will use a more direct encoding.</p>
<div id="representTM" class="definition" title="String representation of Turing Machine" name="Definition 8.2 (String representation of Turing Machine) ">
<p>Let <span><span class="math inline">\(M\)</span></span> be a Turing machine with <span><span class="math inline">\(k\)</span></span> states and a size <span><span class="math inline">\(\ell\)</span></span> alphabet <span><span class="math inline">\(\Sigma = \{ \sigma_0,\ldots,\sigma_{\ell-1} \}\)</span></span> (we use the convention <span><span class="math inline">\(\sigma_0 = 0\)</span></span>,<span><span class="math inline">\(\sigma_1 = 1\)</span></span>, <span><span class="math inline">\(\sigma_2 = \varnothing\)</span></span>, <span><span class="math inline">\(\sigma_3=\triangleright\)</span></span>). We represent <span><span class="math inline">\(M\)</span></span> as the triple <span><span class="math inline">\((k,\ell,T)\)</span></span> where <span><span class="math inline">\(T\)</span></span> is the table of values for <span><span class="math inline">\(\delta_M\)</span></span>:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[T = \left(\delta_M(0,0),\delta_M(0,\sigma_0),\ldots,\delta_M(k-1,\sigma_{k-1})\right) \;,\]</span></div></span></p>
<p>where each value <span><span class="math inline">\(\delta_M(s,\sigma)\)</span></span> is a triple <span><span class="math inline">\((s&#39;,\sigma&#39;,d)\)</span></span> with <span><span class="math inline">\(s&#39;\in [k]\)</span></span>, <span><span class="math inline">\(\sigma&#39;\in \Sigma\)</span></span> and <span><span class="math inline">\(d\)</span></span> a number <span><span class="math inline">\(\{0,1,2,3 \}\)</span></span> encoding one of <span><span class="math inline">\(\{ \mathsf{L},\mathsf{R},\mathsf{S},\mathsf{H} \}\)</span></span>. Thus such a machine <span><span class="math inline">\(M\)</span></span> is encoded by a list of <span><span class="math inline">\(2 + 3k\cdot\ell\)</span></span> natural numbers. The <em>string representation</em> of <span><span class="math inline">\(M\)</span></span> is obtained by concatenating prefix free representation of all these integers. If a string <span><span class="math inline">\(\alpha \in \{0,1\}^*\)</span></span> does not represent a list of integers in the form above, then we treat it as representing the trivial Turing machine with one state that immediately halts on every input.</p>
</div>
<div id="TMrepremark" class="remark" title="Take away points of representation" name="Remark 8.3 (Take away points of representation) ">
<p>The details of the representation scheme of Turing machines as strings are immaterial for almost all applications. What you need to remember are the following points:</p>
<ol type="1">
<li><p>We can represent every Turing machine as a string.</p></li>
<li><p>Given the string representation of a Turing machine <span><span class="math inline">\(M\)</span></span> and an input <span><span class="math inline">\(x\)</span></span>, we can simulate <span><span class="math inline">\(M\)</span></span>’s execution on the input <span><span class="math inline">\(x\)</span></span>. (This is the content of <a href='#universaltmthm'>Theorem 8.1</a>.)</p></li>
</ol>
<p>An additional minor issue is that for convenience we make the assumption that <em>every</em> string represents <em>some</em> Turing machine. This is very easy to ensure by just mapping strings that would otherwise not represent a Turing machine into some fixed trivial machine. This assumption is not very important, but does make a few results (such as Rice’s Theorem: <a href='#rice-thm'>Theorem 8.16</a>) a little less cumbersome to state.</p>
</div>
<p>Using this representation, we can formally prove <a href='#universaltmthm'>Theorem 8.1</a>.</p>
<div class="proof" data-ref="universaltmthm" name="Proof 8.1.1">
<p>We will only sketch the proof, giving the major ideas. First, we observe that we can easily write a <em>Python</em> program that, on input a representation <span><span class="math inline">\((k,\ell,T)\)</span></span> of a Turing machine <span><span class="math inline">\(M\)</span></span> and an input <span><span class="math inline">\(x\)</span></span>, evaluates <span><span class="math inline">\(M\)</span></span> on <span><span class="math inline">\(X\)</span></span>. Here is the code of this program for concreteness, though you can feel free to skip it if you are not familiar with (or interested in) Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># constants</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">def</span> EVAL(δ,x):</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="co">&#39;&#39;&#39;Evaluate TM given by transition table δ</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">    on input x&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-5" title="5">    Tape <span class="op">=</span> [<span class="st">&quot;▷&quot;</span>] <span class="op">+</span> [a <span class="cf">for</span> a <span class="kw">in</span> x]</a>
<a class="sourceLine" id="cb1-6" title="6">    i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> s <span class="op">=</span> <span class="dv">0</span> <span class="co"># i = head pos, s = state</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb1-8" title="8">        s, Tape[i], d <span class="op">=</span> δ[(s,Tape[i])]</a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="cf">if</span> d <span class="op">==</span> <span class="st">&quot;H&quot;</span>: <span class="cf">break</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="cf">if</span> d <span class="op">==</span> <span class="st">&quot;L&quot;</span>: i <span class="op">=</span> <span class="bu">max</span>(i<span class="dv">-1</span>,<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-11" title="11">        <span class="cf">if</span> d <span class="op">==</span> <span class="st">&quot;R&quot;</span>: i <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-12" title="12">        <span class="cf">if</span> i<span class="op">&gt;=</span> <span class="bu">len</span>(Tape): Tape.append(<span class="st">&#39;Φ&#39;</span>)</a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14">    j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> Y <span class="op">=</span> [] <span class="co"># produce output</span></a>
<a class="sourceLine" id="cb1-15" title="15">    <span class="cf">while</span> Tape[j] <span class="op">!=</span> <span class="st">&#39;Φ&#39;</span>:</a>
<a class="sourceLine" id="cb1-16" title="16">        Y.append(Tape[j])</a>
<a class="sourceLine" id="cb1-17" title="17">        j <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="cf">return</span> Y</a></code></pre></div>
<p>On input a transition table <span><span class="math inline">\(\delta\)</span></span> this program will simulate the corresponding machine <span><span class="math inline">\(M\)</span></span> step by step, at each point maintaining the invariant that the array <code>Tape</code> contains the contents of <span><span class="math inline">\(M\)</span></span>’s tape, and the variable <code>s</code> contains <span><span class="math inline">\(M\)</span></span>’s current state.</p>
<p>The above does not prove the theorem as stated, since we need to show a <em>Turing machine</em> that computes <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> rather than a Python program. With enough effort, we can translate this Python code line by line to a Turing machine. However, to prove the theorem we don’t need to do this, but can use our “eat the cake and have it too” paradigm. That is, while we need to evaluate a Turing machine, in writing the code for the interpreter we are allowed to use a richer model such as NAND-RAM since it is equivalent in power to Turing machines per <a href='lec_07_other_models.html#RAMTMequivalencethm'>Theorem 7.1</a>).</p>
<p>Translating the above Python code to NAND-RAM is truly straightforward. The only issue is that NAND-RAM doesn’t have the <em>dictionary</em> data structure built in, which we have used above to store the transition function <code>δ</code>. However, we can represent a dictionary <span><span class="math inline">\(D\)</span></span> of the form <span><span class="math inline">\(\{ key_0:val_0 , \ldots, key_{m-1}:val_{m-1} \}\)</span></span> as simply a list of pairs. To compute <span><span class="math inline">\(D[k]\)</span></span> we can scan over all the pairs until we find one of the form <span><span class="math inline">\((k,v)\)</span></span> in which case we return <span><span class="math inline">\(v\)</span></span>. Similarly we scan the list to update the dictionary with a new value, either modifying it or appending the pair <span><span class="math inline">\((key,val)\)</span></span> at the end.</p>
</div>
<div class="remark" title="Efficiency of the simulation" name="Remark 8.4 (Efficiency of the simulation) ">
<p>The argument in the proof of <a href='#universaltmthm'>Theorem 8.1</a> is a very inefficient way to implement the dictionary data structure in practice, but it suffices for the purpose of proving the theorem. Reading and writing to a dictionary of <span><span class="math inline">\(m\)</span></span> values in this implementation takes <span><span class="math inline">\(\Omega(m)\)</span></span> steps, but it is in fact possible to do this in <span><span class="math inline">\(O(\log m)\)</span></span> steps using a <em>search tree</em> data structure or even <span><span class="math inline">\(O(1)\)</span></span> (for “typical” instances) using a <em>hash table</em>. NAND-RAM and RAM machines correspond to the architecture of modern electronic computers, and so we can implement hash tables and search trees in NAND-RAM just as they are implemented in other programming languages.</p>
</div>
<div id="directunivtm" class="remark" title="Direct construction of universal Turing Machines" name="Remark 8.5 (Direct construction of universal Turing Machines) ">
<p>Since universal Turing</p>
</div>
<h3 id="implications-of-universality-discussion" data-number="8.1.2">Implications of universality (discussion)</h3>
<figure>
<img src="../figure/lispandselfreplicatingprograms.png" alt="8.3: a) A particularly elegant example of a “meta-circular evaluator” comes from John McCarthy’s 1960 paper, where he defined the Lisp programming language and gave a Lisp function that evaluates an arbitrary Lisp program (see above). Lisp was not initially intended as a practical programming language and this example was merely meant as an illustration that the Lisp universal function is more elegant than the universal Turing machine. It was McCarthy’s graduate student Steve Russell who suggested that it can be implemented. As McCarthy later recalled, “I said to him, ho, ho, you’re confusing theory with practice, this eval is intended for reading, not for computing. But he went ahead and did it. That is, he compiled the eval in my paper into IBM 704 machine code, fixing a bug, and then advertised this as a Lisp interpreter, which it certainly was”. b) A self-replicating C program from the classic essay of Thompson ." id="lispinterpreterfig" /><figcaption>8.3: <strong>a)</strong> A particularly elegant example of a “meta-circular evaluator” comes from John McCarthy’s 1960 paper, where he defined the Lisp programming language and gave a Lisp function that evaluates an arbitrary Lisp program (see above). Lisp was not initially intended as a practical programming language and this example was merely meant as an illustration that the Lisp universal function is more elegant than the universal Turing machine. It was McCarthy’s graduate student Steve Russell who suggested that it can be implemented. As McCarthy later recalled, <em>“I said to him, ho, ho, you’re confusing theory with practice, this eval is intended for reading, not for computing. But he went ahead and did it. That is, he compiled the eval in my paper into IBM 704 machine code, fixing a bug, and then advertised this as a Lisp interpreter, which it certainly was”.</em> <strong>b)</strong> A self-replicating C program from the classic essay of Thompson  (<a href="https://scholar.google.com/scholar?hl=en&q=Thompson+Reflections+on+trusting+trust" target="_blank">Thompson, 1984</a>) .</figcaption>
</figure>
<p>There is more than one Turing machine <span><span class="math inline">\(U\)</span></span> that satisfies the conditions of <a href='#universaltmthm'>Theorem 8.1</a>, but the existence of even a single such machine is already extremely fundamental to both the theory and practice of computer science. <a href='#universaltmthm'>Theorem 8.1</a>’s impact reaches beyond the particular model of Turing machines. Because we can simulate every Turing Machine by a NAND-TM program and vice versa, <a href='#universaltmthm'>Theorem 8.1</a> immediately implies there exists a universal NAND-TM program <span><span class="math inline">\(P_U\)</span></span> such that <span><span class="math inline">\(P_U(P,x)=P(x)\)</span></span> for every NAND-TM program <span><span class="math inline">\(P\)</span></span>. We can also “mix and match” models. For example since we can simulate every NAND-RAM program by a Turing machine, and every Turing Machine by the <span><span class="math inline">\(\lambda\)</span></span> calculus, <a href='#universaltmthm'>Theorem 8.1</a> implies that there exists a <span><span class="math inline">\(\lambda\)</span></span> expression <span><span class="math inline">\(e\)</span></span> such that for every NAND-RAM program <span><span class="math inline">\(P\)</span></span> and input <span><span class="math inline">\(x\)</span></span> on which <span><span class="math inline">\(P(x)=y\)</span></span>, if we encode <span><span class="math inline">\((P,x)\)</span></span> as a <span><span class="math inline">\(\lambda\)</span></span>-expression <span><span class="math inline">\(f\)</span></span> (using the <span><span class="math inline">\(\lambda\)</span></span>-calculus encoding of strings as lists of <span><span class="math inline">\(0\)</span></span>’s and <span><span class="math inline">\(1\)</span></span>’s) then <span><span class="math inline">\((e\; f)\)</span></span> evaluates to an encoding of <span><span class="math inline">\(y\)</span></span>. More generally we can say that for every <span><span class="math inline">\(\mathcal{X}\)</span></span> and <span><span class="math inline">\(\mathcal{Y}\)</span></span> in the set <span><span class="math inline">\(\{\)</span></span> Turing Machines, RAM Machines, NAND-TM, NAND-RAM, <span><span class="math inline">\(\lambda\)</span></span>-calculus, JavaScript, Python, <span><span class="math inline">\(\ldots\)</span></span> <span><span class="math inline">\(\}\)</span></span> of Turing equivalent models, there exists a program/machine in <span><span class="math inline">\(\mathcal{X}\)</span></span> that computes the map <span><span class="math inline">\((P,x) \mapsto P(x)\)</span></span> for every program/machine <span><span class="math inline">\(P \in \mathcal{Y}\)</span></span>.</p>
<p>The idea of a “universal program” is of course not limited to theory. For example compilers for programming languages are often used to compile <em>themselves</em>, as well as programs more complicated than the compiler. (An extreme example of this is Fabrice Bellard’s <a href="https://bellard.org/otcc/">Obfuscated Tiny C Compiler</a> which is a C program of 2048 bytes that can compile a large subset of the C programming language, and in particular can compile itself.) This is also related to the fact that it is possible to write a program that can print its own source code, see <a href='#lispinterpreterfig'>Figure 8.3</a>. There are universal Turing machines known that require a very small number of states or alphabet symbols, and in particular there is a universal Turing machine (with respect to a particular choice of representing Turing machines as strings) whose tape alphabet is <span><span class="math inline">\(\{ \triangleright, \varnothing, 0, 1 \}\)</span></span> and has fewer than <span><span class="math inline">\(25\)</span></span> states (see <a href='#uncomputablebibnotes'>Section 8.7</a>).</p>
<h2 id="is-every-function-computable" data-number="8.2">Is every function computable?</h2>
<p>In <a href='lec_03a_computing_every_function.html#NAND-univ-thm'>Theorem 4.12</a>, we saw that NAND-CIRC programs can compute every finite function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>. Therefore a natural guess is that NAND-TM programs (or equivalently, Turing Machines) could compute every infinite function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>. However, this turns out to be <em>false</em>. That is, there exists a function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that is <em>uncomputable</em>!</p>
<p>The existence of uncomputable functions is quite surprising. Our intuitive notion of a “function” (and the notion most mathematicians had until the 20th century) is that a function <span><span class="math inline">\(f\)</span></span> defines some implicit or explicit way of computing the output <span><span class="math inline">\(f(x)\)</span></span> from the input <span><span class="math inline">\(x\)</span></span>. The notion of an “uncomputable function” thus seems to be a contradiction in terms, but yet the following theorem shows that such creatures do exist:</p>
<div id="uncomputable-func" class="theorem" title="Uncomputable functions" name="Theorem 8.6 (Uncomputable functions) ">
<p>There exists a function <span><span class="math inline">\(F^*:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that is not computable by any Turing machine.</p>
</div>
<div id="section-1" class="proofidea" data-ref="uncomputable-func" name="Proofidea">
<p>The idea behind the proof follows quite closely Cantor’s proof that the reals are uncountable (<a href='lec_02_representation.html#cantorthm'>Theorem 2.5</a>), and in fact the theorem can also be obtained fairly directly from that result (see <a href='lec_06_loops.html#uncountablefuncex'>Exercise 6.11</a>). However, it is instructive to see the direct proof. The idea is to construct <span><span class="math inline">\(F^*\)</span></span> in a way that will ensure that every possible machine <span><span class="math inline">\(M\)</span></span> will in fact fail to compute <span><span class="math inline">\(F^*\)</span></span>. We do so by defining <span><span class="math inline">\(F^*(x)\)</span></span> to equal <span><span class="math inline">\(0\)</span></span> if <span><span class="math inline">\(x\)</span></span> describes a Turing machine <span><span class="math inline">\(M\)</span></span> which satisfies <span><span class="math inline">\(M(x)=1\)</span></span> and defining <span><span class="math inline">\(F^*(x)=1\)</span></span> otherwise. By construction, if <span><span class="math inline">\(M\)</span></span> is any Turing machine and <span><span class="math inline">\(x\)</span></span> is the string describing it, then <span><span class="math inline">\(F^*(x) \neq M(x)\)</span></span> and therefore <span><span class="math inline">\(M\)</span></span> does <em>not</em> compute <span><span class="math inline">\(F^*\)</span></span>.</p>
</div>
<div class="proof" data-ref="uncomputable-func" name="Proofidea 20.6.1">
<p>The proof is illustrated in <a href='#diagonal-fig'>Figure 8.4</a>. We start by defining the following function <span><span class="math inline">\(G:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>:</p>
<p>For every string <span><span class="math inline">\(x\in\{0,1\}^*\)</span></span>, if <span><span class="math inline">\(x\)</span></span> satisfies <strong>(1)</strong> <span><span class="math inline">\(x\)</span></span> is a valid representation of some Turing machine <span><span class="math inline">\(M\)</span></span> (per the representation scheme above) and <strong>(2)</strong> when the program <span><span class="math inline">\(M\)</span></span> is executed on the input <span><span class="math inline">\(x\)</span></span> it halts and produces an output, then we define <span><span class="math inline">\(G(x)\)</span></span> as the first bit of this output. Otherwise (i.e., if <span><span class="math inline">\(x\)</span></span> is not a valid representation of a Turing machine, or the machine <span><span class="math inline">\(M_x\)</span></span> never halts on <span><span class="math inline">\(x\)</span></span>) we define <span><span class="math inline">\(G(x)=0\)</span></span>. We define <span><span class="math inline">\(F^*(x) = 1 - G(x)\)</span></span>.</p>
<p>We claim that there is no Turing machine that computes <span><span class="math inline">\(F^*\)</span></span>. Indeed, suppose, towards the sake of contradiction, there exists a machine <span><span class="math inline">\(M\)</span></span> that computes <span><span class="math inline">\(F^*\)</span></span>, and let <span><span class="math inline">\(x\)</span></span> be the binary string that represents the machine <span><span class="math inline">\(M\)</span></span>. On one hand, since by our assumption <span><span class="math inline">\(M\)</span></span> computes <span><span class="math inline">\(F^*\)</span></span>, on input <span><span class="math inline">\(x\)</span></span> the machine <span><span class="math inline">\(M\)</span></span> halts and outputs <span><span class="math inline">\(F^*(x)\)</span></span>. On the other hand, by the definition of <span><span class="math inline">\(F^*\)</span></span>, since <span><span class="math inline">\(x\)</span></span> is the representation of the machine <span><span class="math inline">\(M\)</span></span>, <span><span class="math inline">\(F^*(x) = 1 - G(x) = 1 - M(x)\)</span></span>, hence yielding a contradiction.</p>
</div>
<figure>
<img src="../figure/diagonal_proof.png" alt="8.4: We construct an uncomputable function by defining for every two strings x,y the value 1-M_y(x) which equals 0 if the machine described by y outputs 1 on x, and 1 otherwise. We then define F^*(x) to be the “diagonal” of this table, namely F^*(x)=1-M_x(x) for every x. The function F^* is uncomputable, because if it was computable by some machine whose string description is x^* then we would get that M_{x^*}(x^*)=F(x^*)=1-M_{x^*}(x^*)." id="diagonal-fig" /><figcaption>8.4: We construct an uncomputable function by defining for every two strings <span><span class="math inline">\(x,y\)</span></span> the value <span><span class="math inline">\(1-M_y(x)\)</span></span> which equals <span><span class="math inline">\(0\)</span></span> if the machine described by <span><span class="math inline">\(y\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> on <span><span class="math inline">\(x\)</span></span>, and <span><span class="math inline">\(1\)</span></span> otherwise. We then define <span><span class="math inline">\(F^*(x)\)</span></span> to be the “diagonal” of this table, namely <span><span class="math inline">\(F^*(x)=1-M_x(x)\)</span></span> for every <span><span class="math inline">\(x\)</span></span>. The function <span><span class="math inline">\(F^*\)</span></span> is uncomputable, because if it was computable by some machine whose string description is <span><span class="math inline">\(x^*\)</span></span> then we would get that <span><span class="math inline">\(M_{x^*}(x^*)=F(x^*)=1-M_{x^*}(x^*)\)</span></span>.</figcaption>
</figure>
<div id="uncomputablefunctions" class="bigidea" name="Bigidea 11">
<p>There are some functions that <em>can not</em> be computed by <em>any</em> algorithm.</p>
</div>
<div id="section-2" class="pause" name="Pause">
<p>The proof of <a href='#uncomputable-func'>Theorem 8.6</a> is short but subtle. I suggest that you pause here and go back to read it again and think about it - this is a proof that is worth reading at least twice if not three or four times. It is not often the case that a few lines of mathematical reasoning establish a deeply profound fact - that there are problems we simply <em>cannot</em> solve.</p>
</div>
<p>The type of argument used to prove <a href='#uncomputable-func'>Theorem 8.6</a> is known as <em>diagonalization</em> since it can be described as defining a function based on the diagonal entries of a table as in <a href='#diagonal-fig'>Figure 8.4</a>. The proof can be thought of as an infinite version of the <em>counting</em> argument we used for showing lower bound for NAND-CIRC programs in <a href='lec_04_code_and_data.html#counting-lb'>Theorem 5.3</a>. Namely, we show that it’s not possible to compute all functions from <span><span class="math inline">\(\{0,1\}^* \rightarrow \{0,1\}\)</span></span> by Turing machines simply because there are more functions like that then there are Turing machines.</p>
<p>As mentioned in <a href='#decidablelanguages'>?? ??</a>, many texts use the “language” terminology and so will call a set <span><span class="math inline">\(L \subseteq \{0,1\}^*\)</span></span> an <a href="https://goo.gl/3YvQvL"><em>undecidable</em></a> or <em>non recursive</em> language if the function <span><span class="math inline">\(F:\{0,1\}^* :\rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(F(x)=1 \leftrightarrow x\in L\)</span></span> is uncomputable.</p>
<h2 id="haltingsec" data-number="8.3">The Halting problem</h2>
<p><a href='#uncomputable-func'>Theorem 8.6</a> shows that there is <em>some</em> function that cannot be computed. But is this function the equivalent of the “tree that falls in the forest with no one hearing it”? That is, perhaps it is a function that no one actually <em>wants</em> to compute. It turns out that there are natural uncomputable functions:</p>
<div id="halt-thm" class="theorem" title="Uncomputability of Halting function" name="Theorem 8.7 (Uncomputability of Halting function) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{HALT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function such that for every string <span><span class="math inline">\(M\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(M,x)=1\)</span></span> if Turing machine <span><span class="math inline">\(M\)</span></span> halts on the input <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(M,x)=0\)</span></span> otherwise. Then <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> is not computable.</p>
</div>
<p>Before turning to prove <a href='#halt-thm'>Theorem 8.7</a>, we note that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> is a very natural function to want to compute. For example, one can think of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> as a special case of the task of managing an “App store”. That is, given the code of some application, the gatekeeper for the store needs to decide if this code is safe enough to allow in the store or not. At a minimum, it seems that we should verify that the code would not go into an infinite loop.</p>
<div class="proofidea" data-ref="halt-thm" name="Proofidea 8.3">
<p>One way to think about this proof is as follows: <span>
<div class='myequationbox'><span class="math display">\[
\text{Uncomputability of $F^*$} \;+\; \text{Universality} \;=\; \text{Uncomputability of $\ensuremath{\mathit{HALT}}$}
\]</span></div></span> That is, we will use the universal Turing machine that computes <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> to derive the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> from the uncomputability of <span><span class="math inline">\(F^*\)</span></span> shown in <a href='#uncomputable-func'>Theorem 8.6</a>. Specifically, the proof will be by contradiction. That is, we will assume towards a contradiction that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> is computable, and use that assumption, together with the universal Turing machine of <a href='#universaltmthm'>Theorem 8.1</a>, to derive that <span><span class="math inline">\(F^*\)</span></span> is computable, which will contradict <a href='#uncomputable-func'>Theorem 8.6</a>.</p>
</div>
<div id="reductionuncomputeidea" class="bigidea" name="Bigidea 12">
<p>If a function <span><span class="math inline">\(F\)</span></span> is uncomputable we can show that another function <span><span class="math inline">\(H\)</span></span> is uncomputable by giving a way to <em>reduce</em> the task of computing <span><span class="math inline">\(F\)</span></span> to computing <span><span class="math inline">\(H\)</span></span>.</p>
</div>
<div class="proof" data-ref="halt-thm" name="Proof 8.3">
<p>The proof will use the previously established result <a href='#uncomputable-func'>Theorem 8.6</a>. Recall that <a href='#uncomputable-func'>Theorem 8.6</a> shows that the following function <span><span class="math inline">\(F^*: \{0,1\}^* \rightarrow \{0,1\}\)</span></span> is uncomputable:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
F^*(x) = \begin{cases}1 &amp; x(x)=0 \\ 0 &amp; \text{otherwise} \end{cases}
\]</span></div></span> where <span><span class="math inline">\(x(x)\)</span></span> denotes the output of the Turing machine described by the string <span><span class="math inline">\(x\)</span></span> on the input <span><span class="math inline">\(x\)</span></span> (with the usual convention that <span><span class="math inline">\(x(x)=\bot\)</span></span> if this computation does not halt).</p>
<p>We will show that the uncomputability of <span><span class="math inline">\(F^*\)</span></span> implies the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>. Specifically, we will assume, towards a contradiction, that there exists a Turing machine <span><span class="math inline">\(M\)</span></span> that can compute the <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> function, and use that to obtain a Turing machine <span><span class="math inline">\(M&#39;\)</span></span> that computes the function <span><span class="math inline">\(F^*\)</span></span>. (This is known as a proof by <em>reduction</em>, since we reduce the task of computing <span><span class="math inline">\(F^*\)</span></span> to the task of computing <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>. By the contrapositive, this means the uncomputability of <span><span class="math inline">\(F^*\)</span></span> implies the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>.)</p>
<p>Indeed, suppose that <span><span class="math inline">\(M\)</span></span> is a Turing machine that computes <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>. <a href='#halttof'>Algorithm 8.8</a> describes a Turing Machine <span><span class="math inline">\(M&#39;\)</span></span> that computes <span><span class="math inline">\(F^*\)</span></span>. (We use “high level” description of Turing machines, appealing to the “have your cake and eat it too” paradigm, see <a href='lec_07_other_models.html#eatandhavecake'>Bigidea 9</a>.)</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = halttof>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 8 </span>$F^*$ to $HALT$ reduction</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  \(x\in \{0,1\}^*\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>  \(F^*(x)\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> <span class="ps-comment"><i>#  Assume T.M. \(M_{HALT</i></span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(z \leftarrow M_{HALT}(x,x)\). <span class="ps-comment"><i>#  Assume \(z=HALT(x,x)\).</i></span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">if</span>{\(z=0\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(0\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endif</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(y \leftarrow U(x,x)\) <span class="ps-comment"><i>#  \(U\) universal TM, i.e., \(y=x(x)\)</i></span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">if</span>{\(y=0\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(1\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endif</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(0\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p>We claim that <a href='#halttof'>Algorithm 8.8</a> computes the function <span><span class="math inline">\(F^*\)</span></span>. Indeed, suppose that <span><span class="math inline">\(x(x)=0\)</span></span> (and hence <span><span class="math inline">\(F^*(x)=1\)</span></span>). In this case, <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(x,x)=1\)</span></span> and hence, under our assumption that <span><span class="math inline">\(M(x,x)=\ensuremath{\mathit{HALT}}(x,x)\)</span></span>, the value <span><span class="math inline">\(z\)</span></span> will equal <span><span class="math inline">\(1\)</span></span>, and hence <a href='#halttof'>Algorithm 8.8</a> will set <span><span class="math inline">\(y=x(x)=0\)</span></span>, and output the correct value <span><span class="math inline">\(1\)</span></span>.</p>
<p>Suppose otherwise that <span><span class="math inline">\(x(x) \neq 0\)</span></span> (and hence <span><span class="math inline">\(F^*(x)=0\)</span></span>). In this case there are two possibilities:</p>
<ul>
<li><p><strong>Case 1:</strong> The machine described by <span><span class="math inline">\(x\)</span></span> does not halt on the input <span><span class="math inline">\(x\)</span></span>. In this case, <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(x,x)=0\)</span></span>. Since we assume that <span><span class="math inline">\(M\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> it means that on input <span><span class="math inline">\(x,x\)</span></span>, the machine <span><span class="math inline">\(M\)</span></span> must halt and output the value <span><span class="math inline">\(0\)</span></span>. This means that <a href='#halttof'>Algorithm 8.8</a> will set <span><span class="math inline">\(z=0\)</span></span> and output <span><span class="math inline">\(0\)</span></span>.</p></li>
<li><p><strong>Case 2:</strong> The machine described by <span><span class="math inline">\(x\)</span></span> halts on the input <span><span class="math inline">\(x\)</span></span> and outputs some <span><span class="math inline">\(y&#39; \neq 0\)</span></span>. In this case, since <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(x,x)=1\)</span></span>, under our assumptions, <a href='#halttof'>Algorithm 8.8</a> will set <span><span class="math inline">\(y=y&#39; \neq 0\)</span></span> and so output <span><span class="math inline">\(0\)</span></span>.</p></li>
</ul>
<p>We see that in all cases, <span><span class="math inline">\(M&#39;(x)=F^*(x)\)</span></span>, which contradicts the fact that <span><span class="math inline">\(F^*\)</span></span> is uncomputable. Hence we reach a contradiction to our original assumption that <span><span class="math inline">\(M\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>.</p>
</div>
<div id="section-3" class="pause" name="Pause">
<p>Once again, this is a proof that’s worth reading more than once. The uncomputability of the halting problem is one of the fundamental theorems of computer science, and is the starting point for much of the investigations we will see later. An excellent way to get a better understanding of <a href='#halt-thm'>Theorem 8.7</a> is to go over <a href='#haltalternativesec'>Subsection 8.3.2</a>, which presents an alternative proof of the same result.</p>
</div>
<h3 id="is-the-halting-problem-really-hard-discussion" data-number="8.3.1">Is the Halting problem really hard? (discussion)</h3>
<p>Many people’s first instinct when they see the proof of <a href='#halt-thm'>Theorem 8.7</a> is to not believe it. That is, most people do believe the mathematical statement, but intuitively it doesn’t seem that the Halting problem is really that hard. After all, being uncomputable only means that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> cannot be computed by a Turing machine.</p>
<p>But programmers seem to solve <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> all the time by informally or formally arguing that their programs halt. It’s true that their programs are written in C or Python, as opposed to Turing machines, but that makes no difference: we can easily translate back and forth between this model and any other programming language.</p>
<p>While every programmer encounters at some point an infinite loop, is there really no way to solve the halting problem? Some people argue that <em>they</em> personally can, if they think hard enough, determine whether any concrete program that they are given will halt or not. Some have even <a href="https://goo.gl/Bm4MWK">argued</a> that humans in general have the ability to do that, and hence humans have inherently superior intelligence to computers or anything else modeled by Turing machines.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>The best answer we have so far is that there truly is no way to solve <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>, whether using Macs, PCs, quantum computers, humans, or any other combination of electronic, mechanical, and biological devices. Indeed this assertion is the content of the <em>Church-Turing Thesis</em>. This of course does not mean that for <em>every</em> possible program <span><span class="math inline">\(P\)</span></span>, it is hard to decide if <span><span class="math inline">\(P\)</span></span> enters an infinite loop. Some programs don’t even have loops at all (and hence trivially halt), and there are many other far less trivial examples of programs that we can certify to never enter an infinite loop (or programs that we know for sure that <em>will</em> enter such a loop). However, there is no <em>general procedure</em> that would determine for an <em>arbitrary</em> program <span><span class="math inline">\(P\)</span></span> whether it halts or not. Moreover, there are some very simple programs for which no one knows whether they halt or not. For example, the following Python program will halt if and only if <a href="https://goo.gl/DX63q5">Goldbach’s conjecture</a> is false:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> isprime(p):</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="cf">return</span> <span class="bu">all</span>(p <span class="op">%</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,p<span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">def</span> Goldbach(n):</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="cf">return</span> <span class="bu">any</span>( (isprime(p) <span class="kw">and</span> isprime(n<span class="op">-</span>p))</a>
<a class="sourceLine" id="cb2-6" title="6">           <span class="cf">for</span> p <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">n <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="cf">if</span> <span class="kw">not</span> Goldbach(n): <span class="cf">break</span></a>
<a class="sourceLine" id="cb2-11" title="11">    n<span class="op">+=</span> <span class="dv">2</span></a></code></pre></div>
<p>Given that Goldbach’s Conjecture has been open since 1742, it is unclear that humans have any magical ability to say whether this (or other similar programs) will halt or not.</p>
<figure>
<img src="../figure/smbchalting.png" alt="8.5: SMBC’s take on solving the Halting problem." id="xkcdhaltingfig" class="margin" /><figcaption>8.5: <a href="http://smbc-comics.com/comic/halting">SMBC</a>’s take on solving the Halting problem.</figcaption>
</figure>
<h3 id="haltalternativesec" data-number="8.3.2">A direct proof of the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> (optional)</h3>
<p>It turns out that we can combine the ideas of the proofs of <a href='#uncomputable-func'>Theorem 8.6</a> and <a href='#halt-thm'>Theorem 8.7</a> to obtain a short proof of the latter theorem, that does not appeal to the uncomputability of <span><span class="math inline">\(F^*\)</span></span>. This short proof appeared in print in a 1965 letter to the editor of Christopher Strachey:</p>
<blockquote>
<p>To the Editor, The Computer Journal.</p>
<p>An Impossible Program</p>
<p>Sir,</p>
<p>A well-known piece of folk-lore among programmers holds that it is impossible to write a program which can examine any other program and tell, in every case, if it will terminate or get into a closed loop when it is run. I have never actually seen a proof of this in print, and though Alan Turing once gave me a verbal proof (in a railway carriage on the way to a Conference at the NPL in 1953), I unfortunately and promptly forgot the details. This left me with an uneasy feeling that the proof must be long or complicated, but in fact it is so short and simple that it may be of interest to casual readers. The version below uses CPL, but not in any essential way.</p>
<p>Suppose <code>T[R]</code> is a Boolean function taking a routine (or program) <code>R</code> with no formal or free variables as its arguments and that for all <code>R</code>, <code>T[R] = True</code> if <code>R</code> terminates if run and that <code>T[R] = False</code> if <code>R</code> does not terminate.</p>
<p>Consider the routine P defined as follows</p>
<p><code>rec routine P</code><br />
<code>§L: if T[P] go to L</code><br />
<code>Return §</code></p>
<p>If <code>T[P] = True</code> the routine <code>P</code> will loop, and it will only terminate if <code>T[P] = False</code>. In each case `T[P]`` has exactly the wrong value, and this contradiction shows that the function T cannot exist.</p>
<p>Yours faithfully,<br />
C. Strachey</p>
<p>Churchill College, Cambridge</p>
</blockquote>
<div class="pause" name="Pause 8.3.2">
<p>Try to stop and extract the argument for proving <a href='#halt-thm'>Theorem 8.7</a> from the letter above.</p>
</div>
<p>Since CPL is not as common today, let us reproduce this proof. The idea is the following: suppose for the sake of contradiction that there exists a program <code>T</code> such that <code>T(f,x)</code> equals <code>True</code> iff <code>f</code> halts on input <code>x</code>. (Strachey’s letter considers the no-input variant of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>, but as we’ll see, this is an immaterial distinction.) Then we can construct a program <code>P</code> and an input <code>x</code> such that <code>T(P,x)</code> gives the wrong answer. The idea is that on input <code>x</code>, the program <code>P</code> will do the following: run <code>T(x,x)</code>, and if the answer is <code>True</code> then go into an infinite loop, and otherwise halt. Now you can see that <code>T(P,P)</code> will give the wrong answer: if <code>P</code> halts when it gets its own code as input, then <code>T(P,P)</code> is supposed to be <code>True</code>, but then <code>P(P)</code> will go into an infinite loop. And if <code>P</code> does not halt, then <code>T(P,P)</code> is supposed to be <code>False</code> but then <code>P(P)</code> will halt. We can also code this up in Python:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> CantSolveMe(T):</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">    Gets function T that claims to solve HALT.</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">    Returns a pair (P,x) of code and input on which</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">    T(P,x) ≠ HALT(x)</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">def</span> fool(x):</a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="cf">if</span> T(x,x):</a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="cf">while</span> <span class="va">True</span>: <span class="cf">pass</span></a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="cf">return</span> <span class="st">&quot;I halted&quot;</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="cf">return</span> (fool,fool)</a></code></pre></div>
<p>For example, consider the following Naive Python program <code>T</code> that guesses that a given function does not halt if its input contains <code>while</code> or <code>for</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> T(f,x):</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">&quot;&quot;&quot;Crude halting tester - decides it doesn&#39;t halt if it contains a loop.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="im">import</span> inspect</a>
<a class="sourceLine" id="cb4-4" title="4">    source <span class="op">=</span> inspect.getsource(f)</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="cf">if</span> source.find(<span class="st">&quot;while&quot;</span>): <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="cf">if</span> source.find(<span class="st">&quot;for&quot;</span>): <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="cf">return</span> <span class="va">True</span></a></code></pre></div>
<p>If we now set <code>(f,x) = CantSolveMe(T)</code>, then <code>T(f,x)=False</code> but <code>f(x)</code> does in fact halt. This is of course not specific to this particular <code>T</code>: for every program <code>T</code>, if we run <code>(f,x) = CantSolveMe(T)</code> then we’ll get an input on which <code>T</code> gives the wrong answer to <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>.</p>
<h2 id="reductionsuncompsec" data-number="8.4">Reductions</h2>
<p>The Halting problem turns out to be a linchpin of uncomputability, in the sense that <a href='#halt-thm'>Theorem 8.7</a> has been used to show the uncomputability of a great many interesting functions. We will see several examples of such results in this chapter and the exercises, but there are many more such results (see <a href='#haltreductions'>Figure 8.6</a>).</p>
<figure>
<img src="../figure/reductions_from_halting.png" alt="8.6: Some uncomputability results. An arrow from problem X to problem Y means that we use the uncomputability of X to prove the uncomputability of Y by reducing computing X to computing Y. All of these results except for the MRDP Theorem appear in either the text or exercises. The Halting Problem \ensuremath{\mathit{HALT}} serves as our starting point for all these uncomputability results as well as many others." id="haltreductions" /><figcaption>8.6: Some uncomputability results. An arrow from problem X to problem Y means that we use the uncomputability of X to prove the uncomputability of Y by reducing computing X to computing Y. All of these results except for the MRDP Theorem appear in either the text or exercises. The Halting Problem <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> serves as our starting point for all these uncomputability results as well as many others.</figcaption>
</figure>
<p>The idea behind such uncomputability results is conceptually simple but can at first be quite confusing. If we know that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> is uncomputable, and we want to show that some other function <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span> is uncomputable, then we can do so via a <em>contrapositive</em> argument (i.e., proof by contradiction). That is, we show that <strong>if</strong> there exists a Turing machine that computes <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span> <strong>then</strong> there exists a Turing machine that computes <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>. (Indeed, this is exactly how we showed that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> itself is uncomputable, by reducing this fact to the uncomputability of the function <span><span class="math inline">\(F^*\)</span></span> from <a href='#uncomputable-func'>Theorem 8.6</a>.)</p>
<p>For example, to prove that <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span> is uncomputable, we could show that there is a computable function <span><span class="math inline">\(R:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> such that for every pair <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(M,x)=\ensuremath{\mathit{BLAH}}(R(M,x))\)</span></span>. The existence of such a function <span><span class="math inline">\(R\)</span></span> implies that <strong>if</strong> <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span> was computable <strong>then</strong> <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> would be computable as well, hence leading to a contradiction! The confusing part about reductions is that we are assuming something we <em>believe</em> is false (that <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span> has an algorithm) to derive something that we <em>know</em> is false (that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> has an algorithm). Michael Sipser describes such results as having the form <em>“If pigs could whistle then horses could fly”</em>.</p>
<p>A reduction-based proof has two components. For starters, since we need <span><span class="math inline">\(R\)</span></span> to be computable, we should describe the algorithm to compute it. The algorithm to compute <span><span class="math inline">\(R\)</span></span> is known as a <em>reduction</em> since the transformation <span><span class="math inline">\(R\)</span></span> modifies an input to <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> to an input to <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span>, and hence <em>reduces</em> the task of computing <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> to the task of computing <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span>. The second component of a reduction-based proof is the <em>analysis</em> of the algorithm <span><span class="math inline">\(R\)</span></span>: namely a proof that <span><span class="math inline">\(R\)</span></span> does indeed satisfy the desired properties.</p>
<p>Reduction-based proofs are just like other proofs by contradiction, but the fact that they involve hypothetical algorithms that don’t really exist tends to make reductions quite confusing. The one silver lining is that at the end of the day the notion of reductions is mathematically quite simple, and so it’s not that bad even if you have to go back to first principles every time you need to remember what is the direction that a reduction should go in.</p>
<div id="reductionsaralg" class="remark" title="Reductions are algorithms" name="Remark 8.9 (Reductions are algorithms) ">
<p>A reduction is an <em>algorithm</em>, which means that, as discussed in <a href='lec_01_introduction.html#implspecanarem'>Remark 0.3</a>, a reduction has three components:</p>
<ul>
<li><p><strong>Specification (what):</strong> In the case of a reduction from <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{BLAH}}\)</span></span>, the specification is that function <span><span class="math inline">\(R:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> should satisfy that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(M,x)=\ensuremath{\mathit{BLAH}}(R(M,x))\)</span></span> for every Turing machine <span><span class="math inline">\(M\)</span></span> and input <span><span class="math inline">\(x\)</span></span>. In general, to reduce a function <span><span class="math inline">\(F\)</span></span> to <span><span class="math inline">\(G\)</span></span>, the reduction should satisfy <span><span class="math inline">\(F(w)=G(R(w))\)</span></span> for every input <span><span class="math inline">\(w\)</span></span> to <span><span class="math inline">\(F\)</span></span>.</p></li>
<li><p><strong>Implementation (how):</strong> The algorithm’s description: the precise instructions how to transform an input <span><span class="math inline">\(w\)</span></span> to the output <span><span class="math inline">\(R(w)\)</span></span>.</p></li>
<li><p><strong>Analysis (why):</strong> A <em>proof</em> that the algorithm meets the specification. In particular, in a reduction from <span><span class="math inline">\(F\)</span></span> to <span><span class="math inline">\(G\)</span></span> this is a proof that for every input <span><span class="math inline">\(w\)</span></span>, the output <span><span class="math inline">\(y\)</span></span> of the algorithm satisfies that <span><span class="math inline">\(F(w)=G(y)\)</span></span>.</p></li>
</ul>
</div>
<h3 id="example-halting-on-the-zero-problem" data-number="8.4.1">Example: Halting on the zero problem</h3>
<p>Here is a concrete example for a proof by reduction. We define the function <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> as follows. Given any string <span><span class="math inline">\(M\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(M)=1\)</span></span> if and only if <span><span class="math inline">\(M\)</span></span> describes a Turing machine that halts when it is given the string <span><span class="math inline">\(0\)</span></span> as input. A priori <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> seems like a potentially easier function to compute than the full-fledged <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> function, and so we could perhaps hope that it is not uncomputable. Alas, the following theorem shows that this is not the case:</p>
<div id="haltonzero-thm" class="theorem" title="Halting without input" name="Theorem 8.10 (Halting without input) ">
<p><span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> is uncomputable.</p>
</div>
<div id="section-4" class="pause" name="Pause">
<p>The proof of <a href='#haltonzero-thm'>Theorem 8.10</a> is below, but before reading it you might want to pause for a couple of minutes and think how you would prove it yourself. In particular, try to think of what a reduction from <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> would look like. Doing so is an excellent way to get some initial comfort with the notion of proofs by reduction, which a technique we will be using time and again in this book.</p>
</div>
<figure>
<img src="../figure/haltonzerored.png" alt="8.7: To prove , we show that \ensuremath{\mathit{HALTONZERO}} is uncomputable by giving a reduction from the task of computing \ensuremath{\mathit{HALT}} to the task of computing \ensuremath{\mathit{HALTONZERO}}. This shows that if there was a hypothetical algorithm A computing \ensuremath{\mathit{HALTONZERO}}, then there would be an algorithm B computing \ensuremath{\mathit{HALT}}, contradicting . Since neither A nor B actually exists, this is an example of an implication of the form “if pigs could whistle then horses could fly”." id="haltonzerofig" class="figure" /><figcaption>8.7: To prove <a href='#haltonzero-thm'>Theorem 8.10</a>, we show that <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> is uncomputable by giving a <em>reduction</em> from the task of computing <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> to the task of computing <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>. This shows that if there was a hypothetical algorithm <span><span class="math inline">\(A\)</span></span> computing <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>, then there would be an algorithm <span><span class="math inline">\(B\)</span></span> computing <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>, contradicting <a href='#halt-thm'>Theorem 8.7</a>. Since neither <span><span class="math inline">\(A\)</span></span> nor <span><span class="math inline">\(B\)</span></span> actually exists, this is an example of an implication of the form “if pigs could whistle then horses could fly”.</figcaption>
</figure>
<div class="proof" data-ref="haltonzero-thm" name="Proof 8.5">
<p>The proof is by reduction from <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>, see <a href='#haltonzerofig'>Figure 8.7</a>. We will assume, towards the sake of contradiction, that <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> is computable by some algorithm <span><span class="math inline">\(A\)</span></span>, and use this hypothetical algorithm <span><span class="math inline">\(A\)</span></span> to construct an algorithm <span><span class="math inline">\(B\)</span></span> to compute <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>, hence obtaining a contradiction to <a href='#halt-thm'>Theorem 8.7</a>. (As discussed in <a href='#defalgsec'>?? ??</a>, following our “eat your cake and have it too” paradigm, we just use the generic name “algorithm” rather than worrying whether we model them as Turing machines, NAND-TM programs, NAND-RAM, etc.; this makes no difference since all these models are equivalent to one another.)</p>
<p>Since this is our first proof by reduction from the Halting problem, we will spell it out in more details than usual. Such a proof by reduction consists of two steps:</p>
<ol type="1">
<li><p><em>Description of the reduction:</em> We will describe the operation of our algorithm <span><span class="math inline">\(B\)</span></span>, and how it makes “function calls” to the hypothetical algorithm <span><span class="math inline">\(A\)</span></span>.</p></li>
<li><p><em>Analysis of the reduction:</em> We will then prove that under the hypothesis that Algorithm <span><span class="math inline">\(A\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>, Algorithm <span><span class="math inline">\(B\)</span></span> will compute <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>.</p></li>
</ol>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = halttohaltonzerored>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 11 </span>$HALT$ to $HALTONZERO$ reduction</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  Turing machine \(M\) and string \(x\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>  Turing machine \(M'\) such that \(M\) halts on \(x\) iff \(M'\) halts on zero<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Procedure</span>{\(N_{M,x}\)}{\(w\)} <span class="ps-comment"><i>#  Description of the T.M. \(N_{M,x</i></span> 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> <span class="ps-keyword">return</span> \(EVAL(M,x)\) <span class="ps-comment"><i>#  Ignore the <span class="ps-keyword">Input:</span> \(w\), evaluate \(M\) on \(x\).</i></span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endproc</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(N_{M,x}\) <span class="ps-comment"><i>#  We do not execute \(N_{M,x</i></span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p>Our Algorithm <span><span class="math inline">\(B\)</span></span> works as follows: on input <span><span class="math inline">\(M,x\)</span></span>, it runs <a href='#halttohaltonzerored'>Algorithm 8.11</a> to obtain a Turing Machine <span><span class="math inline">\(M&#39;\)</span></span>, and then returns <span><span class="math inline">\(A(M&#39;)\)</span></span>. The machine <span><span class="math inline">\(M&#39;\)</span></span> ignores its input <span><span class="math inline">\(z\)</span></span> and simply runs <span><span class="math inline">\(M\)</span></span> on <span><span class="math inline">\(x\)</span></span>.</p>
<p>In pseudocode, the program <span><span class="math inline">\(N_{M,x}\)</span></span> will look something like the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> N(z):</a>
<a class="sourceLine" id="cb5-2" title="2">    M <span class="op">=</span> <span class="vs">r&#39;.......&#39;</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="co"># a string constant containing desc. of M</span></a>
<a class="sourceLine" id="cb5-4" title="4">    x <span class="op">=</span> <span class="vs">r&#39;.......&#39;</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="co"># a string constant containing x</span></a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="cf">return</span> <span class="bu">eval</span>(M,x)</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co"># note that we ignore the input z</span></a></code></pre></div>
<p>That is, if we think of <span><span class="math inline">\(N_{M,x}\)</span></span> as a program, then it is a program that contains <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(x\)</span></span> as “hardwired constants”, and given any input <span><span class="math inline">\(z\)</span></span>, it simply ignores the input and always returns the result of evaluating <span><span class="math inline">\(M\)</span></span> on <span><span class="math inline">\(x\)</span></span>. The algorithm <span><span class="math inline">\(B\)</span></span> does <em>not</em> actually execute the machine <span><span class="math inline">\(N_{M,x}\)</span></span>. <span><span class="math inline">\(B\)</span></span> merely writes down the description of <span><span class="math inline">\(N_{M,x}\)</span></span> as a string (just as we did above) and feeds this string as input to <span><span class="math inline">\(A\)</span></span>.</p>
<p>The above completes the <em>description</em> of the reduction. The <em>analysis</em> is obtained by proving the following claim:</p>
<p><strong>Claim:</strong> For every strings <span><span class="math inline">\(M,x,z\)</span></span>, the machine <span><span class="math inline">\(N_{M,x}\)</span></span> constructed by Algorithm <span><span class="math inline">\(B\)</span></span> in Step 1 satisfies that <span><span class="math inline">\(N_{M,x}\)</span></span> halts on <span><span class="math inline">\(z\)</span></span> if and only if the program described by <span><span class="math inline">\(M\)</span></span> halts on the input <span><span class="math inline">\(x\)</span></span>.</p>
<p><strong>Proof of Claim:</strong> Since <span><span class="math inline">\(N_{M,x}\)</span></span> ignores its input and evaluates <span><span class="math inline">\(M\)</span></span> on <span><span class="math inline">\(x\)</span></span> using the universal Turing machine, it will halt on <span><span class="math inline">\(z\)</span></span> if and only if <span><span class="math inline">\(M\)</span></span> halts on <span><span class="math inline">\(x\)</span></span>.</p>
<p>In particular if we instantiate this claim with the input <span><span class="math inline">\(z=0\)</span></span> to <span><span class="math inline">\(N_{M,x}\)</span></span>, we see that <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(N_{M,x})=\ensuremath{\mathit{HALT}}(M,x)\)</span></span>. Thus if the hypothetical algorithm <span><span class="math inline">\(A\)</span></span> satisfies <span><span class="math inline">\(A(M)=\ensuremath{\mathit{HALTONZERO}}(M)\)</span></span> for every <span><span class="math inline">\(M\)</span></span> then the algorithm <span><span class="math inline">\(B\)</span></span> we construct satisfies <span><span class="math inline">\(B(M,x)=\ensuremath{\mathit{HALT}}(M,x)\)</span></span> for every <span><span class="math inline">\(M,x\)</span></span>, contradicting the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span>.</p>
</div>
<div id="hardwiringrem" class="remark" title="The hardwiring technique" name="Remark 8.12 (The hardwiring technique) ">
<p>In the proof of <a href='#haltonzero-thm'>Theorem 8.10</a> we used the technique of “hardwiring” an input <span><span class="math inline">\(x\)</span></span> to a program/machine <span><span class="math inline">\(P\)</span></span>. That is, modifying a program <span><span class="math inline">\(P\)</span></span> that it uses “hardwired constants” for some of all of its input. This technique is quite common in reductions and elsewhere, and we will often use it again in this course.</p>
</div>
<h2 id="rices-theorem-and-the-impossibility-of-general-software-verification" data-number="8.5">Rice’s Theorem and the impossibility of general software verification</h2>
<p>The uncomputability of the Halting problem turns out to be a special case of a much more general phenomenon. Namely, that <em>we cannot certify semantic properties of general purpose programs</em>. “Semantic properties” mean properties of the <em>function</em> that the program computes, as opposed to properties that depend on the particular syntax used by the program.</p>
<p>An example for a <em>semantic property</em> of a program <span><span class="math inline">\(P\)</span></span> is the property that whenever <span><span class="math inline">\(P\)</span></span> is given an input string with an even number of <span><span class="math inline">\(1\)</span></span>’s, it outputs <span><span class="math inline">\(0\)</span></span>. Another example is the property that <span><span class="math inline">\(P\)</span></span> will always halt whenever the input ends with a <span><span class="math inline">\(1\)</span></span>. In contrast, the property that a C program contains a comment before every function declaration is not a semantic property, since it depends on the actual source code as opposed to the input/output relation.</p>
<p>Checking semantic properties of programs is of great interest, as it corresponds to checking whether a program conforms to a specification. Alas it turns out that such properties are in general <em>uncomputable</em>. We have already seen some examples of uncomputable semantic functions, namely <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>, but these are just the “tip of the iceberg”. We start by observing one more such example:</p>
<div id="allzero-thm" class="theorem" title="Computing all zero function" name="Theorem 8.13 (Computing all zero function) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function such that for every <span><span class="math inline">\(M\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}(M)=1\)</span></span> if and only if <span><span class="math inline">\(M\)</span></span> represents a Turing machine such that <span><span class="math inline">\(M\)</span></span> outputs <span><span class="math inline">\(0\)</span></span> on every input <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. Then <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}\)</span></span> is uncomputable.</p>
</div>
<div class="pause" name="Pause 8.5">
<p>Despite the similarity in their names, <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> are two different functions. For example, if <span><span class="math inline">\(M\)</span></span> is a Turing machine that on input <span><span class="math inline">\(x \in \{0,1\}^*\)</span></span>, halts and outputs the OR of all of <span><span class="math inline">\(x\)</span></span>’s coordinates, then <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(M)=1\)</span></span> (since <span><span class="math inline">\(M\)</span></span> does halt on the input <span><span class="math inline">\(0\)</span></span>) but <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}(M)=0\)</span></span> (since <span><span class="math inline">\(M\)</span></span> does not compute the constant zero function).</p>
</div>
<div class="proof" data-ref="allzero-thm" name="Proof 8.5">
<p>The proof is by reduction to <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>. Suppose, towards the sake of contradiction, that there was an algorithm <span><span class="math inline">\(A\)</span></span> such that <span><span class="math inline">\(A(M)=\ensuremath{\mathit{ZEROFUNC}}(M)\)</span></span> for every <span><span class="math inline">\(M \in \{0,1\}^*\)</span></span>. Then we will construct an algorithm <span><span class="math inline">\(B\)</span></span> that solves <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>, contradicting <a href='#haltonzero-thm'>Theorem 8.10</a>.</p>
<p>Given a Turing machine <span><span class="math inline">\(N\)</span></span> (which is the input to <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>), our Algorithm <span><span class="math inline">\(B\)</span></span> does the following:</p>
<ol type="1">
<li><p>Construct a Turing Machine <span><span class="math inline">\(M\)</span></span> which on input <span><span class="math inline">\(x\in\{0,1\}^*\)</span></span>, first runs <span><span class="math inline">\(N(0)\)</span></span> and then outputs <span><span class="math inline">\(0\)</span></span>.</p></li>
<li><p>Return <span><span class="math inline">\(A(M)\)</span></span>.</p></li>
</ol>
<p>Now if <span><span class="math inline">\(N\)</span></span> halts on the input <span><span class="math inline">\(0\)</span></span> then the Turing machine <span><span class="math inline">\(M\)</span></span> computes the constant zero function, and hence under our assumption that <span><span class="math inline">\(A\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}\)</span></span>, <span><span class="math inline">\(A(M)=1\)</span></span>. If <span><span class="math inline">\(N\)</span></span> does not halt on the input <span><span class="math inline">\(0\)</span></span>, then the Turing machine <span><span class="math inline">\(M\)</span></span> will not halt on any input, and so in particular will <em>not</em> compute the constant zero function. Hence under our assumption that <span><span class="math inline">\(A\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}\)</span></span>, <span><span class="math inline">\(A(M)=0\)</span></span>. We see that in both cases, <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}(M)=\ensuremath{\mathit{HALTONZERO}}(N)\)</span></span> and hence the value that Algorithm <span><span class="math inline">\(B\)</span></span> returns in step 2 is equal to <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(N)\)</span></span> which is what we needed to prove.</p>
</div>
<p>Another result along similar lines is the following:</p>
<div id="paritythm" class="theorem" title="Uncomputability of verifying parity" name="Theorem 8.14 (Uncomputability of verifying parity) ">
<p>The following function is uncomputable <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{COMPUTES}}\text{-}\ensuremath{\mathit{PARITY}}(P) = \begin{cases} 1 &amp; P \text{ computes the parity function } \\ 0 &amp; \text{otherwise} \end{cases}
\]</span></div></span></p>
</div>
<div class="pause" name="Pause">
<p>We leave the proof of <a href='#paritythm'>Theorem 8.14</a> as an exercise (<a href='#paritythmex'>Exercise 8.6</a>). I strongly encourage you to stop here and try to solve this exercise.</p>
</div>
<h3 id="ricethmsec" data-number="8.5.1">Rice’s Theorem</h3>
<p><a href='#paritythm'>Theorem 8.14</a> can be generalized far beyond the parity function. In fact, this generalization rules out verifying any type of semantic specification on programs. We define a <em>semantic specification</em> on programs to be some property that does not depend on the code of the program but just on the function that the program computes.</p>
<p>For example, consider the following two C programs</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="bu">int</span> First(<span class="bu">int</span> k) {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>k<span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3">}</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="bu">int</span> Second(<span class="bu">int</span> n) {</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="bu">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="bu">int</span> j <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="cf">while</span> (j<span class="op">&lt;</span>n) {</a>
<a class="sourceLine" id="cb7-5" title="5">        i <span class="op">=</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6">        j<span class="op">=</span>  j <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    }</a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="cf">return</span> i<span class="op">;</span></a>
<a class="sourceLine" id="cb7-9" title="9">}</a></code></pre></div>
<p><code>First</code> and <code>Second</code> are two distinct C programs, but they compute the same function. A <em>semantic</em> property, would be either <em>true</em> for both programs or <em>false</em> for both programs, since it depends on the <em>function</em> the programs compute and not on their code. An example for a semantic property that both <code>First</code> and <code>Second</code> satisfy is the following: <em>“The program <span><span class="math inline">\(P\)</span></span> computes a function <span><span class="math inline">\(f\)</span></span> mapping integers to integers satisfying that <span><span class="math inline">\(f(n) \geq n\)</span></span> for every input <span><span class="math inline">\(n\)</span></span>”.</em></p>
<p>A property is <em>not semantic</em> if it depends on the <em>source code</em> rather than the input/output behavior. For example, properties such as “the program contains the variable <code>k</code>” or “the program uses the <code>while</code> operation” are not semantic. Such properties can be true for one of the programs and false for others. Formally, we define semantic properties as follows:</p>
<div id="semanticpropdef" class="definition" title="Semantic properties" name="Definition 8.15 (Semantic properties) ">
<p>A pair of Turing machines <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(M&#39;\)</span></span> are <em>functionally equivalent</em> if for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(M(x)=M&#39;(x)\)</span></span>. (In particular, <span><span class="math inline">\(M(x)=\bot\)</span></span> iff <span><span class="math inline">\(M&#39;(x)=\bot\)</span></span> for all <span><span class="math inline">\(x\)</span></span>.)</p>
<p>A function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> is <em>semantic</em> if for every pair of strings <span><span class="math inline">\(M,M&#39;\)</span></span> that represent functionally equivalent Turing machines, <span><span class="math inline">\(F(M)=F(M&#39;)\)</span></span>. (Recall that we assume that every string represents <em>some</em> Turing machine, see <a href='#TMrepremark'>Remark 8.3</a>)</p>
</div>
<p>There are two trivial examples of semantic functions: the constant one function and the constant zero function. For example, if <span><span class="math inline">\(Z\)</span></span> is the constant zero function (i.e., <span><span class="math inline">\(Z(M)=0\)</span></span> for every <span><span class="math inline">\(M\)</span></span>) then clearly <span><span class="math inline">\(F(M)=F(M&#39;)\)</span></span> for every pair of Turing machines <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(M&#39;\)</span></span> that are functionally equivalent <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(M&#39;\)</span></span>. Here is a non-trivial example</p>
<div id="zerofuncsem" class="solvedexercise" title="$ZEROFUNC$ is semantic" name="Solvedexercise 8.1 ($ZEROFUNC$ is semantic) ">
<p>Prove that the function <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}\)</span></span> is semantic.</p>
</div>
<div class="solution" data-ref="zerofuncsem" name="Solution 8.5.1">
<p>Recall that <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}(M)=1\)</span></span> if and only if <span><span class="math inline">\(M(x)=0\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. If <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(M&#39;\)</span></span> are functionally equivalent, then for every <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(M(x)=M&#39;(x)\)</span></span>. Hence <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}(M)=1\)</span></span> if and only if <span><span class="math inline">\(\ensuremath{\mathit{ZEROFUNC}}(M&#39;)=1\)</span></span>.</p>
</div>
<p>Often the properties of programs that we are most interested in computing are the <em>semantic</em> ones, since we want to understand the programs’ functionality. Unfortunately, Rice’s Theorem tells us that these properties are all uncomputable:</p>
<div id="rice-thm" class="theorem" title="Rice&#39;s Theorem" name="Theorem 8.16 (Rice&#39;s Theorem) ">
<p>Let <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>. If <span><span class="math inline">\(F\)</span></span> is semantic and non-trivial then it is uncomputable.</p>
</div>
<div class="proofidea" data-ref="rice-thm" name="Proofidea 22.11.1">
<p>The idea behind the proof is to show that every semantic non-trivial function <span><span class="math inline">\(F\)</span></span> is at least as hard to compute as <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>. This will conclude the proof since by <a href='#haltonzero-thm'>Theorem 8.10</a>, <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> is uncomputable. If a function <span><span class="math inline">\(F\)</span></span> is non trivial then there are two machines <span><span class="math inline">\(M_0\)</span></span> and <span><span class="math inline">\(M_1\)</span></span> such that <span><span class="math inline">\(F(M_0)=0\)</span></span> and <span><span class="math inline">\(F(M_1)=1\)</span></span>. So, the goal would be to take a machine <span><span class="math inline">\(N\)</span></span> and find a way to map it into a machine <span><span class="math inline">\(M=R(N)\)</span></span>, such that <strong>(i)</strong> if <span><span class="math inline">\(N\)</span></span> halts on zero then <span><span class="math inline">\(M\)</span></span> is functionally equivalent to <span><span class="math inline">\(M_1\)</span></span> and <strong>(ii)</strong> if <span><span class="math inline">\(N\)</span></span> does <em>not</em> halt on zero then <span><span class="math inline">\(M\)</span></span> is functionally equivalent <span><span class="math inline">\(M_0\)</span></span>.</p>
<p>Because <span><span class="math inline">\(F\)</span></span> is semantic, if we achieved this, then we would be guaranteed that <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(N) = F(R(N))\)</span></span>, and hence would show that if <span><span class="math inline">\(F\)</span></span> was computable, then <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> would be computable as well, contradicting <a href='#haltonzero-thm'>Theorem 8.10</a>.</p>
</div>
<div class="proof" data-ref="rice-thm" name="Proof 8.5.1">
<p>We will not give the proof in full formality, but rather illustrate the proof idea by restricting our attention to a particular semantic function <span><span class="math inline">\(F\)</span></span>. However, the same techniques generalize to all possible semantic functions. Define <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> as follows: <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(M)=1\)</span></span> if there does not exist <span><span class="math inline">\(n\in \N\)</span></span> and two inputs <span><span class="math inline">\(x,x&#39; \in \{0,1\}^n\)</span></span> such that for every <span><span class="math inline">\(i\in [n]\)</span></span> <span><span class="math inline">\(x_i \leq x&#39;_i\)</span></span> but <span><span class="math inline">\(M(x)\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(M(x&#39;)=0\)</span></span>. That is, <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(M)=1\)</span></span> if it’s not possible to find an input <span><span class="math inline">\(x\)</span></span> such that flipping some bits of <span><span class="math inline">\(x\)</span></span> from <span><span class="math inline">\(0\)</span></span> to <span><span class="math inline">\(1\)</span></span> will change <span><span class="math inline">\(M\)</span></span>’s output in the other direction from <span><span class="math inline">\(1\)</span></span> to <span><span class="math inline">\(0\)</span></span>. We will prove that <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span> is uncomputable, but the proof will easily generalize to any semantic function.</p>
<p>We start by noting that <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span> is neither the constant zero nor the constant one function:</p>
<ul>
<li><p>The machine <span><span class="math inline">\(\ensuremath{\mathit{INF}}\)</span></span> that simply goes into an infinite loop on every input satisfies <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(\ensuremath{\mathit{INF}})=1\)</span></span>, since <span><span class="math inline">\(\ensuremath{\mathit{INF}}\)</span></span> is not defined <em>anywhere</em> and so in particular there are no two inputs <span><span class="math inline">\(x,x&#39;\)</span></span> where <span><span class="math inline">\(x_i \leq x&#39;_i\)</span></span> for every <span><span class="math inline">\(i\)</span></span> but <span><span class="math inline">\(\ensuremath{\mathit{INF}}(x)=0\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{INF}}(x&#39;)=1\)</span></span>.</p></li>
<li><p>The machine <span><span class="math inline">\(\ensuremath{\mathit{PAR}}\)</span></span> that computes the XOR or parity of its input, is not monotone (e.g., <span><span class="math inline">\(\ensuremath{\mathit{PAR}}(1,1,0,0,\ldots,0)=0\)</span></span> but <span><span class="math inline">\(\ensuremath{\mathit{PAR}}(1,0,0,\ldots,0)=0\)</span></span>) and hence <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(\ensuremath{\mathit{PAR}})=0\)</span></span>.</p></li>
</ul>
<p>(Note that <span><span class="math inline">\(\ensuremath{\mathit{INF}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{PAR}}\)</span></span> are <em>machines</em> and not <em>functions</em>.)</p>
<p>We will now give a reduction from <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span>. That is, we assume towards a contradiction that there exists an algorithm <span><span class="math inline">\(A\)</span></span> that computes <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span> and we will build an algorithm <span><span class="math inline">\(B\)</span></span> that computes <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>. Our algorithm <span><span class="math inline">\(B\)</span></span> will work as follows:</p>
<blockquote>
<div class="quote" name="Quote 8.5.1">
<p><strong>Algorithm <span><span class="math inline">\(B\)</span></span>:</strong></p>
<p><strong>Input:</strong> String <span><span class="math inline">\(N\)</span></span> describing a Turing machine. (<em>Goal:</em> Compute <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(N)\)</span></span>)</p>
<p><strong>Assumption:</strong> Access to Algorithm <span><span class="math inline">\(A\)</span></span> to compute <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span>.</p>
<p><strong>Operation:</strong></p>
<ol type="1">
<li><p>Construct the following machine <span><span class="math inline">\(M\)</span></span>: “On input <span><span class="math inline">\(z\in \{0,1\}^*\)</span></span> do: <strong>(a)</strong> Run <span><span class="math inline">\(N(0)\)</span></span>, <strong>(b)</strong> Return <span><span class="math inline">\(\ensuremath{\mathit{PAR}}(z)\)</span></span>”.</p></li>
<li><p>Return <span><span class="math inline">\(1-A(M)\)</span></span>.</p></li>
</ol>
</div>
</blockquote>
<p>To complete the proof we need to show that <span><span class="math inline">\(B\)</span></span> outputs the correct answer, under our assumption that <span><span class="math inline">\(A\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span>. In other words, we need to show that <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(N)=1-MONOTONE(M)\)</span></span>. Suppose that <span><span class="math inline">\(N\)</span></span> does <em>not</em> halt on zero. In this case the program <span><span class="math inline">\(M\)</span></span> constructed by Algorithm <span><span class="math inline">\(B\)</span></span> enters into an infinite loop in step <strong>(a)</strong> and will never reach step <strong>(b)</strong>. Hence in this case <span><span class="math inline">\(N\)</span></span> is functionally equivalent to <span><span class="math inline">\(\ensuremath{\mathit{INF}}\)</span></span>. (The machine <span><span class="math inline">\(N\)</span></span> is not the same machine as <span><span class="math inline">\(\ensuremath{\mathit{INF}}\)</span></span>: its description or <em>code</em> is different. But it does have the same input/output behavior (in this case) of never halting on any input. Also, while the program <span><span class="math inline">\(M\)</span></span> will go into an infinite loop on every input, Algorithm <span><span class="math inline">\(B\)</span></span> never actually runs <span><span class="math inline">\(M\)</span></span>: it only produces its code and feeds it to <span><span class="math inline">\(A\)</span></span>. Hence Algorithm <span><span class="math inline">\(B\)</span></span> will <em>not</em> enter into an infinite loop even in this case.) Thus in this case, <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(N)=\ensuremath{\mathit{MONOTONE}}(\ensuremath{\mathit{INF}})=1\)</span></span>.</p>
<p>If <span><span class="math inline">\(N\)</span></span> <em>does</em> halt on zero, then step <strong>(a)</strong> in <span><span class="math inline">\(M\)</span></span> will eventually conclude and <span><span class="math inline">\(M\)</span></span>’s output will be determined by step <strong>(b)</strong>, where it simply outputs the parity of its input. Hence in this case, <span><span class="math inline">\(M\)</span></span> computes the non-monotone parity function (i.e., is functionally equivalent to <span><span class="math inline">\(\ensuremath{\mathit{PAR}}\)</span></span>), and so we get that <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(M)=\ensuremath{\mathit{MONOTONE}}(\ensuremath{\mathit{PAR}})=0\)</span></span>. In both cases, <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}(M)=1-HALTONZERO(N)\)</span></span>, which is what we wanted to prove.</p>
<p>An examination of this proof shows that we did not use anything about <span><span class="math inline">\(\ensuremath{\mathit{MONOTONE}}\)</span></span> beyond the fact that it is semantic and non-trivial. For every semantic non-trivial <span><span class="math inline">\(F\)</span></span>, we can use the same proof, replacing <span><span class="math inline">\(\ensuremath{\mathit{PAR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{INF}}\)</span></span> with two machines <span><span class="math inline">\(M_0\)</span></span> and <span><span class="math inline">\(M_1\)</span></span> such that <span><span class="math inline">\(F(M_0)=0\)</span></span> and <span><span class="math inline">\(F(M_1)=1\)</span></span>. Such machines must exist if <span><span class="math inline">\(F\)</span></span> is non trivial.</p>
</div>
<div id="syntacticcomputablefunctions" class="remark" title="Semantic is not the same as uncomputable" name="Remark 8.17 (Semantic is not the same as uncomputable) ">
<p>Rice’s Theorem is so powerful and such a popular way of proving uncomputability that people sometimes get confused and think that it is the <em>only</em> way to prove uncomputability. In particular, a common misconception is that if a function <span><span class="math inline">\(F\)</span></span> is <em>not</em> semantic then it is <em>computable</em>. This is not at all the case.</p>
<p>For example, consider the following function <span><span class="math inline">\(\ensuremath{\mathit{HALTNOYALE}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>. This is a function that on input a string that represents a NAND-TM program <span><span class="math inline">\(P\)</span></span>, outputs <span><span class="math inline">\(1\)</span></span> if and only if both <strong>(i)</strong> <span><span class="math inline">\(P\)</span></span> halts on the input <span><span class="math inline">\(0\)</span></span>, and <strong>(ii)</strong> the program <span><span class="math inline">\(P\)</span></span> does not contain a variable with the identifier <code>Yale</code>. The function <span><span class="math inline">\(\ensuremath{\mathit{HALTNOYALE}}\)</span></span> is clearly not semantic, as it will output two different values when given as input one of the following two functionally equivalent programs:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">Yale[<span class="dv">0</span>] <span class="op">=</span> NAND(X[<span class="dv">0</span>],X[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb8-2" title="2">Y[<span class="dv">0</span>] <span class="op">=</span> NAND(X[<span class="dv">0</span>],Yale[<span class="dv">0</span>])</a></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">Harvard[<span class="dv">0</span>] <span class="op">=</span> NAND(X[<span class="dv">0</span>],X[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb9-2" title="2">Y[<span class="dv">0</span>] <span class="op">=</span> NAND(X[<span class="dv">0</span>],Harvard[<span class="dv">0</span>])</a></code></pre></div>
<p>However, <span><span class="math inline">\(\ensuremath{\mathit{HALTNOYALE}}\)</span></span> is uncomputable since every program <span><span class="math inline">\(P\)</span></span> can be transformed into an equivalent (and in fact improved <code>:)</code>) program <span><span class="math inline">\(P&#39;\)</span></span> that does not contain the variable <code>Yale</code>. Hence if we could compute <span><span class="math inline">\(\ensuremath{\mathit{HALTONYALE}}\)</span></span> then determine halting on zero for NAND-TM programs (and hence for Turing machines as well).</p>
<p>Moreover, as we will see in <a href='lec_09_godel.html#godelchap'>Chapter 10</a>, there are uncomputable functions whose inputs are not programs, and hence for which the adjective “semantic” is not applicable.</p>
<p>Properties such as “the program contains the variable <code>Yale</code>” are sometimes known as <em>syntactic</em> properties. The terms “semantic” and “syntactic” are used beyond the realm of programming languages: a famous example of a syntactically correct but semantically meaningless sentence in English is Chomsky’s <a href="https://goo.gl/4gXoiV">“Colorless green ideas sleep furiously.”</a> However, formally defining “syntactic properties” is rather subtle and we will not use this terminology in this book, sticking to the terms “semantic” and “non semantic” only.</p>
</div>
<h3 id="halting-and-rices-theorem-for-other-turing-complete-models" data-number="8.5.2">Halting and Rice’s Theorem for other Turing-complete models</h3>
<p>As we saw before, many natural computational models turn out to be <em>equivalent</em> to one another, in the sense that we can transform a “program” of one model (such as a <span><span class="math inline">\(\lambda\)</span></span> expression, or a game-of-life configurations) into another model (such as a NAND-TM program). This equivalence implies that we can translate the uncomputability of the Halting problem for NAND-TM programs into uncomputability for Halting in other models. For example:</p>
<div id="halt-tm" class="theorem" title="NAND-TM Machine Halting" name="Theorem 8.18 (NAND-TM Machine Halting) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{NANDTMHALT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that on input strings <span><span class="math inline">\(P\in\{0,1\}^*\)</span></span> and <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> if the NAND-TM program described by <span><span class="math inline">\(P\)</span></span> halts on the input <span><span class="math inline">\(x\)</span></span> and outputs <span><span class="math inline">\(0\)</span></span> otherwise. Then <span><span class="math inline">\(\ensuremath{\mathit{NANDTMHALT}}\)</span></span> is uncomputable.</p>
</div>
<div id="section-5" class="pause" name="Pause">
<p>Once again, this is a good point for you to stop and try to prove the result yourself before reading the proof below.</p>
</div>
<div class="proof" name="Proof">
<p>We have seen in <a href='lec_06_loops.html#TM-equiv-thm'>Theorem 6.12</a> that for every Turing machine <span><span class="math inline">\(M\)</span></span>, there is an equivalent NAND-TM program <span><span class="math inline">\(P_M\)</span></span> such that for every <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(P_M(x)=M(x)\)</span></span>. In particular this means that <span><span class="math inline">\(\ensuremath{\mathit{HALT}}(M)= \ensuremath{\mathit{NANDTMHALT}}(P_M)\)</span></span>.</p>
<p>The transformation <span><span class="math inline">\(M \mapsto P_M\)</span></span> that is obtained from the proof of <a href='lec_06_loops.html#TM-equiv-thm'>Theorem 6.12</a> is <em>constructive</em>. That is, the proof yields a way to <em>compute</em> the map <span><span class="math inline">\(M \mapsto P_M\)</span></span>. This means that this proof yields a <em>reduction</em> from task of computing <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> to the task of computing <span><span class="math inline">\(\ensuremath{\mathit{NANDTMHALT}}\)</span></span>, which means that since <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> is uncomputable, neither is <span><span class="math inline">\(\ensuremath{\mathit{NANDTMHALT}}\)</span></span>.</p>
</div>
<p>The same proof carries over to other computational models such as the <em><span><span class="math inline">\(\lambda\)</span></span> calculus</em>, <em>two dimensional</em> (or even one-dimensional) <em>automata</em> etc. Hence for example, there is no algorithm to decide if a <span><span class="math inline">\(\lambda\)</span></span> expression evaluates the identity function, and no algorithm to decide whether an initial configuration of the game of life will result in eventually coloring the cell <span><span class="math inline">\((0,0)\)</span></span> black or not.</p>
<p>Indeed, we can generalize Rice’s Theorem to all these models. For example, if <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> is a non-trivial function such that <span><span class="math inline">\(F(P)=F(P&#39;)\)</span></span> for every functionally equivalent NAND-TM programs <span><span class="math inline">\(P,P&#39;\)</span></span> then <span><span class="math inline">\(F\)</span></span> is uncomputable, and the same holds for NAND-RAM programs, <span><span class="math inline">\(\lambda\)</span></span>-expressions, and all other Turing complete models (as defined in <a href='lec_07_other_models.html#turingcompletedef'>Definition 7.5</a>), see also <a href='#ricegeneralex'>Exercise 8.12</a>.</p>
<h3 id="is-software-verification-doomed-discussion" data-number="8.5.3">Is software verification doomed? (discussion)</h3>
<p>Programs are increasingly being used for mission critical purposes, whether it’s running our banking system, flying planes, or monitoring nuclear reactors. If we can’t even give a certification algorithm that a program correctly computes the parity function, how can we ever be assured that a program does what it is supposed to do? The key insight is that while it is impossible to certify that a <em>general</em> program conforms with a specification, it is possible to write a program in the first place in a way that will make it easier to certify. As a trivial example, if you write a program without loops, then you can certify that it halts. Also, while it might not be possible to certify that an <em>arbitrary</em> program computes the parity function, it is quite possible to write a particular program <span><span class="math inline">\(P\)</span></span> for which we can mathematically <em>prove</em> that <span><span class="math inline">\(P\)</span></span> computes the parity. In fact, writing programs or algorithms and providing proofs for their correctness is what we do all the time in algorithms research.</p>
<p>The field of <em>software verification</em> is concerned with verifying that given programs satisfy certain conditions. These conditions can be that the program computes a certain function, that it never writes into a dangerous memory location, that is respects certain invariants, and others. While the general tasks of verifying this may be uncomputable, researchers have managed to do so for many interesting cases, especially if the program is written in the first place in a formalism or programming language that makes verification easier. That said, verification, especially of large and complex programs, remains a highly challenging task in practice as well, and the number of programs that have been formally proven correct is still quite small. Moreover, even phrasing the right theorem to prove (i.e., the specification) if often a highly non-trivial endeavor.</p>
<figure>
<img src="../figure/inclusion_noncomputable.png" alt="8.8: The set \mathbf{R} of computable Boolean functions () is a proper subset of the set of all functions mapping \{0,1\}^* to \{0,1\}. In this chapter we saw a few examples of elements in the latter set that are not in the former." id="inclusionuncomputablefig" class="class" /><figcaption>8.8: The set <span><span class="math inline">\(\mathbf{R}\)</span></span> of computable Boolean functions (<a href='lec_06_loops.html#classRdef'>Definition 6.4</a>) is a proper subset of the set of all functions mapping <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>. In this chapter we saw a few examples of elements in the latter set that are not in the former.</figcaption>
</figure>
<div class="recap" name="Recap 8.5.3">
<ul>
<li><p>There is a <em>universal</em> Turing machine (or NAND-TM program) <span><span class="math inline">\(U\)</span></span> such that on input a description of a Turing machine <span><span class="math inline">\(M\)</span></span> and some input <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(U(M,x)\)</span></span> halts and outputs <span><span class="math inline">\(M(x)\)</span></span> if (and only if) <span><span class="math inline">\(M\)</span></span> halts on input <span><span class="math inline">\(x\)</span></span>. Unlike in the case of finite computation (i.e., NAND-CIRC programs / circuits), the input to the program <span><span class="math inline">\(U\)</span></span> can be a machine <span><span class="math inline">\(M\)</span></span> that has more states than <span><span class="math inline">\(U\)</span></span> itself.</p></li>
<li><p>Unlike the finite case, there are actually functions that are <em>inherently uncomputable</em> in the sense that they cannot be computed by <em>any</em> Turing machine.</p></li>
<li><p>These include not only some “degenerate” or “esoteric” functions but also functions that people have deeply care about and conjectured that could be computed.</p></li>
<li><p>If the Church-Turing thesis holds then a function <span><span class="math inline">\(F\)</span></span> that is uncomputable according to our definition cannot be computed by any means in our physical world.</p></li>
</ul>
</div>
<h2 id="exercises" data-number="8.6">Exercises</h2>
<div id="NANDRAMHalt" class="exercise" title="NAND-RAM Halt" name="Exercise 8.1 (NAND-RAM Halt) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{NANDRAMHALT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function such that on input <span><span class="math inline">\((P,x)\)</span></span> where <span><span class="math inline">\(P\)</span></span> represents a NAND-RAM program, <span><span class="math inline">\(\ensuremath{\mathit{NANDRAMHALT}}(P,x)=1\)</span></span> iff <span><span class="math inline">\(P\)</span></span> halts on the input <span><span class="math inline">\(x\)</span></span>. Prove that <span><span class="math inline">\(\ensuremath{\mathit{NANDRAMHALT}}\)</span></span> is uncomputable.</p>
</div>
<div id="timedhalt" class="exercise" title="Timed halting" name="Exercise 8.2 (Timed halting) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{TIMEDHALT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that on input (a string representing) a triple <span><span class="math inline">\((M,x,T)\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{TIMEDHALT}}(M,x,T)=1\)</span></span> iff the Turing machine <span><span class="math inline">\(M\)</span></span>, on input <span><span class="math inline">\(x\)</span></span>, halts within at most <span><span class="math inline">\(T\)</span></span> steps (where a <em>step</em> is defined as one sequence of reading a symbol from the tape, updating the state, writing a new symbol and (potentially) moving the head).</p>
<p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{TIMEDHALT}}\)</span></span> is <em>computable</em>.</p>
</div>
<div id="spacehalting" class="exercise" title="Space halting (challenging)" name="Exercise 8.3 (Space halting (challenging)) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{SPACEHALT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that on input (a string representing) a triple <span><span class="math inline">\((M,x,T)\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{SPACEHALT}}(M,x,T)=1\)</span></span> iff the Turing machine <span><span class="math inline">\(M\)</span></span>, on input <span><span class="math inline">\(x\)</span></span>, halts before its head reached the <span><span class="math inline">\(T\)</span></span>-th location of its tape. (We don’t care how many steps <span><span class="math inline">\(M\)</span></span> makes, as long as the head stays inside locations <span><span class="math inline">\(\{0,\ldots,T-1\}\)</span></span>.)</p>
<p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{SPACEHALT}}\)</span></span> is <em>computable</em>. See footnote for hint<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
</div>
<div id="necessarilyuncomputableex" class="exercise" title="Computable compositions" name="Exercise 8.4 (Computable compositions) ">
<p>Suppose that <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> and <span><span class="math inline">\(G:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> are computable functions. For each one of the following functions <span><span class="math inline">\(H\)</span></span>, either prove that <span><span class="math inline">\(H\)</span></span> is <em>necessarily computable</em> or give an example of a pair <span><span class="math inline">\(F\)</span></span> and <span><span class="math inline">\(G\)</span></span> of computable functions such that <span><span class="math inline">\(H\)</span></span> will not be computable. Prove your assertions.</p>
<ol type="1">
<li><p><span><span class="math inline">\(H(x)=1\)</span></span> iff <span><span class="math inline">\(F(x)=1\)</span></span> OR <span><span class="math inline">\(G(x)=1\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(H(x)=1\)</span></span> iff there exist two nonempty strings <span><span class="math inline">\(u,v \in \{0,1\}^*\)</span></span> such that <span><span class="math inline">\(x=uv\)</span></span> (i.e., <span><span class="math inline">\(x\)</span></span> is the concatenation of <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(v\)</span></span>), <span><span class="math inline">\(F(u)=1\)</span></span> and <span><span class="math inline">\(G(v)=1\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(H(x)=1\)</span></span> iff there exist a list <span><span class="math inline">\(u_0,\ldots,u_{t-1}\)</span></span> of non empty strings such that strings<span><span class="math inline">\(F(u_i)=1\)</span></span> for every <span><span class="math inline">\(i\in [t]\)</span></span> and <span><span class="math inline">\(x=u_0u_1\cdots u_{t-1}\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(H(x)=1\)</span></span> iff <span><span class="math inline">\(x\)</span></span> is a valid string representation of a NAND++ program <span><span class="math inline">\(P\)</span></span> such that for every <span><span class="math inline">\(z\in \{0,1\}^*\)</span></span>, on input <span><span class="math inline">\(z\)</span></span> the program <span><span class="math inline">\(P\)</span></span> outputs <span><span class="math inline">\(F(z)\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(H(x)=1\)</span></span> iff <span><span class="math inline">\(x\)</span></span> is a valid string representation of a NAND++ program <span><span class="math inline">\(P\)</span></span> such that on input <span><span class="math inline">\(x\)</span></span> the program <span><span class="math inline">\(P\)</span></span> outputs <span><span class="math inline">\(F(x)\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(H(x)=1\)</span></span> iff <span><span class="math inline">\(x\)</span></span> is a valid string representation of a NAND++ program <span><span class="math inline">\(P\)</span></span> such that on input <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(P\)</span></span> outputs <span><span class="math inline">\(F(x)\)</span></span> after executing at most <span><span class="math inline">\(100\cdot |x|^2\)</span></span> lines.</p></li>
</ol>
</div>
<div id="finiteuncompex" class="exercise" name="Exercise 8.5">
<p>Prove that the following function <span><span class="math inline">\(\ensuremath{\mathit{FINITE}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> is uncomputable. On input <span><span class="math inline">\(P\in \{0,1\}^*\)</span></span>, we define <span><span class="math inline">\(\ensuremath{\mathit{FINITE}}(P)=1\)</span></span> if and only if <span><span class="math inline">\(P\)</span></span> is a string that represents a NAND++ program such that there only a finite number of inputs <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> s.t. <span><span class="math inline">\(P(x)=1\)</span></span>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
</div>
<div id="paritythmex" class="exercise" title="Computing parity" name="Exercise 8.6 (Computing parity) ">
<p>Prove <a href='#paritythm'>Theorem 8.14</a> without using Rice’s Theorem.</p>
</div>
<div id="TMequivex" class="exercise" title="TM Equivalence" name="Exercise 8.7 (TM Equivalence) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{EQ}}:\{0,1\}^* :\rightarrow \{0,1\}\)</span></span> be the function defined as follows: given a string representing a pair <span><span class="math inline">\((M,M&#39;)\)</span></span> of Turing machines, <span><span class="math inline">\(\ensuremath{\mathit{EQ}}(M,M&#39;)=1\)</span></span> iff <span><span class="math inline">\(M\)</span></span> and <span><span class="math inline">\(M&#39;\)</span></span> are functionally equivalent as per <a href='#semanticpropdef'>Definition 8.15</a>. Prove that <span><span class="math inline">\(\ensuremath{\mathit{EQ}}\)</span></span> is uncomputable.</p>
<p>Note that you <em>cannot</em> use Rice’s Theorem directly, as this theorem only deals with functions that take a single Turing machine as input, and <span><span class="math inline">\(\ensuremath{\mathit{EQ}}\)</span></span> takes two machines.</p>
</div>
<div id="salil-ex" class="exercise" name="Exercise 8.8">
<p>For each of the following two functions, say whether it is computable or not:</p>
<ol type="1">
<li><p>Given a NAND-TM program <span><span class="math inline">\(P\)</span></span>, an input <span><span class="math inline">\(x\)</span></span>, and a number <span><span class="math inline">\(k\)</span></span>, when we run <span><span class="math inline">\(P\)</span></span> on <span><span class="math inline">\(x\)</span></span>, does the index variable <code>i</code> ever reach <span><span class="math inline">\(k\)</span></span>?</p></li>
<li><p>Given a NAND-TM program <span><span class="math inline">\(P\)</span></span>, an input <span><span class="math inline">\(x\)</span></span>, and a number <span><span class="math inline">\(k\)</span></span>, when we run <span><span class="math inline">\(P\)</span></span> on <span><span class="math inline">\(x\)</span></span>, does <span><span class="math inline">\(P\)</span></span> ever write to an array at index <span><span class="math inline">\(k\)</span></span>?</p></li>
</ol>
</div>
<div id="ricetmnandram" class="exercise" name="Exercise 8.9">
<p>Let <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that is defined as follows. On input a string <span><span class="math inline">\(P\)</span></span> that represents a NAND-RAM program and a String <span><span class="math inline">\(M\)</span></span> that represents a Turing machine, <span><span class="math inline">\(F(P,M)=1\)</span></span> if and only if there exists some input <span><span class="math inline">\(x\)</span></span> such <span><span class="math inline">\(P\)</span></span> halts on <span><span class="math inline">\(x\)</span></span> but <span><span class="math inline">\(M\)</span></span> does not halt on <span><span class="math inline">\(x\)</span></span>. Prove that <span><span class="math inline">\(F\)</span></span> is uncomputable. See footnote for hint.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
</div>
<div id="recursiveenumerableex" class="exercise" title="Recursively enumerable" name="Exercise 8.10 (Recursively enumerable) ">
<p>Define a function <span><span class="math inline">\(F:\{0,1\}^* :\rightarrow \{0,1\}\)</span></span> to be <em>recursively enumerable</em> if there exists a Turing machine <span><span class="math inline">\(M\)</span></span> such that such that for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, if <span><span class="math inline">\(F(x)=1\)</span></span> then <span><span class="math inline">\(M(x)=1\)</span></span>, and if <span><span class="math inline">\(F(x)=0\)</span></span> then <span><span class="math inline">\(M(x)=\bot\)</span></span>. (i.e., if <span><span class="math inline">\(F(x)=0\)</span></span> then <span><span class="math inline">\(M\)</span></span> does not halt on <span><span class="math inline">\(x\)</span></span>.)</p>
<ol type="1">
<li><p>Prove that every computable <span><span class="math inline">\(F\)</span></span> is also recursively enumerable.</p></li>
<li><p>Prove that there exists <span><span class="math inline">\(F\)</span></span> that is not computable but is recursively enumerable. See footnote for hint.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p></li>
<li><p>Prove that there exists a function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(F\)</span></span> is not recursively enumerable. See footnote for hint.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p></li>
<li><p>Prove that there exists a function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(F\)</span></span> is recursively enumerable but the function <span><span class="math inline">\(\overline{F}\)</span></span> defined as <span><span class="math inline">\(\overline{F}(x)=1-F(x)\)</span></span> is <em>not</em> recursively enumerable. See footnote for hint.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p></li>
</ol>
</div>
<div id="ricestandardex" class="exercise" title="Rice&#39;s Theorem: standard form" name="Exercise 8.11 (Rice&#39;s Theorem: standard form) ">
<p>In this exercise we will prove Rice’s Theorem in the form that it is typically stated in the literature.</p>
<p>For a Turing machine <span><span class="math inline">\(M\)</span></span>, define <span><span class="math inline">\(L(M) \subseteq \{0,1\}^*\)</span></span> to be the set of all <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> such that <span><span class="math inline">\(M\)</span></span> halts on the input <span><span class="math inline">\(x\)</span></span> and outputs <span><span class="math inline">\(1\)</span></span>. (The set <span><span class="math inline">\(L(M)\)</span></span> is known in the literature as the <em>language recognized by <span><span class="math inline">\(M\)</span></span></em>. Note that <span><span class="math inline">\(M\)</span></span> might either output a value other than <span><span class="math inline">\(1\)</span></span> or not halt at all on inputs <span><span class="math inline">\(x\not\in L(M)\)</span></span>. )</p>
<ol type="1">
<li><p>Prove that for every Turing Machine <span><span class="math inline">\(M\)</span></span>, if we define <span><span class="math inline">\(F_M:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> to be the function such that <span><span class="math inline">\(F_M(x)=1\)</span></span> iff <span><span class="math inline">\(x\in L(M)\)</span></span> then <span><span class="math inline">\(F_M\)</span></span> is <em>recursively enumerable</em> as defined in <a href='#recursiveenumerableex'>Exercise 8.10</a>.</p></li>
<li><p>Use <a href='#rice-thm'>Theorem 8.16</a> to prove that for every <span><span class="math inline">\(G:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>, if <strong>(a)</strong> <span><span class="math inline">\(G\)</span></span> is neither the constant zero nor the constant one function, and <strong>(b)</strong> for every <span><span class="math inline">\(M,M&#39;\)</span></span> such that <span><span class="math inline">\(L(M)=L(M&#39;)\)</span></span>, <span><span class="math inline">\(G(M)=G(M&#39;)\)</span></span>, then <span><span class="math inline">\(G\)</span></span> is uncomputable. See footnote for hint.<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p></li>
</ol>
</div>
<div id="ricegeneralex" class="exercise" title="Rice&#39;s Theorem for general Turing-equivalent models (optional)" name="Exercise 8.12 (Rice&#39;s Theorem for general Turing-equivalent models (optional)) ">
<p>Let <span><span class="math inline">\(\mathcal{F}\)</span></span> be the set of all partial functions from <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span> and <span><span class="math inline">\(\mathcal{M}:\{0,1\}^* \rightarrow \mathcal{F}\)</span></span> be a Turing-equivalent model as defined in <a href='lec_07_other_models.html#turingcompletedef'>Definition 7.5</a>. We define a function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> to be <em><span><span class="math inline">\(\mathcal{M}\)</span></span>-semantic</em> if there exists some <span><span class="math inline">\(\mathcal{G}:\mathcal{F} \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(F(P) = \mathcal{G}(\mathcal{M}(P))\)</span></span> for every <span><span class="math inline">\(P\in \{0,1\}^*\)</span></span>.</p>
<p>Prove that for every <span><span class="math inline">\(\mathcal{M}\)</span></span>-semantic <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that is neither the constant one nor the constant zero function, <span><span class="math inline">\(F\)</span></span> is uncomputable.</p>
</div>
<h2 id="uncomputablebibnotes" data-number="8.7">Bibliographical notes</h2>
<p>The cartoon of the Halting problem in <a href='#universalchapoverviewfig'>Figure 8.1</a> and taken from <a href="https://www.coopertoons.com/education/haltingproblem/haltingproblem.html/">Charles Cooper’s website</a>.</p>
<p>Section 7.2 in  (<a href="https://scholar.google.com/scholar?hl=en&q=Moore,+Mertens+The+nature+of+computation" target="_blank">Moore, Mertens, 2011</a>)  gives a highly recommended overview of uncomputability. Gödel, Escher, Bach  (<a href="https://scholar.google.com/scholar?hl=en&q=Hofstadter+GoÌˆdel,+Escher,+Bach+:+an+eternal+golden+braid" target="_blank">Hofstadter, 1999</a>)  is a classic popular science book that touches on uncomputability, and unprovability, and specifically Gödel’s Theorem that we will see in <a href='lec_09_godel.html#godelchap'>Chapter 10</a>. See also the recent book by Holt  (<a href="https://scholar.google.com/scholar?hl=en&q=Holt+When+Einstein+walked+with+GoÌˆdel+:+excursions+to+the+edge+of+thought" target="_blank">Holt, 2018</a>) .</p>
<p>The history of the definition of a function is intertwined with the development of mathematics as a field. For many years, a function was identified (as per Euler’s quote above) with the means to calculate the output from the input. In the 1800’s, with the invention of the Fourier series and with the systematic study of continuity and differentiability, people have started looking at more general kinds of functions, but the modern definition of a function as an arbitrary mapping was not yet universally accepted. For example, in 1899 Poincare wrote <em>“we have seen a mass of bizarre functions which appear to be forced to resemble as little as possible honest functions which serve some purpose. … they are invented on purpose to show that our ancestor’s reasoning was at fault, and we shall never get anything more than that out of them”.</em> Some of this fascinating history is discussed in  (<a href="https://scholar.google.com/scholar?hl=en&q=Grabiner+Who+gave+you+the+epsilon?+Cauchy+and+the+origins+of+rigorous+calculus" target="_blank">Grabiner, 1983</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=Kleiner+Rigor+and+Proof+in+Mathematics:+A+Historical+Perspective" target="_blank">Kleiner, 1991</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=LÃ¼tzen+Between+Rigor+and+Applications:+Developments+in+the+Concept+of+Function+in+Mathematical+Analysis" target="_blank">LÃ¼tzen, 2002</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=Grabiner+The+origins+of+Cauchy's+rigorous+calculus" target="_blank">Grabiner, 2005</a>) .</p>
<p>The existence of a universal Turing machine, and the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> was first shown by Turing in his seminal paper  (<a href="https://scholar.google.com/scholar?hl=en&q=Turing+On+computable+numbers,+with+an+application+to+the+Entscheidungsproblem" target="_blank">Turing, 1937</a>) , though closely related results were shown by Church a year before. These works built on Gödel’s 1931 <em>incompleteness theorem</em> that we will discuss in <a href='lec_09_godel.html#godelchap'>Chapter 10</a>.</p>
<p>Some universal Turing Machines with a small alphabet and number of states are given in  (<a href="https://scholar.google.com/scholar?hl=en&q=Rogozhin+Small+universal+Turing+machines" target="_blank">Rogozhin, 1996</a>) , including a single-tape universal Turing machine with the binary alphabet and with less than <span><span class="math inline">\(25\)</span></span> states; see also the survey  (<a href="https://scholar.google.com/scholar?hl=en&q=Woods,+Neary+The+complexity+of+small+universal+Turing+machines:+A+survey" target="_blank">Woods, Neary, 2009</a>) . Adam Yedidia has written <a href="https://github.com/adamyedidia/parsimony">software</a> to help in producing Turing machines with a small number of states. This is related to the recreational pastime of <a href="https://codegolf.stackexchange.com/">“Code Golfing”</a> which is about solving a certain computational task using the as short as possible program.</p>
<p>The diagonalization argument used to prove uncomputability of <span><span class="math inline">\(F^*\)</span></span> is derived from Cantor’s argument for the uncountability of the reals discussed in <a href='lec_02_representation.html#chaprepres'>Chapter 2</a>.</p>
<p>Christopher Strachey was an English computer scientist and the inventor of the CPL programming language. He was also an early artificial intelligence visionary, programming a computer to play Checkers and even write love letters in the early 1950’s, see <a href="https://www.newyorker.com/tech/elements/christopher-stracheys-nineteen-fifties-love-machine">this New Yorker article</a> and <a href="http://www.alpha60.de/art/love_letters/">this website</a>.</p>
<p>Rice’s Theorem was proven in  (<a href="https://scholar.google.com/scholar?hl=en&q=Rice+Classes+of+recursively+enumerable+sets+and+their+decision+problems" target="_blank">Rice, 1953</a>) . It is typically stated in a form somewhat different than what we used, see <a href='#ricesstandardex'>?? ??</a>.</p>
<p>We do not discuss in the chapter the concept of <em>recursively enumerable</em> languages, but it is covered briefly in <a href='#recursiveenumerableex'>Exercise 8.10</a>. As usual, we use function, as opposto language, notation.</p>
<p>The cartoon of the Halting problem in <a href='#universalchapoverviewfig'>Figure 8.1</a> is copyright 2019 Charles F. Cooper.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>This argument has also been connected to the issues of consciousness and free will. I am personally skeptical of its relevance to these issues. Perhaps the reasoning is that humans have the ability to solve the halting problem but they exercise their free will and consciousness by choosing not to do so.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>A machine with alphabet <span><span class="math inline">\(\Sigma\)</span></span> can have at most <span><span class="math inline">\(|\Sigma|^T\)</span></span> choices for the contents of the first <span><span class="math inline">\(T\)</span></span> locations of its tape. What happens if the machine repeats a previously seen configuration, in the sense that the tape contents, the head location, and the current state, are all identical to what they were in some previous state of the execution?</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>Hint: You can use Rice’s Theorem.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p><em>Hint:</em> While it cannot be applied directly, with a little “massaging” you can prove this using Rice’s Theorem.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p><span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> has this property.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>You can either use the diagonalization method to prove this directly or show that the set of all recursively enumerable functions is <em>countable</em>.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:7"><p>
<div>
<p><span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> has this property: show that if both <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> and <span><span class="math inline">\(\overline{HALT}\)</span></span> were recursively enumerable then <span><span class="math inline">\(\ensuremath{\mathit{HALT}}\)</span></span> would be in fact computable.</p>
</div>
<a href="#fnref:7" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:8"><p>
<div>
<p>Show that any <span><span class="math inline">\(G\)</span></span> satisfying <strong>(b)</strong> must be semantic.</p>
</div>
<a href="#fnref:8" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:38:57</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_08_uncomputability.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
