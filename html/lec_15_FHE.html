<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Fully Homomorphic Encryption</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Fully Homomorphic Encryption" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#countoperation"><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li><li class="chapter" data-level="5.4" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>5.4</b> Optional, Aside: Broadcast Encryption</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash Functions and Random Oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "Bitcoin" Problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The Currency Problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin Architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The Bitcoin Ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From Proof of Work to Consensus on Ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision Resistance Hash Functions and Creating Short "Unique" Identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical Constructions of Cryptographic Hash Functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical Random-ish Functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some History</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions"><i class="fa fa-check"></i><b>7.4.3</b> The NSA and Hash Functions</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs Non-Cryptographic Hash Functions</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li><li class="chapter" data-level="10.6" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a><ul><li class="chapter" data-level="10.6.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li></ul></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li><ul><li class="chapter" data-level="12.0.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li></ul></li><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption: Construction {chapfhetwo }</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#advanced-topics"><i class="fa fa-check"></i><b>17.6</b> Advanced topics:</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#hbctomalred"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation II: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Fully Homomorphic Encryption</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_15_FHE.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="chapfheone" data-number="16">Fully homomorphic encryption: Introduction and bootstrapping</h1>
<p>In today’s era of “cloud computing”, much of individuals’ and businesses’ data is stored and computed on by third parties such as Google, Microsoft, Apple, Amazon, Facebook, Dropbox and many others. Classically, cryptography provided solutions to protecting <a href="https://www.schneier.com/blog/archives/2010/06/data_at_rest_vs.html">data in motion</a> from point A to point B. But these are not always sufficient to protect <a href="https://en.wikipedia.org/wiki/Data_at_rest">data at rest</a> and particularly <a href="https://en.wikipedia.org/wiki/Data_in_use">data in use</a>. For example, suppose that <em>Alice</em> has some data <span><span class="math inline">\(x \in \{0,1\}^n\)</span></span> (in modern applications <span><span class="math inline">\(x\)</span></span> would well be terabytes in length or larger) that she wishes to store with the cloud service <em>Bob</em>, but is afraid that Bob will be hacked, subpoenaed or simply does not completely trust Bob.</p>
<p>Encryption does not seem to immediately solve the problem. Alice could store at Bob an <em>encrypted</em> version of the data and keep the secret key for herself. But then she would be at a loss if she wanted to do with the data anything more than retrieving particular blocks of it. If she wanted to outsource computation to Bob as well, and compute <span><span class="math inline">\(f(x)\)</span></span> for some function <span><span class="math inline">\(f\)</span></span>, then she would need to share the secret key with Bob, thus defeating the purpose of encrypting the data in the first place.</p>
<p>For example, after the computing systems of Office of Personell Management (OPM) were <a href="https://www.lawfareblog.com/why-opm-hack-far-worse-you-imagine">discovered to be hacked</a> in June of 2015, revealing sensitive information, including fingerprints and all data gathered during security clearance checks of up to 18 million people, DHS assistant secretary for cybersecurity and communications Andy Ozment <a href="http://www.federaltimes.com/story/government/omr/opm-cyber-report/2015/06/19/opm-breach-encryption/28985237/">said</a> that encryption wouldn’t have helped preventing it since “if an adversary has the credentials of a user on the network, then they can access data even if it’s encrypted, just as the users on the network have to access data”. So, can we encrypt data in a way that still allows some access and computing on it?</p>
<p>Already in 1978, <a href="http://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/RAD78.pdf">Rivest, Adleman and Dertouzos</a> considered this problem of a business that wishes to use a “commercial <a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a> service” to store some sensitive data. They envisioned a potential solution for this task which they called a privacy homomorphism. This notion later became known as <em>fully homomorphic encryption (FHE)</em> which is an encryption that allows a party (such as the cloud provider) that <em>does not know the secret key</em> to modify a ciphertext <span><span class="math inline">\(c\)</span></span> encrypting <span><span class="math inline">\(x\)</span></span> to a ciphertext <span><span class="math inline">\(c&#39;\)</span></span> encrypting <span><span class="math inline">\(f(x)\)</span></span> for every efficiently computable <span><span class="math inline">\(f()\)</span></span>. In particular in our scenario above (see <a href='#fhefig'>Figure 16.1</a>), such a scheme will allow Bob, given an encryption of <span><span class="math inline">\(x\)</span></span>, to compute the encryption of <span><span class="math inline">\(f(x)\)</span></span> and send this ciphertext to Alice without ever getting the secret key and so without ever learning anything about <span><span class="math inline">\(x\)</span></span> (or <span><span class="math inline">\(f(x)\)</span></span> for that matter).</p>
<figure>
<img src="../figure/fhedescription.png" alt="16.1: A fully homomorphic encryption can be used to store data on the cloud in encrypted form, but still have the cloud provider be able to evaluate functions on the data in encrypted form (without ever learning either the inputs or the outputs of the function they evaluate)." id="fhefig" class="margin" /><figcaption>16.1: A fully homomorphic encryption can be used to store data on the cloud in encrypted form, but still have the cloud provider be able to evaluate functions on the data in encrypted form (without ever learning either the inputs or the outputs of the function they evaluate).</figcaption>
</figure>
<p>Unlike the case of a trapdoor function, where it only took a year for Diffie and Hellman’s challenge to be answered by RSA, in the case of fully homomorphic encryption for more than 30 years cryptographers had no constructions achieving this goal. In fact, some people suspected that there is something inherently incompatible between the security of an encryption scheme and the ability of a user to perform all these operations on ciphertexts. Stanford cryptographer Dan Boneh used to joke to incoming graduate students that he will immediately sign the thesis of anyone who came up with a fully homomorphic encryption. But he never expected that he will actually encounter such a thesis, until in 2009, Boneh’s student Craig Gentry released a <a href="https://crypto.stanford.edu/craig/">paper</a> doing just that. Gentry’s paper shook the world of cryptography, and instigated a flurry of research results making his scheme more efficient, reducing the assumptions it relied on, extending and applying it, and much more. In particular, Brakerski and Vaikuntanathan managed to obtain a fully homomorphic encryption scheme based only on the <em>Learning with Error (LWE)</em> assumption we have seen before.</p>
<p>Although there is an <a href="http://shaih.github.io/HElib/">open source library</a>, as well as <a href="https://www.dcsec.uni-hannover.de/fileadmin/ful/mitarbeiter/brenner/wahc14_RC.pdf">other</a> <a href="https://eprint.iacr.org/2014/816">implementations</a>, there is still much work to be done in order to turn FHE from theory to practice. For a comparable level of security, the encryption and decryption operations of a fully homomorphic encryption scheme are several orders of magnitude slower than a conventional public key system, and (depending on its complexity) homomorphically evaluating a circuit can be significantly more taxing. However, this is a fast evolving field, and already since 2009 significant optimizations have been discovered that reduced the computational and storage overhead by many orders of magnitudes. As in public key encryption, one would imagine that for larger data one would use a “hybrid” approach of combining FHE with symmetric encryption, though one might need to come up with tailor-made symmetric encryption schemes that can be efficiently evaluated.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>In this lecture and the next one we will focus on the fully homomorphic encryption schemes that are <em>easiest to describe</em>, rather than the ones that are most <em>efficient</em> (though the efficient schemes share many similarities with the ones we will talk about). As is generally the case for lattice based encryption, the current most efficient schemes are based on <em>ideal</em> lattices and on assumptions such as ring LWE or the security of the NTRU cryptosystem.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<div id="verifyinglessonrem" class="remark" title="Lesson from verifying computation" data-number="16" name="Remark 16.1 (Lesson from verifying computation) ">
<p>To take the distance between theory and practice in perspective, it might be useful to consider the case of <em>verifying computation</em>. In the early 1990’s researchers (motivated initially by zero knowledge proofs) came up with the notion of <a href="http://madhu.seas.harvard.edu/papers/2009/pcpcacm.pdf">probabilistically checkable proofs (PCP’s)</a> which could yield in principle extremely succinct ways to check correctness of computation.</p>
<p>Probabilistically checkable proofs can be thought of as “souped up” versions of NP completeness reductions and like these reductions, have been mostly used for <em>negative</em> results, especially since the initial proofs were extremely complicated and also included enormous hidden constants. However, with time people have slowly understood these better and made them more efficient (e.g., see <a href="http://m.cacm.acm.org/magazines/2015/2/182636-verifying-computations-without-reexecuting-them/fulltext">this survey</a>) and it has now reached the point where these results, are <a href="http://cacm.acm.org/magazines/2016/2/197429-pinocchio/abstract">nearly practical</a> (see also <a href="https://eprint.iacr.org/2016/646">this</a>) and in fact these ideas underly at least one <a href="http://z.cash">startup</a>. Overall, constructions for verifying computation have improved by at least 20 orders of magnitude over the last two decades. (We will talk about some of these constructions later in this course.) If progress on fully homomorphic encryption follows a similar trajectory, then we can expect the road to practical utility to be very long, but there is hope that it’s not a “bridge to nowhere”.</p>
</div>
<div id="hardwarefhe" class="remark" title="Poor man&#39;s FHE via hardware" data-number="16" name="Remark 16.2 (Poor man&#39;s FHE via hardware) ">
<p>Since large scale fully homomorphic encryption is still impractical, people have been trying to achieve at least weaker security goals using certain assumptions. In particular Intel chips have so called <a href="https://goo.gl/HW4pPU">“Secure enclaves”</a> which one can think of as a somewhat tamper-protected region of the processor that is supposed to be out of reach for the outside world. The idea is that a cloud provider client would treat this enclave as a trusted party that it can communicate with through the cloud provider. The client can store their data on the cloud encrypted with some key <span><span class="math inline">\(k\)</span></span>, and then set up a secure channel with the enclave using an authenticated key exchange protocol, and send <span><span class="math inline">\(k\)</span></span> over. Then, when the client sends over a function <span><span class="math inline">\(f\)</span></span> to the cloud provider, the latter party can simulate FHE by asking the enclave to compute the encryption of <span><span class="math inline">\(f(x)\)</span></span> given the encryption of <span><span class="math inline">\(x\)</span></span>. In this solution ultimately the private key does reside on the cloud provider’s computers, and the client has to trust the security of the enclave. In practice, this could provide reasonable security against remote hackers, but (unlike FHE) probably not against sophisticated attackers (e.g., governments) that have physical access to the server.</p>
</div>
<h2 id="defining-fully-homomorphic-encryption" data-number="16.1">Defining fully homomorphic encryption</h2>
<p>We start by defining <em>partially homomorphic</em> encryption. We focus on encryption for single bits. This is without loss of generality for CPA security (CCA security is anyway ruled out for homomorphic encryption- can you see why?), though there are more efficient constructions that encrypt several bits at a time.</p>
<div id="partialhomdef" class="definition" title="Partially Homomorphic Encryption" name="Definition 16.3 (Partially Homomorphic Encryption) ">
<p>Let <span><span class="math inline">\(\mathcal{F} = \cup \mathcal{F}_\ell\)</span></span> be a class of functions where every <span><span class="math inline">\(f\in\mathcal{F}_\ell\)</span></span> maps <span><span class="math inline">\(\{0,1\}^\ell\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>.<br />
An <em><span><span class="math inline">\(\mathcal{F}\)</span></span>-homomorphic public key encryption scheme</em> is a CPA secure public key encryption scheme <span><span class="math inline">\((G,E,D)\)</span></span> such that there exists a polynomial-time algorithm <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> such that for every <span><span class="math inline">\((e,d)=G(1^n)\)</span></span>, <span><span class="math inline">\(\ell=poly(n)\)</span></span>, <span><span class="math inline">\(x_1,\ldots,x_\ell \in \{0,1\}\)</span></span>, and <span><span class="math inline">\(f\in \mathcal{F}_\ell\)</span></span> of description size <span><span class="math inline">\(|f|\)</span></span> at most <span><span class="math inline">\(poly(\ell)\)</span></span> it holds that:</p>
<ul>
<li><p><span><span class="math inline">\(c=\ensuremath{\mathit{EVAL}}_e(f,E_e(x_1),\ldots,E_e(x_\ell))\)</span></span> has length at most <span><span class="math inline">\(n\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(D_d(c)=f(x_1,\ldots,x_\ell)\)</span></span>.</p></li>
</ul>
</div>
<div id="section" class="pause" data-number="16.1" name="Pause">
<p>Please stop and verify you understand the definition. In particular you should understand why some bound on the length of the output of <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> is needed to rule out trivial constructions that are the analogous of the cloud provider sending over to Alice the entire encrypted database every time she wants to evaluate a function of it. By artificially increasing the randomness for the key generation algorithm, this is equivalent to requiring that <span><span class="math inline">\(|c| \leq p(n)\)</span></span> for some fixed polynomial <span><span class="math inline">\(p(\cdot)\)</span></span> that does not grow with <span><span class="math inline">\(\ell\)</span></span> or <span><span class="math inline">\(|f|\)</span></span>. You should also understand the distinction between ciphertexts that are the output of the encryption algorithm on the plaintext <span><span class="math inline">\(b\)</span></span>, and ciphertexts that decrypt to <span><span class="math inline">\(b\)</span></span>, see <a href='#evalciphertextfig'>Figure 16.2</a>.</p>
</div>
<figure>
<img src="../figure/evalciphertexts.png" alt="16.2: In a valid encryption scheme E, the set of ciphertexts c such that D_d(c)=b is a superset of the set of ciphertexts c such that c=E_e(b;r) for some r \in \{0,1\}^{t} where t is the number of random bits used by the encryption algorithm. Our definition of partially homomorphic encryption scheme requires that for every f:\{0,1\}^\ell \rightarrow \{0,1\} in our family and x\in \{0,1\}^\ell, if c_i \in E_e(x_i;\{0,1\}^t) for i=1..\ell then \ensuremath{\mathit{EVAL}}(f,c_1,\ldots,c_\ell) is in the superset \{ c \;|\; D_d(c)=f(x) \} of E_e(f(x);\{0,1\}^t). For example if we apply \ensuremath{\mathit{EVAL}} to the \ensuremath{\mathit{OR}} function and ciphertexts c,c&#39; that were obtained as encryptions of 1 and 0 respectively, then the output is a ciphertext c&#39;&#39; that would be decrypted to \ensuremath{\mathit{OR}}(1,0)=1, even if c&#39;&#39; is not in the smaller set of possible outputs of the encryption algorithm on 1. This distinction between the smaller and larger set is the reason why we cannot automatically apply the \ensuremath{\mathit{EVAL}} function to ciphertexts that are obtained from the outputs of previous \ensuremath{\mathit{EVAL}} operations." id="evalciphertextfig" class="margin" /><figcaption>16.2: In a valid encryption scheme <span><span class="math inline">\(E\)</span></span>, the set of ciphertexts <span><span class="math inline">\(c\)</span></span> such that <span><span class="math inline">\(D_d(c)=b\)</span></span> is a superset of the set of ciphertexts <span><span class="math inline">\(c\)</span></span> such that <span><span class="math inline">\(c=E_e(b;r)\)</span></span> for some <span><span class="math inline">\(r \in \{0,1\}^{t}\)</span></span> where <span><span class="math inline">\(t\)</span></span> is the number of random bits used by the encryption algorithm. Our definition of partially homomorphic encryption scheme requires that for every <span><span class="math inline">\(f:\{0,1\}^\ell \rightarrow \{0,1\}\)</span></span> in our family and <span><span class="math inline">\(x\in \{0,1\}^\ell\)</span></span>, if <span><span class="math inline">\(c_i \in E_e(x_i;\{0,1\}^t)\)</span></span> for <span><span class="math inline">\(i=1..\ell\)</span></span> then <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}(f,c_1,\ldots,c_\ell)\)</span></span> is in the superset <span><span class="math inline">\(\{ c \;|\; D_d(c)=f(x) \}\)</span></span> of <span><span class="math inline">\(E_e(f(x);\{0,1\}^t)\)</span></span>. For example if we apply <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> to the <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> function and ciphertexts <span><span class="math inline">\(c,c&#39;\)</span></span> that were obtained as encryptions of <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(0\)</span></span> respectively, then the output is a ciphertext <span><span class="math inline">\(c&#39;&#39;\)</span></span> that would be decrypted to <span><span class="math inline">\(\ensuremath{\mathit{OR}}(1,0)=1\)</span></span>, even if <span><span class="math inline">\(c&#39;&#39;\)</span></span> is not in the smaller set of possible outputs of the encryption algorithm on <span><span class="math inline">\(1\)</span></span>. This distinction between the smaller and larger set is the reason why we cannot automatically apply the <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> function to ciphertexts that are obtained from the outputs of previous <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> operations.</figcaption>
</figure>
<p>A <em>fully homomomorphic encryption</em> is simply a partially homomorphic encryption scheme for the family <span><span class="math inline">\(\mathcal{F}\)</span></span> of <em>all</em> functions, where the description of a function is as a circuit (say composed of <a href="https://en.wikipedia.org/wiki/NAND_gate">NAND</a> gates, which are known to be a universal basis).</p>
<h3 id="another-application-fully-homomorphic-encryption-for-verifying-computation" data-number="16.1.1">Another application: fully homomorphic encryption for verifying computation</h3>
<p>The canonical application of fully homomorphic encryption is for a client to store encrypted data <span><span class="math inline">\(E(x)\)</span></span> on a server, send a function <span><span class="math inline">\(f\)</span></span> to the server, and get back the encryption <span><span class="math inline">\(E(f(x))\)</span></span> of <span><span class="math inline">\(f(x)\)</span></span>. This ensures that the server does not learn any information about <span><span class="math inline">\(x\)</span></span>, but does not ensure that it actually computes the correct function!</p>
<p>Here is a cute protocol to achieve the latter goal (due to <a href="https://eprint.iacr.org/2010/241">Chung Kalai and Vadhan</a>). Curiously the protocol involves “doubly encrypting” the input, and homomorphically evaluating the <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> function itself.</p>
<ul>
<li><p><strong>Assumptions:</strong> We assume that all functions <span><span class="math inline">\(f\)</span></span> that the client will be interested in can be described by a string of length <span><span class="math inline">\(n\)</span></span>.</p></li>
<li><p><strong>Preprocessing:</strong> The client generates a pair of keys <span><span class="math inline">\((e,d)\)</span></span>. In the initial stage the client computes the encrypted database <span><span class="math inline">\(\overline{c}=E_e(x)\)</span></span> and sends <span><span class="math inline">\(\overline{c},e,e&#39;\)</span></span> to the server. It also computes <span><span class="math inline">\(c^* = E_e(f^*)\)</span></span> for some function <span><span class="math inline">\(f^*\)</span></span> as well as <span><span class="math inline">\(C^{**}=\ensuremath{\mathit{EVAL}}_{e}(eval,E_e(f^*)\|\overline{c})\)</span></span> for some function <span><span class="math inline">\(f^*\)</span></span> and keeps <span><span class="math inline">\(c^*,c^{**}\)</span></span> for herself, where <span><span class="math inline">\(eval(f,x)=f(x)\)</span></span> is the circuit evaluation function.</p></li>
<li><p><strong>Client query:</strong> To ask for an evaluation of <span><span class="math inline">\(f\)</span></span>, the client generates a new random FHE keypair <span><span class="math inline">\((e&#39;,d&#39;)\)</span></span>, chooses <span><span class="math inline">\(b \leftarrow_R \{0,1\}\)</span></span> and lets <span><span class="math inline">\(c_b = E_{e&#39;}(E_e(f))\)</span></span> and <span><span class="math inline">\(c_{1-b}=E_{e&#39;}(c^*)\)</span></span>. It sends the triple <span><span class="math inline">\(e&#39;,c_0,c_1\)</span></span> to the server.</p></li>
<li><p><strong>Server response:</strong> Given the queries <span><span class="math inline">\(c_0,c_1\)</span></span>, the server defines the function <span><span class="math inline">\(g:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> where <span><span class="math inline">\(g(c)=\ensuremath{\mathit{EVAL}}_e(eval,c\|\overline{c})\)</span></span> (for the fixed <span><span class="math inline">\(\overline{c}\)</span></span> received) and computes <span><span class="math inline">\(c&#39;_0,c&#39;_1\)</span></span> where <span><span class="math inline">\(c&#39;_b = \ensuremath{\mathit{EVAL}}_{e&#39;}(g_b,c_b)\)</span></span>. (Please pause here and make sure you understand what this step is doing! Note that we use here crucially the fact that <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> itself is a polynomial time computation.)</p></li>
<li><p><strong>Client check:</strong> Client checks whether <span><span class="math inline">\(D_{d&#39;}(c&#39;_{1-b})=c^{**}\)</span></span> and if so accepts <span><span class="math inline">\(D_d(D_{d&#39;}(c&#39;_b))\)</span></span> as the answer.</p></li>
</ul>
<p>We claim that if the server cheats then the client will detect this with probability <span><span class="math inline">\(1/2 - negl(n)\)</span></span>. Working this out is a great exercise. The probability of detection can be amplified to <span><span class="math inline">\(1-negl(n)\)</span></span> using appropriate repetition, see the paper for details.</p>
<h2 id="example-an-xor-homomorphic-encryption" data-number="16.2">Example: An XOR homomorphic encryption</h2>
<p>It turns out that Regev’s LWE-based encryption LWEENC we saw before is homomorphic with respect to the class of linear (mod 2) functions. Let us recall the LWE assumption and the encryption scheme based on it.</p>
<div id="LWEdef" class="definition" title="LWE (simplified decision variant)" name="Definition 16.4 (LWE (simplified decision variant)) ">
<p>Let <span><span class="math inline">\(q=q(n)\)</span></span> be some function mapping the natural numbers to primes. The <em><span><span class="math inline">\(q(n)\)</span></span>-decision learning with error (<span><span class="math inline">\(q(n)\)</span></span>-dLWE) conjecture</em> is the following: for every <span><span class="math inline">\(m=poly(n)\)</span></span> there is a distribution <span><span class="math inline">\(\ensuremath{\mathit{LWE}}_q\)</span></span> over pairs <span><span class="math inline">\((A,s)\)</span></span> such that:</p>
<ul>
<li><p><span><span class="math inline">\(A\)</span></span> is an <span><span class="math inline">\(m\times n\)</span></span> matrix over <span><span class="math inline">\(\Z_q\)</span></span> and <span><span class="math inline">\(s\in\Z_q^n\)</span></span> satisfies <span><span class="math inline">\(s_1=\floor{\tfrac{q}{2}}\)</span></span> and <span><span class="math inline">\(|As|_i \leq \sqrt{q}\)</span></span> for every <span><span class="math inline">\(i\in \{1,\ldots, m\}\)</span></span>.</p></li>
<li><p>The distribution <span><span class="math inline">\(A\)</span></span> where <span><span class="math inline">\((A,s)\)</span></span> is sampled from <span><span class="math inline">\(\ensuremath{\mathit{LWE}}_q\)</span></span> is computationally indistinguishable from the uniform distribution of <span><span class="math inline">\(m\times n\)</span></span> matrices over <span><span class="math inline">\(\Z_q\)</span></span>.</p></li>
</ul>
</div>
<p>The <em>dLWE conjecture</em> is that <span><span class="math inline">\(q(n)\)</span></span>-dLWE holds for every <span><span class="math inline">\(q(n)\)</span></span> that is at most <span><span class="math inline">\(poly(n)\)</span></span>. This is not exactly the same phrasing we used before, but as we sketch below, it is essentially equivalent to it. One can also make the stronger conjecture that <span><span class="math inline">\(q(n)\)</span></span>-dLWE holds even for <span><span class="math inline">\(q(n)\)</span></span> that is <em>super polynomial</em> in <span><span class="math inline">\(n\)</span></span> (e.g., <span><span class="math inline">\(q(n)\)</span></span> magnitude roughly <span><span class="math inline">\(2^n\)</span></span> - note that such a number can still be described in <span><span class="math inline">\(n\)</span></span> bits and we can still efficiently perform operations such as addition and multiplication modulo <span><span class="math inline">\(q\)</span></span>). This stronger conjecture also seems well supported by evidence and we will use it in future lectures.</p>
<div id="section-1" class="pause" data-number="16.2" name="Pause">
<p>It is a good idea for you to pause here and try to show the equivalence on your own.</p>
</div>
<p><strong>Equivalence between LWE and DLWE:</strong> The reason the two conjectures are equivalent are the following. Before we phrased the conjecture as recovering <span><span class="math inline">\(s\)</span></span> from a pair <span><span class="math inline">\((A&#39;,y)\)</span></span> where <span><span class="math inline">\(y=A&#39;s&#39;+e\)</span></span> and <span><span class="math inline">\(|e_i|\leq \delta q\)</span></span> for every <span><span class="math inline">\(i\)</span></span>. We then showed a <em>search to decision</em> reduction (<a href='lec_12_lattices.html#LWEsearchtodecthm'>Theorem 13.2</a>) demonstrating that this is equivalent to the task of distinguishing between this case and the case that <span><span class="math inline">\(y\)</span></span> is a random vector. If we now let <span><span class="math inline">\(\alpha = \floor{\tfrac{q}{2}}\)</span></span> and <span><span class="math inline">\(\beta = \alpha^{-1} (\mod\;q)\)</span></span>, and consider the matrix <span><span class="math inline">\(A=(-\beta y|A&#39;)\)</span></span> and the column vector <span><span class="math inline">\(s=\binom{\alpha}{s&#39;}\)</span></span> we see that <span><span class="math inline">\(As = e\)</span></span>. Note that if <span><span class="math inline">\(y\)</span></span> is a random vector in <span><span class="math inline">\(\Z_q^m\)</span></span> then so is <span><span class="math inline">\(-\beta y\)</span></span> and so the current form of the conjecture follows from the previous one. (To reduce the number of free parameters, we fixed <span><span class="math inline">\(\delta\)</span></span> to equal <span><span class="math inline">\(1/\sqrt{q}\)</span></span>; in this form the conjecture becomes stronger as <span><span class="math inline">\(q\)</span></span> grows.)</p>
<p><strong>A linearly-homomorphic encryption scheme:</strong> The following variant of the LWE-ENC described in <a href='lec_12_lattices.html#lweencsec'>Section 13.4</a> turns out to be linearly homomorphic:</p>
<blockquote>
<div class="quote" name="Quote 16.2">
<p><strong>LWE-ENC’ encryption:</strong></p>
<ul>
<li><p><em>Key generation:</em> Choose <span><span class="math inline">\((A,s)\)</span></span> from <span><span class="math inline">\(\ensuremath{\mathit{LWE}}_q\)</span></span> where <span><span class="math inline">\(m\)</span></span> satisfies <span><span class="math inline">\(q^{1/4} \gg m \log q \gg n\)</span></span>.</p></li>
<li><p>To <em>encrypt</em> <span><span class="math inline">\(b\in\{0,1\}\)</span></span>, choose <span><span class="math inline">\(w\in\{0,1\}^m\)</span></span> and output <span><span class="math inline">\(w^\top A + (b,0,\ldots,0)\)</span></span>.</p></li>
<li><p>To <em>decrypt</em> <span><span class="math inline">\(c\in\Z_q^n\)</span></span>, output <span><span class="math inline">\(0\)</span></span> iff <span><span class="math inline">\(|\langle c,s \rangle| \leq q/10\)</span></span>, where for <span><span class="math inline">\(x\in\Z_q\)</span></span> we defined <span><span class="math inline">\(|x| = \min \{ x , q-x \}\)</span></span>. (Recall that the first coordinate of <span><span class="math inline">\(s\)</span></span> is <span><span class="math inline">\(\floor{q/2}\)</span></span>.</p></li>
</ul>
</div>
</blockquote>
<p>The decryption algorithm recovers the original plaintext since <span><span class="math inline">\(\langle c,s \rangle= w^\top A s + s_1 b\)</span></span> and <span><span class="math inline">\(|w^\top A s| \leq m\sqrt{q} \ll q\)</span></span>. It turns out that this scheme is homomorphic with respect to the class of <em>linear functions</em> modulo <span><span class="math inline">\(2\)</span></span>. Specifically we make the following claim:</p>
<div id="parityhomlem" class="lemma" data-number="16.2" name="Lemma 16.5">
<p>For every <span><span class="math inline">\(\ell \ll q^{1/4}\)</span></span>, there is an algorithm <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}_\ell\)</span></span> that on input <span><span class="math inline">\(c_1,\ldots,c_\ell\)</span></span> encrypting via LWEENC bits <span><span class="math inline">\(b_1,\ldots,b_\ell \in \{0,1\}\)</span></span>, outputs a ciphertext <span><span class="math inline">\(c\)</span></span> whose decryption <span><span class="math inline">\(b_1 \oplus \cdots \oplus b_\ell\)</span></span>.</p>
</div>
<div id="section-2" class="pause" data-number="16.2" name="Pause">
<p>This claim is not hard to prove, but working it out for yourself can be a good way to get more familiarity with LWE-ENC’ and the kind of manipulations we’ll be making time and again in the constructions of many lattice based cryptographic primitives. Try to show that <span><span class="math inline">\(c = c_1 + \cdots +c_\ell\)</span></span> (where addition is done as vectors in <span><span class="math inline">\(\Z_q\)</span></span>) will be the encryption <span><span class="math inline">\(b_1 \oplus \cdots \oplus b_\ell\)</span></span>. Note that if <span><span class="math inline">\(q\)</span></span> is <em>super polynomial</em> in <span><span class="math inline">\(n\)</span></span> then <span><span class="math inline">\(\ell\)</span></span> can be an arbitrarily large polynomial in <span><span class="math inline">\(n\)</span></span>.</p>
</div>
<div id="section-3" class="proof" data-ref="parityhomlem" data-number="16.2" name="Proof">
<p>The proof is quite simple. <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span> will simply add the ciphertexts as vectors in <span><span class="math inline">\(\Z_q\)</span></span>. If <span><span class="math inline">\(c = \sum c_i\)</span></span> then <span>
<div class='myequationbox'><span class="math display">\[\langle c,s \rangle = \sum b_i \floor{\tfrac{q}{2}}  +  \xi \mod  q\]</span></div></span> where <span><span class="math inline">\(\xi \in \Z_q\)</span></span> is a “noise term” such that <span><span class="math inline">\(|\xi| \leq \ell m \sqrt{q} \ll q\)</span></span>. Since <span><span class="math inline">\(|\floor{\tfrac{q}{2}}- \tfrac{q}{2}|&lt;1\)</span></span>, adding at most <span><span class="math inline">\(\ell\)</span></span> terms of this difference adds at most <span><span class="math inline">\(\ell\)</span></span>, and so we can also write <span>
<div class='myequationbox'><span class="math display">\[\langle c,s \rangle = \floor{ \sum b_i \tfrac{q}{2} }  +  \xi&#39; \mod  q\]</span></div></span> for <span><span class="math inline">\(|\xi&#39;| \leq \ell m \sqrt{q} + \ell \ll q\)</span></span>. If <span><span class="math inline">\(\sum b_i\)</span></span> is even then <span><span class="math inline">\(\sum b_i \tfrac{q}{2}\)</span></span> is an integer multiple of <span><span class="math inline">\(q\)</span></span> and hence in this case <span><span class="math inline">\(|\langle c,s \rangle| \ll q\)</span></span>. If <span><span class="math inline">\(\sum b_i\)</span></span> is odd <span><span class="math inline">\(\floor{\sum b_i \tfrac{q}{2}} = \floor{q/2} \mod q\)</span></span> and so in this case <span><span class="math inline">\(|\langle c,s \rangle| = q/2 \pm o(q) &gt; q/10\)</span></span>.</p>
</div>
<p>Several other encryption schemes are also homomorphic with respect to linear functions. Even before Gentry’s construction there were constructions of encryption schemes that are homomorphic with respect to somewhat larger classes (e.g., quadratic functions by Boneh, Goh and Nissim) but not significantly so.</p>
<h3 id="abstraction-a-trapdoor-pseudorandom-generator." data-number="16.2.1">Abstraction: A trapdoor pseudorandom generator.</h3>
<p>It is instructive to consider the following abstraction (which we’ll use in the next lecture) of the above encryption scheme as a <em>trapdoor generator</em> (see <a href='#TDPgenfig'>Figure 16.3</a>). On input <span><span class="math inline">\(1^n\)</span></span> key generation algorithm outputs a vector <span><span class="math inline">\(s\in\Z_q^m\)</span></span> with <span><span class="math inline">\(s_1 = \floor{\tfrac{q}{2}}\)</span></span> and a probabilistic algorithm <span><span class="math inline">\(G_s\)</span></span> such that the following holds:</p>
<ul>
<li><p>Any polynomial number of samples from the distribution <span><span class="math inline">\(G_s(1^n)\)</span></span> is computationally indistinguishable from independent samples from the uniform distribution over <span><span class="math inline">\(\Z_q^n\)</span></span></p></li>
<li><p>If <span><span class="math inline">\(c\)</span></span> is output by <span><span class="math inline">\(G_s(1^n)\)</span></span> then <span><span class="math inline">\(|\langle c,s \rangle| \leq n\sqrt{q}\)</span></span>.</p></li>
</ul>
<p>Thus <span><span class="math inline">\(s\)</span></span> can be thought of a “trapdoor” for the generator that allows to distinguish between a random vector <span><span class="math inline">\(c\in \Z_q^n\)</span></span> (that with high probability would satisfy <span><span class="math inline">\(|\langle c,s \rangle|\geq q/10\)</span></span>) and an output of the generator. We use <span><span class="math inline">\(G_s\)</span></span> to encrypt a bit <span><span class="math inline">\(b\)</span></span> by letting <span><span class="math inline">\(c \leftarrow_R G_s(1^n)\)</span></span> and outputting <span><span class="math inline">\(c + (b,0,\ldots,0)^\top\)</span></span>. In the particular instantiation above we obtain <span><span class="math inline">\(G_s\)</span></span> by sampling the matrix <span><span class="math inline">\(A\)</span></span> from the LWE assumption and having <span><span class="math inline">\(G_s\)</span></span> output <span><span class="math inline">\(w^\top A\)</span></span> for a random <span><span class="math inline">\(w\in\{0,1\}^n\)</span></span>, but we can ignore this particular implementation detail in the forgoing.</p>
<figure>
<img src="../figure/trapdoorprg.png" alt="16.3: In a trapdoor generator, we have two ways to generate randomized algorithms. That is, we have some algorithms \ensuremath{\mathit{GEN}} and \ensuremath{\mathit{GEN}}&#39; such that \ensuremath{\mathit{GEN}} outputs a pair (G_s,s) and \ensuremath{\mathit{GEN}}&#39; outputs G&#39; with G_s,G&#39; being themselves algorithms (e.g., randomized circuits). The conditions we require are that (1) the descriptions of the circuits G_s and G&#39; (considering them as distributions over strings) are computationally indistinguishable and (2) the distribution G&#39;(1^n) is statistically indistinguishable from the uniform distribution , (3) there is an efficient algorithm that given the secret “trapdoor” s can distinguish the output of G_s from the uniform distribution. In particular (1),(2), and (3) together imply that it is not feasible to exract s from the description of G_s." id="TDPgenfig" class="margin" /><figcaption>16.3: In a <em>trapdoor generator</em>, we have two ways to generate randomized algorithms. That is, we have some algorithms <span><span class="math inline">\(\ensuremath{\mathit{GEN}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{GEN}}&#39;\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{GEN}}\)</span></span> outputs a pair <span><span class="math inline">\((G_s,s)\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{GEN}}&#39;\)</span></span> outputs <span><span class="math inline">\(G&#39;\)</span></span> with <span><span class="math inline">\(G_s,G&#39;\)</span></span> being themselves algorithms (e.g., randomized circuits). The conditions we require are that <strong>(1)</strong> the descriptions of the circuits <span><span class="math inline">\(G_s\)</span></span> and <span><span class="math inline">\(G&#39;\)</span></span> (considering them as distributions over strings) are computationally indistinguishable and <strong>(2)</strong> the distribution <span><span class="math inline">\(G&#39;(1^n)\)</span></span> is <em>statistically indistinguishable</em> from the uniform distribution , <strong>(3)</strong> there is an efficient algorithm that given the secret “trapdoor” <span><span class="math inline">\(s\)</span></span> can distinguish the output of <span><span class="math inline">\(G_s\)</span></span> from the uniform distribution. In particular <strong>(1)</strong>,<strong>(2)</strong>, and <strong>(3)</strong> together imply that it is <em>not</em> feasible to exract <span><span class="math inline">\(s\)</span></span> from the description of <span><span class="math inline">\(G_s\)</span></span>.</figcaption>
</figure>
<p>Note that this trapdoor generator satisfies the following stronger property: we can generate an alternative generator <span><span class="math inline">\(G&#39;\)</span></span> such that the description of <span><span class="math inline">\(G&#39;\)</span></span> is indistinguishable from the description of <span><span class="math inline">\(G_s\)</span></span> but such that <span><span class="math inline">\(G&#39;\)</span></span> actually does produce (up to exponentially small statistical error) the uniform distribution over <span><span class="math inline">\(\Z_q^n\)</span></span>. We can define trapdoor generators formally as follows</p>
<div id="tdpgendef" class="definition" title="Trapdoor generators" name="Definition 16.6 (Trapdoor generators) ">
<p>A <em>trapdoor generator</em> is a pair of randomized algorithms <span><span class="math inline">\(\ensuremath{\mathit{GEN}},\ensuremath{\mathit{GEN}}&#39;\)</span></span> that satisfy the following:</p>
<ul>
<li><p>On input <span><span class="math inline">\(1^n\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{GEN}}\)</span></span> outputs a pair <span><span class="math inline">\((G_s,s)\)</span></span> where <span><span class="math inline">\(G_s\)</span></span> is a string describing a <em>randomized</em> circuit that itself takes <span><span class="math inline">\(1^n\)</span></span> as input and outputs a string of length <span><span class="math inline">\(t\)</span></span> where <span><span class="math inline">\(t=t(n)\)</span></span> is some polynomial.</p></li>
<li><p>On input <span><span class="math inline">\(1^n\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{GEN}}&#39;\)</span></span> outputs <span><span class="math inline">\(G&#39;\)</span></span> where <span><span class="math inline">\(G&#39;\)</span></span> is a string describing a randomized circuit that itself takes <span><span class="math inline">\(1^n\)</span></span> as input.</p></li>
<li><p>The distributions <span><span class="math inline">\(\ensuremath{\mathit{GEN}}(1^n)_1\)</span></span> (i.e., the first output of <span><span class="math inline">\(\ensuremath{\mathit{GEN}}(1^n)\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{GEN}}&#39;(1^n)\)</span></span> are computationally indistinguishable</p></li>
<li><p>With probability <span><span class="math inline">\(1-negl(n)\)</span></span> over the choice of <span><span class="math inline">\(G&#39;\)</span></span> output by <span><span class="math inline">\(\ensuremath{\mathit{GEN}}&#39;\)</span></span>, the distribution <span><span class="math inline">\(G&#39;(1^n)\)</span></span> is <em>statistically indistinguishable</em> (i.e., within <span><span class="math inline">\(negl(n)\)</span></span> total variation distance) from <span><span class="math inline">\(U_t\)</span></span>.</p></li>
<li><p>There is an efficient algorithm <span><span class="math inline">\(T\)</span></span> such that for every pair <span><span class="math inline">\((G_s,s)\)</span></span> output by <span><span class="math inline">\(\ensuremath{\mathit{GEN}}\)</span></span>, <span><span class="math inline">\(\Pr[ T(s,G_s(1^n))=1] \geq 1- negl(n)\)</span></span> (where this probability is over the internal randomness used by <span><span class="math inline">\(G_s\)</span></span> on the input <span><span class="math inline">\(1^n\)</span></span>) but <span><span class="math inline">\(\Pr[ T(s,U_t)=1] \leq 1/3\)</span></span>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p></li>
</ul>
</div>
<div id="section-4" class="pause" data-number="16.2.1" name="Pause">
<p>This is not an easy definition to parse, but looking at <a href='#TDPgenfig'>Figure 16.3</a> can help. Make sure you understand why <span><span class="math inline">\(\ensuremath{\mathit{LWEENC}}\)</span></span> gives rise to a trapdoor generator satisfying all the conditions of <a href='#tdpgendef'>Definition 16.6</a>.</p>
</div>
<div id="trapdoorgenreal" class="remark" title="Trapdoor generators in real life" name="Remark 16.7 (Trapdoor generators in real life) ">
<p>In the above we use the notion of a “trapdoor” in the pseudorandom generator as a mathematical abstraction, but generators with actual trapdoors have arisen in practice. In 2007 the National Institute of Standards (NIST) released standards for pseudorandom generators. Pseudorandom generators are the quintessential private key primitive, typically built out of hash functions, block ciphers, and such and so it was surprising that NIST included in the list a pseudorandom generator based on public key tools - the <a href="https://en.wikipedia.org/wiki/Dual_EC_DRBG">Dual EC DRBG</a> generator based on elliptic curve cryptography. This was already strange but became even more worrying when Microsoft researchers Dan Shumow and Niels Ferguson <a href="http://rump2007.cr.yp.to/15-shumow.pdf">showed</a> that this generator <em>could</em> have a trapdoor in the sense that it contained some hardwired constants that if generated in a particular way, there would be some information that (just like in <span><span class="math inline">\(G_s\)</span></span> above) allows to distinguish the generator from random (see here for a <a href="https://www.schneier.com/blog/archives/2007/11/the_strange_sto.html">2007 blog post</a> on this issue). We learned more about this when leaks from the Snowden document <a href="http://www.reuters.com/article/us-usa-security-rsa-idUSBRE9BJ1C220131220">showed</a> that the NSA secretly paid 10 million dollars to RSA to make this generator the default option in their Bsafe software.</p>
<p>You’d think that this generator is long dead but it turns out to be the “gift that keeps on giving”. In December of 2015, Juniper systems <a href="http://www.wired.com/2015/12/juniper-networks-hidden-backdoors-show-the-risk-of-government-backdoors/">announced</a> that they have discovered a malicious code in their system, dating back to at least 2012 (possibly <a href="https://goo.gl/X6pAXV">2008</a>), that would allow an attacker to surreptitiously decrypt all VPN traffic through their firewalls. The issue is that Juniper has been using the Dual EC DRBG and someone has managed to replace the constant they were using with another one, one that they presumably knew the trapdoor for (see <a href="https://rpw.sh/blog/2015/12/21/the-backdoored-backdoor/">here</a> and <a href="http://blog.cryptographyengineering.com/2015/12/on-juniper-backdoor.html">here</a> for more; of course unless you know to check for this, it’s very hard by looking at the code to see that one arbitrary looking constant has been replaced by another). Apparently, even though this is very surprising to many people in law enforcement and government, inserting back doors into cryptographic primitives might end up making them less secure.</p>
</div>
<h2 id="from-linear-homomorphism-to-full-homomorphism" data-number="16.3">From linear homomorphism to full homomorphism</h2>
<p>Gentry’s breakthrough had two components:</p>
<ul>
<li><p>First, he gave a scheme that is homomorphic with respect to arithmetic circuits (involving not just addition but also multiplications) of <em>logarithmic depth</em>.</p></li>
<li><p>Second, he showed the amazing “bootstrapping theorem” that if a scheme is homomorphic enough to evaluate its own decryption circuit, then it can be turned into a <em>fully homomorphic</em> encryption that can evaluate <em>any</em> function.</p></li>
</ul>
<p>Combining these two insights led to his fully homomorphic encryption.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
<p>In this lecture we will focus on the second component - the bootstrapping theorem. We will show a “partially homomorphic encryption” (based on a later work of Gentry, Sahai and Waters) that can fit that theorem in the next lecture.</p>
<h2 id="bootstrapping-fully-homomorphic-escape-velocity" data-number="16.4">Bootstrapping: Fully Homomorphic “escape velocity”</h2>
<figure>
<img src="../figure/fheescape.png" alt="16.4: The “Bootstrapping Theorem” shows that once a partially homomorphic encryption scheme is homomorphic with respect to a rich enough family of functions, and specifically a family that contains its own decryption algorithm, then it can be converted to a fully homomorphic encryption scheme that can be used to evaluate any function." id="bootstrapfig" class="margin" /><figcaption>16.4: The “Bootstrapping Theorem” shows that once a partially homomorphic encryption scheme is homomorphic with respect to a rich enough family of functions, and specifically a family that contains its own decryption algorithm, then it can be converted to a fully homomorphic encryption scheme that can be used to evaluate <em>any</em> function.</figcaption>
</figure>
<p>The bootstrapping theorem is quite surprising. A priori you might expect that given that a homomorphic encryption for linear functions was not trivial to do, a homomorphic encryption for quadratics would be harder, cubics even harder and so on and so forth. But it turns out that there is some special degree <span><span class="math inline">\(t^*\)</span></span> such that if we obtain homomorphic encryption for degree <span><span class="math inline">\(t^*\)</span></span> polynomials then we can obtain <em>fully</em> homomorphic encryption that works for <em>all</em> functions. (Specifically, if the decryption algorithm <span><span class="math inline">\(c \mapsto D_d(c)\)</span></span> is a degree <span><span class="math inline">\(t\)</span></span> polynomial, then homomorphically evaluating polynomials of degree <span><span class="math inline">\(t^*=2t\)</span></span> will be sufficient.) That is, it turns out that once an encryption scheme is strong enough to <em>homomorphically evaluate its own decryption algorithm</em> then we can use it to obtain a fully homomorphic encryption by “pulling itself up by its own bootstraps”. One analogy is that at this point the encryption reaches “escape velocity” and we can continue onwards evaluating gates in perpetuity.</p>
<p>We now show the bootstrapping theorem:</p>
<div id="bootstrapthm" class="theorem" title="Bootstrapping Theorem, Gentry 2009" data-number="16.4" name="Theorem 16.8 (Bootstrapping Theorem, Gentry 2009) ">
<p>Suppose that <span><span class="math inline">\((G,E,D)\)</span></span> is a CPA circular<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> secure partially homomorphic encryption scheme for the family <span><span class="math inline">\(\mathcal{F}\)</span></span> and suppose that for every pair of ciphertexts <span><span class="math inline">\(c,c&#39;\)</span></span> the map <span><span class="math inline">\(d \mapsto D_d(c) \;\ensuremath{\mathit{NAND}}\; D_d(c&#39;)\)</span></span> is in <span><span class="math inline">\(\mathcal{F}\)</span></span>. Then <span><span class="math inline">\((G,E,D)\)</span></span> can be turned a fully homomorphic encryption scheme.</p>
</div>
<h3 id="radioactive-legos-analogy" data-number="16.4.1">Radioactive legos analogy</h3>
<figure>
<img src="../figure/fheziplocbag.png" alt="16.5: To build a castle from radioactive Lego bricks, which can be kept safe in a special ziploc bag for 10 seconds, we can: 1) Place the bricks in a bag, and place the bag inside an outer bag. 2) Manipulate the inner bag through the outer bag to remove the bricks from it in 9 seconds, and spend 1 second putting one brick in place 3) Now the outer bag has 9 seconds of life left, and we can put it inside a new bag and repeat the process." id="ziplocbagfig" class="margin" /><figcaption>16.5: To build a castle from radioactive Lego bricks, which can be kept safe in a special ziploc bag for 10 seconds, we can: 1) Place the bricks in a bag, and place the bag inside an outer bag. 2) Manipulate the inner bag through the outer bag to remove the bricks from it in 9 seconds, and spend 1 second putting one brick in place 3) Now the outer bag has 9 seconds of life left, and we can put it inside a new bag and repeat the process.</figcaption>
</figure>
<p>Here is one analogy for bootstrapping, inspired by Gentry’s <a href="https://crypto.stanford.edu/craig/easy-fhe.pdf">survey</a>. Suppose that you need to construct some complicated object from a highly toxic material (see <a href='#ziplocbagfig'>Figure 16.5</a>). You are given a supply of sealed bags that are flexible enough so you can manipulate the object from outside the bag. However, each bag can only hold for <span><span class="math inline">\(10\)</span></span> seconds of such manipulations before it leaks. The idea is that if you can open one bag inside another within <span><span class="math inline">\(9\)</span></span> seconds then you can perform the manipulations for arbitrary length. That is, if the object is in the <span><span class="math inline">\(i^{th}\)</span></span> bag then you put this bag inside the <span><span class="math inline">\(i+1^{st}\)</span></span> bag, spend <span><span class="math inline">\(9\)</span></span> seconds on opening the <span><span class="math inline">\(i^{th}\)</span></span> bag inside the <span><span class="math inline">\(i+1^{st}\)</span></span> bag and then spend another second of whatever manipulations you wanted to perform. We then continue this process by putting the <span><span class="math inline">\(i+1^{st}\)</span></span> bag inside the <span><span class="math inline">\(i+2^{nd}\)</span></span> bag and so on and so forth.</p>
<h3 id="proving-the-bootstrapping-theorem" data-number="16.4.2">Proving the bootstrapping theorem</h3>
<p>We now turn to the formal proof of <a href='#bootstrapthm'>Theorem 16.8</a></p>
<div id="section-5" class="proof" data-ref="bootstrapthm" data-number="16.4.2" name="Proof">
<p>The idea behind the proof is simple but ingenious. Recall that the NAND gate <span><span class="math inline">\(b,b&#39; \mapsto \neg(b \wedge b&#39;)\)</span></span> is a universal gate that allows us to compute any function <span><span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}\)</span></span> that can be efficiently computed. Thus, to obtain a fully homomorphic encryption it suffices to obtain a function <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}\)</span></span> such that <span><span class="math inline">\(D_d(\ensuremath{\mathit{NANDEVAL}}(c,c&#39;))=D_d(c) \;\ensuremath{\mathit{NAND}}\; D_d(c&#39;)\)</span></span>. (Note that this is stronger than the typical notion of homomorphic evaluation since we require that <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}\)</span></span> outputs an encryption of <span><span class="math inline">\(b \;\ensuremath{\mathit{NAND}}\; b&#39;\)</span></span> when given <em>any</em> pair of ciphertexts that decrypt to <span><span class="math inline">\(b\)</span></span> and <span><span class="math inline">\(b&#39;\)</span></span> respectively, regardless whether these ciphertexts were produced by the encryption algorithm or by some other method, including the <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}\)</span></span> procedure itself.)</p>
<p>Thus to prove the theorem, we need to modify <span><span class="math inline">\((G,E,D)\)</span></span> into an encryption scheme supporting the <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}\)</span></span> operation. Our new scheme will use the same encryption algorithms <span><span class="math inline">\(E\)</span></span> and <span><span class="math inline">\(D\)</span></span> but the following modification <span><span class="math inline">\(G&#39;\)</span></span> of the key generation algorithm: after running <span><span class="math inline">\((d,e)=G(1^n)\)</span></span>, we will append to the public key an encryption <span><span class="math inline">\(c^* = E_e(d)\)</span></span> of the secret key. We have now defined the key generation, encryption and decryption. CPA security follows from the security of the original scheme, where by circular security we refer exactly to the condition that the scheme is secure even if the adversary gets a single encryption of the public key.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> This latter condition is not known to be implied by standard CPA security but as far as we know is satisfied by all natural public key encryptions, including the LWE-based ones we will plug into this theorem later on.</p>
<p>So, now all that is left is to define the <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}\)</span></span> operation. On input two ciphertexts <span><span class="math inline">\(c\)</span></span> and <span><span class="math inline">\(c&#39;\)</span></span>, we will construct the function <span><span class="math inline">\(f_{c,c&#39;}:\{0,1\}^n\rightarrow\{0,1\}\)</span></span> (where <span><span class="math inline">\(n\)</span></span> is the length of the secret key) such that <span><span class="math inline">\(f_{c,c&#39;}(d)=D_d(c) \;\ensuremath{\mathit{NAND}}\; D_d(c&#39;)\)</span></span>. It would be useful to pause at this point and make sure you understand what are the inputs to <span><span class="math inline">\(f_{c,c&#39;}\)</span></span>, what are “hardwired constants” and what is its output. The ciphertexts <span><span class="math inline">\(c\)</span></span> and <span><span class="math inline">\(c&#39;\)</span></span> are simply treated as fixed strings and are <em>not</em> part of the input to <span><span class="math inline">\(f_{c,c&#39;}\)</span></span>. Rather <span><span class="math inline">\(f_{c,c&#39;}\)</span></span> is a function (depending on the strings <span><span class="math inline">\(c,c&#39;\)</span></span>) that maps the secret key into a bit. When running <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}\)</span></span> we of course do not know the secret key <span><span class="math inline">\(d\)</span></span>, but we can still design a circuit that computes this function <span><span class="math inline">\(f_{c,c&#39;}\)</span></span>. Now <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}(c,c&#39;)\)</span></span> will simply be defined as <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}(f_{c,c&#39;},c^*)\)</span></span>. Since <span><span class="math inline">\(c^* = E_e(d)\)</span></span>, we get that <span>
<div class='myequationbox'><span class="math display">\[D_d(\ensuremath{\mathit{NANDEVAL}}(c,c&#39;))= D_d(\ensuremath{\mathit{EVAL}}(f_{c,c&#39;},c^*))=f_{c,c&#39;}(d) =D_d(c) \;\ensuremath{\mathit{NAND}}\; D_d(c&#39;) \;.\]</span></div></span> Thus indeed we map <em>any</em> pair of ciphertexts <span><span class="math inline">\(c,c&#39;\)</span></span> that decrypt to <span><span class="math inline">\(b,b&#39;\)</span></span> into a ciphertext <span><span class="math inline">\(c&#39;&#39;\)</span></span> that decrypts to <span><span class="math inline">\(b \;\ensuremath{\mathit{NAND}}\; b&#39;\)</span></span>. This is all that we needed to prove.</p>
</div>
<div id="section-6" class="pause" data-number="16.4.2" name="Pause">
<p>Don’t let the short proof fool you. This theorem is quite deep and subtle, and requires some reading and re-reading to truly “get” it.</p>
</div>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>In <a href="https://eprint.iacr.org/2012/099.pdf">2012</a> the state of art on homomorphically evaluating AES was about six orders of magnitude slower than non-homomorphic AES computation. I don’t know what’s the current record.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>As we mentioned before, as a general rule of thumb, the difference between the ideal schemes and the one that we describe is that in the ideal setting one deals with <em>structured</em> matrices that have a compact representation as a single vector and also enable fast FFT-like matrix-vector multiplication. This saves a factor of about <span><span class="math inline">\(n\)</span></span> in the storage and computation requirements (where <span><span class="math inline">\(n\)</span></span> is the dimension of the subspace/lattice). However, there can be some subtle security implications for ideal lattices as well, see e.g., <a href="https://eprint.iacr.org/2016/127">here</a>, <a href="https://eprint.iacr.org/2015/313">here</a>, <a href="https://eprint.iacr.org/2016/139">here</a>, and <a href="https://eprint.iacr.org/2015/676">here</a>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>The choice of <span><span class="math inline">\(1/3\)</span></span> is arbitrary, and can be amplified as needed.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>The story is a bit more complex than that. Frustratingly, the decryption circuit of Gentry’s basic scheme was just a little bit too deep for the bootstrapping theorem to apply. A lesser man, such as yours truly, would at this point surmise that fully homomprphic encryption was just not meant to be, and perhaps take up knitting or playing bridge as an alternative hobby. However, Craig persevered and managed to come up with a way to “squash” the decryption circuit so it can fit the bootstrapping parameters. Follow up works, and in particular the paper of Brakerski and Vaikuntanathan, managed to get schemes with much better relation between the homomorphism depth and decryption circuit, and hence avoid the need for squashing and also improve the security assumptions.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>You can ignore the condition of circular security in a first read - we will discuss it later.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>Without this assumption we can still obtained a form of FHE known as a <em>leveled</em> FHE where the size of the public key grows with the <a href="https://en.wikipedia.org/wiki/Circuit_complexity">depth</a> of the circuit to be evaluated. We can do this by having <span><span class="math inline">\(\ell\)</span></span> public keys where <span><span class="math inline">\(\ell\)</span></span> is the depth we want to evaluate, and encrypt the private key of the <span><span class="math inline">\(i^{th}\)</span></span> key with the <span><span class="math inline">\(i+1^{st}\)</span></span> public key. However, since circular security seems quite likely to hold, we ignore this extra complication in the rest of the discussion.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Fully Homomorphic Encryption+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 04/01/2020 19:09:52</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_15_FHE.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
