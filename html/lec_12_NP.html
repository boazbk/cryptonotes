<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: Polynomial time reductions</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: Polynomial time reductions" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#lecture-summary"><i class="fa fa-check"></i><b>16.1</b> Lecture summary</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.2</b> Exercises</a></li><li class="chapter" data-level="16.3" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.3</b> Bibliographical notes</a></li><li class="chapter" data-level="16.4" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#further-explorations"><i class="fa fa-check"></i><b>16.4</b> Further explorations</a></li><li class="chapter" data-level="16.5" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#acknowledgements"><i class="fa fa-check"></i><b>16.5</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Polynomial time reductions</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_12_NP.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="reductionchap" data-number="13">Polynomial-time reductions</h1>
<div id="section" class="objectives" name="Objectives">
<ul>
<li>Introduce the notion of <em>polynomial-time reductions</em> as a way to relate the complexity of problems to one another.<br />
</li>
<li>See several examples of such reductions.<br />
</li>
<li>3SAT as a basic starting point for reductions.</li>
</ul>
</div>
<p>Consider some of the problems we have encountered in <a href='lec_10_efficient_alg.html#chapefficient'>Chapter 11</a>:</p>
<ol type="1">
<li><p>The <em>3SAT</em> problem: deciding whether a given 3CNF formula has a satisfying assignment.</p></li>
<li><p>Finding the <em>longest path</em> in a graph.</p></li>
<li><p>Finding the <em>maximum cut</em> in a graph.</p></li>
<li><p>Solving <em>quadratic equations</em> over <span><span class="math inline">\(n\)</span></span> variables <span><span class="math inline">\(x_0,\ldots,x_{n-1} \in \R\)</span></span>.</p></li>
</ol>
<p>All of these problems have the following properties:</p>
<ul>
<li><p>These are important problems, and people have spent significant effort on trying to find better algorithms for them.</p></li>
<li><p>Each one of these is a <em>search</em> problem, whereby we search for a solution that is “good” in some easy to define sense (e.g., a long path, a satisfying assignment, etc.).</p></li>
<li><p>Each of these problems has a trivial exponential time algorithm that involve enumerating all possible solutions.</p></li>
<li><p>At the moment, for all these problems the best known algorithm is not much faster than the trivial one in the worst case.</p></li>
</ul>
<p>In this chapter and in <a href='lec_13_Cook_Levin.html#cooklevinchap'>Chapter 14</a> we will see that, despite their apparent differences, we can relate the computational complexity of these and many other problems. In fact, it turns out that the problem above are <em>computationally equivalent</em>, in the sense that solving one of them immediately implies solving the others. This phenomenon, known as <em><span><span class="math inline">\(\mathbf{NP}\)</span></span> completeness</em>, is one of the surprising discoveries of theoretical computer science, and we will see that it has far-reaching ramifications.</p>
<figure>
<img src="../figure/reductionsoverview.png" alt="13.1: In this chapter we show that if the 3\ensuremath{\mathit{SAT}} problem cannot be solved in polynomial time, then neither can the \ensuremath{\mathit{QUADEQ}}, \ensuremath{\mathit{LONGESTPATH}}, \ensuremath{\mathit{ISET}} and \ensuremath{\mathit{MAXCUT}} problems. We do this by using the reduction paradigm showing for example “if pigs could whistle” (i.e., if we had an efficient algorithm for \ensuremath{\mathit{QUADEQ}}) then “horses could fly” (i.e., we would have an efficient algorithm for 3\ensuremath{\mathit{SAT}}.)" id="reductionsoverviewfig" /><figcaption>13.1: In this chapter we show that if the <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> problem cannot be solved in polynomial time, then neither can the <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LONGESTPATH}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{ISET}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> problems. We do this by using the <em>reduction paradigm</em> showing for example “if pigs could whistle” (i.e., if we had an efficient algorithm for <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span>) then “horses could fly” (i.e., we would have an efficient algorithm for <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>.)</figcaption>
</figure>
<p>In this chapter we will see that for each one of the problems of finding a longest path in a graph, solving quadratic equations, and finding the maximum cut, if there exists a polynomial-time algorithm for this problem then there exists a polynomial-time algorithm for the 3SAT problem as well. In other words, we will <em>reduce</em> the task of solving 3SAT to each one of the above tasks. Another way to interpret these results is that if there <em>does not exist</em> a polynomial-time algorithm for 3SAT then there does not exist a polynomial-time algorithm for these other problems as well. In <a href='lec_13_Cook_Levin.html#cooklevinchap'>Chapter 14</a> we will see evidence (though no proof!) that all of the above problems do not have polynomial-time algorithms and hence are <em>inherently intractable</em>.</p>
<h2 id="formaldefdecisionexamplessec" data-number="13.1">Formal definitions of problems</h2>
<p>For reasons of technical convenience rather than anything substantial, we concern ourselves with <em>decision problems</em> (i.e., Yes/No questions) or in other words <em>Boolean</em> (i.e., one-bit output) functions. We model the problems above as functions mapping <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span> in the following way:</p>
<p><strong>3SAT.</strong> The <em>3SAT problem</em> can be phrased as the function <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that takes as input a 3CNF formula <span><span class="math inline">\(\varphi\)</span></span> (i.e., a formula of the form <span><span class="math inline">\(C_0 \wedge \cdots \wedge C_{m-1}\)</span></span> where each <span><span class="math inline">\(C_i\)</span></span> is the OR of three variables or their negation) and maps <span><span class="math inline">\(\varphi\)</span></span> to <span><span class="math inline">\(1\)</span></span> if there exists some assignment to the variables of <span><span class="math inline">\(\varphi\)</span></span> that causes it to evalute to <em>true</em>, and to <span><span class="math inline">\(0\)</span></span> otherwise. For example</p>
<p><span>
<div class='myequationbox'><span class="math display">\[3\ensuremath{\mathit{SAT}}\left(&quot;(x_0 \vee \overline{x}_1 \vee x_2)  \wedge   (x_1 \vee x_2 \vee \overline{x_3}) \wedge (\overline{x}_0 \vee \overline{x}_2 \vee x_3)&quot; \right)  = 1\]</span></div></span></p>
<p>since the assignment <span><span class="math inline">\(x = 1101\)</span></span> satisfies the input formula. In the above we assume some representation of formulas as strings, and define the function to output <span><span class="math inline">\(0\)</span></span> if its input is not a valid representation; we use the same convention for all the other functions below.</p>
<p><strong>Quadratic equations.</strong> The <em>quadratic equations problem</em> corresponds to the function <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that maps a set of quadratic equations <span><span class="math inline">\(E\)</span></span> to <span><span class="math inline">\(1\)</span></span> if there is an assignment <span><span class="math inline">\(x\)</span></span> that satisfies all equations, and to <span><span class="math inline">\(0\)</span></span> otherwise.</p>
<p><strong>Longest path.</strong> The <em>longest path problem</em> corresponds to the function <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that maps a graph <span><span class="math inline">\(G\)</span></span> and a number <span><span class="math inline">\(k\)</span></span> to <span><span class="math inline">\(1\)</span></span> if there is a simple path in <span><span class="math inline">\(G\)</span></span> of length at least <span><span class="math inline">\(k\)</span></span>, and maps <span><span class="math inline">\((G,k)\)</span></span> to <span><span class="math inline">\(0\)</span></span> otherwise. The longest path problem is a generalization of the well-known <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem">Hamiltonian Path Problem</a> of determining whether a path of length <span><span class="math inline">\(n\)</span></span> exists in a given <span><span class="math inline">\(n\)</span></span> vertex graph.</p>
<p><strong>Maximum cut.</strong> The <em>maximum cut problem</em> corresponds to the function <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that maps a graph <span><span class="math inline">\(G\)</span></span> and a number <span><span class="math inline">\(k\)</span></span> to <span><span class="math inline">\(1\)</span></span> if there is a cut in <span><span class="math inline">\(G\)</span></span> that cuts at least <span><span class="math inline">\(k\)</span></span> edges, and maps <span><span class="math inline">\((G,k)\)</span></span> to <span><span class="math inline">\(0\)</span></span> otherwise.</p>
<p>All of the problems above are in <span><span class="math inline">\(\mathbf{EXP}\)</span></span> but it is not known whether or not they are in <span><span class="math inline">\(\mathbf{P}\)</span></span>. However, we will see in this chapter that if either <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> , <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span> or <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> are in <span><span class="math inline">\(\mathbf{P}\)</span></span>, then so is <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>.</p>
<h2 id="polytimeredsec" data-number="13.2">Polynomial-time reductions</h2>
<p>Suppose that <span><span class="math inline">\(F,G:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> are two functions. A <em>polynomial-time reduction</em> (or sometimes just <em>“reduction”</em> for short) from <span><span class="math inline">\(F\)</span></span> to <span><span class="math inline">\(G\)</span></span> is a way to show that <span><span class="math inline">\(F\)</span></span> is “no harder” than <span><span class="math inline">\(G\)</span></span>, in the sense that a polynomial-time algorithm for <span><span class="math inline">\(G\)</span></span> implies a polynomial-time algorithm for <span><span class="math inline">\(F\)</span></span>.</p>
<div id="reduction-def" class="definition" title="Polynomial-time reductions" name="Definition 13.1 (Polynomial-time reductions) ">
<p>Let <span><span class="math inline">\(F,G:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span>. We say that <em><span><span class="math inline">\(F\)</span></span> reduces to <span><span class="math inline">\(G\)</span></span></em>, denoted by <span><span class="math inline">\(F \leq_p G\)</span></span> if there is a polynomial-time computable <span><span class="math inline">\(R:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> such that for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span>
<div class='myequationbox'><span class="math display">\[
F(x) = G(R(x)) \;. \;\;(13.2)
\]</span><a id='eq:reduction'></a></div></span> We say that <span><span class="math inline">\(F\)</span></span> and <span><span class="math inline">\(G\)</span></span> have <em>equivalent complexity</em> if <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(G \leq_p F\)</span></span>.</p>
</div>
<figure>
<img src="../figure/reductiondescription.png" alt="13.2: If F \leq_p G then we can transform a polynomial-time algorithm B that computes G into a polynomial-time algorithm A that computes F. To compute F(x) we can run the reduction R guaranteed by the fact that F \leq_p G to obtain y=F(x) and then run our algorithm B for G to compute G(y)." id="reductionsfig" class="margin" /><figcaption>13.2: If <span><span class="math inline">\(F \leq_p G\)</span></span> then we can transform a polynomial-time algorithm <span><span class="math inline">\(B\)</span></span> that computes <span><span class="math inline">\(G\)</span></span> into a polynomial-time algorithm <span><span class="math inline">\(A\)</span></span> that computes <span><span class="math inline">\(F\)</span></span>. To compute <span><span class="math inline">\(F(x)\)</span></span> we can run the reduction <span><span class="math inline">\(R\)</span></span> guaranteed by the fact that <span><span class="math inline">\(F \leq_p G\)</span></span> to obtain <span><span class="math inline">\(y=F(x)\)</span></span> and then run our algorithm <span><span class="math inline">\(B\)</span></span> for <span><span class="math inline">\(G\)</span></span> to compute <span><span class="math inline">\(G(y)\)</span></span>.</figcaption>
</figure>
<p>The following exercise justifies our intuition that <span><span class="math inline">\(F \leq_p G\)</span></span> signifies that "<span><span class="math inline">\(F\)</span></span> is no harder than <span><span class="math inline">\(G\)</span></span>.</p>
<div id="reductionsandP" class="solvedexercise" title="Reductions and $\mathbf{P}$" name="Solvedexercise 13.1 (Reductions and $\mathbf{P}$) ">
<p>Prove that if <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(G \in \mathbf{P}\)</span></span> then <span><span class="math inline">\(F\in \mathbf{P}\)</span></span>.</p>
</div>
<div class="pause" name="Pause 13.2">
<p>As usual, solving this exercise on your own is an excellent way to make sure you understand <a href='#reduction-def'>Definition 13.1</a>.</p>
</div>
<div class="solution" data-ref="reductionsandP" name="Solution 13.2">
<p>Suppose there was an algorithm <span><span class="math inline">\(B\)</span></span> that compute <span><span class="math inline">\(F\)</span></span> in time <span><span class="math inline">\(p(n)\)</span></span> where <span><span class="math inline">\(p\)</span></span> is its input size. Then, <a href='#eq:reduction'>Equation 13.2</a> directly gives an algorithm <span><span class="math inline">\(A\)</span></span> to compute <span><span class="math inline">\(F\)</span></span> (see <a href='#reductionsfig'>Figure 13.2</a>). Indeed, on input <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, Algorithm <span><span class="math inline">\(A\)</span></span> will run the polynomial-time reduction <span><span class="math inline">\(R\)</span></span> to obtain <span><span class="math inline">\(y=R(x)\)</span></span> and then return <span><span class="math inline">\(B(y)\)</span></span>. By <a href='#eq:reduction'>Equation 13.2</a>, <span><span class="math inline">\(G(R(x)) = F(x)\)</span></span> and hence Algorithm <span><span class="math inline">\(A\)</span></span> will indeed compute <span><span class="math inline">\(F\)</span></span>.</p>
<p>We now show that <span><span class="math inline">\(A\)</span></span> runs in polynomial time. By assumption, <span><span class="math inline">\(R\)</span></span> can be computed in time <span><span class="math inline">\(q(n)\)</span></span> for some polynomial <span><span class="math inline">\(q\)</span></span>. In particular, this means that <span><span class="math inline">\(|y| \leq q(|x|)\)</span></span> (as just writing down <span><span class="math inline">\(y\)</span></span> takes <span><span class="math inline">\(|y|\)</span></span> steps). This, computing <span><span class="math inline">\(B(y)\)</span></span> will take at most <span><span class="math inline">\(p(|y|) \leq p(q(|x|))\)</span></span> steps. Thus the total running time of <span><span class="math inline">\(A\)</span></span> on inputs of length <span><span class="math inline">\(n\)</span></span> is at most the time to compute <span><span class="math inline">\(y\)</span></span>, which is bounded by <span><span class="math inline">\(q(n)\)</span></span>, and the time to compute <span><span class="math inline">\(B(y)\)</span></span>, which is bounded by <span><span class="math inline">\(p(q(n))\)</span></span>, and since the composition of two polynomials is a polynomial, <span><span class="math inline">\(A\)</span></span> runs in polynomial time.</p>
</div>
<div id="reduction" class="bigidea" name="Bigidea 20">
<p>A <em>reduction</em> <span><span class="math inline">\(F \leq_p G\)</span></span> shows that <span><span class="math inline">\(F\)</span></span> is “no harder than <span><span class="math inline">\(G\)</span></span>” or equivalently that <span><span class="math inline">\(G\)</span></span> is “no easier than <span><span class="math inline">\(F\)</span></span>”.</p>
</div>
<p>A reduction from <span><span class="math inline">\(F\)</span></span> to <span><span class="math inline">\(G\)</span></span> can be used for two purposes:</p>
<ul>
<li><p>If we already know an algorithm for <span><span class="math inline">\(G\)</span></span> and <span><span class="math inline">\(F \leq_p G\)</span></span> then we can use the reduction to obtain an algorithm for <span><span class="math inline">\(F\)</span></span>. This is a widely used tool in algorithm design. For example in <a href='lec_10_efficient_alg.html#linerprogsec'>Subsection 11.1.4</a> we saw how the <em>Min-Cut Max-Flow</em> theorem allows to reduce the task of computing a minimum cut in a graph to the task of computing a maximum flow in it.</p></li>
<li><p>If we have proven (or have evidence) that there exists <em>no polynomial-time algorithm</em> for <span><span class="math inline">\(F\)</span></span> and <span><span class="math inline">\(F \leq_p G\)</span></span> then the existence of this reduction allows us to concludes that there exists no polynomial-time algorithm for <span><span class="math inline">\(G\)</span></span>. This is the “if pigs could whistle then horses could fly” interpretation we’ve seen in <a href='lec_08_uncomputability.html#reductionsuncompsec'>Section 8.4</a>. We show that if there was an hypothetical efficient algorithm for <span><span class="math inline">\(G\)</span></span> (a “whistling pig”) then since <span><span class="math inline">\(F \leq_p G\)</span></span> then there would be an efficient algorithm for <span><span class="math inline">\(F\)</span></span> (a “flying horse”). In this book we often use reductions for this second purpose, although the lines between the two is sometimes blurry (see the bibliographical notes in <a href='#reductionsbibnotes'>Section 13.8</a>).</p></li>
</ul>
<p>The most crucial difference between the notion in <a href='#reduction-def'>Definition 13.1</a> and the reductions we saw in the context of <em>uncomputability</em> (e.g., in <a href='lec_08_uncomputability.html#reductionsuncompsec'>Section 8.4</a>) is that for relating time complexity of problems, we need the reduction to be computable in <em>polynomial time</em>, as opposed to merely computable. <a href='#reduction-def'>Definition 13.1</a> also restricts reductions to have a very specific format. That is, to show that <span><span class="math inline">\(F \leq_p G\)</span></span>, rather than allowing a general algorithm for <span><span class="math inline">\(F\)</span></span> that uses a “magic box” that computes <span><span class="math inline">\(G\)</span></span>, we only allow an algorithm that computes <span><span class="math inline">\(F(x)\)</span></span> by outputting <span><span class="math inline">\(G(R(x))\)</span></span>. This restricted form is convenient for us, but people have defined and used more general reductions as well (see <a href='#reductionsbibnotes'>Section 13.8</a>).</p>
<p>In this chapter we use reductions to relate the computational complexity of the problems mentioned above: 3SAT, Quadratic Equations, Maximum Cut, and Longest Path, as well as a few others. We will reduce 3SAT to the latter problems, demonstrating that solving any one of them efficiently will result in an efficient algorithm for 3SAT. In <a href='lec_13_Cook_Levin.html#cooklevinchap'>Chapter 14</a> we show the other direction: reducing each one of these problems to 3SAT in one fell swoop.</p>
<p><strong>Transitivity of reductions.</strong> Since we think of <span><span class="math inline">\(F \leq_p G\)</span></span> as saying that (as far as polynomial-time computation is concerned) <span><span class="math inline">\(F\)</span></span> is “easier or equal in difficulty to” <span><span class="math inline">\(G\)</span></span>, we would expect that if <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(G \leq_p H\)</span></span>, then it would hold that <span><span class="math inline">\(F \leq_p H\)</span></span>. Indeed this is the case:</p>
<div id="transitiveex" class="solvedexercise" title="Transitivity of polynomial-time reductions" name="Solvedexercise 13.2 (Transitivity of polynomial-time reductions) ">
<p>For every <span><span class="math inline">\(F,G,H :\{0,1\}^* \rightarrow \{0,1\}\)</span></span>, if <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(G \leq_p H\)</span></span> then <span><span class="math inline">\(F \leq_p H\)</span></span>.</p>
</div>
<div class="solution" data-ref="transitiveex" name="Solution 13.2">
<p>If <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(G \leq_p H\)</span></span> then there exist polynomial-time computable functions <span><span class="math inline">\(R_1\)</span></span> and <span><span class="math inline">\(R_2\)</span></span> mapping <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span> such that for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(F(x) = G(R_1(x))\)</span></span> and for every <span><span class="math inline">\(y\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(G(y) = H(R_2(y))\)</span></span>. Combining these two equalities, we see that for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(F(x) = H(R_2(R_1(x)))\)</span></span> and so to show that <span><span class="math inline">\(F \leq_p H\)</span></span>, it is sufficient to show that the map <span><span class="math inline">\(x \mapsto R_2(R_1(x))\)</span></span> is computable in polynomial time. But if there are some constants <span><span class="math inline">\(c,d\)</span></span> such that <span><span class="math inline">\(R_1(x)\)</span></span> is computable in time <span><span class="math inline">\(|x|^c\)</span></span> and <span><span class="math inline">\(R_2(y)\)</span></span> is computable in time <span><span class="math inline">\(|y|^d\)</span></span> then <span><span class="math inline">\(R_2(R_1(x))\)</span></span> is computable in time <span><span class="math inline">\((|x|^c)^d = |x|^{cd}\)</span></span> which is polynomial.</p>
</div>
<h2 id="reducing-3sat-to-zero-one-equations" data-number="13.3">Reducing 3SAT to zero one equations</h2>
<p>We will now show our first example of a reduction. The <em>Zero-One Linear Equations problem</em> corresponds to the function <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> whose input is a collection <span><span class="math inline">\(E\)</span></span> of linear equations in variables <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>, and the output is <span><span class="math inline">\(1\)</span></span> iff there is an assignment <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> of <span><span class="math inline">\(0/1\)</span></span> values to the variables that satisfies all the equations. For example, if the input <span><span class="math inline">\(E\)</span></span> is a string encoding the set of equations</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\begin{aligned}
x_0 + x_1 + x_{2} &amp;= 2 \\
x_0 + x_2     &amp;= 1 \\
x_1 + x_{2} &amp;= 2 
\end{aligned}
\]</span></div></span></p>
<p>then <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(E)=1\)</span></span> since the assignment <span><span class="math inline">\(x = 011\)</span></span> satisfies all three equations. We specifically restrict attention to linear equations in variables <span><span class="math inline">\(x_0,\ldots, x_{n-1}\)</span></span> in which every equation has the form <span><span class="math inline">\(\sum_{i \in S} x_i = b\)</span></span> where <span><span class="math inline">\(S \subseteq [n]\)</span></span> and <span><span class="math inline">\(b\in \N\)</span></span>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>If we asked the question of whether there is a solution <span><span class="math inline">\(x \in \R^n\)</span></span> of <em>real numbers</em> to <span><span class="math inline">\(E\)</span></span>, then this can be solved using the famous <em>Gaussian elimination</em> algorithm in polynomial time. However, there is no known efficient algorithm to solve <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span>. Indeed, such an algorithm would imply an algorithm for <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> as shown by the following theorem:</p>
<div id="tsattozoeqthm" class="theorem" title="Hardness of $01EQ$" name="Theorem 13.2 (Hardness of $01EQ$) ">
<p><span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p 01\ensuremath{\mathit{EQ}}\)</span></span></p>
</div>
<div id="section-1" class="proofidea" data-ref="tsattozoeqthm" name="Proofidea">
<p>A constraint <span><span class="math inline">\(x_2 \vee \overline{x}_5 \vee x_7\)</span></span> can be written as <span><span class="math inline">\(x_2 + (1-x_5) + x_7 \geq 1\)</span></span>. This is a linear <em>inequality</em> but since the sum on the left-hand side is at most three, we can also turn it into an <em>equality</em> by adding two new variables <span><span class="math inline">\(y,z\)</span></span> and writing it as <span><span class="math inline">\(x_2 + (1-x_5) + x_7 + y + z =3\)</span></span>. (We will use fresh such variables <span><span class="math inline">\(y,z\)</span></span> for every constraint.) Finally, for every variable <span><span class="math inline">\(x_i\)</span></span> we can add a variable <span><span class="math inline">\(x&#39;_i\)</span></span> corresponding to its negation by adding the equation <span><span class="math inline">\(x_i + x&#39;_i = 1\)</span></span>, hence mapping the original constraint <span><span class="math inline">\(x_2 \vee \overline{x}_5 \vee x_7\)</span></span> to <span><span class="math inline">\(x_2 + x&#39;_5 + x_7 +y + z = 3\)</span></span>. The main <strong>takeaway technique</strong> from this reduction is the idea of adding <em>auxiliary variables</em> to replace an equation such as <span><span class="math inline">\(x_1+x_2 +x_3 \geq 1\)</span></span> that is not quite in the form we want with the equivalent (for <span><span class="math inline">\(0/1\)</span></span> valued variables) equation <span><span class="math inline">\(x_1+x_2+x_3+u+v=3\)</span></span> which is in the form we want.</p>
</div>
<figure>
<img src="../figure/3sat2zoeqreduction.png" alt="13.3: Left: Python code implementing the reduction of 3\ensuremath{\mathit{SAT}} to 01\ensuremath{\mathit{EQ}}. Right: Example output of the reduction. Code is in our repository." id="threesat2zoeqreductionfig" /><figcaption>13.3: Left: Python code implementing the reduction of <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> to <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span>. Right: Example output of the reduction. Code is in our <a href="https://github.com/boazbk/tcscode">repository</a>.</figcaption>
</figure>
<div class="proof" data-ref="tsattozoeqthm" name="Proof 13.3">
<p>To prove the theorem we need to:</p>
<ol type="1">
<li><p>Describe an algorithm <span><span class="math inline">\(R\)</span></span> for mapping an input <span><span class="math inline">\(\varphi\)</span></span> for <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> into an input <span><span class="math inline">\(E\)</span></span> for <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span>.</p></li>
<li><p>Prove that the algorithm runs in polynomial time.</p></li>
<li><p>Prove that <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(R(\varphi)) =3\ensuremath{\mathit{SAT}}(\varphi)\)</span></span> for every 3CNF formula <span><span class="math inline">\(\varphi\)</span></span>.</p></li>
</ol>
<p>We now proceed to do just that. Since this is our first reduction, we will spell out this proof in detail. However it straightforwardly follows the proof idea.</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = zerooneeqreduction>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 3 </span>$3SAT$ to $01EQ$ reduction</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  3CNF formula \(\varphi\) with \(n\) variables \(x_0,\ldots,x_{n-1}\) and \(m\) clauses.<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>  Set \(E\) of linear equations over \(0/1\) such that \(3SAT(\varphi)=1\) -iff \(01EQ(E)=1\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(E\)'s variables be \(x_0,\ldots,x_{n-1}\), \(x'_0,\ldots,x'_{n-1}\), \(y_0,\ldots,y_{m-1}\), \(z_0,\ldots,z_{m-1}\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">for</span>{\(i \in [n]\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">   add to \(E\) the equation \(x_i + x'_i = 1\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">for</span>{j\in [m]} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">   Let \(j\)-th clause be \(w_1 \vee w_2 \vee w_3\) where \(w_1,w_2,w_3\) are literals.<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">  <span class="ps-keyword">for</span>{\(a\in[3]\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">if</span>{\(w_a\) is variable \(x_i\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">       set \(t_a \leftarrow x_i\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">endif</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">if</span>{\(w_a\) is negation \(\neg x_i\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">       set \(t_a \leftarrow x'_i\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">endif</span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">   <span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    Add to \(E\) the equation \(t_1 + t_2 + t_3 + y_j + z_j = 3\).
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(E\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p>The reduction is described in <a href='#zerooneeqreduction'>Algorithm 13.3</a>, see also <a href='#threesat2zoeqreductionfig'>Figure 13.3</a>. If the input formula has <span><span class="math inline">\(n\)</span></span> variable and <span><span class="math inline">\(m\)</span></span> steps, <a href='#zerooneeqreduction'>Algorithm 13.3</a> creates a set <span><span class="math inline">\(E\)</span></span> of <span><span class="math inline">\(n+m\)</span></span> equations over <span><span class="math inline">\(2n+2m\)</span></span> variables. <a href='#zerooneeqreduction'>Algorithm 13.3</a> makes an initial loop of <span><span class="math inline">\(n\)</span></span> steps (each taking constant time) and then another loop of <span><span class="math inline">\(m\)</span></span> steps (each taking constant time) to create the equations, and hence it runs in polynomial time.</p>
<p>Let <span><span class="math inline">\(R\)</span></span> be the function computed by <a href='#zerooneeqreduction'>Algorithm 13.3</a>. The heart of the proof is to show that for every 3CNF <span><span class="math inline">\(\varphi\)</span></span>, <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(R(\varphi)) = 3\ensuremath{\mathit{SAT}}(\varphi)\)</span></span>. We split the proof into two parts. The first part, traditionally known as the <strong>completeness</strong> property, is to show that if <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}(\varphi)=1\)</span></span> then <span><span class="math inline">\(O1\ensuremath{\mathit{EQ}}(R(\varphi))=1\)</span></span>. The second part, traditionally known as the <strong>soundness</strong> property, is to show that if <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(R(\varphi))=1\)</span></span> then <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}(\varphi)=1\)</span></span>. (The names “completeness” and “soundness” derive viewing a solution to <span><span class="math inline">\(R(\varphi)\)</span></span> as a “proof” that <span><span class="math inline">\(\varphi\)</span></span> is satisfiable, in which case these conditions corresponds to completeness and soundness as defined in <a href='lec_09_godel.html#godelproofsystemssec'>Subsection 10.1.1</a>. However, if you find the names confusing you can simply think of completeness as the “<span><span class="math inline">\(1\)</span></span>-instance maps to <span><span class="math inline">\(1\)</span></span>-instance” property and soundness as the “<span><span class="math inline">\(0\)</span></span>-instance maps to <span><span class="math inline">\(0\)</span></span>-instance” property.)</p>
<p>We complete the proof by showing both parts:</p>
<ul>
<li><p><strong>Completeness:</strong> Suppose that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}(\varphi)=1\)</span></span>, which means that there is an assignment <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> that satisfies <span><span class="math inline">\(\varphi\)</span></span>. We know that for every clause <span><span class="math inline">\(C_j\)</span></span> in <span><span class="math inline">\(\varphi\)</span></span> of the form <span><span class="math inline">\(w_1 \vee w_2 \vee w_3\)</span></span> (with <span><span class="math inline">\(w_1,w_2,w_3\)</span></span> being literals), <span><span class="math inline">\(w_1 + w_2 + w_3 \geq 1\)</span></span>, which means that we can assign values to <span><span class="math inline">\(y_j,z_j\)</span></span> in <span><span class="math inline">\(\{0,1\}\)</span></span> such that <span><span class="math inline">\(w_1 + w_2 + w_3 + y_j + z_j = 3\)</span></span>. This means that if we let <span><span class="math inline">\(x&#39;_i = 1-x_i\)</span></span> for every <span><span class="math inline">\(i\in [n]\)</span></span>, then the assignment <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>, <span><span class="math inline">\(x&#39;_0,\ldots,x&#39;_{n-1}\)</span></span>, <span><span class="math inline">\(y_0,\ldots,y_{m-1}\)</span></span>, <span><span class="math inline">\(z_0,\ldots,z_{m-1}\)</span></span> satisfies the equations <span><span class="math inline">\(E = R(\varphi)\)</span></span> and hence <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(R(\varphi))=1\)</span></span>.</p></li>
<li><p><strong>Soundness:</strong> Suppose that the set of equations <span><span class="math inline">\(E=R(\varphi)\)</span></span> has a satisfying assignment <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>, <span><span class="math inline">\(x&#39;_0,\ldots,x&#39;_{n-1}\)</span></span>, <span><span class="math inline">\(y_0,\ldots,y_{m-1}\)</span></span>, <span><span class="math inline">\(z_0,\ldots,z_{m-1}\)</span></span>. Then it must be the case that <span><span class="math inline">\(x&#39;_i\)</span></span> is the negation of <span><span class="math inline">\(x_i\)</span></span> for all <span><span class="math inline">\(i\in [n]\)</span></span> and since <span><span class="math inline">\(y_j + z_j \leq 2\)</span></span> for every <span><span class="math inline">\(j\in [m]\)</span></span>, it must be the case that for every clause <span><span class="math inline">\(C_j\)</span></span> in <span><span class="math inline">\(\varphi\)</span></span> of the form <span><span class="math inline">\(w_1 \vee w_2 \vee w_3\)</span></span> (with <span><span class="math inline">\(w_1,w_2,w_3\)</span></span> being literals), <span><span class="math inline">\(w_1 + w_2 + w_3 \geq 1\)</span></span>, which means that the assignment <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span> satisfies <span><span class="math inline">\(\varphi\)</span></span> and hence <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}(\varphi)=1\)</span></span>.</p></li>
</ul>
</div>
<p><strong>Anatomy of a reduction.</strong> A reduction is simply an algorithm, and like any algorithm, when we come up with a reduction, it is not enough to describe <em>what</em> the reduction does, but we also have to provide an <em>analysis</em> of <em>why</em> it actually works. Specifically, to describe a reduction <span><span class="math inline">\(R\)</span></span> demonstrating that <span><span class="math inline">\(F \leq_p G\)</span></span> we need to provide the following:</p>
<ul>
<li><p><strong>Algorithm description:</strong> This is the description of <em>how</em> the algorithm maps an input into the output. For example, <a href='#zerooneeqreduction'>Algorithm 13.3</a> above is the description of how we map an instance of <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> into an instance of <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span> in the reduction demonstrating <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p 01\ensuremath{\mathit{EQ}}\)</span></span>.</p></li>
<li><p><strong>Algorithm analysis:</strong> It is not enough to describe <em>how</em> the algorithm works but we need to also explain <em>why</em> it works. In particular we need to provide an <em>analysis</em> explaining why the reduction is both <em>efficient</em> (i.e., runs in polynomial time) and <em>correct</em> (satisfies that <span><span class="math inline">\(G(R(x)=F(x)\)</span></span> for every <span><span class="math inline">\(x\)</span></span>)). Specifically, the components of analysis of a reduction <span><span class="math inline">\(R\)</span></span> include:</p>
<ul>
<li><p><strong>Efficiency:</strong> We need to show that <span><span class="math inline">\(R\)</span></span> runs in polynomial time. In most reductions we encounter this part is straightforward, as the reductions we typically use involve a constant number of nested loops, each involving a constant number of operations.</p></li>
<li><p><strong>Completeness:</strong> In a reduction <span><span class="math inline">\(R\)</span></span> demonstrating <span><span class="math inline">\(F \leq_p G\)</span></span>, the <em>completeness</em> condition is the condition that for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, if <span><span class="math inline">\(F(x) = 1\)</span></span> then <span><span class="math inline">\(G(R(x))=1\)</span></span>. Typically we construct the reduction to ensure that this holds, by giving a way to map a “certificate/solution” certifying that <span><span class="math inline">\(F(x)=1\)</span></span> into a solution certifying that <span><span class="math inline">\(G(R(x))=1\)</span></span>. For example in the proof of <a href='#tsattozoeqthm'>Theorem 13.2</a> the satisfying assignment for the <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> formula <span><span class="math inline">\(\varphi\)</span></span> can be mapped to a solution to the set of equations <span><span class="math inline">\(R(\varphi)\)</span></span>.</p></li>
<li><p><strong>Soundness:</strong> This is the condition that if <span><span class="math inline">\(F(x)=0\)</span></span> then <span><span class="math inline">\(G(R(x))=0\)</span></span> or (taking the contrapositive) if <span><span class="math inline">\(G(R(x))=1\)</span></span> then <span><span class="math inline">\(F(x)=1\)</span></span>. This is sometimes straightforward but can also be harder to show than the completeness condition, and in more advanced reductions (such as the reduction <span><span class="math inline">\(\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{ISET}}\)</span></span> of <a href='#isetnpc'>Theorem 13.5</a>) demonstrating soundness is the main part of the analysis.</p></li>
</ul></li>
</ul>
<p>Whenever you need to provide a reduction, you should make sure that your description has all these components. While it is sometimes tempting to weave together the description of the reduction and its analysis, it is usually clearer if you separate the two, and also break down the analysis to its three components of efficiency, completeness, and soundness.</p>
<h3 id="quadratic-equations" data-number="13.3.1">Quadratic equations</h3>
<p>Now that we reduced <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> to <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span>, we can use this to reduce <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> to the <em>quadratic equations</em> problem. This is the function <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> in which the input is a list of <span><span class="math inline">\(n\)</span></span>-variate polynomials <span><span class="math inline">\(p_0,\ldots,p_{m-1}:\R^n \rightarrow \R\)</span></span> that are all of <a href="https://en.wikipedia.org/wiki/Degree_of_a_polynomial">degree</a> at most two (i.e., they are <em>quadratic</em>) and with integer coefficients. (The latter condition is for convenience and can be achieved by scaling.) We define <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}(p_0,\ldots,p_{m-1})\)</span></span> to equal <span><span class="math inline">\(1\)</span></span> if and only if there is a solution <span><span class="math inline">\(x\in \R^n\)</span></span> to the equations <span><span class="math inline">\(p_0(x)=0\)</span></span>, <span><span class="math inline">\(p_1(x)=0\)</span></span>, <span><span class="math inline">\(\ldots\)</span></span>, <span><span class="math inline">\(p_{m-1}(x)=0\)</span></span>.</p>
<p>For example, the following is a set of quadratic equations over the variables <span><span class="math inline">\(x_0,x_1,x_2\)</span></span>: <span>
<div class='myequationbox'><span class="math display">\[
\begin{aligned}
x_0^2 - x_0 &amp;= 0 \\
x_1^2 - x_1 &amp;= 0 \\
x_2^2 - x_2 &amp;= 0 \\
1-x_0-x_1+x_0x_1    &amp;= 0
\end{aligned}
\]</span></div></span> You can verify that <span><span class="math inline">\(x \in \R^3\)</span></span> satisfies this set of equations if and only if <span><span class="math inline">\(x \in \{0,1\}^3\)</span></span> and <span><span class="math inline">\(x_0 \vee x_1 = 1\)</span></span>.</p>
<div id="quadeq-thm" class="theorem" title="Hardness of quadratic equations" name="Theorem 13.4 (Hardness of quadratic equations) ">
<p><span>
<div class='myequationbox'><span class="math display">\[3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{QUADEQ}}\]</span></div></span></p>
</div>
<div id="section-2" class="proofidea" data-ref="quadeq-thm" name="Proofidea">
<p>Using the transitivity of reductions (<a href='#transitiveex'>Solvedexercise 13.2</a>), it is enough to show that <span><span class="math inline">\(01\ensuremath{\mathit{EQ}} \leq_p \ensuremath{\mathit{QUADEQ}}\)</span></span>, but this follows since we can phrase the equation <span><span class="math inline">\(x_i \in \{0,1\}\)</span></span> as the quadratic constraint <span><span class="math inline">\(x_i^2 - x_i = 0\)</span></span>. The <strong>takeaway technique</strong> of this reduction is that we can use <em>nonlinearity</em> to force continuous variables (e.g., variables taking values in <span><span class="math inline">\(\R\)</span></span>) to be discrete (e.g., take values in <span><span class="math inline">\(\{0,1\}\)</span></span>).</p>
</div>
<div class="proof" data-ref="quadeq-thm" name="Proof">
<p>By <a href='#tsattozoeqthm'>Theorem 13.2</a> and <a href='#transitiveex'>Solvedexercise 13.2</a>, it is sufficient to prove that <span><span class="math inline">\(01\ensuremath{\mathit{EQ}} \leq_p \ensuremath{\mathit{QUADEQ}}\)</span></span>. Let <span><span class="math inline">\(E\)</span></span> be an instance of <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span> with variables <span><span class="math inline">\(x_0,\ldots,x_{m-1}\)</span></span>. We define <span><span class="math inline">\(R(E)\)</span></span> to be the set of quadratic equations <span><span class="math inline">\(E&#39;\)</span></span> that is obtained by taking the linear equations in <span><span class="math inline">\(E\)</span></span> and adding to them the <span><span class="math inline">\(n\)</span></span> quadratic equations <span><span class="math inline">\(x_i^2 - x_i = 0\)</span></span> for all <span><span class="math inline">\(i\in [n]\)</span></span>. Clearly the map <span><span class="math inline">\(E \mapsto E&#39;\)</span></span> can be computed in polynomial time. We claim that <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(E)=1\)</span></span> if and only if <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}(E&#39;)=1\)</span></span>. Indeed, the only difference between the two instances is that:</p>
<ul>
<li><p>In the <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}\)</span></span> instance <span><span class="math inline">\(E\)</span></span>, the equations are over variables <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span> in <span><span class="math inline">\(\{0,1\}\)</span></span>.</p></li>
<li><p>In the <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> instance <span><span class="math inline">\(E&#39;\)</span></span>, the equations are overvariables <span><span class="math inline">\(x_0,\ldots,x_{n-1} \in \R\)</span></span> but we have the extra constraints <span><span class="math inline">\(x_i^2 - x_i = 0\)</span></span> for all <span><span class="math inline">\(i\in [n]\)</span></span>.</p></li>
</ul>
<p>Since for every <span><span class="math inline">\(a\in \R\)</span></span>, <span><span class="math inline">\(a^2 - a = 0\)</span></span> if and only if <span><span class="math inline">\(a \in \{0,1\}\)</span></span>, the two sets of equations are equivalent and <span><span class="math inline">\(01\ensuremath{\mathit{EQ}}(E)=\ensuremath{\mathit{QUADEQ}}(E&#39;)\)</span></span> which is what we wanted to prove.</p>
</div>
<h2 id="the-independent-set-problem" data-number="13.4">The independent set problem</h2>
<p>For a graph <span><span class="math inline">\(G=(V,E)\)</span></span>, an <a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">independent set</a> (also known as a <em>stable set</em>) is a subset <span><span class="math inline">\(S \subseteq V\)</span></span> such that there are no edges with both endpoints in <span><span class="math inline">\(S\)</span></span> (in other words, <span><span class="math inline">\(E(S,S)=\emptyset\)</span></span>). Every “singleton” (set consisting of a single vertex) is trivially an independent set, but finding larger independent sets can be challenging. The <em>maximum independent set</em> problem (henceforth simply “independent set”) is the task of finding the largest independent set in the graph. The independent set problem is naturally related to <em>scheduling problems</em>: if we put an edge between two conflicting tasks, then an independent set corresponds to a set of tasks that can all be scheduled together without conflicts. The independent set problem has been studied in a variety of settings, including for example in the case of algorithms for finding structure in <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3919085/">protein-protein interaction graphs</a>.</p>
<p>As mentioned in <a href='#formaldefdecisionexamplessec'>Section 13.1</a>, we think of the independent set problem as the function <span><span class="math inline">\(\ensuremath{\mathit{ISET}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> that on input a graph <span><span class="math inline">\(G\)</span></span> and a number <span><span class="math inline">\(k\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> if and only if the graph <span><span class="math inline">\(G\)</span></span> contains an independent set of size at least <span><span class="math inline">\(k\)</span></span>. We now reduce 3SAT to Independent set.</p>
<div id="isetnpc" class="theorem" title="Hardness of Independent Set" name="Theorem 13.5 (Hardness of Independent Set) ">
<p><span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{ISET}}\)</span></span>.</p>
</div>
<div id="section-3" class="proofidea" data-ref="isetnpc" name="Proofidea">
<p>The idea is that finding a satisfying assignment to a 3SAT formula corresponds to satisfying many local constraints without creating any conflicts. One can think of “<span><span class="math inline">\(x_{17}=0\)</span></span>” and “<span><span class="math inline">\(x_{17}=1\)</span></span>” as two conflicting events, and of the constraints <span><span class="math inline">\(x_{17} \vee \overline{x}_5 \vee x_9\)</span></span> as creating a conflict between the events “<span><span class="math inline">\(x_{17}=0\)</span></span>”, “<span><span class="math inline">\(x_5=1\)</span></span>” and “<span><span class="math inline">\(x_9=0\)</span></span>”, saying that these three cannot simultaneosly co-occur. Using these ideas, we can we can think of solving a 3SAT problem as trying to schedule non conflicting events, though the devil is, as usual, in the details. The <strong>takeaway technique</strong> here is to map each clause of the original formula into a <em>gadget</em> which is a small subgraph (or more generally “subinstance”) satisfying some convenient properties. We will see these “gadgets” used time and again in the construction of polynomial-time reductions.</p>
</div>
<figure>
<img src="../figure/example3sat2iset.png" alt="13.4: An example of the reduction of 3\ensuremath{\mathit{SAT}} to \ensuremath{\mathit{ISET}} for the case the original input formula is \varphi = (x_0 \vee \overline{x}_1 \vee x_2) \wedge (\overline{x}_0 \vee x_1 \vee \overline{x}_2) \wedge (x_1 \vee x_2 \vee \overline{x}_3). We map each clause of \varphi to a triangle of three vertices, each tagged above with “x_i = 0” or “x_i=1” depending on the value of x_i that would satisfy the particular literal. We put an edge between every two literals that are conflicting (i.e., tagged with “x_i=0” and “x_i=1” respectively)." id="example3sat2isetfig" class="margin" /><figcaption>13.4: An example of the reduction of <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{ISET}}\)</span></span> for the case the original input formula is <span><span class="math inline">\(\varphi = (x_0 \vee \overline{x}_1 \vee x_2) \wedge (\overline{x}_0 \vee x_1 \vee \overline{x}_2) \wedge (x_1 \vee x_2 \vee \overline{x}_3)\)</span></span>. We map each clause of <span><span class="math inline">\(\varphi\)</span></span> to a triangle of three vertices, each tagged above with “<span><span class="math inline">\(x_i = 0\)</span></span>” or “<span><span class="math inline">\(x_i=1\)</span></span>” depending on the value of <span><span class="math inline">\(x_i\)</span></span> that would satisfy the particular literal. We put an edge between every two literals that are <em>conflicting</em> (i.e., tagged with “<span><span class="math inline">\(x_i=0\)</span></span>” and “<span><span class="math inline">\(x_i=1\)</span></span>” respectively).</figcaption>
</figure>
<div class="proof" data-ref="isetnpc" name="Proof 13.4">
<p>Given a 3SAT formula <span><span class="math inline">\(\varphi\)</span></span> on <span><span class="math inline">\(n\)</span></span> variables and with <span><span class="math inline">\(m\)</span></span> clauses, we will create a graph <span><span class="math inline">\(G\)</span></span> with <span><span class="math inline">\(3m\)</span></span> vertices as follows. (See <a href='#example3sat2isetfig'>Figure 13.4</a> for an example and <a href='#threesattoisfig'>Figure 13.5</a> for Python code.)</p>
<ul>
<li><p>A clause <span><span class="math inline">\(C\)</span></span> in <span><span class="math inline">\(\varphi\)</span></span> has the form <span><span class="math inline">\(C = y \vee y&#39; \vee y&#39;&#39;\)</span></span> where <span><span class="math inline">\(y,y&#39;,y&#39;&#39;\)</span></span> are <em>literals</em> (variables or their negation). For each such clause <span><span class="math inline">\(C\)</span></span>, we will add three vertices to <span><span class="math inline">\(G\)</span></span>, and label them <span><span class="math inline">\((C,y)\)</span></span>, <span><span class="math inline">\((C,y&#39;)\)</span></span>, and <span><span class="math inline">\((C,y&#39;&#39;)\)</span></span> respectively. We will also add the three edges between all pairs of these vertices, so they form a <em>triangle</em>. Since there are <span><span class="math inline">\(m\)</span></span> clauses in <span><span class="math inline">\(\varphi\)</span></span>, the graph <span><span class="math inline">\(G\)</span></span> will have <span><span class="math inline">\(3m\)</span></span> vertices.</p></li>
<li><p>In addition to the above edges, we also add an edge between every pair vertices of the form <span><span class="math inline">\((C,y)\)</span></span> and <span><span class="math inline">\((C&#39;,y&#39;)\)</span></span> where <span><span class="math inline">\(y\)</span></span> and <span><span class="math inline">\(y&#39;\)</span></span> are <em>conflicting</em> literals. That is, we add an edge between <span><span class="math inline">\((C,y)\)</span></span> and <span><span class="math inline">\((C,y&#39;)\)</span></span> if there is an <span><span class="math inline">\(i\)</span></span> such that <span><span class="math inline">\(y=x_i\)</span></span> and <span><span class="math inline">\(y&#39; = \overline{x}_i\)</span></span> or vice versa.</p></li>
</ul>
<p>The above construction of <span><span class="math inline">\(G\)</span></span> based on <span><span class="math inline">\(\varphi\)</span></span> can clearly be carried out in polynomial time. Hence to prove the theorem we need to show that <span><span class="math inline">\(\varphi\)</span></span> is satisfiable if and only if <span><span class="math inline">\(G\)</span></span> contains an independent set of <span><span class="math inline">\(m\)</span></span> vertices. We now show both directions of this equivalence:</p>
<p><strong>Part 1: Completeness.</strong> The “completeness” direction is to show that if <span><span class="math inline">\(\varphi\)</span></span> has a satisfying assignment <span><span class="math inline">\(x^*\)</span></span>, then <span><span class="math inline">\(G\)</span></span> has an independent set <span><span class="math inline">\(S^*\)</span></span> of <span><span class="math inline">\(m\)</span></span> vertices. Let us now show this.</p>
<p>Indeed, suppose that <span><span class="math inline">\(\varphi\)</span></span> has a satisfying assignment <span><span class="math inline">\(x^* \in \{0,1\}^n\)</span></span>. Then for every clause <span><span class="math inline">\(C = y \vee y&#39; \vee y&#39;&#39;\)</span></span> of <span><span class="math inline">\(\varphi\)</span></span>, one of the literals <span><span class="math inline">\(y,y&#39;,y&#39;&#39;\)</span></span> must evaluate to <em>true</em> under the assignment <span><span class="math inline">\(x^*\)</span></span> (as otherwise it would not satisfy <span><span class="math inline">\(\varphi\)</span></span>). We let <span><span class="math inline">\(S\)</span></span> be a set of <span><span class="math inline">\(m\)</span></span> vertices that is obtained by choosing for every clause <span><span class="math inline">\(C\)</span></span> one vertex of the form <span><span class="math inline">\((C,y)\)</span></span> such that <span><span class="math inline">\(y\)</span></span> evaluates to true under <span><span class="math inline">\(x^*\)</span></span>. (If there is more than one such vertex for the same <span><span class="math inline">\(C\)</span></span>, we arbitrarily choose one of them.)</p>
<p>We claim that <span><span class="math inline">\(S\)</span></span> is an independent set. Indeed, suppose otherwise that there was a pair of vertices <span><span class="math inline">\((C,y)\)</span></span> and <span><span class="math inline">\((C&#39;,y&#39;)\)</span></span> in <span><span class="math inline">\(S\)</span></span> that have an edge between them. Since we picked one vertex out of each triangle corresponding to a clause, it must be that <span><span class="math inline">\(C \neq C&#39;\)</span></span>. Hence the only way that there is an edge between <span><span class="math inline">\((C,y)\)</span></span> and <span><span class="math inline">\((C,y&#39;)\)</span></span> is if <span><span class="math inline">\(y\)</span></span> and <span><span class="math inline">\(y&#39;\)</span></span> are conflicting literals (i.e. <span><span class="math inline">\(y=x_i\)</span></span> and <span><span class="math inline">\(y&#39;=\overline{x}_i\)</span></span> for some <span><span class="math inline">\(i\)</span></span>). But that would that they can’t both evaluate to <em>true</em> under the assignment <span><span class="math inline">\(x^*\)</span></span>, which contradicts the way we constructed the set <span><span class="math inline">\(S\)</span></span>. This completes the proof of the completeness condition.</p>
<p><strong>Part 2: Soundness.</strong> The “soundness” direction is to show that if <span><span class="math inline">\(G\)</span></span> has an independent set <span><span class="math inline">\(S^*\)</span></span> of <span><span class="math inline">\(m\)</span></span> vertices, then <span><span class="math inline">\(\varphi\)</span></span> has a satisfying assignment <span><span class="math inline">\(x^* \in \{0,1\}^n\)</span></span>. Let us now show this.</p>
<p>Indeed, suppose that <span><span class="math inline">\(G\)</span></span> has an independent set <span><span class="math inline">\(S*\)</span></span> with <span><span class="math inline">\(m\)</span></span> vertices. We will define an assignment <span><span class="math inline">\(x^* \in \{0,1\}^n\)</span></span> for the variables of <span><span class="math inline">\(\varphi\)</span></span> as follows. For every <span><span class="math inline">\(i\in [n]\)</span></span>, we set <span><span class="math inline">\(x^*_i\)</span></span> according to the following rules:</p>
<ul>
<li><p>If <span><span class="math inline">\(S^*\)</span></span> contains a vertex of the form <span><span class="math inline">\((C,x_i)\)</span></span> then we set <span><span class="math inline">\(x^*_i=1\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(S^*\)</span></span> contains a vertex of the form <span><span class="math inline">\((C,\overline{x_i})\)</span></span> then we set <span><span class="math inline">\(x^*_i=0\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(S^*\)</span></span> does not contain a vertex of either of these forms, then it does not matter which value we give to <span><span class="math inline">\(x^*_i\)</span></span>, but for concreteness we’ll set <span><span class="math inline">\(x^*_i=0\)</span></span>.</p></li>
</ul>
<p>The first observation is that <span><span class="math inline">\(x^*\)</span></span> is indeed well defined, in the sense that the rules above do not conflict with one another, and ask to set <span><span class="math inline">\(x^*_i\)</span></span> to be both <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span>. This follows from the fact that <span><span class="math inline">\(S^*\)</span></span> is an <em>independent set</em> and hence if it contains a vertex of the form <span><span class="math inline">\((C,x_i)\)</span></span> then it cannot contain a vertex of the form <span><span class="math inline">\((C&#39;,\overline{x_i})\)</span></span>.</p>
<p>We now claim that <span><span class="math inline">\(x^*\)</span></span> is a satisfying assignment for <span><span class="math inline">\(\varphi\)</span></span>. Indeed, since <span><span class="math inline">\(S^*\)</span></span> is an independent set, it cannot have more than one vertex inside each one of the <span><span class="math inline">\(m\)</span></span> triangles <span><span class="math inline">\((C,y),(C,y&#39;),(C,y&#39;&#39;)\)</span></span> corresponding to a clause of <span><span class="math inline">\(\varphi\)</span></span>. Hence since <span><span class="math inline">\(|S^*|=m\)</span></span>, it must have exactly one vertex in each such triangle. For every clause <span><span class="math inline">\(C\)</span></span> of <span><span class="math inline">\(\varphi\)</span></span>, if <span><span class="math inline">\((C,y)\)</span></span> is the vertex in <span><span class="math inline">\(S^*\)</span></span> in the triangle corresponding to <span><span class="math inline">\(C\)</span></span>, then by the way we defined <span><span class="math inline">\(x^*\)</span></span>, the literal <span><span class="math inline">\(y\)</span></span> must evaluate to <em>true</em>, which means that <span><span class="math inline">\(x^*\)</span></span> satisfies this clause. Therefore <span><span class="math inline">\(x^*\)</span></span> satisfies all clauses of <span><span class="math inline">\(\varphi\)</span></span>, which is the definition of a satisfying assignment.</p>
<p>This completes the proof of <a href='#isetnpc'>Theorem 13.5</a></p>
</div>
<figure>
<img src="../figure/3sat2ISreduction.png" alt="13.5: The reduction of 3SAT to Independent Set. On the righthand side is Python code that implements this reduction. On the lefthand side is a sample output of the reduction. We use black for the “triangle edges” and red for the “conflict edges”. Note that the satisfying assignment x^* = 0110 corresponds to the independent set (0,\neg x_3), (1, \neg x_0), (2,x_2)." id="threesattoisfig" /><figcaption>13.5: The reduction of 3SAT to Independent Set. On the righthand side is <em>Python</em> code that implements this reduction. On the lefthand side is a sample output of the reduction. We use black for the “triangle edges” and red for the “conflict edges”. Note that the satisfying assignment <span><span class="math inline">\(x^* = 0110\)</span></span> corresponds to the independent set <span><span class="math inline">\((0,\neg x_3)\)</span></span>, <span><span class="math inline">\((1, \neg x_0)\)</span></span>, <span><span class="math inline">\((2,x_2)\)</span></span>.</figcaption>
</figure>
<div id="iscliqueex" class="solvedexercise" title="Clique is equivalent to independent set" name="Solvedexercise 13.3 (Clique is equivalent to independent set) ">
<p>The <a href="https://en.wikipedia.org/wiki/Clique_problem">maximum clique problem</a> corresponds to the function <span><span class="math inline">\(\ensuremath{\mathit{CLIQUE}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> such that for a graph <span><span class="math inline">\(G\)</span></span> and a number <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{CLIQUE}}(G,k)=1\)</span></span> iff there is a <span><span class="math inline">\(S\)</span></span> subset of <span><span class="math inline">\(k\)</span></span> vertices such that for <em>every</em> distinct <span><span class="math inline">\(u,v \in S\)</span></span>, the edge <span><span class="math inline">\(u,v\)</span></span> is in <span><span class="math inline">\(G\)</span></span>. Such a set is known as a <em>clique</em>.</p>
<p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{CLIQUE}} \leq_p \ensuremath{\mathit{ISET}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{ISET}} \leq_p \ensuremath{\mathit{CLIQUE}}\)</span></span>.</p>
</div>
<div class="solution" data-ref="iscliqueex" name="Solution 13.4">
<p>If <span><span class="math inline">\(G=(V,E)\)</span></span> is a graph, we denote by <span><span class="math inline">\(\overline{G}\)</span></span> its <em>complement</em> which is the graph on the same vertices <span><span class="math inline">\(V\)</span></span> and such that for every distinct <span><span class="math inline">\(u,v \in V\)</span></span>, the edge <span><span class="math inline">\(\{u,v\}\)</span></span> is present in <span><span class="math inline">\(\overline{G}\)</span></span> if and only if this edge is <em>not</em> present in <span><span class="math inline">\(G\)</span></span>.</p>
<p>This means that for every set <span><span class="math inline">\(S\)</span></span>, <span><span class="math inline">\(S\)</span></span> is an independent set in <span><span class="math inline">\(G\)</span></span> if and only if <span><span class="math inline">\(S\)</span></span> is a <em>clique</em> in <span><span class="math inline">\(\overline{S}\)</span></span>. Therefore for every <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{ISET}}(G,k)=\ensuremath{\mathit{CLIQUE}}(\overline{G},k)\)</span></span>. Since the map <span><span class="math inline">\(G \mapsto \overline{G}\)</span></span> can be computed efficiently, this yields a reduction <span><span class="math inline">\(\ensuremath{\mathit{ISET}} \leq_p \ensuremath{\mathit{CLIQUE}}\)</span></span>. Moreover, since <span><span class="math inline">\(\overline{\overline{G}}=G\)</span></span> this yields a reduction in the other direction as well.</p>
</div>
<h2 id="reducing-independent-set-to-maximum-cut" data-number="13.5">Reducing Independent Set to Maximum Cut</h2>
<p>We now show that the independent set problem reduces to the <em>maximum cut</em> (or “max cut”) problem, modeled as the function <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> that on input a pair <span><span class="math inline">\((G,k)\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> iff <span><span class="math inline">\(G\)</span></span> contains a cut of at least <span><span class="math inline">\(k\)</span></span> edges. Since both are graph problems, a reduction from independent set to max cut maps one graph into the other, but as we will see the output graph does not have to have the same vertices or edges as the input graph.</p>
<div id="isettomaxcut" class="theorem" title="Hardness of Max Cut" name="Theorem 13.6 (Hardness of Max Cut) ">
<p><span><span class="math inline">\(\ensuremath{\mathit{ISET}} \leq_p \ensuremath{\mathit{MAXCUT}}\)</span></span></p>
</div>
<div id="section-4" class="proofidea" data-ref="isettomaxcut" name="Proofidea">
<p>We will map a graph <span><span class="math inline">\(G\)</span></span> into a graph <span><span class="math inline">\(H\)</span></span> such that a large independent set in <span><span class="math inline">\(G\)</span></span> becomes a partition cutting many edges in <span><span class="math inline">\(H\)</span></span>. We can think of a cut in <span><span class="math inline">\(H\)</span></span> as coloring each vertex either “blue” or “red”. We will add a special “source” vertex <span><span class="math inline">\(s^*\)</span></span>, connect it to all other vertices, and assume without loss of generality that it is colored blue. Hence the more vertices we color red, the more edges from <span><span class="math inline">\(s^*\)</span></span> we cut. Now, for every edge <span><span class="math inline">\(u,v\)</span></span> in the original graph <span><span class="math inline">\(G\)</span></span> we will add a special “gadget” which will be a small subgraph that involves <span><span class="math inline">\(u\)</span></span>,<span><span class="math inline">\(v\)</span></span>, the source <span><span class="math inline">\(s^*\)</span></span>, and two other additional vertices. We design the gadget in a way so that if the red vertices are not an independent set in <span><span class="math inline">\(G\)</span></span> then the corresponding cut in <span><span class="math inline">\(H\)</span></span> will be “penalized” in the sense that it would not cut as many edges. Once we set for ourselves this objective, it is not hard to find a gadget that achieves it<span><span class="math inline">\(-\)</span></span> see the proof below. Once again the <strong>takeaway technique</strong> is to use (this time a slightly more clever) gadget.</p>
</div>
<figure>
<img src="../figure/iset2maxcutoverview.png" alt="13.6: In the reduction of \ensuremath{\mathit{ISET}} to \ensuremath{\mathit{MAXCUT}} we map an n-vertex m-edge graph G into the n+2m+1 vertex and n+5m edge graph H as follows. The graph H contains a special “source” vertex s^*,n vertices v_0,\ldots,v_{n-1}, and 2m vertices e_0^0,e_0^1,\ldots,e_{m-1}^0,e_{m-1}^1 with each pair corresponding to an edge of G. We put an edge between s^* and v_i for every i\in [n], and if the t-th edge of G was (v_i,v_j) then we add the five edges (s^*,e_t^0),(s^*,e_t^1),(v_i,e_t^0),(v_j,e_t^1),(e_t^0,e_t^1). The intent is that if cut at most one of v_i,v_j from s^* then we’ll be able to cut 4 out of these five edges, while if we cut both v_i and v_j from s^* then we’ll be able to cut at most three of them." id="iset2maxcutoverviewfig" /><figcaption>13.6: In the reduction of <span><span class="math inline">\(\ensuremath{\mathit{ISET}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> we map an <span><span class="math inline">\(n\)</span></span>-vertex <span><span class="math inline">\(m\)</span></span>-edge graph <span><span class="math inline">\(G\)</span></span> into the <span><span class="math inline">\(n+2m+1\)</span></span> vertex and <span><span class="math inline">\(n+5m\)</span></span> edge graph <span><span class="math inline">\(H\)</span></span> as follows. The graph <span><span class="math inline">\(H\)</span></span> contains a special “source” vertex <span><span class="math inline">\(s^*\)</span></span>,<span><span class="math inline">\(n\)</span></span> vertices <span><span class="math inline">\(v_0,\ldots,v_{n-1}\)</span></span>, and <span><span class="math inline">\(2m\)</span></span> vertices <span><span class="math inline">\(e_0^0,e_0^1,\ldots,e_{m-1}^0,e_{m-1}^1\)</span></span> with each pair corresponding to an edge of <span><span class="math inline">\(G\)</span></span>. We put an edge between <span><span class="math inline">\(s^*\)</span></span> and <span><span class="math inline">\(v_i\)</span></span> for every <span><span class="math inline">\(i\in [n]\)</span></span>, and if the <span><span class="math inline">\(t\)</span></span>-th edge of <span><span class="math inline">\(G\)</span></span> was <span><span class="math inline">\((v_i,v_j)\)</span></span> then we add the five edges <span><span class="math inline">\((s^*,e_t^0),(s^*,e_t^1),(v_i,e_t^0),(v_j,e_t^1),(e_t^0,e_t^1)\)</span></span>. The intent is that if cut at most one of <span><span class="math inline">\(v_i,v_j\)</span></span> from <span><span class="math inline">\(s^*\)</span></span> then we’ll be able to cut <span><span class="math inline">\(4\)</span></span> out of these five edges, while if we cut both <span><span class="math inline">\(v_i\)</span></span> and <span><span class="math inline">\(v_j\)</span></span> from <span><span class="math inline">\(s^*\)</span></span> then we’ll be able to cut at most three of them.</figcaption>
</figure>
<div class="proof" data-ref="isettomaxcut" name="Proof 13.5">
<p>We will transform a graph <span><span class="math inline">\(G\)</span></span> of <span><span class="math inline">\(n\)</span></span> vertices and <span><span class="math inline">\(m\)</span></span> edges into a graph <span><span class="math inline">\(H\)</span></span> of <span><span class="math inline">\(n+1+2m\)</span></span> vertices and <span><span class="math inline">\(n+5m\)</span></span> edges in the following way (see also <a href='#iset2maxcutoverviewfig'>Figure 13.6</a>). The graph <span><span class="math inline">\(H\)</span></span> contains all vertices of <span><span class="math inline">\(G\)</span></span> (though not the edges between them!) and in addition <span><span class="math inline">\(H\)</span></span> also has:<br />
* A special vertex <span><span class="math inline">\(s^*\)</span></span> that is connected to all the vertices of <span><span class="math inline">\(G\)</span></span><br />
* For every edge <span><span class="math inline">\(e=\{u,v\} \in E(G)\)</span></span>, two vertices <span><span class="math inline">\(e_0,e_1\)</span></span> such that <span><span class="math inline">\(e_0\)</span></span> is connected to <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(e_1\)</span></span> is connected to <span><span class="math inline">\(v\)</span></span>, and moreover we add the edges <span><span class="math inline">\(\{e_0,e_1 \},\{ e_0,s^* \},\{e_1,s^*\}\)</span></span> to <span><span class="math inline">\(H\)</span></span>.</p>
<p><a href='#isettomaxcut'>Theorem 13.6</a> will follow by showing that <span><span class="math inline">\(G\)</span></span> contains an independent set of size at least <span><span class="math inline">\(k\)</span></span> if and only if <span><span class="math inline">\(H\)</span></span> has a cut cutting at least <span><span class="math inline">\(k+4m\)</span></span> edges. We now prove both directions of this equivalence:</p>
<p><strong>Part 1: Completeness.</strong> If <span><span class="math inline">\(I\)</span></span> is an independent <span><span class="math inline">\(k\)</span></span>-sized set in <span><span class="math inline">\(G\)</span></span>, then we can define <span><span class="math inline">\(S\)</span></span> to be a cut in <span><span class="math inline">\(H\)</span></span> of the following form: we let <span><span class="math inline">\(S\)</span></span> contain all the vertices of <span><span class="math inline">\(I\)</span></span> and for every edge <span><span class="math inline">\(e=\{u,v \} \in E(G)\)</span></span>, if <span><span class="math inline">\(u\in I\)</span></span> and <span><span class="math inline">\(v\not\in I\)</span></span> then we add <span><span class="math inline">\(e_1\)</span></span> to <span><span class="math inline">\(S\)</span></span>; if <span><span class="math inline">\(u\not\in I\)</span></span> and <span><span class="math inline">\(v\in I\)</span></span> then we add <span><span class="math inline">\(e_0\)</span></span> to <span><span class="math inline">\(S\)</span></span>; and if <span><span class="math inline">\(u\not\in I\)</span></span> and <span><span class="math inline">\(v\not\in I\)</span></span> then we add both <span><span class="math inline">\(e_0\)</span></span> and <span><span class="math inline">\(e_1\)</span></span> to <span><span class="math inline">\(S\)</span></span>. (We don’t need to worry about the case that both <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(v\)</span></span> are in <span><span class="math inline">\(I\)</span></span> since it is an independent set.) We can verify that in all cases the number of edges from <span><span class="math inline">\(S\)</span></span> to its complement in the gadget corresponding to <span><span class="math inline">\(e\)</span></span> will be four (see <a href='#ISETtoMAXCUTfig'>Figure 13.7</a>). Since <span><span class="math inline">\(s^*\)</span></span> is not in <span><span class="math inline">\(S\)</span></span>, we also have <span><span class="math inline">\(k\)</span></span> edges from <span><span class="math inline">\(s^*\)</span></span> to <span><span class="math inline">\(I\)</span></span>, for a total of <span><span class="math inline">\(k+4m\)</span></span> edges.</p>
<p><strong>Part 2: Soundness.</strong> Suppose that <span><span class="math inline">\(S\)</span></span> is a cut in <span><span class="math inline">\(H\)</span></span> that cuts at least <span><span class="math inline">\(C=k+4m\)</span></span> edges. We can assume that <span><span class="math inline">\(s^*\)</span></span> is not in <span><span class="math inline">\(S\)</span></span> (otherwise we can “flip” <span><span class="math inline">\(S\)</span></span> to its complement <span><span class="math inline">\(\overline{S}\)</span></span>, since this does not change the size of the cut). Now let <span><span class="math inline">\(I\)</span></span> be the set of vertices in <span><span class="math inline">\(S\)</span></span> that correspond to the original vertices of <span><span class="math inline">\(G\)</span></span>. If <span><span class="math inline">\(I\)</span></span> was an independent set of size <span><span class="math inline">\(k\)</span></span> then would be done. This might not always be the case but we will see that if <span><span class="math inline">\(I\)</span></span> is not an independent set then it’s also larger than <span><span class="math inline">\(k\)</span></span>. Specifically, we define <span><span class="math inline">\(m_{in}=|E(I,I)|\)</span></span> be the set of edges in <span><span class="math inline">\(G\)</span></span> that are contained in <span><span class="math inline">\(I\)</span></span> and let <span><span class="math inline">\(m_{out}=m-m_{in}\)</span></span> (i.e., if <span><span class="math inline">\(I\)</span></span> is an independent set then <span><span class="math inline">\(m_{in}=0\)</span></span> and <span><span class="math inline">\(m_{out}=m\)</span></span>). By the properties of our gadget we know that for every edge <span><span class="math inline">\(\{u,v\}\)</span></span> of <span><span class="math inline">\(G\)</span></span>, we can cut at most three edges when both <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(v\)</span></span> are in <span><span class="math inline">\(S\)</span></span>, and at most four edges otherwise. Hence the number <span><span class="math inline">\(C\)</span></span> of edges cut by <span><span class="math inline">\(S\)</span></span> satisfies <span><span class="math inline">\(C \leq |I| + 3m_{in}+4m_{out} = |I|+ 3m_{in} + 4(m-m_{in})=|I|+4m-m_{in}\)</span></span>. Since <span><span class="math inline">\(C = k +4m\)</span></span> we get that <span><span class="math inline">\(|I|-m_{in} \geq k\)</span></span>. Now we can transform <span><span class="math inline">\(I\)</span></span> into an independent set <span><span class="math inline">\(I&#39;\)</span></span> by going over every one of the <span><span class="math inline">\(m_{in}\)</span></span> edges that are inside <span><span class="math inline">\(I\)</span></span> and removing one of the endpoints of the edge from it. The resulting set <span><span class="math inline">\(I&#39;\)</span></span> is an independent set in the graph <span><span class="math inline">\(G\)</span></span> of size <span><span class="math inline">\(|I|-m_{in} \geq k\)</span></span> and so this concludes the proof of the soundness condition.</p>
</div>
<figure>
<img src="../figure/iset2maxcutgadgetanalysis.png" alt="13.7: In the reduction of independent set to max cut, for every t\in [m], we have a “gadget” corresponding to the t-th edge e= \{ v_i,v_j\} in the original graph. If we think of the side of the cut containing the special source vertex s^* as “white” and the other side as “blue”, then the leftmost and center figures show that if v_i and v_j are not both blue then we can cut four edges from the gadget. In contrast, by enumerating all possibilities one can verify that if both u and v are blue, then no matter how we color the intermediate vertices e_t^0,e_t^1, we will cut at most three edges from the gadget. The figure above contains only the gadget edges and ignores the edges connecting s^* to the vertices v_0,\ldots,v_{n-1}." id="ISETtoMAXCUTfig" class="margin" /><figcaption>13.7: In the reduction of independent set to max cut, for every <span><span class="math inline">\(t\in [m]\)</span></span>, we have a “gadget” corresponding to the <span><span class="math inline">\(t\)</span></span>-th edge <span><span class="math inline">\(e= \{ v_i,v_j\}\)</span></span> in the original graph. If we think of the side of the cut containing the special source vertex <span><span class="math inline">\(s^*\)</span></span> as “white” and the other side as “blue”, then the leftmost and center figures show that if <span><span class="math inline">\(v_i\)</span></span> and <span><span class="math inline">\(v_j\)</span></span> are not both blue then we can cut four edges from the gadget. In contrast, by enumerating all possibilities one can verify that if both <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(v\)</span></span> are blue, then no matter how we color the intermediate vertices <span><span class="math inline">\(e_t^0,e_t^1\)</span></span>, we will cut at most three edges from the gadget. The figure above contains only the gadget edges and ignores the edges connecting <span><span class="math inline">\(s^*\)</span></span> to the vertices <span><span class="math inline">\(v_0,\ldots,v_{n-1}\)</span></span>.</figcaption>
</figure>
<figure>
<img src="../figure/is2maxcut.png" alt="13.8: The reduction of independent set to max cut. On the righthand side is Python code implementing the reduction. On the lefthand side is an example output of the reduction where we apply it to the independent set instance that is obtained by running the reduction of  on the 3CNF formula (x_0 \vee \overline{x}_3 \vee x_2) \wedge (\overline{x}_0 \vee x_1 \vee \overline{x}_2) \wedge (\overline{x}_1 \vee x_2 \vee x_3)." id="isettomaxcutcodefig" /><figcaption>13.8: The reduction of independent set to max cut. On the righthand side is Python code implementing the reduction. On the lefthand side is an example output of the reduction where we apply it to the independent set instance that is obtained by running the reduction of <a href='#isetnpc'>Theorem 13.5</a> on the 3CNF formula <span><span class="math inline">\((x_0 \vee \overline{x}_3 \vee x_2) \wedge (\overline{x}_0 \vee x_1 \vee \overline{x}_2) \wedge (\overline{x}_1 \vee x_2 \vee x_3)\)</span></span>.</figcaption>
</figure>
<h2 id="reducing-3sat-to-longest-path" data-number="13.6">Reducing 3SAT to Longest Path</h2>
<p><strong>Note:</strong> This section is still a little messy; feel free to skip it or just read it without going into the proof details. The proof appears in Section 7.5 in Sipser’s book.</p>
<p>One of the most basic algorithms in Computer Science is Dijkstra’s algorithm to find the <em>shortest path</em> between two vertices. We now show that in contrast, an efficient algorithm for the <em>longest path</em> problem would imply a polynomial-time algorithm for 3SAT.</p>
<div id="longpaththm" class="theorem" title="Hardness of longest path" name="Theorem 13.7 (Hardness of longest path) ">
<p><span>
<div class='myequationbox'><span class="math display">\[3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{LONGPATH}}\]</span></div></span></p>
</div>
<figure>
<img src="../figure/3sat_longest_path_red_without_path.png" alt="13.9: We can transform a 3SAT formula \varphi into a graph G such that the longest path in the graph G would correspond to a satisfying assignment in \varphi. In this graph, the black colored part corresponds to the variables of \varphi and the blue colored part corresponds to the vertices. A sufficiently long path would have to first “snake” through the black part, for each variable choosing either the “upper path” (corresponding to assigning it the value True) or the “lower path” (corresponding to assigning it the value False). Then to achieve maximum length the path would traverse through the blue part, where to go between two vertices corresponding to a clause such as x_{17} \vee \overline{x}_{32} \vee x_{57}, the corresponding vertices would have to have been not traversed before." id="longpathfig" class="margin" /><figcaption>13.9: We can transform a 3SAT formula <span><span class="math inline">\(\varphi\)</span></span> into a graph <span><span class="math inline">\(G\)</span></span> such that the longest path in the graph <span><span class="math inline">\(G\)</span></span> would correspond to a satisfying assignment in <span><span class="math inline">\(\varphi\)</span></span>. In this graph, the black colored part corresponds to the variables of <span><span class="math inline">\(\varphi\)</span></span> and the blue colored part corresponds to the vertices. A sufficiently long path would have to first “snake” through the black part, for each variable choosing either the “upper path” (corresponding to assigning it the value <code>True</code>) or the “lower path” (corresponding to assigning it the value <code>False</code>). Then to achieve maximum length the path would traverse through the blue part, where to go between two vertices corresponding to a clause such as <span><span class="math inline">\(x_{17} \vee \overline{x}_{32} \vee x_{57}\)</span></span>, the corresponding vertices would have to have been not traversed before.</figcaption>
</figure>
<figure>
<img src="../figure/3sat_to_longest_path_reduction.png" alt="13.10: The graph above with the longest path marked on it, the part of the path corresponding to variables is in green and part corresponding to the clauses is in pink." id="longpathfigtwo" class="margin" /><figcaption>13.10: The graph above with the longest path marked on it, the part of the path corresponding to variables is in green and part corresponding to the clauses is in pink.</figcaption>
</figure>
<div id="section-5" class="proofidea" data-ref="longpaththm" name="Proofidea">
<p>To prove <a href='#longpaththm'>Theorem 13.7</a> need to show how to transform a 3CNF formula <span><span class="math inline">\(\varphi\)</span></span> into a graph <span><span class="math inline">\(G\)</span></span> and two vertices <span><span class="math inline">\(s,t\)</span></span> such that <span><span class="math inline">\(G\)</span></span> has a path of length at least <span><span class="math inline">\(k\)</span></span> if and only if <span><span class="math inline">\(\varphi\)</span></span> is satisfiable. The idea of the reduction is sketched in <a href='#longpathfig'>Figure 13.9</a> and <a href='#longpathfigtwo'>Figure 13.10</a>. We will construct a graph that contains a potentially long “snaking path” that corresponds to all variables in the formula. We will add a “gadget” corresponding to each clause of <span><span class="math inline">\(\varphi\)</span></span> in a way that we would only be able to use the gadgets if we have a satisfying assignment.</p>
</div>
<div class="proof" data-ref="longpaththm" name="Proof 13.6">
<p>We build a graph <span><span class="math inline">\(G\)</span></span> that “snakes” from <span><span class="math inline">\(s\)</span></span> to <span><span class="math inline">\(t\)</span></span> as follows. After <span><span class="math inline">\(s\)</span></span> we add a sequence of <span><span class="math inline">\(n\)</span></span> long loops. Each loop has an “upper path” and a “lower path”. A simple path cannot take both the upper path and the lower path, and so it will need to take exactly one of them to reach <span><span class="math inline">\(s\)</span></span> from <span><span class="math inline">\(t\)</span></span>.</p>
<p>Our intention is that a path in the graph will correspond to an assignment <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> in the sense that taking the upper path in the <span><span class="math inline">\(i^{th}\)</span></span> loop corresponds to assigning <span><span class="math inline">\(x_i=1\)</span></span> and taking the lower path corresponds to assigning <span><span class="math inline">\(x_i=0\)</span></span>. When we are done snaking through all the <span><span class="math inline">\(n\)</span></span> loops corresponding to the variables to reach <span><span class="math inline">\(t\)</span></span> we need to pass through <span><span class="math inline">\(m\)</span></span> “obstacles”: for each clause <span><span class="math inline">\(j\)</span></span> we will have a small gadget consisting of a pair of vertices <span><span class="math inline">\(s_j,t_j\)</span></span> that have three paths between them. For example, if the <span><span class="math inline">\(j^{th}\)</span></span> clause had the form <span><span class="math inline">\(x_{17} \vee \overline{x}_{55} \vee x_{72}\)</span></span> then one path would go through a vertex in the lower loop corresponding to <span><span class="math inline">\(x_{17}\)</span></span>, one path would go through a vertex in the upper loop corresponding to <span><span class="math inline">\(x_{55}\)</span></span> and the third would go through the lower loop corresponding to <span><span class="math inline">\(x_{72}\)</span></span>. We see that if we went in the first stage according to a satisfying assignment then we will be able to find a free vertex to travel from <span><span class="math inline">\(s_j\)</span></span> to <span><span class="math inline">\(t_j\)</span></span>. We link <span><span class="math inline">\(t_1\)</span></span> to <span><span class="math inline">\(s_2\)</span></span>, <span><span class="math inline">\(t_2\)</span></span> to <span><span class="math inline">\(s_3\)</span></span>, etc and link <span><span class="math inline">\(t_m\)</span></span> to <span><span class="math inline">\(t\)</span></span>. Thus a satisfying assignment would correspond to a path from <span><span class="math inline">\(s\)</span></span> to <span><span class="math inline">\(t\)</span></span> that goes through one path in each loop corresponding to the variables, and one path in each loop corresponding to the clauses. We can make the loop corresponding to the variables long enough so that we must take the entire path in each loop in order to have a fighting chance of getting a path as long as the one corresponds to a satisfying assignment. But if we do that, then the only way if we are able to reach <span><span class="math inline">\(t\)</span></span> is if the paths we took corresponded to a satisfying assignment, since otherwise we will have one clause <span><span class="math inline">\(j\)</span></span> where we cannot reach <span><span class="math inline">\(t_j\)</span></span> from <span><span class="math inline">\(s_j\)</span></span> without using a vertex we already used before.</p>
</div>
<h3 id="summary-of-relations" data-number="13.6.1">Summary of relations</h3>
<p>We have shown that there are a number of functions <span><span class="math inline">\(F\)</span></span> for which we can prove a statement of the form “If <span><span class="math inline">\(F\in \mathbf{P}\)</span></span> then <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \in \mathbf{P}\)</span></span>”. Hence coming up with a polynomial-time algorithm for even one of these problems will entail a polynomial-time algorithm for <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> (see for example <a href='#reductiondiagramfig'>Figure 13.11</a>). In <a href='lec_13_Cook_Levin.html#cooklevinchap'>Chapter 14</a> we will show the inverse direction (“If <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \in \mathbf{P}\)</span></span> then <span><span class="math inline">\(F\in \mathbf{P}\)</span></span>”) for these functions, hence allowing us to conclude that they have <em>equivalent complexity</em> to <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>.</p>
<figure>
<img src="../figure/reduction_inc_diagram.png" alt="13.11: So far we have shown that \mathbf{P} \subseteq \mathbf{EXP} and that several problems we care about such as 3\ensuremath{\mathit{SAT}} and \ensuremath{\mathit{MAXCUT}} are in \mathbf{EXP} but it is not known whether or not they are in \mathbf{EXP}. However, since 3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{MAXCUT}} we can rule out the possiblity that \ensuremath{\mathit{MAXCUT}} \in \mathbf{P} but 3\ensuremath{\mathit{SAT}} \not\in \mathbf{P}. The relation of \mathbf{P_{/poly}} to the class \mathbf{EXP} is not known. We know that \mathbf{EXP} does not contain \mathbf{P_{/poly}} since the latter even contains uncomputable functions, but we do not know whether ot not \mathbf{EXP} \subseteq \mathbf{P_{/poly}} (though it is believed that this is not the case and in particular that both 3\ensuremath{\mathit{SAT}} and \ensuremath{\mathit{MAXCUT}} are not in \mathbf{P_{/poly}})." id="reductiondiagramfig" /><figcaption>13.11: So far we have shown that <span><span class="math inline">\(\mathbf{P} \subseteq \mathbf{EXP}\)</span></span> and that several problems we care about such as <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> are in <span><span class="math inline">\(\mathbf{EXP}\)</span></span> but it is not known whether or not they are in <span><span class="math inline">\(\mathbf{EXP}\)</span></span>. However, since <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{MAXCUT}}\)</span></span> we can rule out the possiblity that <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}} \in \mathbf{P}\)</span></span> but <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \not\in \mathbf{P}\)</span></span>. The relation of <span><span class="math inline">\(\mathbf{P_{/poly}}\)</span></span> to the class <span><span class="math inline">\(\mathbf{EXP}\)</span></span> is not known. We know that <span><span class="math inline">\(\mathbf{EXP}\)</span></span> does not contain <span><span class="math inline">\(\mathbf{P_{/poly}}\)</span></span> since the latter even contains uncomputable functions, but we do not know whether ot not <span><span class="math inline">\(\mathbf{EXP} \subseteq \mathbf{P_{/poly}}\)</span></span> (though it is believed that this is not the case and in particular that both <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> are not in <span><span class="math inline">\(\mathbf{P_{/poly}}\)</span></span>).</figcaption>
</figure>
<div class="recap" name="Recap 13.6.1">
<ul>
<li><p>The computational complexity of many seemingly unrelated computational problems can be related to one another through the use of <em>reductions</em>.</p></li>
<li><p>If <span><span class="math inline">\(F \leq_p G\)</span></span> then a polynomial-time algorithm for <span><span class="math inline">\(G\)</span></span> can be transformed into a polynomial-time algorithm for <span><span class="math inline">\(F\)</span></span>.</p></li>
<li><p>Equivalently, if <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(F\)</span></span> does <em>not</em> have a polynomial-time algorithm then neither does <span><span class="math inline">\(G\)</span></span>.</p></li>
<li><p>We’ve developed many techniques to show that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p F\)</span></span> for interesting functions <span><span class="math inline">\(F\)</span></span>. Sometimes we can do so by using <em>transitivity</em> of reductions: if <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p G\)</span></span> and <span><span class="math inline">\(G \leq_p F\)</span></span> then <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p F\)</span></span>.</p></li>
</ul>
</div>
<h2 id="exercises" data-number="13.7">Exercises</h2>
<h2 id="reductionsbibnotes" data-number="13.8">Bibliographical notes</h2>
<p>Several notions of reductions are defined in the literature. The notion defined in <a href='#reduction-def'>Definition 13.1</a> is often known as a <em>mapping reduction</em>, <em>many to one reduction</em> or a <em>Karp reduction</em>.</p>
<p>The <em>maximal</em> (as opposed to <em>maximum</em>) independent set is the task of finding a “local maximum” of an independent set: an independent set <span><span class="math inline">\(S\)</span></span> such that one cannot add a vertex to it without losing the independence property (such a set is known as a <em>vertex cover</em>). Unlike finding a <em>maximum</em> independent set, finding a <em>maximal</em> independent set can be done efficiently by a greedy algorithm, but this local maximum can be much smaller than the global maximum.</p>
<p>Reduction of independent set to max cut taken from <a href="https://people.engr.ncsu.edu/mfms/Teaching/CSC505/wrap/Lectures/week14.pdf">these notes</a>. Image of Hamiltonian Path through Dodecahedron by <a href="https://commons.wikimedia.org/wiki/File:Hamiltonian_path.svg">Christoph Sommer</a>.</p>
<p>We have mentioned that the line between reductions used for algorithm design and showing hardness is sometimes blurry. An excellent example for this is the area of <em>SAT Solvers</em> (see  (<a href="https://scholar.google.com/scholar?hl=en&q=Gomes,+Kautz,+Sabharwal,+Selman+Satisfiability+solvers" target="_blank">Gomes, Kautz, Sabharwal, Selman, 2008</a>) ). In this field people use algorithms for SAT (that take exponential time in the worst case but often are much faster on many instances in practice) together with reductions of the form <span><span class="math inline">\(F \leq_p \ensuremath{\mathit{SAT}}\)</span></span> to derive algorithms for other functions <span><span class="math inline">\(F\)</span></span> of interest.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>If you are familiar with matrix notation you may note that such equations can be written as <span><span class="math inline">\(Ax = \mathbf{b}\)</span></span> where <span><span class="math inline">\(A\)</span></span> is an <span><span class="math inline">\(m\times n\)</span></span> matrix with entries in <span><span class="math inline">\(0/1\)</span></span> and <span><span class="math inline">\(\mathbf{b} \in \N^m\)</span></span>.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:38:27</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_12_NP.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
