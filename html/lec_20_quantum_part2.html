<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Quantum II: Shor</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Quantum II: Shor" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#counting-number-of-operations."><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash functions and random oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "bitcoin" problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The currency problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The bitcoin ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From proof of work to consensus on ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision resistance hash functions and creating short "unique" identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical constructions of cryptographic hash functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical random-ish functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some history</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions."><i class="fa fa-check"></i><b>7.4.3</b> The NSA and hash functions.</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs non-cryptographic hash functions:</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#an-lwe-based-encryption-scheme"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Quantum II: Shor</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_20_quantum_part2.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="quantum-computing-and-cryptography-ii" data-number="21">Quantum computing and cryptography II</h1>
<p>Bell’s Inequality is powerful demonstration that there is something very strange going on with quantum mechanics. But could this “strangeness” be of any use to solve computational problems not directly related to quantum systems? A priori, one could guess the answer is <em>no</em>. In 1994 Peter Shor showed that one would be wrong:</p>
<div id="shorthm" class="theorem" title="Shor&#39;s Theorem" data-number="21" name="Theorem 21.1 (Shor&#39;s Theorem) ">
<p>The map that takes an integer <span><span class="math inline">\(m\)</span></span> into its prime factorization is efficiently quantumly computable. Specifically, it can be computed using <span><span class="math inline">\(O(\log^3 m)\)</span></span> quantum gates.</p>
</div>
<p>This is an exponential improvement over the best known classical algorithms, which as we mentioned before, take roughly <span><span class="math inline">\(2^{\tilde{O(\log^{1/3}m)}}\)</span></span> time.</p>
<p>We will now sketch the ideas behind Shor’s algorithm. In fact, Shor proved the following more general theorem:</p>
<div id="hiddengroupthm" class="theorem" title="Order Finding Algorithm" data-number="21" name="Theorem 21.2 (Order Finding Algorithm) ">
<p>There is a quantum polynomial time algorithm that given a multiplicative Abelian group <span><span class="math inline">\(\mathbb{G}\)</span></span> and element <span><span class="math inline">\(g\in\mathbb{G}\)</span></span> computes the <em>order</em> of <span><span class="math inline">\(g\)</span></span> in the group.</p>
</div>
<p>Recall that the order of <span><span class="math inline">\(g\)</span></span> in <span><span class="math inline">\(\mathbb{G}\)</span></span> is the smallest positive integer <span><span class="math inline">\(a\)</span></span> such that <span><span class="math inline">\(g^a = 1\)</span></span>. By “given a group” we mean that we can represent the elements of the group as strings of length <span><span class="math inline">\(O(\log |\mathbb{G}|)\)</span></span> and there is a <span><span class="math inline">\(poly(\log|\mathbb{G}|)\)</span></span> algorithm to perform multiplication in the group.</p>
<h2 id="from-order-finding-to-factoring-and-discrete-log" data-number="21.1">From order finding to factoring and discrete log</h2>
<p>The order finding problem allows not just to factor integers in polynomial time, but also solve the discrete logarithm over arbitrary Abelian groups, hereby showing that quantum computers will break not just RSA but also Diffie Hellman and Elliptic Curve Cryptography. We merely sketch how one reduces the factoring and discrete logarithm problems to order finding: (see some of the sources above for the full details)</p>
<ul>
<li><p>For <strong>factoring</strong>, let us restrict to the case <span><span class="math inline">\(m=pq\)</span></span> for distinct <span><span class="math inline">\(p,q\)</span></span>. Recall that we showed that finding the size <span><span class="math inline">\((p-1)(q-1)=m-p-q+1\)</span></span> of the group <span><span class="math inline">\(\Z^*_m\)</span></span> is sufficient to recover <span><span class="math inline">\(p\)</span></span> and <span><span class="math inline">\(q\)</span></span>. One can show that if we pick a few random <span><span class="math inline">\(x\)</span></span>’s in <span><span class="math inline">\(\Z^*_m\)</span></span> and compute their order, the least common multiplier of these orders is likely to be the group size.</p></li>
<li><p>For <strong>discrete log</strong> in a group <span><span class="math inline">\(\mathbb{G}\)</span></span>, if we get <span><span class="math inline">\(X=g^x\)</span></span> and need to recover <span><span class="math inline">\(x\)</span></span>, we can compute the order of various elements of the form <span><span class="math inline">\(X^ag^b\)</span></span>. The order of such an element is a number <span><span class="math inline">\(c\)</span></span> satisfying <span><span class="math inline">\(c(xa+b) = 0 \pmod{|\mathbb{G}|}\)</span></span>. Again, with a few random examples we will get a non trivial example (where <span><span class="math inline">\(c \neq 0 \pmod{|\mathbb{G}|}\)</span></span> ) and be able to recover the unknown <span><span class="math inline">\(x\)</span></span>.</p></li>
</ul>
<h2 id="finding-periods-of-a-function-simons-algorithm" data-number="21.2">Finding periods of a function: Simon’s Algorithm</h2>
<p>Let <span><span class="math inline">\(\mathbb{H}\)</span></span> be some Abelian group with a group operation that we’ll denote by <span><span class="math inline">\(\oplus\)</span></span>, and <span><span class="math inline">\(f\)</span></span> be some function mapping <span><span class="math inline">\(\mathbb{H}\)</span></span> to an arbitrary set (which we can encode as <span><span class="math inline">\(\{0,1\}^*\)</span></span>). We say that <span><span class="math inline">\(f\)</span></span> has <em>period <span><span class="math inline">\(h^*\)</span></span></em> for some <span><span class="math inline">\(h^*\in\mathbb{H}\)</span></span> if for every <span><span class="math inline">\(x,y \in \mathbb{H}\)</span></span>, <span><span class="math inline">\(f(x)=f(y)\)</span></span> if and only if <span><span class="math inline">\(y = x \oplus kh^*\)</span></span> for some integer <span><span class="math inline">\(k\)</span></span>. Note that if <span><span class="math inline">\(\mathbb{G}\)</span></span> is some Abelian group, then if we define <span><span class="math inline">\(\mathbb{H}=\Z_{|\mathbb{G}|}\)</span></span>, for every element <span><span class="math inline">\(g\in \mathbb{G}\)</span></span>, the map <span><span class="math inline">\(f(a)=g^a\)</span></span> is a periodic map over <span><span class="math inline">\(\mathbb{H}\)</span></span> with period the order of <span><span class="math inline">\(g\)</span></span>. So, finding the order of an item reduces to the question of finding the period of a function.</p>
<p>How do we generally find the period of a function? Let us consider the simplest case, where <span><span class="math inline">\(f\)</span></span> is a function from <span><span class="math inline">\(\R\)</span></span> to <span><span class="math inline">\(\R\)</span></span> that is <span><span class="math inline">\(h^*\)</span></span> periodic for some number <span><span class="math inline">\(h^*\)</span></span>, in the sense that <span><span class="math inline">\(f\)</span></span> repeats itself on the intervals <span><span class="math inline">\([0,h^*]\)</span></span>, <span><span class="math inline">\([h^*,2h^*]\)</span></span>, <span><span class="math inline">\([2h^*,3h^*]\)</span></span>, etc.. How do we find this number <span><span class="math inline">\(h^*\)</span></span>? The key idea would be to transform <span><span class="math inline">\(f\)</span></span> from the <em>time</em> to the <em>frequency</em> domain. That is, we use the <em>Fourier transform</em> to represent <span><span class="math inline">\(f\)</span></span> as a sum of wave functions. In this representation wavelengths that divide the period <span><span class="math inline">\(h^*\)</span></span> would get significant mass, while wavelengths that don’t would likely “cancel out”.</p>
<figure>
<img src="../figure/quantum_fourier.jpg" alt="21.1: If f is a periodic function then when we represent it in the Fourier transform, we expect the coefficients corresponding to wavelengths that do not evenly divide the period to be very small, as they would tend to “cancel out”." id="tmplabelfig" /><figcaption>21.1: If <span><span class="math inline">\(f\)</span></span> is a periodic function then when we represent it in the Fourier transform, we expect the coefficients corresponding to wavelengths that do not evenly divide the period to be very small, as they would tend to “cancel out”.</figcaption>
</figure>
<p>Similarly, the main idea behind Shor’s algorithm is to use a tool known as the <em>quantum fourier transform</em> that given a circuit computing the function <span><span class="math inline">\(f:\mathbb{H}\rightarrow\R\)</span></span>, creates a quantum state over roughly <span><span class="math inline">\(\log |\mathbb{H}|\)</span></span> qubits (and hence dimension <span><span class="math inline">\(|\mathbb{H}|\)</span></span>) that corresponds to the Fourier transform of <span><span class="math inline">\(f\)</span></span>. Hence when we measure this state, we get a group element <span><span class="math inline">\(h\)</span></span> with probability proportional to the square of the corresponding Fourier coefficient. One can show that if <span><span class="math inline">\(f\)</span></span> is <span><span class="math inline">\(h^*\)</span></span>-periodic then we can recover <span><span class="math inline">\(h^*\)</span></span> from this distribution.</p>
<p>Shor carried out this approach for the group <span><span class="math inline">\(\mathbb{H}=\Z^*_q\)</span></span> for some <span><span class="math inline">\(q\)</span></span>, but we will start be seeing this for the group <span><span class="math inline">\(\mathbb{H} = \{0,1\}^n\)</span></span> with the XOR operation. This case is known as <em>Simon’s algorithm</em> (given by Dan Simon in 1994) and actually preceded (and inspired) Shor’s algorithm:</p>
<div id="simonsthm" class="theorem" title="Simon&#39;s Algorithm" data-number="21.2" name="Theorem 21.3 (Simon&#39;s Algorithm) ">
<p>If <span><span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}^*\)</span></span> is polynomial time computable and satisfies the property that <span><span class="math inline">\(f(x)=f(y)\)</span></span> iff <span><span class="math inline">\(x\oplus y = h^*\)</span></span> then there exists a quantum polynomial-time algorithm that outputs a random <span><span class="math inline">\(h\in \{0,1\}^n\)</span></span> such that <span><span class="math inline">\(\langle h,h^* \rangle=0 \pmod{2}\)</span></span>.</p>
</div>
<p>Note that given <span><span class="math inline">\(O(n)\)</span></span> such samples, we can recover <span><span class="math inline">\(h^*\)</span></span> with high probability by solving the corresponding linear equations.</p>
<div id="section" class="proof" data-ref="simonsthm" data-number="21.2" name="Proof">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{HAD}}\)</span></span> be the <span><span class="math inline">\(2\times 2\)</span></span> unitary matrix corresponding to the one qubit operation <span><span class="math inline">\(|0\rangle \mapsto \tfrac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\)</span></span> and <span><span class="math inline">\(|1\rangle \mapsto \tfrac{1}{\sqrt{2}}(|0\rangle-|1\rangle)\)</span></span> or <span><span class="math inline">\(|a\rangle\mapsto \tfrac{1}{\sqrt{2}}(|0\rangle+(-1)^a|1\rangle)\)</span></span>. Given the state <span><span class="math inline">\(|0^{n+m\rangle}\)</span></span> we can apply this map to each one of the first <span><span class="math inline">\(n\)</span></span> qubits to get the state <span><span class="math inline">\(2^{-n/2}\sum_{x\in\{0,1\}^n}|x\rangle|0^m\rangle\)</span></span> and then we can apply the gates of <span><span class="math inline">\(f\)</span></span> to map this to the state <span><span class="math inline">\(2^{-n/2}\sum_{x\in\{0,1\}^n}|x\rangle|f(x)\rangle\)</span></span> now suppose that we apply this operation again to the first <span><span class="math inline">\(n\)</span></span> qubits then we get the state <span><span class="math inline">\(2^{-n}\sum_{x\in\{0,1\}^n}\prod_{i=1}^n(|0\rangle+(-1)^{x_i}|1\rangle)|f(x)\rangle\)</span></span> which if we open up each one of these product and look at all <span><span class="math inline">\(2^n\)</span></span> choices <span><span class="math inline">\(y\in\{0,1\}^n\)</span></span> (with <span><span class="math inline">\(y_i=0\)</span></span> corresponding to picking <span><span class="math inline">\(|0\rangle\)</span></span> and <span><span class="math inline">\(y_i=1\)</span></span> corresponding to picking <span><span class="math inline">\(|1\rangle\)</span></span> in the <span><span class="math inline">\(i^{th}\)</span></span> product) we get <span><span class="math inline">\(2^{-n}\sum_{x\in\{0,1\}^n}\sum_{y\in\{0,1\}^n}(-1)^{\langle x,y \rangle}|y\rangle|f(x)\rangle\)</span></span>. Now under our assumptions for every particular <span><span class="math inline">\(z\)</span></span> in the image of <span><span class="math inline">\(f\)</span></span>, there exist exactly two preimages <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(x\oplus h^*\)</span></span> such that <span><span class="math inline">\(f(x)=f(x+h^*)=z\)</span></span>. So, if <span><span class="math inline">\(\langle y,h^* \rangle=0 \pmod{2}\)</span></span>, we get that <span><span class="math inline">\((-1)^{\langle x,y \rangle}+(-1)^{\langle x,y+h^* \rangle}=2\)</span></span> and otherwise we get <span><span class="math inline">\((-1)^{\langle x,y \rangle}+(-1)^{\langle x,y+h^* \rangle}=0\)</span></span>. Therefore, if measure the state we will get a pair <span><span class="math inline">\((y,z)\)</span></span> such that <span><span class="math inline">\(\langle y,h^* \rangle=0 \pmod{2}\)</span></span>. QED</p>
</div>
<p>Simon’s algorithm seems to really use the special bit-wise structure of the group <span><span class="math inline">\(\{0,1\}^n\)</span></span>, so one could wonder if it has any relevance for the group <span><span class="math inline">\(\Z^*_m\)</span></span> for some exponentially large <span><span class="math inline">\(m\)</span></span>. It turns out that the same insights that underlie the well known Fast Fourier Transform (FFT) algorithm can be used to essentially follow the same strategy for this group as well.</p>
<h2 id="from-simon-to-shor" data-number="21.3">From Simon to Shor</h2>
<p>(Note: The presentation here is adapted from the quantum computing chapter in my textbook with Arora.)</p>
<p>We now describe how to achieve Shor’s algorithm for order finding. We will not do this for a general group but rather focus our attention on the group <span><span class="math inline">\(\Z^*_{\ell}\)</span></span> for some number <span><span class="math inline">\(\ell\)</span></span> which is the case of interest for integer factoring and the discrete logarithm modulo primes problems.</p>
<p>That is, we prove the following theorem:</p>
<div id="shortwothm" class="theorem" title="Shor&#39;s Algorithm, restated" data-number="21.3" name="Theorem 21.4 (Shor&#39;s Algorithm, restated) ">
<p>For every <span><span class="math inline">\(\ell\)</span></span> and <span><span class="math inline">\(a\in\Z^*_\ell\)</span></span>, there is a quantum <span><span class="math inline">\(poly(log \ell)\)</span></span> algorithm to find the order of <span><span class="math inline">\(a\)</span></span> in <span><span class="math inline">\(\Z^*_\ell\)</span></span>.</p>
</div>
<p>The idea is similar to Simon’s algorithm. We consider the map <span><span class="math inline">\(x \mapsto a^x (\mod \ell)\)</span></span> which is a periodic map over <span><span class="math inline">\(\Z_m\)</span></span> where <span><span class="math inline">\(m=|\Z^*_\ell|\)</span></span> with period being the order of <span><span class="math inline">\(a\)</span></span>.<br />
To find the period of this map we will now need to perform a <em>Quantum Fourier Transform (QFT)</em> over the group <span><span class="math inline">\(\Z_m\)</span></span> instead of <span><span class="math inline">\(\{0,1\}^n\)</span></span>. This is a quantum algorithm that takes a register from some arbitrary state <span><span class="math inline">\(f \in \mathbb{C}^{m}\)</span></span> into a state whose vector is the Fourier transform <span><span class="math inline">\(\hat{f}\)</span></span> of <span><span class="math inline">\(f\)</span></span>. The QFT takes only <span><span class="math inline">\(O(\log^2 m)\)</span></span> elementary steps and is thus very efficient. Note that we cannot say that this algorithm “computes” the Fourier transform, since the transform is stored in the amplitudes of the state, and as mentioned earlier, quantum mechanics give no way to “read out” the amplitudes per se. The only way to get information from a quantum state is by <em>measuring</em> it, which yields a single basis state with probability that is related to its amplitude. This is hardly representative of the entire Fourier transform vector, but sometimes (as is the case in Shor’s algorithm) this is enough to get highly non-trivial information, which we do not know how to obtain using classical (non-quantum) computers.</p>
<h3 id="the-fourier-transform-over-z_m" data-number="21.3.1">The Fourier transform over <span><span class="math inline">\(\Z_m\)</span></span></h3>
<p>We now define the Fourier transform over <span><span class="math inline">\(\Z_m\)</span></span> (the group of integers in <span><span class="math inline">\(\{0,\ldots,m-1\}\)</span></span> with addition modulo <span><span class="math inline">\(m\)</span></span>). We give a definition that is specialized to the current context. For every vector <span><span class="math inline">\(f\in\mathbb{C}^m\)</span></span>, the <em>Fourier transform of <span><span class="math inline">\(f\)</span></span></em> is the vector <span><span class="math inline">\(\hat{f}\)</span></span> where the <span><span class="math inline">\(x^{th}\)</span></span> coordinate of <span><span class="math inline">\(\hat{f}\)</span></span> is defined as<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p><span><span class="math inline">\(\hat{f}(x) = \tfrac{1}{\sqrt{m}}\sum_{y\in\Z_m} f(x)\omega^{xy}\)</span></span></p>
<p>where <span><span class="math inline">\(\omega = e^{2\pi i/m}\)</span></span>.</p>
<p>The Fourier transform is simply a representation of <span><span class="math inline">\(f\)</span></span> in the <em>Fourier basis</em> <span><span class="math inline">\(\{ \chi_x \}_{x \in \Z_m}\)</span></span>, where <span><span class="math inline">\(\chi_x\)</span></span> is the vector/function whose <span><span class="math inline">\(y^{th}\)</span></span> coordinate is <span><span class="math inline">\(\tfrac{1}{\sqrt{m}\omega^{xy}}\)</span></span>. Now the inner product of any two vectors <span><span class="math inline">\(\chi_x,\chi_z\)</span></span> in this basis is equal to <span>
<div class='myequationbox'><span class="math display">\[\langle \chi_x,\chi_z \rangle = \tfrac{1}{m}\sum_{y\in\Z_m} \omega^{xy} \overline{\omega^{zy}} = \tfrac{1}{m}\sum_{y\in\Z_m} \omega^{(x-z)y}  \;.\]</span></div></span> But if <span><span class="math inline">\(x=z\)</span></span> then <span><span class="math inline">\(\omega^{(x-z)}=1\)</span></span> and hence this sum is equal to <span><span class="math inline">\(1\)</span></span>. On the other hand, if <span><span class="math inline">\(x \neq z\)</span></span>, then this sum is equal to <span><span class="math inline">\(\tfrac{1}{m} \tfrac{1 -\omega^{(x-y)m}}{1-\omega^{x-y}}= \tfrac{1}{m}\tfrac{1-1}{1-\omega^{x-y}}=0\)</span></span> using the formula for the sum of a geometric series. In other words, this is an <em>orthonormal</em> basis which means that the Fourier transform map <span><span class="math inline">\(f \mapsto \hat{f}\)</span></span> is a <em>unitary</em> operation.</p>
<p>What is so special about the Fourier basis? For one thing, if we identify vectors in <span><span class="math inline">\(\mathbb{C}^m\)</span></span> with functions mapping <span><span class="math inline">\(\Z_m\)</span></span> to <span><span class="math inline">\(\mathbb{C}\)</span></span>, then it’s easy to see that every function <span><span class="math inline">\(\chi\)</span></span> in the Fourier basis is a <em>homomorphism</em> from <span><span class="math inline">\(\Z_m\)</span></span> to <span><span class="math inline">\(\mathbb{C}\)</span></span> in the sense that <span><span class="math inline">\(\chi(y+z)= \chi(y)\chi(z)\)</span></span> for every <span><span class="math inline">\(y,z \in \Z_m\)</span></span>. Also, every function <span><span class="math inline">\(\chi\)</span></span> is <em>periodic</em> in the sense that there exists <span><span class="math inline">\(r\in \Z_m\)</span></span> such that <span><span class="math inline">\(\chi(y+r)=\chi(z)\)</span></span> for every <span><span class="math inline">\(y\in \Z_m\)</span></span> (indeed if <span><span class="math inline">\(\chi(y) = \omega^{xy}\)</span></span> then we can take <span><span class="math inline">\(r\)</span></span> to be <span><span class="math inline">\(\ell/x\)</span></span> where <span><span class="math inline">\(\ell\)</span></span> is the least common multiple of <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(m\)</span></span>). Thus, intuitively, if a function <span><span class="math inline">\(f:\Z_m\rightarrow\mathbb{C}\)</span></span> is itself periodic (or roughly periodic) then when representing <span><span class="math inline">\(f\)</span></span> in the Fourier basis, the coefficients of basis vectors with periods agreeing with the period of <span><span class="math inline">\(f\)</span></span> should be large, and so we might be able to discover <span><span class="math inline">\(f\)</span></span>’s period from this representation. This does turn out to be the case, and is a crucial point in Shor’s algorithm.</p>
<h4 id="fast-fourier-transform." data-number="21.3.1.1">Fast Fourier Transform.</h4>
<p>Denote by <span><span class="math inline">\(\ensuremath{\mathit{FT}}_m\)</span></span> the operation that maps every vector <span><span class="math inline">\(f\in\mathbb{C}^m\)</span></span> to its Fourier transform <span><span class="math inline">\(\hat{f}\)</span></span>. The operation <span><span class="math inline">\(\ensuremath{\mathit{FT}}_m\)</span></span> is represented by an <span><span class="math inline">\(m\times m\)</span></span> matrix whose <span><span class="math inline">\((x,y)\)</span></span>th entry is <span><span class="math inline">\(\omega^{xy}\)</span></span>. The trivial algorithm to compute it takes <span><span class="math inline">\(m^2\)</span></span> operations. The famous <em>Fast Fourier Transform</em> (FFT) algorithm computes the Fourier transform in <span><span class="math inline">\(O(m\log m)\)</span></span> operations. We now sketch the idea behind the FFT algorithm as the same idea is used in the <em>quantum</em> Fourier transform algorithm.</p>
<p>Note that</p>
<p><span><span class="math inline">\(\hat{f}(x) = \tfrac{1}{\sqrt{m}}\sum_{y\in\Z_m} f(y)\omega^{xy} =\)</span></span></p>
<p><span><span class="math inline">\(\tfrac{1}{\sqrt{m}}\sum_{y\in\Z_m,y \;even} f(y)\omega^{-2x(y/2)} + \omega^x\tfrac{1}{\sqrt{m}}\sum_{y\in\Z_m,y \;odd} f(y)\omega^{2x(y-1)/2} \;.\)</span></span></p>
<p>Now since <span><span class="math inline">\(\omega^2\)</span></span> is an <span><span class="math inline">\(m/2\)</span></span>th root of unity and <span><span class="math inline">\(\omega^{m/2}=-1\)</span></span>, letting <span><span class="math inline">\(W\)</span></span> be the <span><span class="math inline">\(m/2 \times m/2\)</span></span> diagonal matrix with diagonal entries <span><span class="math inline">\(\omega^0,\ldots,\omega^{m/2-1}\)</span></span>, we get that</p>
<p><span><span class="math inline">\(\ensuremath{\mathit{FT}}_m(f)_{low} = \ensuremath{\mathit{FT}}_{m/2}(f_{even}) + W \ensuremath{\mathit{FT}}_{m/2}(f_{odd})\)</span></span></p>
<p><span><span class="math inline">\(\ensuremath{\mathit{FT}}_m(f)_{high} = \ensuremath{\mathit{FT}}_{m/2}(f_{even}) - W \ensuremath{\mathit{FT}}_{m/2}(f_{odd})\)</span></span></p>
<p>where for an <span><span class="math inline">\(m\)</span></span>-dimensional vector <span><span class="math inline">\(\vec{v}\)</span></span>, we denote by <span><span class="math inline">\(\vec{v}_{even}\)</span></span> (resp. <span><span class="math inline">\(\vec{v}_{odd}\)</span></span>) the <span><span class="math inline">\(m/2\)</span></span>-dimensional vector obtained by restricting <span><span class="math inline">\(\vec{v}\)</span></span> to the coordinates whose indices have least significant bit equal to <span><span class="math inline">\(0\)</span></span> (resp. <span><span class="math inline">\(1\)</span></span>) and by <span><span class="math inline">\(\vec{v}_{low}\)</span></span> (resp. <span><span class="math inline">\(\vec{v}_{high}\)</span></span>) the restriction of <span><span class="math inline">\(\vec{v}\)</span></span> to coordinates with most significant bit <span><span class="math inline">\(0\)</span></span> (resp. <span><span class="math inline">\(1\)</span></span>).</p>
<p>The equations above are the crux of the divide-and-conquer idea of the FFT algorithm, since they allow to replace a size-<span><span class="math inline">\(m\)</span></span> problem with two size-<span><span class="math inline">\(m/2\)</span></span> subproblems, leading to a recursive time bound of the form <span><span class="math inline">\(T(m) = 2T(m/2) + O(m)\)</span></span> which solves to <span><span class="math inline">\(T(m)=O(m\log m)\)</span></span>.</p>
<h3 id="quantum-fourier-transform-over-z_m" data-number="21.3.2">Quantum Fourier Transform over <span><span class="math inline">\(\Z_m\)</span></span></h3>
<p>The <em>quantum Fourier transform</em> is an algorithm to change the state of a quantum register from <span><span class="math inline">\(f \in \mathbb{C}^m\)</span></span> to its Fourier transform <span><span class="math inline">\(\hat{f}\)</span></span>.</p>
<div id="quantumftthm" class="theorem" title="Quantum Fourier Transform (Bernstein-Vazirani)" data-number="21.3.2" name="Theorem 21.5 (Quantum Fourier Transform (Bernstein-Vazirani)) ">
<p>For every <span><span class="math inline">\(m\)</span></span> and <span><span class="math inline">\(m =2^m\)</span></span> there is a quantum algorithm that uses <span><span class="math inline">\(O(m^2)\)</span></span> elementary quantum operations and transforms a quantum register in state <span><span class="math inline">\(f = \sum_{x\in\Z_m} f(x)|x\rangle\)</span></span> into the state <span><span class="math inline">\(\hat{f}= \sum_{x\in\Z_m} \hat{f}(x) |x\rangle\)</span></span>, where <span><span class="math inline">\(\hat{f}(x) = \tfrac{1}{\sqrt{m}} \sum_{y\in \Z_m} \omega^{xy}f(x)\)</span></span>.</p>
</div>
<p>The crux of the algorithm is the FFT equations, which allow the problem of computing <span><span class="math inline">\(\ensuremath{\mathit{FT}}_m\)</span></span>, the problem of size <span><span class="math inline">\(m\)</span></span>, to be split into two identical subproblems of size <span><span class="math inline">\(m/2\)</span></span> involving computation of <span><span class="math inline">\(\ensuremath{\mathit{FT}}_{m/2}\)</span></span>, which can be carried out recursively using the same elementary operations. (Aside: Not every divide-and-conquer classical algorithm can be implemented as a fast quantum algorithm; we are really using the structure of the problem here.)</p>
<p>We now describe the algorithm and the state, neglecting normalizing factors.</p>
<ol type="1">
<li><p><em>initial state:</em> <span><span class="math inline">\(f= \sum_{x\in\Z_m} f(x)|x\rangle\)</span></span></p></li>
<li><p>Recursively run <span><span class="math inline">\(\ensuremath{\mathit{FT}}_{m/2}\)</span></span> on <span><span class="math inline">\(m-1\)</span></span> most significant qubits (state: <span><span class="math inline">\((\ensuremath{\mathit{FT}}_{m/2}f_{even})|0\rangle + (\ensuremath{\mathit{FT}}_{m/2}f_{odd})|1\rangle\)</span></span>)</p></li>
<li><p>If LSB is <span><span class="math inline">\(1\)</span></span> then compute <span><span class="math inline">\(W\)</span></span> on <span><span class="math inline">\(m-1\)</span></span> most significant qubits (see below). (state : <span><span class="math inline">\((\ensuremath{\mathit{FT}}_{m/2}f_{even})|0\rangle + (W \ensuremath{\mathit{FT}}_{m/2}f_{odd})|1\rangle\)</span></span>)</p></li>
<li><p>Apply Hadmard gate <span><span class="math inline">\(H\)</span></span> to least significant qubit. (state: <span><span class="math inline">\((\ensuremath{\mathit{FT}}_{m/2}f_{even})(|0\rangle+|1\rangle)\)</span></span> <span><span class="math inline">\(+\)</span></span> <span><span class="math inline">\((W \ensuremath{\mathit{FT}}_{m/2}f_{odd})(|0\rangle-|1\rangle) =\)</span></span> <span><span class="math inline">\((\ensuremath{\mathit{FT}}_{m/2}f_{even}+ W \ensuremath{\mathit{FT}}_{m/2}f_{odd})|0\rangle + (\ensuremath{\mathit{FT}}_{m/2}f_{even}-W \ensuremath{\mathit{FT}}_{m/2}f_{odd})|1\rangle\)</span></span>)</p></li>
<li><p>Move LSB to the most significant position (state: <span><span class="math inline">\(|0\rangle(\ensuremath{\mathit{FT}}_{m/2}f_{even}+ W \ensuremath{\mathit{FT}}_{m/2}f_{odd}) + |1\rangle(\ensuremath{\mathit{FT}}_{m/2}f_{even}- W \ensuremath{\mathit{FT}}_{m/2}f_{odd}) = \hat{f}\)</span></span>)</p></li>
</ol>
<p>The transformation <span><span class="math inline">\(W\)</span></span> on <span><span class="math inline">\(m-1\)</span></span> qubits can be defined by <span><span class="math inline">\(|x\rangle \mapsto \omega^x = \omega^{\sum_{i=0}^{m-2} 2^ix_i}\)</span></span> (where <span><span class="math inline">\(x_i\)</span></span> is the <span><span class="math inline">\(i^{th}\)</span></span> qubit of <span><span class="math inline">\(x\)</span></span>). It can be easily seen to be the result of applying for every <span><span class="math inline">\(i\in \{ 0,\ldots,m-2\}\)</span></span> the following elementary operation on the <span><span class="math inline">\(i^{th}\)</span></span> qubit of the register:</p>
<p><span><span class="math inline">\(|0\rangle \mapsto |0\rangle\)</span></span> and <span><span class="math inline">\(|1\rangle \mapsto \omega^{2^i}|1\rangle\)</span></span>.</p>
<p>The final state is equal to <span><span class="math inline">\(\hat{f}\)</span></span> by the FFT equations (we leave this as an exercise)</p>
<h2 id="shors-order-finding-algorithm." data-number="21.4">Shor’s Order-Finding Algorithm.</h2>
<p>We now present the central step in Shor’s factoring algorithm: a quantum polynomial-time algorithm to find the <em>order</em> of an integer <span><span class="math inline">\(a\)</span></span> modulo an integer <span><span class="math inline">\(\ell\)</span></span>.</p>
<div id="orderdinfindrestatethm" class="theorem" title="Order finding algorithm, restated" data-number="21.4" name="Theorem 21.6 (Order finding algorithm, restated) ">
<p>There is a polynomial-time quantum algorithm that on input <span><span class="math inline">\(A,N\)</span></span> (represented in binary) finds the smallest <span><span class="math inline">\(r\)</span></span> such that <span><span class="math inline">\(A^r=1 \pmod{N}\)</span></span>.</p>
</div>
<p>Let <span><span class="math inline">\(t=\ceil{5\log (A+N)}\)</span></span>. Our register will consist of <span><span class="math inline">\(t+polylog(N)\)</span></span> qubits. Note that the function <span><span class="math inline">\(x \mapsto A^x \pmod{N}\)</span></span> can be computed in <span><span class="math inline">\(polylog(N)\)</span></span> time and so we will assume that we can compute the map <span><span class="math inline">\(|x\rangle|y\rangle \mapsto |x\rangle|y\oplus (A^x \pmod{N\rangle)}\)</span></span> (where we identify a number <span><span class="math inline">\(X \in \{ 0,\ldots,N-1\}\)</span></span> with its representation as a binary string of length <span><span class="math inline">\(\log N\)</span></span>).<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Now we describe the order-finding algorithm. It uses a tool of elementary number theory called <em>continued fractions</em> which allows us to approximate (using a classical algorithm) an arbitrary real number <span><span class="math inline">\(\alpha\)</span></span> with a rational number <span><span class="math inline">\(p/q\)</span></span> where there is a prescribed upper bound on <span><span class="math inline">\(q\)</span></span> (see below)</p>
<p>We now describe the algorithm and the state, this time <em>including</em> normalizing factors.</p>
<ol type="1">
<li><p>Apply Fourier transform to the first <span><span class="math inline">\(m\)</span></span> bits. (state: <span><span class="math inline">\(\tfrac{1}{\sqrt{m}}\sum_{x\in\Z_m}|x\rangle)|0^n\rangle\)</span></span>)</p></li>
<li><p>Compute the transformation <span><span class="math inline">\(|x\rangle|y\rangle \mapsto |x\rangle|y \oplus (A^x \pmod{N\rangle)}\)</span></span>. (state: <span><span class="math inline">\(\tfrac{1}{\sqrt{m}}\sum_{x\in\Z_m} |x\rangle|A^x \pmod{N\rangle}\)</span></span>)</p></li>
<li><p>Measure the second register to get a value <span><span class="math inline">\(y_0\)</span></span>. (state: <span><span class="math inline">\(\tfrac{1}{\sqrt{K}}\sum_{\ell=0}^{K-1}|x_0 + \ell r\rangle|y_0\rangle\)</span></span> where <span><span class="math inline">\(x_0\)</span></span> is the smallest number such that <span><span class="math inline">\(A^{x_0} = y_0 \pmod{N}\)</span></span> and <span><span class="math inline">\(K= \floor{(m-1-x_0)/r}\)</span></span>.)</p></li>
<li><p>Apply the Fourier transform to the first register. (state: <span><span class="math inline">\(\tfrac{1}{\sqrt{m}\sqrt{K}} \left(\sum_{x\in\Z_n}\sum_{\ell=0}^{K-1} \omega^{(x_0+\ell r)x}|x\rangle \right) |y_0\rangle\)</span></span>)</p></li>
</ol>
<p>In the analysis, it will suffice to show that this algorithm outputs the order <span><span class="math inline">\(r\)</span></span> with probability at least <span><span class="math inline">\(\Omega(1/\log N)\)</span></span> (we can always amplify the algorithm’s success by running it several times and taking the smallest output).</p>
<h3 id="analysis-the-case-that-rm" data-number="21.4.1">Analysis: the case that <span><span class="math inline">\(r|m\)</span></span></h3>
<p>We start by analyzing the algorithm in the case that <span><span class="math inline">\(m = rc\)</span></span> for some integer <span><span class="math inline">\(c\)</span></span>. Though very unrealistic (remember that <span><span class="math inline">\(m\)</span></span> is a power of <span><span class="math inline">\(2\)</span></span>!) this gives the intuition why Fourier transforms are useful for detecting periods.</p>
<p><strong>Claim:</strong> In this case the value <span><span class="math inline">\(x\)</span></span> measured will be equal to <span><span class="math inline">\(ac\)</span></span> for a random <span><span class="math inline">\(a \in \{0,\ldots,r-1\}\)</span></span>.</p>
<p>The claim concludes the proof since it implies that <span><span class="math inline">\(x/m = a/r\)</span></span> where <span><span class="math inline">\(a\)</span></span> is random integer less than <span><span class="math inline">\(r\)</span></span>. Now for every <span><span class="math inline">\(r\)</span></span>, at least <span><span class="math inline">\(\Omega(r/\log r)\)</span></span> of the numbers in <span><span class="math inline">\([r-1]\)</span></span> are co-prime to <span><span class="math inline">\(r\)</span></span>. Indeed, the prime number theorem says that there at least this many primes in this interval, and since <span><span class="math inline">\(r\)</span></span> has at most <span><span class="math inline">\(\log r\)</span></span> prime factors, all but <span><span class="math inline">\(\log r\)</span></span> of these primes are co-prime to <span><span class="math inline">\(r\)</span></span>. Thus, when the algorithm computes a rational approximation for <span><span class="math inline">\(x/m\)</span></span>, the denominator it will find will indeed be <span><span class="math inline">\(r\)</span></span>.</p>
<p>To prove the claim, we compute for every <span><span class="math inline">\(x \in \Z_m\)</span></span> the absolute value of <span><span class="math inline">\(|x\rangle\)</span></span>’s coefficient before the measurement. Up to some normalization factor this is</p>
<p><span><span class="math inline">\(\left| \sum_{\ell=0}^{c-1} \omega^{(x_0+\ell r)x} \right| = \left| \omega^{x_0c&#39;c} \right| \left| \sum_{\ell=0}^{c-1} \omega^{r\ell x} \right| = 1 \cdot \left| \sum_{\ell=0}^{c-1} \omega^{r\ell x} \right| \;.\)</span></span></p>
<p>If <span><span class="math inline">\(c\)</span></span> does not divide <span><span class="math inline">\(x\)</span></span> then <span><span class="math inline">\(\omega^r\)</span></span> is a <span><span class="math inline">\(c^{th}\)</span></span> root of unity, so <span><span class="math inline">\(\sum_{\ell=0}^{c-1} w^{r \ell x} =0\)</span></span> by the formula for sums of geometric progressions. Thus, such a number <span><span class="math inline">\(x\)</span></span> would be measured with zero probability. But if <span><span class="math inline">\(x = cj\)</span></span> then <span><span class="math inline">\(\omega^{r\ell x} = w^{r c j \ell} = \omega^{Mj} = 1\)</span></span>, and hence the amplitudes of all such <span><span class="math inline">\(x\)</span></span>’s are equal for all <span><span class="math inline">\(j \in \{0, 2, \ldots, r-1\}\)</span></span>.</p>
<h4 id="the-general-case" data-number="21.4.1.1">The general case</h4>
<p>In the general case, where <span><span class="math inline">\(r\)</span></span> does not necessarily divide <span><span class="math inline">\(m\)</span></span>, we will not be able to show that the measured value <span><span class="math inline">\(x\)</span></span> satisfies <span><span class="math inline">\(m | xr\)</span></span>. However, we will show that with <span><span class="math inline">\(\Omega(1/\log r)\)</span></span> probability, <strong>(1)</strong> <span><span class="math inline">\(xr\)</span></span> will be “almost divisible” by <span><span class="math inline">\(m\)</span></span> in the sense that <span><span class="math inline">\(0 \leq xr \pmod{m} &lt; r/10\)</span></span> and <strong>(2)</strong> <span><span class="math inline">\(\floor{xr/m}\)</span></span> is coprime to <span><span class="math inline">\(r\)</span></span>.</p>
<p>Condition <strong>(1)</strong> implies that <span><span class="math inline">\(|xr - cM| &lt; r/10\)</span></span> for <span><span class="math inline">\(c=\floor{xr/m}\)</span></span>. Dividing by <span><span class="math inline">\(rM\)</span></span> gives <span><span class="math inline">\(\left| \frac{x}{m} - \tfrac{c}{r} \right| &lt; \tfrac{1}{10M}\)</span></span>. Therefore, <span><span class="math inline">\(\tfrac{c}{r}\)</span></span> is a rational number with denominator at most <span><span class="math inline">\(N\)</span></span> that approximates <span><span class="math inline">\(\frac{x}{m}\)</span></span> to within <span><span class="math inline">\(1/(10M) &lt; 1/(4N^4)\)</span></span>. It is not hard to see that such an approximation is unique (again left as an exercise) and hence in this case the algorithm will come up with <span><span class="math inline">\(c/r\)</span></span> and output the denominator <span><span class="math inline">\(r\)</span></span>.</p>
<p>Thus all that is left is to prove the next two lemmas. The first shows that there are <span><span class="math inline">\(\Omega(r/\log r)\)</span></span> values of <span><span class="math inline">\(x\)</span></span> that satisfy the above two conditions and the second shows that each is measured with probability <span><span class="math inline">\(\Omega((1/\sqrt{r})^2) =\Omega(1/r)\)</span></span>.</p>
<p><strong>Lemma 1:</strong> There exist <span><span class="math inline">\(\Omega(r/\log r)\)</span></span> values <span><span class="math inline">\(x \in \Z_m\)</span></span> such that:</p>
<ol type="1">
<li><p><span><span class="math inline">\(0 &lt; xr \pmod{m} &lt; r/10\)</span></span></p></li>
<li><p><span><span class="math inline">\(\floor{xr/m}\)</span></span> and <span><span class="math inline">\(r\)</span></span> are coprime</p></li>
</ol>
<p><strong>Lemma 2:</strong> If <span><span class="math inline">\(x\)</span></span> satisfies <span><span class="math inline">\(0 &lt; xr \pmod{m} &lt; r/10\)</span></span> then, before the measurement in the final step of the order-finding algorithm, the coefficient of <span><span class="math inline">\(|x\rangle\)</span></span> is at least <span><span class="math inline">\(\Omega(\tfrac{1}{\sqrt{r}})\)</span></span>.</p>
<p><strong>Proof of Lemma 1</strong> We prove the lemma for the case that <span><span class="math inline">\(r\)</span></span> is coprime to <span><span class="math inline">\(m\)</span></span>, leaving the general case to the reader. In this case, the map <span><span class="math inline">\(x \mapsto rx \pmod{m}\)</span></span> is a permutation of <span><span class="math inline">\(\Z^*_m\)</span></span>. There are at least <span><span class="math inline">\(\Omega(r/\log r)\)</span></span> numbers in <span><span class="math inline">\([1..r/10]\)</span></span> that are coprime to <span><span class="math inline">\(r\)</span></span> (take primes in this range that are not one of <span><span class="math inline">\(r\)</span></span>’s at most <span><span class="math inline">\(\log r\)</span></span> prime factors) and hence <span><span class="math inline">\(\Omega(r/\log r)\)</span></span> numbers <span><span class="math inline">\(x\)</span></span> such that <span><span class="math inline">\(rx \pmod{m} = xr - \floor{xr/m}m\)</span></span> is in <span><span class="math inline">\([1..r/10]\)</span></span> and coprime to <span><span class="math inline">\(r\)</span></span>. But this means that <span><span class="math inline">\(\floor{rx/m}\)</span></span> can not have a nontrivial shared factor with <span><span class="math inline">\(r\)</span></span>, as otherwise this factor would be shared with <span><span class="math inline">\(rx \pmod{m}\)</span></span> as well.</p>
<p><strong>Proof of Lemma 2:</strong> Let <span><span class="math inline">\(x\)</span></span> be such that <span><span class="math inline">\(0 &lt; xr \pmod{m} &lt; r/10\)</span></span>. The absolute value of <span><span class="math inline">\(|x\rangle\)</span></span>’s coefficient in the state before the measurement is <span>
<div class='myequationbox'><span class="math display">\[\tfrac{1}{\sqrt{K}\sqrt{m}}\left| \sum_{\ell=0}^{K-1} \omega^{\ell r x} \right| \;,\]</span></div></span> where <span><span class="math inline">\(K = \floor{(m-x_0-1)/r}\)</span></span>. Note that <span><span class="math inline">\(\tfrac{m}{2r} &lt; K &lt; \tfrac{m}{r}\)</span></span> since <span><span class="math inline">\(x_0 &lt; N \ll m\)</span></span>.</p>
<p>Setting <span><span class="math inline">\(\beta=\omega^{rx}\)</span></span> (note that since <span><span class="math inline">\(m \not| rx\)</span></span>, <span><span class="math inline">\(\beta \neq 1\)</span></span>) and using the formula for the sum of a geometric series, this is at least <span><span class="math inline">\(\tfrac{\sqrt{r}}{2M}\left| \tfrac{1 - \beta^{\ceil{m/r}}}{1-\beta} \right| = \tfrac{\sqrt{r}}{2M}\tfrac{\sin(\theta\ceil{m/r}/2)}{\sin(\theta/2)} \;,\)</span></span> where <span><span class="math inline">\(\theta=\tfrac{rx \pmod{m}}{m}\)</span></span> is the angle such that <span><span class="math inline">\(\beta = e^{i\theta}\)</span></span> (see Figure [quantum:fig:theta] for a proof by picture of the last equality). Under our assumptions <span><span class="math inline">\(\ceil{m/r}\theta&lt;1/10\)</span></span> and hence (using the fact that <span><span class="math inline">\(\sin \alpha \sim \alpha\)</span></span> for small angles <span><span class="math inline">\(\alpha\)</span></span>), the coefficient of <span><span class="math inline">\(x\)</span></span> is at least <span><span class="math inline">\(\tfrac{\sqrt{r}}{4M}\ceil{m/r} \geq \tfrac{1}{8\sqrt{r}}\)</span></span></p>
<p>This completes the proof of <a href='#orderdinfindrestatethm'>Theorem 21.6</a>.</p>
<!--
## Reducing factoring to order finding. {#quantum:sec:orderfind}

The reduction of the factoring problem to the order-finding problem is
classical (in particular, predates quantum computing) and follows from
the following two Lemmas:

\[quantum:lem:factoring2\] For every nonprime $N$ that is not a prime
power, the probability that a random $X$ in the set
$\Z^*_N = \set{ X \in [N-1] : gcd(X,N)=1}$ has an even order $r$ and
furthermore, $X^{r/2} \neq -1 \pmod{N}$ is at least $\nicefrac{1}{4}$.

\[quantum:lem:factoring1\] For every $N$ and $Y$, if $Y^2 = 1 \pmod{N}$
but $Y
\pmod{N}\not\in\{ +1,-1\}$ then $gcd(Y-1,N)\not\in{1,N}$.

Together, lemmas \[quantum:lem:factoring2\]
and \[quantum:lem:factoring1\] show that given a composite $N$ that is
not a prime power if we choose $A$ at random in $[N-1]$ then with good
probability either $gcd(A,N)$ or $gcd(A^{r/2}-1,N)$ will yield a
non-trivial factor $F$ of $N$. We can then use recursion to find the
prime factors of $F$ and $N/F$ respectively, leading to a $polylog(N)$
time factorization algorithm. (Note that if $N$ is a prime power then it
is easy to find its factorization by simply going over all
$\ell \in [\log N]$ and trying the $\ell^{th}$ root of $N$.) Thus to
prove Theorem \[quantum:thm:shor\] all that is left is to prove
lemmas \[quantum:lem:factoring2\] and \[quantum:lem:factoring1\]. The
proofs rely on some basic facts from number theory; see
Section \[appendix:sec:numtheory\] in the Appendix for a quick review.

\[Proof of Lemma \[quantum:lem:factoring1\]\] Under our assumptions, $N$
divides $Y^2 - 1 = (Y-1)(Y+1)$ but does not divide neither $Y-1$ or
$Y+1$. But this means that $gcd(Y-1,N)>1$ since if $Y-1$ and $N$ were
coprime, then since $N$ divides $(Y-1)(Y+1)$, it would have to divide
$Y+1$ (Exercise \[quantum:ex:factoring1\]). Since $Y-1 < N$, obviously
$gcd(Y-1,N)<N$ and hence we’re done.

\[Proof of Lemma \[quantum:lem:factoring2\]\] We prove the lemma for the
case $N=PQ$ for primes $P,Q$: the proof can be suitably generalized for
every $N$. Now, by the Chinese Remainder Theorem every $X\in\Z^*_N$ is
isomorphic to the pair $\tupl{X \pmod{P},X \pmod{Q}}$. In particular,
choosing a random number $X\in\Z^*_N$ is equivalent to choosing two
random numbers $Y,Z$ in $\Z^*_P$ and $\Z^*_Q$ respectively and setting
$X$ to be the unique number corresponding to the pair $\tupl{Y,Z}$. Now
for every $k$, $X^k \pmod{N}$ is isomorphic to
$\tupl{Y^k \pmod{P},Z^k \pmod{Q}}$ and so the *order* of $X$ is the
least common multiple of the orders of $Y$ and $Z$ modulo $P$ and $Q$
respectively. We will complete the proof by showing that with
probability at least $\half$, the order of $Y$ is even: a number of the
form $2^kc$ for $k \geq 1$ and $c$ odd. We then show that with
probability at least $\half$, the order of $Z$ has the form $2^{\ell}d$
for $d$ odd and $\ell \neq k$. This implies that the order of $X$ is
$r=2^{\max\{ k,\ell\}}lcm(c,d)$ (where $lcm$ denotes the least common
multiple) which, means that $X^{r/2}$ will be equal to $1$ in at least
one coordinate. Since $-1 \pmod{N}$ is isomorphic to the tuple
$\tupl{ -1 , -1 }$ this means that $X^{r/2} \neq -1 \pmod{P}$.

Thus all that is left is to prove the following:

-   $Y$ has even order with probability at least $\half$.

    Indeed, the set of numbers in $\Z^*_P$ with odd order is a
    *subgroup* of $\Z^*_P$: if $Y,Y'$ have odd orders $r,r'$
    respectively then $(YY')^{rr'}=1\pmod{P}$, which means that the
    order of $YY'$ divides the odd number $rr'$. Yet $-1$ has even
    order, implying that this is a *proper* subgroup of $\Z^*_P$, taking
    at most $\half$ of $\Z^*_P$.

-   There is a number $\ell_0$ such that with probability exactly
    $\half$, the order of of a random $Z \in \Z^*_Q$ is a number of the
    form $2^{\ell}c$ for $\ell \leq
        \ell_0$. (This implies that for every fixed $k$, the probability
    that the order has the form $2^kd$ is at most $\half$.)

    For every $\ell$, define $G_{\ell}$ to be the subset of $\Z^*_Q$
    whose order modulo $Q$ is of the form $2^jc$ where $j \leq \ell$ and
    $c$ is odd. It can be verified that for every $\ell$, $G_{\ell}$ is
    a subgroup of $G_{\ell+1}$ and furthermore, because modulo a prime
    $P$ the mapping $x \mapsto x^2 \pmod{P}$ is two-to-one and maps
    $G_{\ell+1}$ into $G_{\ell}$ (Exercise \[quantum:ex:factoring2\]),
    $|G_{\ell}| \geq
        |G_{\ell+1}|/2$. It follows that if we take $\ell_0$ to be the
    largest such that $G_{\ell_0}$ is a proper subgroup of $\Z^*_P$,
    then $|G_{\ell_0}| = |Z^*_P|/2$.
-->
<h2 id="rational-approximation-of-real-numbers" data-number="21.5">Rational approximation of real numbers</h2>
<p>In many settings, including Shor’s algorithm, we are given a real number in the form of a program that can compute its first <span><span class="math inline">\(t\)</span></span> bits in <span><span class="math inline">\(poly(t)\)</span></span> time. We are interested in finding a close approximation to this real number of the form <span><span class="math inline">\(a/b\)</span></span>, where there is a prescribed upper bound on <span><span class="math inline">\(b\)</span></span>. Continued fractions is a tool in number theory that is useful for this.</p>
<p>A <em>continued fraction</em> is a number of the following form: <span><span class="math inline">\(a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \tfrac{1}{a_3 + \ldots}} }\)</span></span> for <span><span class="math inline">\(a_0\)</span></span> a non-negative integer and <span><span class="math inline">\(a_1,a_2,\ldots\)</span></span> positive integers.</p>
<p>Given a real number <span><span class="math inline">\(\alpha&gt;0\)</span></span>, we can find its representation as an <em>infinite</em> fraction as follows: split <span><span class="math inline">\(\alpha\)</span></span> into the integer part <span><span class="math inline">\(\floor{\alpha}\)</span></span> and fractional part <span><span class="math inline">\(\alpha - \floor{\alpha}\)</span></span>, find recursively the representation <span><span class="math inline">\(R\)</span></span> of <span><span class="math inline">\(1/(\alpha - \floor{\alpha})\)</span></span>, and then write <span>
<div class='myequationbox'><span class="math display">\[\alpha = \floor{\alpha} + \frac{1}{R} \;.\]</span></div></span> If we continue this process for <span><span class="math inline">\(n\)</span></span> steps, we get a rational number, denoted by <span><span class="math inline">\([a_0,a_1,\ldots,a_n]\)</span></span>, which can be represented as <span><span class="math inline">\(\tfrac{p_n}{q_n}\)</span></span> with <span><span class="math inline">\(p_n,q_n\)</span></span> coprime. The following facts can be proven using induction:</p>
<ul>
<li><p><span><span class="math inline">\(p_0=a_0, q_0 =1\)</span></span> and for every <span><span class="math inline">\(n&gt;1\)</span></span>, <span><span class="math inline">\(p_n = a_np_{n-1} + p_{n-2}\)</span></span>, <span><span class="math inline">\(q_n = a_nq_{n-1} + q_{n-2}\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(\tfrac{p_n}{q_n} - \tfrac{p_{n-1}}{q_{n-1}} = \tfrac{(-1)^{n-1}}{q_nq_{n-1}}\)</span></span></p></li>
</ul>
<p>Furthermore, it is known that <span><span class="math inline">\(\Bigl|\tfrac{p_n}{q_n} - \alpha\Bigl| &lt; \tfrac{1}{q_nq_{n+1}} (*)\)</span></span> which implies that <span><span class="math inline">\(\tfrac{p_n}{q_n}\)</span></span> is the <em>closest</em> rational number to <span><span class="math inline">\(\alpha\)</span></span> with denominator at most <span><span class="math inline">\(q_n\)</span></span>. It also means that if <span><span class="math inline">\(\alpha\)</span></span> is extremely close to a rational number, say, <span><span class="math inline">\(\left|\alpha - \tfrac{a}{b} \right| &lt; \tfrac{1}{4b^4}\)</span></span> for some coprime <span><span class="math inline">\(a,b\)</span></span> then we can find <span><span class="math inline">\(a,b\)</span></span> by iterating the continued fraction algorithm for <span><span class="math inline">\(polylog(b)\)</span></span> steps. Indeed, let <span><span class="math inline">\(q_n\)</span></span> be the first denominator such that <span><span class="math inline">\(q_{n+1} \geq b\)</span></span>. If <span><span class="math inline">\(q_{n+1} &gt; 2b^2\)</span></span> then <span><span class="math inline">\((*)\)</span></span> implies that <span><span class="math inline">\(\bigl|\tfrac{p_n}{q_n}-\alpha\bigr| &lt; \tfrac{1}{2b^2}\)</span></span>. But this means that <span><span class="math inline">\(\tfrac{p_n}{q_n} = \tfrac{a}{b}\)</span></span> since there is at most one rational number of denominator at most <span><span class="math inline">\(b\)</span></span> that is so close to <span><span class="math inline">\(\alpha\)</span></span>. On the other hand, if <span><span class="math inline">\(q_{n+1} \leq 2b^2\)</span></span> then since <span><span class="math inline">\(\tfrac{p_{n+1}}{q_{n+1}}\)</span></span> is closer to <span><span class="math inline">\(\alpha\)</span></span> than <span><span class="math inline">\(\tfrac{a}{b}\)</span></span>, <span><span class="math inline">\(\bigl|\tfrac{p_{n+1}}{q_{n+1}}-\alpha\bigr| &lt; \tfrac{1}{4b^4}\;,\)</span></span> again meaning that <span><span class="math inline">\(\tfrac{p_{n+1}}{q_{n+1}}=\tfrac{a}{b}\)</span></span>. It’s not hard to verify that <span><span class="math inline">\(q_n \geq 2^{n/2}\)</span></span>, implying that <span><span class="math inline">\(p_n\)</span></span> and <span><span class="math inline">\(q_n\)</span></span> can be computed in <span><span class="math inline">\(polylog(q_n)\)</span></span> time.</p>
<h3 id="quantum-cryptography" data-number="21.5.1">Quantum cryptography</h3>
<p>There is another way in which quantum mechanics interacts with cryptography. These “spooky actions at a distance” have been suggested by Weisner and Bennet-Brassard as a way in which parties can create a secret shared key over an insecure channel. On one hand, this concept does not require as much control as general-purpose quantum computing, and so it has in fact been <a href="https://en.wikipedia.org/wiki/Quantum_key_distribution#Quantum_Key_Distribution_Networks">demonstrated physically</a>. On the other hand, unlike transmitting standard digital information, this “insecure channel” cannot be an arbitrary media such as wifi etc.. but rather one needs fiber optics, lasers, etc.. Unlike quantum computers, where we only need one of those to break RSA, to actually use key exchange at scale we need to setup these type of networks, and so it is unclear if this approach will ever dominate the solution of Alice sending to Bob a Brink’s truck with the shared secret key. People have proposed some other ways to use the interesting properties of quantum mechanics for cryptographic purposes including <a href="https://en.wikipedia.org/wiki/Quantum_money">quantum money</a> and <a href="http://www.scottaaronson.com/papers/noclone-ccc.pdf">quantum software protection</a>.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>In the context of Fourier transform it is customary and convenient to denote the <span><span class="math inline">\(x^{th}\)</span></span> coordinate of a vector <span><span class="math inline">\(f\)</span></span> by <span><span class="math inline">\(f(x)\)</span></span> rather than <span><span class="math inline">\(f_x\)</span></span>.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>To compute this map we may need to extend the register by some additional <span><span class="math inline">\(polylog(N)\)</span></span> many qubits, but we can ignore them as they will always be equal to zero except in intermediate computations.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Quantum II: Shor+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 01/17/2020 17:28:29</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_20_quantum_part2.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
