<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: NP, NP completeness, and the Cook-Levin Theorem</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: NP, NP completeness, and the Cook-Levin Theorem" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.1</b> Exercises</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">NP, NP completeness, and the Cook-Levin Theorem</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_13_Cook_Levin.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="cooklevinchap" data-number="14">NP, NP completeness, and the Cook-Levin Theorem</h1>
<div id="section" class="objectives" name="Objectives">
<ul>
<li>Introduce the class <span><span class="math inline">\(\mathbf{NP}\)</span></span> capturing a great many important computational problems<br />
</li>
<li><span><span class="math inline">\(\mathbf{NP}\)</span></span>-completeness: evidence that a problem might be intractable.<br />
</li>
<li>The <span><span class="math inline">\(\mathbf{P}\)</span></span> vs <span><span class="math inline">\(\mathbf{NP}\)</span></span> problem.</li>
</ul>
</div>
<blockquote>
<p><em>“In this paper we give theorems that suggest, but do not imply, that these problems, as well as many others, will remain intractable perpetually”</em>, Richard Karp, 1972</p>
</blockquote>
<blockquote>
<p><em>“Sad to say, but it will be many more years, if ever before we really understand the Mystical Power of Twoness… 2-SAT is easy, 3-SAT is hard, 2-dimensional matching is easy, 3-dimensional matching is hard. Why? oh, Why?”</em> Eugene Lawler</p>
</blockquote>
<p>So far we have shown that 3SAT is no harder than Quadratic Equations, Independent Set, Maximum Cut, and Longest Path. But to show that these problems are <em>computationally equivalent</em> we need to give reductions in the other direction, reducing each one of these problems to 3SAT as well. It turns out we can reduce all three problems to 3SAT in one fell swoop.</p>
<p>In fact, this result extends far beyond these particular problems. All of the problems we discussed in <a href='lec_12_NP.html#reductionchap'>Chapter 13</a>, and a great many other problems, share the same commonality: they are all <em>search</em> problems, where the goal is to decide, given an instance <span><span class="math inline">\(x\)</span></span>, whether there exists a <em>solution</em> <span><span class="math inline">\(y\)</span></span> that satisfies some condition that can be verified in polynomial time. For example, in 3SAT, the instance is a formula and the solution is an assignment to the variable; in Max-Cut the instance is a graph and the solution is a cut in the graph; and so on and so forth. It turns out that <em>every</em> such search problem can be reduced to 3SAT.</p>
<figure>
<img src="../figure/cooklevin_overview.png" alt="14.1: Overview of the results of this chapter. We define \mathbf{NP} to contain all decision problems for which a solution can be efficiently verified. The main result of this chapter is the Cook Levin Theorem () which states that 3\ensuremath{\mathit{SAT}} has a polynomial-time algorithm if and only if every problem in \mathbf{NP} has a polynomial-time algorithm. Another way to state this theorem is that 3\ensuremath{\mathit{SAT}} is \mathbf{NP} complete. We will prove the Cook-Levin theorem by defining the two intermediate problems \ensuremath{\mathit{NANDSAT}} and 3\ensuremath{\mathit{NAND}}, proving that \ensuremath{\mathit{NANDSAT}} is \mathbf{NP} complete, and then proving that \ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}}." id="cooklevin_overviewfig" /><figcaption>14.1: Overview of the results of this chapter. We define <span><span class="math inline">\(\mathbf{NP}\)</span></span> to contain all decision problems for which a solution can be efficiently <em>verified</em>. The main result of this chapter is the <em>Cook Levin Theorem</em> (<a href='#cook-levin-thm'>Theorem 14.6</a>) which states that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> has a polynomial-time algorithm if and only if <em>every</em> problem in <span><span class="math inline">\(\mathbf{NP}\)</span></span> has a polynomial-time algorithm. Another way to state this theorem is that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is <em><span><span class="math inline">\(\mathbf{NP}\)</span></span> complete</em>. We will prove the Cook-Levin theorem by defining the two intermediate problems <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> and <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span>, proving that <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> complete, and then proving that <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span>.</figcaption>
</figure>
<h2 id="the-class-mathbfnp" data-number="14.1">The class <span><span class="math inline">\(\mathbf{NP}\)</span></span></h2>
<p>To make the above precise, we will make the following mathematical definition. we define the class <span><span class="math inline">\(\mathbf{NP}\)</span></span> to contain all Boolean functions that correspond to a <em>search problem</em> of the form above. That is, a Boolean function <span><span class="math inline">\(F\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> if <span><span class="math inline">\(F\)</span></span> has the form that on input a string <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(F(x)=1\)</span></span> if and only if there exists a “solution” string <span><span class="math inline">\(w\)</span></span> such that the pair <span><span class="math inline">\((x,w)\)</span></span> satisfies some polynomial-time checkable condition. Formally, <span><span class="math inline">\(\mathbf{NP}\)</span></span> is defined as follows:</p>
<figure>
<img src="../figure/NPdefinitionfig.png" alt="14.2: The class \mathbf{NP} corresponds to problems where solutions can be efficiently verified. That is, this is the class of functions F such that F(x)=1 if there is a “solution” w of length polynomial in |x| that can be verified by a polynomial-time algorithm V." id="NPdeffigfig" class="margin" /><figcaption>14.2: The class <span><span class="math inline">\(\mathbf{NP}\)</span></span> corresponds to problems where solutions can be <em>efficiently verified</em>. That is, this is the class of functions <span><span class="math inline">\(F\)</span></span> such that <span><span class="math inline">\(F(x)=1\)</span></span> if there is a “solution” <span><span class="math inline">\(w\)</span></span> of length polynomial in <span><span class="math inline">\(|x|\)</span></span> that can be verified by a polynomial-time algorithm <span><span class="math inline">\(V\)</span></span>.</figcaption>
</figure>
<div id="NP-def" class="definition" title="NP" name="Definition 14.1 (NP) ">
<p>We say that <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> if there exists some integer <span><span class="math inline">\(a&gt;0\)</span></span> and <span><span class="math inline">\(V:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(V\in \mathbf{P}\)</span></span> and for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, <span>
<div class='myequationbox'><span class="math display">\[
F(x)=1 \Leftrightarrow \exists_{w \in \{0,1\}^{n^a}} \text{ s.t. } V(xw)=1 \;. \;\;(14.1)
\]</span><a id='NP-eq'></a></div></span></p>
</div>
<p>In other words, for <span><span class="math inline">\(F\)</span></span> to be in <span><span class="math inline">\(\mathbf{NP}\)</span></span>, there needs to exist some polynomial-time computable verification function <span><span class="math inline">\(V\)</span></span>, such that if <span><span class="math inline">\(F(x)=1\)</span></span> then there must exist <span><span class="math inline">\(w\)</span></span> (of length polynomial in <span><span class="math inline">\(|x|\)</span></span>) such that <span><span class="math inline">\(V(xw)=1\)</span></span>, and if <span><span class="math inline">\(F(x)=0\)</span></span> then for <em>every</em> such <span><span class="math inline">\(w\)</span></span>, <span><span class="math inline">\(V(xw)=0\)</span></span>. Since the existence of this string <span><span class="math inline">\(w\)</span></span> certifies that <span><span class="math inline">\(F(x)=1\)</span></span>, <span><span class="math inline">\(w\)</span></span> is often referred to as a <em>certificate</em>, <em>witness</em>, or <em>proof</em> that <span><span class="math inline">\(F(x)=1\)</span></span>.</p>
<p>See also <a href='#NPdeffigfig'>Figure 14.2</a> for an illustration of <a href='#NP-def'>Definition 14.1</a>. The name <span><span class="math inline">\(\mathbf{NP}\)</span></span> stands for “nondeterministic polynomial time” and is used for historical reasons; see the bibiographical notes. The string <span><span class="math inline">\(w\)</span></span> in <a href='#NP-eq'>Equation 14.1</a> is sometimes known as a <em>solution</em>, <em>certificate</em>, or <em>witness</em> for the instance <span><span class="math inline">\(x\)</span></span>.</p>
<div id="NPalternativeex" class="solvedexercise" title="Alternative definition of $\mathbf{NP}$" name="Solvedexercise 14.1 (Alternative definition of $\mathbf{NP}$) ">
<p>Show that the condition that <span><span class="math inline">\(|w|=|x|^a\)</span></span> in <a href='#NP-def'>Definition 14.1</a> can be replaced by the condition that <span><span class="math inline">\(|w| \leq p(|x|)\)</span></span> for some polynomial <span><span class="math inline">\(p\)</span></span>. That is, prove that for every <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>, <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span> if and only if there is a polynomial-time Turing machine <span><span class="math inline">\(V\)</span></span> and a polynomial <span><span class="math inline">\(p:\N \rightarrow \N\)</span></span> such that for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> <span><span class="math inline">\(F(x)=1\)</span></span> if and only if there exists <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span> with <span><span class="math inline">\(|w| \leq p(|x|)\)</span></span> such that <span><span class="math inline">\(V(x,w)=1\)</span></span>.</p>
</div>
<div class="solution" data-ref="NPalternativeex" name="Solution 14.1">
<p>The “only if” direction (namely that if <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> then there is an algorithm <span><span class="math inline">\(V\)</span></span> and a polynomial <span><span class="math inline">\(p\)</span></span> as above) follows immediately from <a href='#NP-def'>Definition 14.1</a> by letting <span><span class="math inline">\(p(n)=n^a\)</span></span>. For the “if” direction, the idea is that if a string <span><span class="math inline">\(w\)</span></span> is of size at most <span><span class="math inline">\(p(n)\)</span></span> for degree <span><span class="math inline">\(d\)</span></span> polynomial <span><span class="math inline">\(p\)</span></span>, then there is some <span><span class="math inline">\(n_0\)</span></span> such that for all <span><span class="math inline">\(n &gt; n_0\)</span></span>, <span><span class="math inline">\(|w| &lt; n^{d+1}\)</span></span>. Hence we can encode <span><span class="math inline">\(w\)</span></span> by a string of exactly length <span><span class="math inline">\(n^{d+1}\)</span></span> by padding it with <span><span class="math inline">\(1\)</span></span> and an appropriate number of zeroes. Hence if there is an algorithm <span><span class="math inline">\(V\)</span></span> and polynomial <span><span class="math inline">\(p\)</span></span> as above, then we can define an algorithm <span><span class="math inline">\(V&#39;\)</span></span> that does the following on input <span><span class="math inline">\(x,w&#39;\)</span></span> with <span><span class="math inline">\(|x|=n\)</span></span> and <span><span class="math inline">\(|w&#39;|=n^a\)</span></span>:</p>
<ul>
<li><p>If <span><span class="math inline">\(n \leq n_0\)</span></span> then <span><span class="math inline">\(V&#39;(x,w&#39;)\)</span></span> ignores <span><span class="math inline">\(w&#39;\)</span></span> and enumerates over all <span><span class="math inline">\(w\)</span></span> of length at most <span><span class="math inline">\(p(n)\)</span></span> and outputs <span><span class="math inline">\(1\)</span></span> if there exists <span><span class="math inline">\(w\)</span></span> such that <span><span class="math inline">\(V(x,w)=1\)</span></span>. (Since <span><span class="math inline">\(n &lt; n_0\)</span></span>, this only takes a constant number of steps.)</p></li>
<li><p>If <span><span class="math inline">\(n&gt; n_0\)</span></span> then <span><span class="math inline">\(V&#39;(x,w&#39;)\)</span></span> “strips out” the padding by dropping all the rightmost zeroes from <span><span class="math inline">\(w\)</span></span> until it reaches out the first <span><span class="math inline">\(1\)</span></span> (which it drops as well) and obtains a string <span><span class="math inline">\(w\)</span></span>. If <span><span class="math inline">\(|w| \leq p(n)\)</span></span> tnen <span><span class="math inline">\(V&#39;\)</span></span> outputs <span><span class="math inline">\(V(x,w)\)</span></span>.</p></li>
</ul>
<p>Since <span><span class="math inline">\(V\)</span></span> runs in polynomial time, <span><span class="math inline">\(V&#39;\)</span></span> runs in polynomial time as well, and by definition for every <span><span class="math inline">\(x\)</span></span>, there exists <span><span class="math inline">\(w&#39; \in \{0,1\}^{|x|^a}\)</span></span> such that <span><span class="math inline">\(V&#39;(xw&#39;)=1\)</span></span> if and only if there exists <span><span class="math inline">\(w \in \{0,1\}^*\)</span></span> with <span><span class="math inline">\(|w| \leq p(|x|)\)</span></span> such that <span><span class="math inline">\(V(xw)=1\)</span></span>.</p>
</div>
<p>The definition of <span><span class="math inline">\(\mathbf{NP}\)</span></span> means that for every <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> and string <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(F(x)=1\)</span></span> if and only if there is a <em>short and efficiently verifiable proof</em> of this fact. That is, we can think of the function <span><span class="math inline">\(V\)</span></span> in <a href='#NP-def'>Definition 14.1</a> as a <em>verifier</em> algorithm, similar to what we’ve seen in <a href='lec_09_godel.html#godelproofdef'>Section 10.1</a>. The verifier checks whether a given string <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span> is a valid proof for the statement “<span><span class="math inline">\(F(x)=1\)</span></span>”. Essentially all proof systems considered in mathematics involve line-by-line checks that can be carried out in polynomial time. Thus the heart of <span><span class="math inline">\(\mathbf{NP}\)</span></span> is asking for statements that have <em>short</em> (i.e., polynomial in the size of the statements) proof. Indeed, as we will see in <a href='lec_14_PvsNP.html#chappvsnp'>Chapter 15</a>, Kurt Gödel phrased the question of whether <span><span class="math inline">\(\mathbf{NP}=\mathbf{P}\)</span></span> as asking whether “the mental work of a mathematician [in proving theorems] could be completely replaced by a machine”.</p>
<div id="NPassymetric" class="remark" title="$\mathbf{NP}$ not (necessaily) closed under complement" name="Remark 14.2 ($\mathbf{NP}$ not (necessaily) closed under complement) ">
<p><a href='#NP-def'>Definition 14.1</a> is <em>asymmetric</em> in the sense that there is a difference between an output of <span><span class="math inline">\(1\)</span></span> and an output of <span><span class="math inline">\(0\)</span></span>. You should make sure you understand why this definition does <em>not</em> guarantee that if <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span> then the function <span><span class="math inline">\(1-F\)</span></span> (i.e., the map <span><span class="math inline">\(x \mapsto 1-F(x)\)</span></span>) is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> as well.</p>
<p>In fact, it is believed that there do exist functions <span><span class="math inline">\(F\)</span></span> such that <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> but <span><span class="math inline">\(1-F \not\in \mathbf{NP}\)</span></span>. For example, as shown below, <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \in \mathbf{NP}\)</span></span>, but the function <span><span class="math inline">\(\overline{3\ensuremath{\mathit{SAT}}}\)</span></span> that on input a 3CNF formula <span><span class="math inline">\(\varphi\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(\varphi\)</span></span> is <em>not</em> satisfiable is not known (nor believed) to be in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. This is in contrast to the class <span><span class="math inline">\(\mathbf{P}\)</span></span> which <em>does</em> satisfy that if <span><span class="math inline">\(F\in \mathbf{P}\)</span></span> then <span><span class="math inline">\(1-F\)</span></span> is in <span><span class="math inline">\(\mathbf{P}\)</span></span> as well.</p>
</div>
<h3 id="examples-of-functions-in-mathbfnp" data-number="14.1.1">Examples of functions in <span><span class="math inline">\(\mathbf{NP}\)</span></span></h3>
<p>We now present some examples of functions that are in the class <span><span class="math inline">\(\mathbf{NP}\)</span></span>. We start with the canonical example of the <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> function.</p>
<div id="threesatinnpex" class="example" title="$3SAT \in \mathbf{NP}$" name="Example 14.3 ($3SAT \in \mathbf{NP}$) ">
<p><span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> since for every <span><span class="math inline">\(\ell\)</span></span>-variable formula <span><span class="math inline">\(\varphi\)</span></span>, <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}(\varphi)=1\)</span></span> if and only if there exists a satisfying assignment <span><span class="math inline">\(x \in \{0,1\}^\ell\)</span></span> such that <span><span class="math inline">\(\varphi(x)=1\)</span></span>, and we can check this condition in polynomial time.</p>
<p>The above reasoning explains why <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span>, but since this is our first example, we will now belabor the point and expand out in full formality the precise representation of the witness <span><span class="math inline">\(w\)</span></span> and the algorithm <span><span class="math inline">\(V\)</span></span> that demonstrate that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. Since demonstrating that functions are in <span><span class="math inline">\(\mathbf{NP}\)</span></span> is fairly straightforward, in future cases we will not use as much detail, and the reader can also feel free to skip the rest of this example.</p>
<p>Using <a href='#NPalternativeex'>Solvedexercise 14.1</a>, it is OK if witness is of size at most polynomial in the input length <span><span class="math inline">\(n\)</span></span>, rather than of precisely size <span><span class="math inline">\(n^a\)</span></span> for some integer <span><span class="math inline">\(a&gt;0\)</span></span>. Specifically, we can represent a 3CNF formula <span><span class="math inline">\(\varphi\)</span></span> with <span><span class="math inline">\(k\)</span></span> variables and <span><span class="math inline">\(m\)</span></span> clauses as a string of length <span><span class="math inline">\(n=O(m\log k)\)</span></span>, since every one of the <span><span class="math inline">\(m\)</span></span> clauses involves three variables and their negation, and the identity of each variable can be represented using <span><span class="math inline">\(\lceil \log_2 k \rceil\)</span></span>. We assume that every variable participates in some clause (as otherwise it can be ignored) and hence that <span><span class="math inline">\(m \geq k\)</span></span>, which in particular means that the input length <span><span class="math inline">\(n\)</span></span> is at least as large as <span><span class="math inline">\(m\)</span></span> and <span><span class="math inline">\(k\)</span></span>.</p>
<p>We can represent an assignment to the <span><span class="math inline">\(k\)</span></span> variables using a <span><span class="math inline">\(k\)</span></span>-length string <span><span class="math inline">\(w\)</span></span>. The following algorithm checks whether a given <span><span class="math inline">\(w\)</span></span> satisfies the formula <span><span class="math inline">\(\varphi\)</span></span>:</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = threesatverifieralg>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 4 </span>Verifier for $3SAT$</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  3CNF formula \(\varphi\) on \(k\) variables and with \(m\) clauses, string \(w \in \{0,1\}^k\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>  \(1\) iff \(w\) satisfies \(\varphi\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">for</span>{\(j \in [m]\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    Let \(\ell_1 \vee \ell_2 \vee \ell_j\) be the \(j\)-th clause of \(\varphi\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">   <span class="ps-keyword">if</span>{\(w\) violates all three literals} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">     <span class="ps-keyword">return</span> \(0\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">   <span class="ps-keyword">endif</span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(1\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p><a href='#threesatverifieralg'>Algorithm 14.4</a> takes <span><span class="math inline">\(O(m)\)</span></span> time to enumerate over all clauses, and will return <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(y\)</span></span> satisfies all the clauses.</p>
</div>
<p>Here are some more examples for problems in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. For each one of these problems we merely sketch how the witness is represented and why it is efficiently checkable, but working out the details can be a good way to get more comfortable with <a href='#NP-def'>Definition 14.1</a>:</p>
<ul>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> since for every <span><span class="math inline">\(\ell\)</span></span>-variable instance of quadratic equations <span><span class="math inline">\(E\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}(E)=1\)</span></span> if and only if there exists an assignment <span><span class="math inline">\(x\in \{0,1\}^\ell\)</span></span> that satisfies <span><span class="math inline">\(E\)</span></span>. We can check the condition that <span><span class="math inline">\(x\)</span></span> satisfies <span><span class="math inline">\(E\)</span></span> in polynomial time by enumerating over all the equations in <span><span class="math inline">\(E\)</span></span>, and for each such equation <span><span class="math inline">\(e\)</span></span>, plug in the values of <span><span class="math inline">\(x\)</span></span> and verify that <span><span class="math inline">\(e\)</span></span> is satisfied.</p></li>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{ISET}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> since for every graph <span><span class="math inline">\(G\)</span></span> and integer <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{ISET}}(G,k)=1\)</span></span> if and only if there exists a set <span><span class="math inline">\(S\)</span></span> of <span><span class="math inline">\(k\)</span></span> vertices that contains no pair of neighbors in <span><span class="math inline">\(G\)</span></span>. We can check the condition that <span><span class="math inline">\(S\)</span></span> is an independent set of size <span><span class="math inline">\(\geq k\)</span></span> in polynomial time by first checking that <span><span class="math inline">\(|S| \geq k\)</span></span> and then enumerating over all edges <span><span class="math inline">\(\{u,v \}\)</span></span> in <span><span class="math inline">\(G\)</span></span>, and for each such edge verify that either <span><span class="math inline">\(u\not\in S\)</span></span> or <span><span class="math inline">\(v\not\in S\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> since for every graph <span><span class="math inline">\(G\)</span></span> and integer <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}(G,k)=1\)</span></span> if and only if there exists a simple path <span><span class="math inline">\(P\)</span></span> in <span><span class="math inline">\(G\)</span></span> that is of length at least <span><span class="math inline">\(k\)</span></span>. We can check the condition that <span><span class="math inline">\(P\)</span></span> is a simple path of length <span><span class="math inline">\(k\)</span></span> in polynomial time by checking that it has the form <span><span class="math inline">\((v_0,v_1,\ldots,v_k)\)</span></span> where each <span><span class="math inline">\(v_i\)</span></span> is a vertex in <span><span class="math inline">\(G\)</span></span>, no <span><span class="math inline">\(v_i\)</span></span> is repeated, and for every <span><span class="math inline">\(i \in [k]\)</span></span>, the edge <span><span class="math inline">\(\{v_i,v_{i+1}\}\)</span></span> is present in the graph.</p></li>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> since for every graph <span><span class="math inline">\(G\)</span></span> and integer <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}(G,k)=1\)</span></span> if and only if there exists a cut <span><span class="math inline">\((S,\overline{S})\)</span></span> in <span><span class="math inline">\(G\)</span></span> that cuts at least <span><span class="math inline">\(k\)</span></span> edges. We can check that condition that <span><span class="math inline">\((S,\overline{S})\)</span></span> is a cut of value at least <span><span class="math inline">\(k\)</span></span> in polynomial time by checking that <span><span class="math inline">\(S\)</span></span> is a subset of <span><span class="math inline">\(G\)</span></span>’s vertices and enumerating over all the edges <span><span class="math inline">\(\{u,v\}\)</span></span> of <span><span class="math inline">\(G\)</span></span>, counting those edges such that <span><span class="math inline">\(u\in S\)</span></span> and <span><span class="math inline">\(v\not\in S\)</span></span> or vice versa.</p></li>
</ul>
<h3 id="basic-facts-about-mathbfnp" data-number="14.1.2">Basic facts about <span><span class="math inline">\(\mathbf{NP}\)</span></span></h3>
<p>The definition of <span><span class="math inline">\(\mathbf{NP}\)</span></span> is one of the most important definitions of this book, and is worth while taking the time to digest and internalize. The following solved exercises establish some basic properties of this class. As usual, I highly recommend that you try to work out the solutions yourself.</p>
<div id="PinNP" class="solvedexercise" title="Verifying is no harder than solving" name="Solvedexercise 14.2 (Verifying is no harder than solving) ">
<p>Prove that <span><span class="math inline">\(\mathbf{P} \subseteq \mathbf{NP}\)</span></span>.</p>
</div>
<div class="solution" data-ref="PinNP" name="Solution 14.1.2">
<p>Suppose that <span><span class="math inline">\(F \in \mathbf{P}\)</span></span>. Define the following function <span><span class="math inline">\(V\)</span></span>: <span><span class="math inline">\(V(x0^n)=1\)</span></span> iff <span><span class="math inline">\(n=|x|\)</span></span> and <span><span class="math inline">\(F(x)=1\)</span></span>. (<span><span class="math inline">\(V\)</span></span> outputs <span><span class="math inline">\(0\)</span></span> on all other inputs.) Since <span><span class="math inline">\(F\in \mathbf{P}\)</span></span> we can clearly compute <span><span class="math inline">\(V\)</span></span> in polynomial time as well.</p>
<p>Let <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> be some string. If <span><span class="math inline">\(F(x)=1\)</span></span> then <span><span class="math inline">\(V(x0^n)=1\)</span></span>. On the other hand, if <span><span class="math inline">\(F(x)=0\)</span></span> then for every <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(V(xw)=0\)</span></span>. Therefore, setting <span><span class="math inline">\(a=b=1\)</span></span>, we see that <span><span class="math inline">\(V\)</span></span> satisfies <a href='#NP-eq'>Equation 14.1</a>, and establishes that <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span>.</p>
</div>
<div id="NPandNOTPolynomial" class="remark" title="$\mathbf{NP}$ does not mean non-polynomial!" name="Remark 14.5 ($\mathbf{NP}$ does not mean non-polynomial!) ">
<p>People sometimes think that <span><span class="math inline">\(\mathbf{NP}\)</span></span> stands for “non polynomial time”. As <a href='#PinNP'>Solvedexercise 14.2</a> shows, this is far from the truth, and in fact every polynomial-time computable function is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> as well.</p>
<p>If <span><span class="math inline">\(F\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> it certainly does <em>not</em> mean that <span><span class="math inline">\(F\)</span></span> is hard to compute (though it does not, as far as we know, necessarily mean that it’s easy to compute either). Rather, it means that <span><span class="math inline">\(F\)</span></span> is <em>easy to verify</em>, in the technical sense of <a href='#NP-def'>Definition 14.1</a>.</p>
</div>
<div id="NPinEXP" class="solvedexercise" title="$\mathbf{NP}$ is in exponential time" name="Solvedexercise 14.3 ($\mathbf{NP}$ is in exponential time) ">
<p>Prove that <span><span class="math inline">\(\mathbf{NP} \subseteq \mathbf{EXP}\)</span></span>.</p>
</div>
<div class="solution" data-ref="NPinEXP" name="Solution 14.1.2">
<p>Suppose that <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> and let <span><span class="math inline">\(V\)</span></span> be the polynomial-time computable function that satisfies <a href='#NP-eq'>Equation 14.1</a> and <span><span class="math inline">\(a\)</span></span> the corresponding constant. Then given every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, we can check whether <span><span class="math inline">\(F(x)=1\)</span></span> in time <span><span class="math inline">\(poly(n)\cdot 2^{n^a} = o(2^{n^{a+1}})\)</span></span> by enumerating over all the <span><span class="math inline">\(2^{n^a}\)</span></span> strings <span><span class="math inline">\(w\in \{0,1\}^{n^a}\)</span></span> and checking whether <span><span class="math inline">\(V(xw)=1\)</span></span>, in which case we return <span><span class="math inline">\(1\)</span></span>. If <span><span class="math inline">\(V(xw)=0\)</span></span> for every such <span><span class="math inline">\(w\)</span></span> then we return <span><span class="math inline">\(0\)</span></span>. By construction, the algorithm above will run in time at most exponential in its input length and by the definition of <span><span class="math inline">\(\mathbf{NP}\)</span></span> it will return <span><span class="math inline">\(F(x)\)</span></span> for every <span><span class="math inline">\(x\)</span></span>.</p>
</div>
<p><a href='#PinNP'>Solvedexercise 14.2</a> and <a href='#NPinEXP'>Solvedexercise 14.3</a> together imply that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\mathbf{P} \subseteq \mathbf{NP} \subseteq \mathbf{EXP}\;.\]</span></div></span></p>
<p>The time hierarchy theorem (<a href='lec_11_running_time.html#time-hierarchy-thm'>Theorem 12.9</a>) implies that <span><span class="math inline">\(\mathbf{P} \subsetneq \mathbf{EXP}\)</span></span> and hence at least one of the two inclusions <span><span class="math inline">\(\mathbf{P} \subseteq \mathbf{NP}\)</span></span> or <span><span class="math inline">\(\mathbf{NP} \subseteq \mathbf{EXP}\)</span></span> is <em>strict</em>. It is believed that both of them are in fact strict inclusions. That is, it is believed that there are functions in <span><span class="math inline">\(\mathbf{NP}\)</span></span> that cannot be computed in polynomial time (this is the <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span> conjecture) and that there are functions <span><span class="math inline">\(F\)</span></span> in <span><span class="math inline">\(\mathbf{EXP}\)</span></span> for which we cannot even efficiently <em>certify</em> that <span><span class="math inline">\(F(x)=1\)</span></span> for a given input <span><span class="math inline">\(x\)</span></span>. One function <span><span class="math inline">\(F\)</span></span> that is believed to lie in <span><span class="math inline">\(\mathbf{EXP} \setminus \mathbf{NP}\)</span></span> is the function <span><span class="math inline">\(\overline{3\ensuremath{\mathit{SAT}}}\)</span></span> defined as <span><span class="math inline">\(\overline{3\ensuremath{\mathit{SAT}}}(\varphi)= 1 - 3\ensuremath{\mathit{SAT}}(\varphi)\)</span></span> for every 3CNF formula <span><span class="math inline">\(\varphi\)</span></span>. The conjecture that <span><span class="math inline">\(\overline{3\ensuremath{\mathit{SAT}}}\not\in \mathbf{NP}\)</span></span> is known as the “<span><span class="math inline">\(\mathbf{NP} \neq \mathbf{co-NP}\)</span></span>” conjecture. It implies the <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span> conjecture (see <a href='#npconppnpex'>Exercise 14.2</a>).</p>
<p>We have previously informally equated the notion of <span><span class="math inline">\(F \leq_p G\)</span></span> with <span><span class="math inline">\(F\)</span></span> being “no harder than <span><span class="math inline">\(G\)</span></span>” and in particular have seen in <a href='lec_12_NP.html#reductionsandP'>Solvedexercise 13.1</a> that if <span><span class="math inline">\(G \in \mathbf{P}\)</span></span> and <span><span class="math inline">\(F \leq_p G\)</span></span>, then <span><span class="math inline">\(F \in \mathbf{P}\)</span></span> as well. The following exercise shows that if <span><span class="math inline">\(F \leq_p G\)</span></span> then it is also “no harder to verify” than <span><span class="math inline">\(G\)</span></span>. That is, regardless of whether or not it is in <span><span class="math inline">\(\mathbf{P}\)</span></span>, if <span><span class="math inline">\(G\)</span></span> has the property that solutions to it can be efficiently verified, then so does <span><span class="math inline">\(F\)</span></span>.</p>
<div id="reductionnpex" class="solvedexercise" title="Reductions and $\mathbf{NP}$" name="Solvedexercise 14.4 (Reductions and $\mathbf{NP}$) ">
<p>Let <span><span class="math inline">\(F,G:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>. Show that if <span><span class="math inline">\(F \leq_p G\)</span></span> and <span><span class="math inline">\(G\in \mathbf{NP}\)</span></span> then <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span>.</p>
</div>
<div class="solution" data-ref="reductionnpex" name="Solution 14.1.2">
<p>Suppose that <span><span class="math inline">\(G\)</span></span> is in <span><span class="math inline">\(\mathbf{NP}\)</span></span> and in particular there exists <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(V \in \mathbf{P}\)</span></span> such that for every <span><span class="math inline">\(y \in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(G(y)=1 \Leftrightarrow \exists_{w\in \{0,1\}^{|y|^a}} V(yw)=1\)</span></span>. Suppose also that <span><span class="math inline">\(F \leq_p G\)</span></span> and so in particular there is a <span><span class="math inline">\(n^b\)</span></span>-time computable function <span><span class="math inline">\(R\)</span></span> such that <span><span class="math inline">\(F(x) = G(R(x))\)</span></span> for all <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. Define <span><span class="math inline">\(V&#39;\)</span></span> to be a Turing Machine that on input a pair <span><span class="math inline">\((x,w)\)</span></span> computes <span><span class="math inline">\(y=R(x)\)</span></span> and returns <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(|w|=|y|^a\)</span></span> and <span><span class="math inline">\(V(yw)=1\)</span></span>. Then <span><span class="math inline">\(V&#39;\)</span></span> runs in polynomial time, and for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(F(x)=1\)</span></span> iff there exists <span><span class="math inline">\(w\)</span></span> of size <span><span class="math inline">\(|R(x)|^a\)</span></span> which is at most polynomial in <span><span class="math inline">\(|x|\)</span></span> such that <span><span class="math inline">\(V&#39;(x,w)=1\)</span></span>, hence demonstrating that <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span>.</p>
</div>
<h2 id="from-mathbfnp-to-3sat-the-cook-levin-theorem" data-number="14.2">From <span><span class="math inline">\(\mathbf{NP}\)</span></span> to 3SAT: The Cook-Levin Theorem</h2>
<p>We have seen everal example of problems for which we do not know if their best algorithm is polynomial or exponential, but we can show that they are in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. That is, we don’t know if they are easy to <em>solve</em>, but we do know that it is easy to <em>verify</em> a given solution. There are many, many, <em>many</em>, more examples of interesting functions we would like to compute that are easily shown to be in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. What is quite amazing is that if we can solve 3SAT then we can solve all of them!</p>
<p>The following is one of the most fundamental theorems in Computer Science:</p>
<div id="cook-levin-thm" class="theorem" title="Cook-Levin Theorem" name="Theorem 14.6 (Cook-Levin Theorem) ">
<p>For every <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span>, <span><span class="math inline">\(F \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span>.</p>
</div>
<p>We will soon show the proof of <a href='#cook-levin-thm'>Theorem 14.6</a>, but note that it immediately implies that <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span> all reduce to <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>. Combining it with the reductions we’ve seen in <a href='lec_12_NP.html#reductionchap'>Chapter 13</a>, it implies that all these problems are <em>equivalent!</em> For example, to reduce <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span>, we can first reduce <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> to <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> using <a href='#cook-levin-thm'>Theorem 14.6</a> and use the reduction we’ve seen in <a href='lec_12_NP.html#longpaththm'>Theorem 13.7</a> from <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span>. That is, since <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}} \in \mathbf{NP}\)</span></span>, <a href='#cook-levin-thm'>Theorem 14.6</a> implies that <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}} \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span>, and <a href='lec_12_NP.html#longpaththm'>Theorem 13.7</a> implies that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{LONGPATH}}\)</span></span>, which by the transitivity of reductions (<a href='lec_12_NP.html#transitiveex'>Solvedexercise 13.2</a>) means that <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}} \leq_p \ensuremath{\mathit{LONGPATH}}\)</span></span>. Similarly, since <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}} \in \mathbf{NP}\)</span></span>, we can use <a href='#cook-levin-thm'>Theorem 14.6</a> and <a href='lec_12_NP.html#quadeq-thm'>Theorem 13.4</a> to show that <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}} \leq_p 3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{QUADEQ}}\)</span></span>, concluding that <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> are computationally equivalent.</p>
<p>There is of course nothing special about <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span> here: by combining <a href='#cook-levin-thm'>Theorem 14.6</a> with the reductions we saw, we see that just like <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>, <em>every</em> <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> reduces to <span><span class="math inline">\(\ensuremath{\mathit{LONGPATH}}\)</span></span>, and the same is true for <span><span class="math inline">\(\ensuremath{\mathit{QUADEQ}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{MAXCUT}}\)</span></span>. All these problems are in some sense “the hardest in <span><span class="math inline">\(\mathbf{NP}\)</span></span>” since an efficient algorithm for any one of them would imply an efficient algorithm for <em>all</em> the problems in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. This motivates the following definition:</p>
<div id="NPC-def" class="definition" title="$\mathbf{NP}$-hardness and $\mathbf{NP}$-completeness" name="Definition 14.7 ($\mathbf{NP}$-hardness and $\mathbf{NP}$-completeness) ">
<p>Let <span><span class="math inline">\(G:\{0,1\}^* \rightarrow \{0,1\}\)</span></span>. We say that <span><span class="math inline">\(G\)</span></span> is <em><span><span class="math inline">\(\mathbf{NP}\)</span></span> hard</em> if for every <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span>, <span><span class="math inline">\(F \leq_p G\)</span></span>.</p>
<p>We say that <span><span class="math inline">\(G\)</span></span> is <em><span><span class="math inline">\(\mathbf{NP}\)</span></span> complete</em> if <span><span class="math inline">\(G\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard and <span><span class="math inline">\(G \in \mathbf{NP}\)</span></span>.</p>
</div>
<p>The Cook-Levin Theorem (<a href='#cook-levin-thm'>Theorem 14.6</a>) can be rephrased as saying that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard, and since it is also in <span><span class="math inline">\(\mathbf{NP}\)</span></span>, this means that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> complete. Together with the reductions of <a href='lec_12_NP.html#reductionchap'>Chapter 13</a>, <a href='#cook-levin-thm'>Theorem 14.6</a> shows that despite their superficial differences, 3SAT, quadratic equations, longest path, independent set, and maximum cut, are all <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete. Many thousands of additional problems have been shown to be <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete, arising from all the sciences, mathematics, economics, engineering and many other fields. (For a few examples, see <a href="https://goo.gl/NomnoU">this Wikipedia page</a> and <a href="https://goo.gl/nfJHWv">this website</a>.)</p>
<div id="npcomplete" class="bigidea" name="Bigidea 21">
<p>If a <em>single</em> <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete has a polynomial-time algorithm, then there is such an algorithm for every decision problem that corresponds to the existence of an <em>efficiently-verifiable</em> solution.</p>
</div>
<h3 id="what-does-this-mean" data-number="14.2.1">What does this mean?</h3>
<p>As we’ve seen in <a href='#PinNP'>Solvedexercise 14.2</a>, <span><span class="math inline">\(\mathbf{P} \subseteq \mathbf{NP}\)</span></span>. <em>The</em> most famous conjecture in Computer Science is that this containment is <em>strict</em>. That is, it is widely conjectured that <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span>. One way to refute the conjecture that <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span> is to give a polynomial-time algorithm for even a single one of the <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problems such as 3SAT, Max Cut, or the thousands of others that have been studied in all fields of human endeavors. The fact that these problems have been studied by so many people, and yet not a single polynomial-time algorithm for any of them has been found, supports that conjecture that indeed <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span>. In fact, for many of these problems (including all the ones we mentioned above), we don’t even know of a <span><span class="math inline">\(2^{o(n)}\)</span></span>-time algorithm! However, to the frustration of computer scientists, we have not yet been able to prove that <span><span class="math inline">\(\mathbf{P}\neq\mathbf{NP}\)</span></span> or even rule out the existence of an <span><span class="math inline">\(O(n)\)</span></span>-time algorithm for 3SAT. Resolving whether or not <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span> is known as the <a href="https://en.wikipedia.org/wiki/P_versus_NP_problem"><span><span class="math inline">\(\mathbf{P}\)</span></span> vs <span><span class="math inline">\(\mathbf{NP}\)</span></span> problem</a>. A million-dollar prize has been <a href="http://www.claymath.org/millennium-problems/p-vs-np-problem">offered</a> for the solution of this problem, a <a href="https://www.amazon.com/dp/B00BKZYGUY">popular book</a> has been written, and every year a new paper comes out claiming a proof of <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span> or <span><span class="math inline">\(\mathbf{P}\neq\mathbf{NP}\)</span></span>, only to wither under scrutiny.</p>
<figure>
<img src="../figure/PNPscenarios.png" alt="14.3: The world if \mathbf{P}\neq \mathbf{NP} (left) and \mathbf{P}=\mathbf{NP} (right). In the former case the set of \mathbf{NP}-complete problems is disjoint from \mathbf{P} and Ladner’s theorem shows that there exist problems that are neither in \mathbf{P} nor are \mathbf{NP}-complete. (There are remarkably few natural candidates for such problems, with some prominent examples being decision variants of problems such as integer factoring, lattice shortest vector, and finding Nash equilibria.) In the latter case that \mathbf{P}=\mathbf{NP} the notion of \mathbf{NP}-completeness loses its meaning, as essentially all functions in \mathbf{P} (save for the trivial constant zero and constant one functions) are \mathbf{NP}-complete." id="PNPscenariosfig" class="margin" /><figcaption>14.3: The world if <span><span class="math inline">\(\mathbf{P}\neq \mathbf{NP}\)</span></span> (left) and <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span> (right). In the former case the set of <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problems is disjoint from <span><span class="math inline">\(\mathbf{P}\)</span></span> and Ladner’s theorem shows that there exist problems that are neither in <span><span class="math inline">\(\mathbf{P}\)</span></span> nor are <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete. (There are remarkably few natural candidates for such problems, with some prominent examples being decision variants of problems such as integer factoring, lattice shortest vector, and finding Nash equilibria.) In the latter case that <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span> the notion of <span><span class="math inline">\(\mathbf{NP}\)</span></span>-completeness loses its meaning, as essentially all functions in <span><span class="math inline">\(\mathbf{P}\)</span></span> (save for the trivial constant zero and constant one functions) are <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete.</figcaption>
</figure>
<p>One of the mysteries of computation is that people have observed a certain empirical “zero-one law” or “dichotomy” in the computational complexity of natural problems, in the sense that many natural problems are either in <span><span class="math inline">\(\mathbf{P}\)</span></span> (often in <span><span class="math inline">\(\ensuremath{\mathit{TIME}}(O(n))\)</span></span> or <span><span class="math inline">\(\ensuremath{\mathit{TIME}}(O(n^2))\)</span></span>), or they are are <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard. This is related to the fact that for most natural problems, the best known algorithm is either exponential or polynomial, with not too many examples where the best running time is some strange intermediate complexity such as <span><span class="math inline">\(2^{2^{\sqrt{\log n}}}\)</span></span>. However, it is believed that there exist problems in <span><span class="math inline">\(\mathbf{NP}\)</span></span> that are neither in <span><span class="math inline">\(\mathbf{P}\)</span></span> nor are <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete, and in fact a result known as “Ladner’s Theorem” shows that if <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span> then this is indeed the case (see also <a href='#ladner-ex'>Exercise 14.1</a> and <a href='#PNPscenariosfig'>Figure 14.3</a>).</p>
<figure>
<img src="../figure/PNPmap.png" alt="14.4: A rough illustration of the (conjectured) status of problems in exponential time. Darker colors correspond to higher running time, and the circle in the middle is the problems in \mathbf{P}. \mathbf{NP} is a (conjectured to be proper) superclass of \mathbf{P} and the \mathbf{NP}-complete problems (or \mathbf{NPC} for short) are the “hardest” problems in \mathbf{NP}, in the sense that a solution for one of them implies a solution for all other problems in \mathbf{NP}. It is conjectured that all the \mathbf{NP}-complete problems require at least \exp(n^\epsilon) time to solve for a constant \epsilon&gt;0, and many require \exp(\Omega(n)) time. The permanent is not believed to be contained in \mathbf{NP} though it is \mathbf{NP}-hard, which means that a polynomial-time algorithm for it implies that \mathbf{P}=\mathbf{NP}." id="complexitymapfig" class="margin" /><figcaption>14.4: A rough illustration of the (conjectured) status of problems in exponential time. Darker colors correspond to higher running time, and the circle in the middle is the problems in <span><span class="math inline">\(\mathbf{P}\)</span></span>. <span><span class="math inline">\(\mathbf{NP}\)</span></span> is a (conjectured to be proper) superclass of <span><span class="math inline">\(\mathbf{P}\)</span></span> and the <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problems (or <span><span class="math inline">\(\mathbf{NPC}\)</span></span> for short) are the “hardest” problems in <span><span class="math inline">\(\mathbf{NP}\)</span></span>, in the sense that a solution for one of them implies a solution for all other problems in <span><span class="math inline">\(\mathbf{NP}\)</span></span>. It is conjectured that all the <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problems require at least <span><span class="math inline">\(\exp(n^\epsilon)\)</span></span> time to solve for a constant <span><span class="math inline">\(\epsilon&gt;0\)</span></span>, and many require <span><span class="math inline">\(\exp(\Omega(n))\)</span></span> time. The <em>permanent</em> is not believed to be contained in <span><span class="math inline">\(\mathbf{NP}\)</span></span> though it is <span><span class="math inline">\(\mathbf{NP}\)</span></span>-hard, which means that a polynomial-time algorithm for it implies that <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span>.</figcaption>
</figure>
<h3 id="the-cook-levin-theorem-proof-outline" data-number="14.2.2">The Cook-Levin Theorem: Proof outline</h3>
<p>We will now prove the Cook-Levin Theorem, which is the underpinning to a great web of reductions from 3SAT to thousands of problems across great many fields. Some problems that have been shown to be <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete include: minimum-energy protein folding, minimum surface-area foam configuration, map coloring, optimal Nash equilibrium, quantum state entanglement, minimum supersequence of a genome, minimum codeword problem, shortest vector in a lattice, minimum genus knots, positive Diophantine equations, integer programming, and many many more. The worst-case complexity of all these problems is (up to polynomial factors) equivalent to that of 3SAT, and through the Cook-Levin Theorem, to all problems in <span><span class="math inline">\(\mathbf{NP}\)</span></span>.</p>
<p>To prove <a href='#cook-levin-thm'>Theorem 14.6</a> we need to show that <span><span class="math inline">\(F \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span> for every <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span>. We will do so in three stages. We define two intermediate problems: <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> and <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span>. We will shortly show the definitions of these two problems, but <a href='#cook-levin-thm'>Theorem 14.6</a> will follow from combining the following three results:</p>
<ol type="1">
<li><p><span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard (<a href='#nand-thm'>Lemma 14.8</a>).</p></li>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}}\)</span></span> (<a href='#threenand-thm'>Lemma 14.9</a>).</p></li>
<li><p><span><span class="math inline">\(3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span> (<a href='#threenand-sat-thm'>Lemma 14.10</a>).</p></li>
</ol>
<p>By the transitivity of reductions, it will follow that for every <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span>,</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
F \leq_p \ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}}
\]</span></div></span></p>
<p>hence establishing <a href='#cook-levin-thm'>Theorem 14.6</a>.</p>
<p>We will prove these three results <a href='#nand-thm'>Lemma 14.8</a>, <a href='#threenand-thm'>Lemma 14.9</a> and <a href='#threenand-sat-thm'>Lemma 14.10</a> one by one, providing the requisite definitions as we go along.</p>
<h2 id="the-nandsat-problem-and-why-it-is-mathbfnp-hard." data-number="14.3">The <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> Problem, and why it is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard.</h2>
<p>The function <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> is defined as follows:</p>
<ul>
<li><p>The <strong>input</strong> to <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> is a string <span><span class="math inline">\(Q\)</span></span> representing a NAND-CIRC program (or equivalently, a circuit with NAND gates).</p></li>
<li><p>The <strong>output</strong> of <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> on input <span><span class="math inline">\(Q\)</span></span> is <span><span class="math inline">\(1\)</span></span> if and only if there exists a string <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span> (where <span><span class="math inline">\(n\)</span></span> is the number of inputs to <span><span class="math inline">\(Q\)</span></span>) such that <span><span class="math inline">\(Q(w)=1\)</span></span>.</p></li>
</ul>
<div id="NANDSATinNP" class="solvedexercise" title="$NANDSAT \in \mathbf{NP}$" name="Solvedexercise 14.5 ($NANDSAT \in \mathbf{NP}$) ">
<p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}} \in \mathbf{NP}\)</span></span>.</p>
</div>
<div class="solution" data-ref="NANDSATinNP" name="Solution 14.3">
<p>We have seen that the circuit (or straightline program) evaluation problem can be computed in polynomial time. Specifically, given a NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> of <span><span class="math inline">\(s\)</span></span> lines and <span><span class="math inline">\(n\)</span></span> inputs, and <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span>, we can evaluate <span><span class="math inline">\(Q\)</span></span> on the input <span><span class="math inline">\(w\)</span></span> in time which is polynomial in <span><span class="math inline">\(s\)</span></span> and hence verify whether or not <span><span class="math inline">\(Q(w)=1\)</span></span>.</p>
</div>
<p>We now prove that <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard.</p>
<div id="nand-thm" class="lemma" name="Lemma 14.8">
<p><span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard.</p>
</div>
<div id="section-1" class="proofidea" data-ref="nand-thm" name="Proofidea">
<p>The proof closely follows the proof that <span><span class="math inline">\(\mathbf{P} \subseteq \mathbf{P_{/poly}}\)</span></span> (<a href='lec_11_running_time.html#non-uniform-thm'>Theorem 12.12</a> , see also <a href='lec_11_running_time.html#unrollloopsec'>Subsection 12.6.2</a>). Specifically, if <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> then there is a polynomial time Turing machine <span><span class="math inline">\(M\)</span></span> and positive integer <span><span class="math inline">\(a\)</span></span> such that for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(F(x)=1\)</span></span> iff there is some <span><span class="math inline">\(w \in \{0,1\}^{n^a}\)</span></span> such that <span><span class="math inline">\(M(xw)=1\)</span></span>. The proof that <span><span class="math inline">\(\mathbf{P} \subseteq \mathbf{P_{/poly}}\)</span></span> gave us way (via “unrolling the loop”) to come up in polynomial time with a Boolean circuit <span><span class="math inline">\(C\)</span></span> on <span><span class="math inline">\(n^a\)</span></span> inputs that computes the function <span><span class="math inline">\(w \mapsto M(xw)\)</span></span>. We can then translate <span><span class="math inline">\(C\)</span></span> into an equivalent NAND circuit (or NAND-CIRC program) <span><span class="math inline">\(Q\)</span></span>. We see that there is a string <span><span class="math inline">\(w \in \{0,1\}^{n^a}\)</span></span> such that <span><span class="math inline">\(Q(w)=1\)</span></span> if and only if there is such <span><span class="math inline">\(w\)</span></span> satisfying <span><span class="math inline">\(M(xw)=1\)</span></span> which (by definition) happens if and only if <span><span class="math inline">\(F(x)=1\)</span></span>. Hence the translation of <span><span class="math inline">\(x\)</span></span> into the circuit <span><span class="math inline">\(Q\)</span></span> is a reduction showing <span><span class="math inline">\(F \leq_p \ensuremath{\mathit{NANDSAT}}\)</span></span>.</p>
</div>
<div id="section-2" class="pause" name="Pause">
<p>The proof is a little bit technical but ultimately follows quite directly from the definition of <span><span class="math inline">\(\mathbf{NP}\)</span></span>, as well as the ability to “unroll the loop” of NAND-TM programs as discussed in <a href='lec_11_running_time.html#unrollloopsec'>Subsection 12.6.2</a>. If you find it confusing, try to pause here and think how you would implement in your favorite programming language the function <code>unroll</code> which on input a NAND-TM program <span><span class="math inline">\(P\)</span></span> and numbers <span><span class="math inline">\(T,n\)</span></span> outputs an <span><span class="math inline">\(n\)</span></span>-input NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> of <span><span class="math inline">\(O(|T|)\)</span></span> lines such that for every input <span><span class="math inline">\(z\in \{0,1\}^n\)</span></span>, if <span><span class="math inline">\(P\)</span></span> halts on <span><span class="math inline">\(z\)</span></span> within at most <span><span class="math inline">\(T\)</span></span> steps and outputs <span><span class="math inline">\(y\)</span></span>, then <span><span class="math inline">\(Q(z)=y\)</span></span>.</p>
</div>
<div class="proof" data-ref="nand-thm" name="Proof 14.3">
<p>Let <span><span class="math inline">\(F \in \mathbf{NP}\)</span></span>. To prove <a href='#nand-thm'>Lemma 14.8</a> we need to give a polynomial-time computable function that will map every <span><span class="math inline">\(x^* \in \{0,1\}^*\)</span></span> to a NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> such that <span><span class="math inline">\(F(x)=\ensuremath{\mathit{NANDSAT}}(Q)\)</span></span>.</p>
<p>Let <span><span class="math inline">\(x^* \in \{0,1\}^*\)</span></span> be such a string and let <span><span class="math inline">\(n=|x^*|\)</span></span> be its length. By <a href='#NP-def'>Definition 14.1</a> there exists <span><span class="math inline">\(V \in \mathbf{P}\)</span></span> and positive <span><span class="math inline">\(a \N\)</span></span> such that <span><span class="math inline">\(F(x^*)=1\)</span></span> if and only if there exists <span><span class="math inline">\(w\in \{0,1\}^{n^a}\)</span></span> satisfying <span><span class="math inline">\(V(x^*w)=1\)</span></span>.</p>
<p>Let <span><span class="math inline">\(m=n^a\)</span></span>. Since <span><span class="math inline">\(V\in \mathbf{P}\)</span></span> there is some NAND-TM program <span><span class="math inline">\(P^*\)</span></span> that computes <span><span class="math inline">\(V\)</span></span> on inputs of the form <span><span class="math inline">\(xw\)</span></span> with <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> and <span><span class="math inline">\(w\in \{0,1\}^m\)</span></span> in at most <span><span class="math inline">\({(n+m)}^c\)</span></span> time for some constant <span><span class="math inline">\(c\)</span></span>. Using our “unrolling the loop NAND-TM to NAND compiler” of <a href='lec_11_running_time.html#nand-compiler'>Theorem 12.14</a>, we can obtain a NAND-CIRC program <span><span class="math inline">\(Q&#39;\)</span></span> that has <span><span class="math inline">\(n+m\)</span></span> inputs and at most <span><span class="math inline">\(O((n+m)^{2c})\)</span></span> lines such that <span><span class="math inline">\(Q&#39;(xw)= P^*(xw)\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> and <span><span class="math inline">\(w \in \{0,1\}^m\)</span></span>.</p>
<p>We can then use a simple “hardwiring” technique, reminiscent of <a href='lec_08_uncomputability.html#hardwiringrem'>Remark 8.12</a> to map <span><span class="math inline">\(Q&#39;\)</span></span> into a circuit/NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> on <span><span class="math inline">\(m\)</span></span> inputs such that <span><span class="math inline">\(Q(w)= Q&#39;(x^*w)\)</span></span> for every <span><span class="math inline">\(w\in \{0,1\}^m\)</span></span>.</p>
<p><strong>CLAIM:</strong> There is a polynomial-time algorithm that on input a NAND-CIRC program <span><span class="math inline">\(Q&#39;\)</span></span> on <span><span class="math inline">\(n+m\)</span></span> inputs and <span><span class="math inline">\(x^* \in \{0,1\}^n\)</span></span>, outputs a NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> such that for every <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(Q(w)=Q&#39;(x^*w)\)</span></span>.</p>
<p><strong>PROOF OF CLAIM:</strong> We can do so by adding a few lines to ensure that the variables <code>zero</code> and <code>one</code> are <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span> respectively, and then simply replacing any reference in <span><span class="math inline">\(Q&#39;\)</span></span> to an input <span><span class="math inline">\(x_i\)</span></span> with <span><span class="math inline">\(i\in [n]\)</span></span> the corresponding value based on <span><span class="math inline">\(x^*_i\)</span></span>. See <a href='#hardwiringfig'>Figure 14.5</a> for an implementation of this reduction in Python.</p>
<p>Our final reduction maps an input <span><span class="math inline">\(x^*\)</span></span>, into the NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> obtained above. By the above discussion, this reduction runs in polynomial time. Since we know that <span><span class="math inline">\(F(x^*)=1\)</span></span> if and only if there exists <span><span class="math inline">\(w\in \{0,1\}^m\)</span></span> such that <span><span class="math inline">\(P^*(x^*w)=1\)</span></span>, this means that <span><span class="math inline">\(F(x^*)=1\)</span></span> if and only if <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}(Q)=1\)</span></span>, which is what we wanted to prove.</p>
</div>
<figure>
<img src="../figure/hardwiring.png" alt="14.5: Given an T-line NAND-CIRC program Q that has n+m inputs and some x^*\in \{0,1\}^n, we can transform Q into a T+3 line NAND-CIRC program Q&#39; that computes the map w \mapsto Q(x^*w) for w\in \{0,1\}^m by simply adding code to compute the zero and one constants, replacing all references to X[i] with either zero or one depending on the value of x^*_i, and then replacing the remaining references to X[j] with X[j-n]. Above is Python code that implements this transformation, as well as an example of its execution on a simple program." id="hardwiringfig" /><figcaption>14.5: Given an <span><span class="math inline">\(T\)</span></span>-line NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> that has <span><span class="math inline">\(n+m\)</span></span> inputs and some <span><span class="math inline">\(x^*\in \{0,1\}^n\)</span></span>, we can transform <span><span class="math inline">\(Q\)</span></span> into a <span><span class="math inline">\(T+3\)</span></span> line NAND-CIRC program <span><span class="math inline">\(Q&#39;\)</span></span> that computes the map <span><span class="math inline">\(w \mapsto Q(x^*w)\)</span></span> for <span><span class="math inline">\(w\in \{0,1\}^m\)</span></span> by simply adding code to compute the <code>zero</code> and <code>one</code> constants, replacing all references to <code>X[</code><span><span class="math inline">\(i\)</span></span><code>]</code> with either <code>zero</code> or <code>one</code> depending on the value of <span><span class="math inline">\(x^*_i\)</span></span>, and then replacing the remaining references to <code>X[</code><span><span class="math inline">\(j\)</span></span><code>]</code> with <code>X[</code><span><span class="math inline">\(j-n\)</span></span><code>]</code>. Above is Python code that implements this transformation, as well as an example of its execution on a simple program.</figcaption>
</figure>
<h2 id="the-3nand-problem" data-number="14.4">The <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> problem</h2>
<p>The <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> problem is defined as follows:</p>
<ul>
<li><p>The <strong>input</strong> is a logical formula <span><span class="math inline">\(\Psi\)</span></span> on a set of variables <span><span class="math inline">\(z_0,\ldots,z_{r-1}\)</span></span> which is an AND of constraints of the form <span><span class="math inline">\(z_i = \ensuremath{\mathit{NAND}}(z_j,z_k)\)</span></span>.</p></li>
<li><p>The <strong>output</strong> is <span><span class="math inline">\(1\)</span></span> if and only if there is an input <span><span class="math inline">\(z\in \{0,1\}^r\)</span></span> that satisfies all of the constraints.</p></li>
</ul>
<p>For example, the following is a <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> formula with <span><span class="math inline">\(5\)</span></span> variables and <span><span class="math inline">\(3\)</span></span> constraints:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\Psi = \left( z_3 = \ensuremath{\mathit{NAND}}(z_0,z_2) \right) \wedge \left( z_1 = \ensuremath{\mathit{NAND}}(z_0,z_2) \right) \wedge \left( z_4 = \ensuremath{\mathit{NAND}}(z_3,z_1) \right) \;.
\]</span></div></span></p>
<p>In this case <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}(\Psi)=1\)</span></span> since the assignment <span><span class="math inline">\(z = 01010\)</span></span> satisfies it. Given a <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> formula <span><span class="math inline">\(\Psi\)</span></span> on <span><span class="math inline">\(r\)</span></span> variables and an assignment <span><span class="math inline">\(z\in \{0,1\}^r\)</span></span>, we can check in polynomial time whether <span><span class="math inline">\(\Psi(z)=1\)</span></span>, and hence <span><span class="math inline">\(3\ensuremath{\mathit{NAND}} \in \mathbf{NP}\)</span></span>. We now prove that <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> hard:</p>
<div id="threenand-thm" class="lemma" name="Lemma 14.9">
<p><span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}}\)</span></span>.</p>
</div>
<div id="section-3" class="proofidea" data-ref="threenand-thm" name="Proofidea">
<p>To prove <a href='#threenand-thm'>Lemma 14.9</a> we need to give a polynomial-time map from every NAND-CIRC program <span><span class="math inline">\(Q\)</span></span> to a 3NAND formula <span><span class="math inline">\(\Psi\)</span></span> such that there exists <span><span class="math inline">\(w\)</span></span> such that <span><span class="math inline">\(Q(w)=1\)</span></span> if and only if there exists <span><span class="math inline">\(z\)</span></span> satisfying <span><span class="math inline">\(\Psi\)</span></span>. For every line <span><span class="math inline">\(i\)</span></span> of <span><span class="math inline">\(Q\)</span></span>, we define a corresponding variable <span><span class="math inline">\(z_i\)</span></span> of <span><span class="math inline">\(\Psi\)</span></span>. If the line <span><span class="math inline">\(i\)</span></span> has the form <code>foo = NAND(bar,blah)</code> then we will add the clause <span><span class="math inline">\(z_i = \ensuremath{\mathit{NAND}}(z_j,z_k)\)</span></span> where <span><span class="math inline">\(j\)</span></span> and <span><span class="math inline">\(k\)</span></span> are the last lines in which <code>bar</code> and <code>blah</code> were written to. We will also set variables corresponding to the input variables, as well as add a clause to ensure that the final output is <span><span class="math inline">\(1\)</span></span>. The resulting reduction can be implemented in about a dozen lines of Python, see <a href='#nandsattothreenandfig'>Figure 14.6</a>.</p>
</div>
<figure>
<img src="../figure/nandsatto3nandreduction.png" alt="14.6: Python code to reduce an instance Q of \ensuremath{\mathit{NANDSAT}} to an instance \Psi of 3\ensuremath{\mathit{NAND}}. In the example above we transform the NAND-CIRC program xor5 which has 5 input variables and 16 lines, into a 3\ensuremath{\mathit{NAND}} formula \Psi that has 24 variables and 20 clauses. Since xor5 outputs 1 on the input 1,0,0,1,1, there exists an assignment z \in \{0,1\}^{24} to \Psi such that (z_0,z_1,z_2,z_3,z_4)=(1,0,0,1,1) and \Psi evaluates to true on z." id="nandsattothreenandfig" /><figcaption>14.6: Python code to reduce an instance <span><span class="math inline">\(Q\)</span></span> of <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> to an instance <span><span class="math inline">\(\Psi\)</span></span> of <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span>. In the example above we transform the NAND-CIRC program <code>xor5</code> which has <span><span class="math inline">\(5\)</span></span> input variables and <span><span class="math inline">\(16\)</span></span> lines, into a <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> formula <span><span class="math inline">\(\Psi\)</span></span> that has <span><span class="math inline">\(24\)</span></span> variables and <span><span class="math inline">\(20\)</span></span> clauses. Since <code>xor5</code> outputs <span><span class="math inline">\(1\)</span></span> on the input <span><span class="math inline">\(1,0,0,1,1\)</span></span>, there exists an assignment <span><span class="math inline">\(z \in \{0,1\}^{24}\)</span></span> to <span><span class="math inline">\(\Psi\)</span></span> such that <span><span class="math inline">\((z_0,z_1,z_2,z_3,z_4)=(1,0,0,1,1)\)</span></span> and <span><span class="math inline">\(\Psi\)</span></span> evaluates to <em>true</em> on <span><span class="math inline">\(z\)</span></span>.</figcaption>
</figure>
<div class="proof" data-ref="threenand-thm" name="Proof">
<p>To prove <a href='#threenand-thm'>Lemma 14.9</a> we need to give a reduction from <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> to <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span>. Let <span><span class="math inline">\(Q\)</span></span> be a NAND-CIRC program with <span><span class="math inline">\(n\)</span></span> inputs, one output, and <span><span class="math inline">\(m\)</span></span> lines. We can assume without loss of generality that <span><span class="math inline">\(Q\)</span></span> contains the variables <code>one</code> and <code>zero</code> as usual.</p>
<p>We map <span><span class="math inline">\(Q\)</span></span> to a <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> formula <span><span class="math inline">\(\Psi\)</span></span> as follows:</p>
<ul>
<li><p><span><span class="math inline">\(\Psi\)</span></span> has <span><span class="math inline">\(m+n\)</span></span> variables <span><span class="math inline">\(z_0,\ldots,z_{m+n-1}\)</span></span>.</p></li>
<li><p>The first <span><span class="math inline">\(n\)</span></span> variables <span><span class="math inline">\(z_0,\ldots,z_{n-1}\)</span></span> will corresponds to the inputs of <span><span class="math inline">\(Q\)</span></span>. The next <span><span class="math inline">\(m\)</span></span> variables <span><span class="math inline">\(z_n,\ldots,z_{n+m-1}\)</span></span> will correspond to the <span><span class="math inline">\(m\)</span></span> lines of <span><span class="math inline">\(Q\)</span></span>.</p></li>
<li><p>For every <span><span class="math inline">\(\ell\in \{n,n+1,\ldots,n+m \}\)</span></span>, if the <span><span class="math inline">\(\ell-n\)</span></span>-th line of the program <span><span class="math inline">\(Q\)</span></span> is <code>foo = NAND(bar,blah)</code> then we add to <span><span class="math inline">\(\Psi\)</span></span> the constraint <span><span class="math inline">\(z_\ell = \ensuremath{\mathit{NAND}}(z_j,z_k)\)</span></span> where <span><span class="math inline">\(j-n\)</span></span> and <span><span class="math inline">\(k-n\)</span></span> correspond to the last lines in which the variables <code>bar</code> and <code>blah</code> (respectively) were written to. If one or both of <code>bar</code> and <code>blah</code> was not written to before then we use <span><span class="math inline">\(z_{\ell_0}\)</span></span> instead of the corresponding value <span><span class="math inline">\(z_j\)</span></span> or <span><span class="math inline">\(z_k\)</span></span> in the constraint, where <span><span class="math inline">\(\ell_0-n\)</span></span> is the line in which <code>zero</code> is assigned a value. If one or both of <code>bar</code> and <code>blah</code> is an input variable <code>X[i]</code> then we use <span><span class="math inline">\(z_i\)</span></span> in the constraint.</p></li>
<li><p>Let <span><span class="math inline">\(\ell^*\)</span></span> be the last line in which the output <code>y_0</code> is assigned a value. Then we add the constraint <span><span class="math inline">\(z_{\ell^*} = \ensuremath{\mathit{NAND}}(z_{\ell_0},z_{\ell_0})\)</span></span> where <span><span class="math inline">\(\ell_0-n\)</span></span> is as above the last line in which <code>zero</code> is assigned a value. Note that this is effectively the constraint <span><span class="math inline">\(z_{\ell^*}=\ensuremath{\mathit{NAND}}(0,0)=1\)</span></span>.</p></li>
</ul>
<p>To complete the proof we need to show that there exists <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span> s.t. <span><span class="math inline">\(Q(w)=1\)</span></span> if and only if there exists <span><span class="math inline">\(z\in \{0,1\}^{n+m}\)</span></span> that satisfies all constraints in <span><span class="math inline">\(\Psi\)</span></span>. We now show both sides of this equivalence.</p>
<p><strong>Part I: Completeness.</strong> Suppose that there is <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span> s.t. <span><span class="math inline">\(Q(w)=1\)</span></span>. Let <span><span class="math inline">\(z\in \{0,1\}^{n+m}\)</span></span> be defined as follows: for <span><span class="math inline">\(i\in [n]\)</span></span>, <span><span class="math inline">\(z_i=w_i\)</span></span> and for <span><span class="math inline">\(i\in \{n,n+1,\ldots,n+m\}\)</span></span> <span><span class="math inline">\(z_i\)</span></span> equals the value that is assigned in the <span><span class="math inline">\((i-n)\)</span></span>-th line of <span><span class="math inline">\(Q\)</span></span> when executed on <span><span class="math inline">\(w\)</span></span>. Then by construction <span><span class="math inline">\(z\)</span></span> satisfies all of the constraints of <span><span class="math inline">\(\Psi\)</span></span> (including the constraint that <span><span class="math inline">\(z_{\ell^*}=\ensuremath{\mathit{NAND}}(0,0)=1\)</span></span> since <span><span class="math inline">\(Q(w)=1\)</span></span>.)</p>
<p><strong>Part II: Soundness.</strong> Suppose that there exists <span><span class="math inline">\(z\in \{0,1\}^{n+m}\)</span></span> satisfying <span><span class="math inline">\(\Psi\)</span></span>. Soundness will follow by showing that <span><span class="math inline">\(Q(z_0,\ldots,z_{n-1})=1\)</span></span> (and hence in particular there exists <span><span class="math inline">\(w\in \{0,1\}^n\)</span></span>, namely <span><span class="math inline">\(w=z_0\cdots z_{n-1}\)</span></span>, such that <span><span class="math inline">\(Q(w)=1\)</span></span>). To do this we will prove the following claim <span><span class="math inline">\((*)\)</span></span>: for every <span><span class="math inline">\(\ell \in [m]\)</span></span>, <span><span class="math inline">\(z_{\ell+n}\)</span></span> equals the value assigned in the <span><span class="math inline">\(\ell\)</span></span>-th step of the execution of the program <span><span class="math inline">\(Q\)</span></span> on <span><span class="math inline">\(z_0,\ldots,z_{n-1}\)</span></span>. Note that because <span><span class="math inline">\(z\)</span></span> satisfies the constraints of <span><span class="math inline">\(\Psi\)</span></span>, <span><span class="math inline">\((*)\)</span></span> is sufficient to prove the soundness condition since these constraints imply that the last value assigned to the variable <code>y_0</code> in the execution of <span><span class="math inline">\(Q\)</span></span> on <span><span class="math inline">\(z_0\cdots w_{n-1}\)</span></span> is equal to <span><span class="math inline">\(1\)</span></span>. To prove <span><span class="math inline">\((*)\)</span></span> suppose, towards a contradiction, that it is false, and let <span><span class="math inline">\(\ell\)</span></span> be the smallest number such that <span><span class="math inline">\(z_{\ell+n}\)</span></span> is <em>not</em> equal to the value assigned in the <span><span class="math inline">\(\ell\)</span></span>-th step of the execution of <span><span class="math inline">\(Q\)</span></span> on <span><span class="math inline">\(z_0,\ldots,z_{n-1}\)</span></span>. But since <span><span class="math inline">\(z\)</span></span> satisfies the constraints of <span><span class="math inline">\(\Psi\)</span></span>, we get that <span><span class="math inline">\(z_{\ell+n}=\ensuremath{\mathit{NAND}}(z_i,z_j)\)</span></span> where (by the assumption above that <span><span class="math inline">\(\ell\)</span></span> is <em>smallest</em> with this property) these values <em>do</em> correspond to the values last assigned to the variables on the righthand side of the assignment operator in the <span><span class="math inline">\(\ell\)</span></span>-th line of the program. But this means that the value assigned in the <span><span class="math inline">\(\ell\)</span></span>-th step is indeed simply the NAND of <span><span class="math inline">\(z_i\)</span></span> and <span><span class="math inline">\(z_j\)</span></span>, contradicting our assumption on the choice of <span><span class="math inline">\(\ell\)</span></span>.</p>
</div>
<figure>
<img src="../figure/threenandresultreduction.png" alt="14.7: A 3\ensuremath{\mathit{NAND}} instance that is obtained by taking a NAND-TM program for computing the \ensuremath{\mathit{AND}} function, unrolling it to obtain a \ensuremath{\mathit{NANDSAT}} instance, and then composing it with the reduction of ." id="resultreduction" class="margin" /><figcaption>14.7: A <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> instance that is obtained by taking a NAND-TM program for computing the <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> function, unrolling it to obtain a <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}}\)</span></span> instance, and then composing it with the reduction of <a href='#threenand-thm'>Lemma 14.9</a>.</figcaption>
</figure>
<h2 id="from-3nand-to-3sat" data-number="14.5">From <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> to <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span></h2>
<p>The final step in the proof of <a href='#cook-levin-thm'>Theorem 14.6</a> is the following:</p>
<div id="threenand-sat-thm" class="lemma" name="Lemma 14.10">
<p><span><span class="math inline">\(3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span>.</p>
</div>
<div id="section-4" class="proofidea" data-ref="threenand-sat-thm" name="Proofidea">
<p>To prove <a href='#threenand-sat-thm'>Lemma 14.10</a> we need to map a 3NAND formula <span><span class="math inline">\(\varphi\)</span></span> into a 3SAT formula <span><span class="math inline">\(\psi\)</span></span> such that <span><span class="math inline">\(\varphi\)</span></span> is satisfiable if and only if <span><span class="math inline">\(\psi\)</span></span> is. The idea is that we can transform every NAND constraint of the form <span><span class="math inline">\(a=\ensuremath{\mathit{NAND}}(b,c)\)</span></span> into the AND of ORs involving the variables <span><span class="math inline">\(a,b,c\)</span></span> and their negations, where each of the ORs contains at most three terms. The construction is fairly straightforward, and the details are given below.</p>
</div>
<div id="section-5" class="pause" name="Pause">
<p>It is a good exercise for you to try to find a 3CNF formula <span><span class="math inline">\(\xi\)</span></span> on three variables <span><span class="math inline">\(a,b,c\)</span></span> such that <span><span class="math inline">\(\xi(a,b,c)\)</span></span> is true if and only if <span><span class="math inline">\(a = \ensuremath{\mathit{NAND}}(b,c)\)</span></span>. Once you do so, try to see why this implies a reduction from <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> to <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>, and hence completes the proof of <a href='#threenand-sat-thm'>Lemma 14.10</a></p>
</div>
<figure>
<img src="../figure/3nandto3sat.png" alt="14.8: Code and example output for the reduction given in  of 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}." id="threenandtothreesat" /><figcaption>14.8: Code and example output for the reduction given in <a href='#threenand-sat-thm'>Lemma 14.10</a> of <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> to <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span>.</figcaption>
</figure>
<div class="proof" data-ref="threenand-sat-thm" name="Proof">
<p>The constraint <span>
<div class='myequationbox'><span class="math display">\[
z_i = \ensuremath{\mathit{NAND}}(z_j,z_k) \;\;(14.5)
\]</span><a id='eq:NANDconstraint'></a></div></span> is satisfied if <span><span class="math inline">\(z_i=1\)</span></span> whenever <span><span class="math inline">\((z_j,z_k) \neq (1,1)\)</span></span>. By going through all cases, we can verify that <a href='#eq:NANDconstraint'>Equation 14.5</a> is equivalent to the constraint</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
 (\overline{z_i} \vee \overline{z_j} \vee\overline{z_k} ) \wedge          (z_i     \vee z_j )
         \wedge  (z_i     \vee z_k) \;\;. \;\;(14.6)
\]</span><a id='eq:CNFNAND'></a></div></span></p>
<p>Indeed if <span><span class="math inline">\(z_j=z_k=1\)</span></span> then the first constraint of <a href='#eq:CNFNAND'>Equation 14.6</a> is only true if <span><span class="math inline">\(z_i=0\)</span></span>. On the other hand, if either of <span><span class="math inline">\(z_j\)</span></span> or <span><span class="math inline">\(z_k\)</span></span> equals <span><span class="math inline">\(0\)</span></span> then unless <span><span class="math inline">\(z_i=1\)</span></span> either the second or third constraints will fail. This means that, given any 3NAND formula <span><span class="math inline">\(\varphi\)</span></span> over <span><span class="math inline">\(n\)</span></span> variables <span><span class="math inline">\(z_0,\ldots,z_{n-1}\)</span></span>, we can obtain a 3SAT formula <span><span class="math inline">\(\psi\)</span></span> over the same variables by replacing every <span><span class="math inline">\(3\ensuremath{\mathit{NAND}}\)</span></span> constraint of <span><span class="math inline">\(\varphi\)</span></span> with three <span><span class="math inline">\(3\ensuremath{\mathit{OR}}\)</span></span> constraints as in <a href='#eq:CNFNAND'>Equation 14.6</a>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> Because of the equivalence of <a href='#eq:NANDconstraint'>Equation 14.5</a> and <a href='#eq:CNFNAND'>Equation 14.6</a>, the formula <span><span class="math inline">\(\psi\)</span></span> satisfies that <span><span class="math inline">\(\psi(z_0,\ldots,z_{n-1})=\varphi(z_0,\ldots,z_{n-1})\)</span></span> for every assignment <span><span class="math inline">\(z_0,\ldots,z_{n-1} \in \{0,1\}^n\)</span></span> to the variables. In particular <span><span class="math inline">\(\psi\)</span></span> is satisfiable if and only if <span><span class="math inline">\(\varphi\)</span></span> is, thus completing the proof.</p>
</div>
<figure>
<img src="../figure/indsetfromnandsat.png" alt="14.9: An instance of the independent set problem obtained by applying the reductions \ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{ISAT}} starting with the xor5 NAND-CIRC program." id="indsetfromnandsatfig" /><figcaption>14.9: An instance of the <em>independent set</em> problem obtained by applying the reductions <span><span class="math inline">\(\ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{ISAT}}\)</span></span> starting with the <code>xor5</code> NAND-CIRC program.</figcaption>
</figure>
<h2 id="wrapping-up" data-number="14.6">Wrapping up</h2>
<p>We have shown that for every function <span><span class="math inline">\(F\)</span></span> in <span><span class="math inline">\(\mathbf{NP}\)</span></span>, <span><span class="math inline">\(F \leq_p \ensuremath{\mathit{NANDSAT}} \leq_p 3\ensuremath{\mathit{NAND}} \leq_p 3\ensuremath{\mathit{SAT}}\)</span></span>, and so <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span>-hard. Since in <a href='lec_12_NP.html#reductionchap'>Chapter 13</a> we saw that <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{QUADEQ}}\)</span></span>, <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{ISET}}\)</span></span>, <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{MAXCUT}}\)</span></span> and <span><span class="math inline">\(3\ensuremath{\mathit{SAT}} \leq_p \ensuremath{\mathit{LONGPATH}}\)</span></span>, all these problems are <span><span class="math inline">\(\mathbf{NP}\)</span></span>-hard as well. Finally, since all the aforementioned problems are in <span><span class="math inline">\(\mathbf{NP}\)</span></span>, they are all in fact <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete and have equivalent complexity. There are thousands of other natural problems that are <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete as well. Finding a polynomial-time algorithm for any one of them will imply a polynomial-time algorithm for all of them.</p>
<figure>
<img src="../figure/inclusion_npc.png" alt="14.10: We believe that \mathbf{P} \neq \mathbf{NP} and all \mathbf{NP} complete problems lie outside of \mathbf{P}, but we cannot rule out the possiblity that \mathbf{P}=\mathbf{NP}. However, we can rule out the possiblity that some \mathbf{NP}-complete problems are in \mathbf{P} and other do not, since we know that if even one \mathbf{NP}-complete problem is in \mathbf{P} then \mathbf{P}=\mathbf{NP}. The relation between \mathbf{P_{/poly}} and \mathbf{NP} is not known though it can be shown that if one \mathbf{NP}-complete problem is in \mathbf{P_{/poly}} then \mathbf{NP} \subseteq \mathbf{P_{/poly}}." id="npcinclusionfig" /><figcaption>14.10: We believe that <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span> and all <span><span class="math inline">\(\mathbf{NP}\)</span></span> complete problems lie outside of <span><span class="math inline">\(\mathbf{P}\)</span></span>, but we cannot rule out the possiblity that <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span>. However, we can rule out the possiblity that <em>some</em> <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problems are in <span><span class="math inline">\(\mathbf{P}\)</span></span> and other do not, since we know that if even one <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problem is in <span><span class="math inline">\(\mathbf{P}\)</span></span> then <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span>. The relation between <span><span class="math inline">\(\mathbf{P_{/poly}}\)</span></span> and <span><span class="math inline">\(\mathbf{NP}\)</span></span> is not known though it can be shown that if one <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete problem is in <span><span class="math inline">\(\mathbf{P_{/poly}}\)</span></span> then <span><span class="math inline">\(\mathbf{NP} \subseteq \mathbf{P_{/poly}}\)</span></span>.</figcaption>
</figure>
<div id="section-6" class="recap" name="Recap">
<ul>
<li>Many of the problems for which we don’t know polynomial-time algorithms are <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete, which means that finding a polynomial-time algorithm for one of them would imply a polynomial-time algorithm for <em>all</em> of them.</li>
<li>It is conjectured that <span><span class="math inline">\(\mathbf{NP}\neq \mathbf{P}\)</span></span> which means that we believe that polynomial-time algorithms for these problems are not merely <em>unknown</em> but are <em>nonexistent</em>.</li>
<li>While an <span><span class="math inline">\(\mathbf{NP}\)</span></span>-hardness result means for example that a full-fledged “textbook” solution to a problem such as MAX-CUT that is as clean and general as the algorithm for MIN-CUT probably does not exist, it does not mean that we need to give up whenever we see a MAX-CUT instance. Later in this course we will discuss several strategies to deal with <span><span class="math inline">\(\mathbf{NP}\)</span></span>-hardness, including <em>average-case complexity</em> and <em>approximation algorithms</em>.</li>
</ul>
</div>
<h2 id="exercises" data-number="14.7">Exercises</h2>
<div id="ladner-ex" class="exercise" title="Poor man&#39;s Ladner&#39;s Theorem" name="Exercise 14.1 (Poor man&#39;s Ladner&#39;s Theorem) ">
<p>Prove that if there is no <span><span class="math inline">\(n^{O(\log^2 n)}\)</span></span> time algorithm for <span><span class="math inline">\(3\ensuremath{\mathit{SAT}}\)</span></span> then there is some <span><span class="math inline">\(F\in \mathbf{NP}\)</span></span> such that <span><span class="math inline">\(F \not\in \mathbf{P}\)</span></span> and <span><span class="math inline">\(F\)</span></span> is not <span><span class="math inline">\(\mathbf{NP}\)</span></span> complete.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
</div>
<div id="npconppnpex" class="exercise" title="$\mathbf{NP} \neq \mathbf{co-NP} \Rightarrow \mathbf{NP} \neq \mathbf{P}$" name="Exercise 14.2 ($\mathbf{NP} \neq \mathbf{co-NP} \Rightarrow \mathbf{NP} \neq \mathbf{P}$) ">
<p>Let <span><span class="math inline">\(\overline{3\ensuremath{\mathit{SAT}}}\)</span></span> be the function that on input a 3CNF formula <span><span class="math inline">\(\varphi\)</span></span> return <span><span class="math inline">\(1-3\ensuremath{\mathit{SAT}}(\varphi)\)</span></span>. Prove that if <span><span class="math inline">\(\overline{3\ensuremath{\mathit{SAT}}} \not\in \mathbf{NP}\)</span></span> then <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span>. See footnote for hint.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
</div>
<div id="WSATex" class="exercise" name="Exercise 14.3">
<p>Define <span><span class="math inline">\(\ensuremath{\mathit{WSAT}}\)</span></span> to be the following function: the input is a CNF formula <span><span class="math inline">\(\varphi\)</span></span> where each clause is the OR of one to three variables (<em>without negations</em>), and a number <span><span class="math inline">\(k\in \mathbb{N}\)</span></span>. For example, the following formula can be used for a valid input to <span><span class="math inline">\(\ensuremath{\mathit{WSAT}}\)</span></span>: <span><span class="math inline">\(\varphi = (x_5 \vee x_{2} \vee x_1) \wedge (x_1 \vee x_3 \vee x_0) \wedge (x_2 \vee x_4 \vee x_0)\)</span></span>. The output <span><span class="math inline">\(\ensuremath{\mathit{WSAT}}(\varphi,k)=1\)</span></span> if and only if there exists a satisfying assignment to <span><span class="math inline">\(\varphi\)</span></span> in which exactly <span><span class="math inline">\(k\)</span></span> of the variables get the value <span><span class="math inline">\(1\)</span></span>. For example for the formula above <span><span class="math inline">\(\ensuremath{\mathit{WSAT}}(\varphi,2)=1\)</span></span> since the assignment <span><span class="math inline">\((1,1,0,0,0,0)\)</span></span> satisfies all the clauses. However <span><span class="math inline">\(\ensuremath{\mathit{WSAT}}(\varphi,1)=0\)</span></span> since there is no single variable appearing in all clauses.</p>
<p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{WSAT}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete.</p>
</div>
<div id="employeerecrutingex" class="exercise" name="Exercise 14.4">
<p>In the <em>employee recruiting problem</em> we are given a list of potential employees, each of which has some subset of <span><span class="math inline">\(m\)</span></span> potential skills, and a number <span><span class="math inline">\(k\)</span></span>. We need to assemble a team of <span><span class="math inline">\(k\)</span></span> employees such that for every skill there would be one member of the team with this skill.</p>
<p>For example, if Alice has the skills “C programming”, “NAND programming” and “Solving Differential Equations”, Bob has the skills “C programming” and “Solving Differential Equations”, and Charlie has the skills “NAND programming” and “Coffee Brewing”, then if we want a team of two people that covers all the four skills, we would hire Alice and Charlie.</p>
<p>Define the function <span><span class="math inline">\(\ensuremath{\mathit{EMP}}\)</span></span> s.t. on input the skills <span><span class="math inline">\(L\)</span></span> of all potential employees (in the form of a sequence <span><span class="math inline">\(L\)</span></span> of <span><span class="math inline">\(n\)</span></span> lists <span><span class="math inline">\(L_1,\ldots,L_n\)</span></span>, each containing distinct numbers between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(m\)</span></span>), and a number <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{EMP}}(L,k)=1\)</span></span> if and only if there is a subset <span><span class="math inline">\(S\)</span></span> of <span><span class="math inline">\(k\)</span></span> potential employees such that for every skill <span><span class="math inline">\(j\)</span></span> in <span><span class="math inline">\([m]\)</span></span>, there is an employee in <span><span class="math inline">\(S\)</span></span> that has the skill <span><span class="math inline">\(j\)</span></span>.</p>
<p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{EMP}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span> complete.</p>
</div>
<div id="balancedmc" class="exercise" title="Balanced max cut" name="Exercise 14.5 (Balanced max cut) ">
<p>Prove that the “balanced variant” of the maximum cut problem is <span><span class="math inline">\(\mathbf{NP}\)</span></span>-complete, where this is defined as <span><span class="math inline">\(\ensuremath{\mathit{BMC}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> where for every graph <span><span class="math inline">\(G=(V,E)\)</span></span> and <span><span class="math inline">\(k\in \mathbb{N}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{BMC}}(G,k)=1\)</span></span> if and only if there exists a cut <span><span class="math inline">\(S\)</span></span> in <span><span class="math inline">\(G\)</span></span> cutting at least <span><span class="math inline">\(k\)</span></span> edges such that <span><span class="math inline">\(|S|=|V|/2\)</span></span>.</p>
</div>
<div id="manyregs" class="exercise" title="Regular expression intersection" name="Exercise 14.6 (Regular expression intersection) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{MANYREGS}}\)</span></span> be the following function: On input a list of regular expressions <span><span class="math inline">\(exp_0,\ldots,\exp_m\)</span></span> (represented as strings in some standard way), output <span><span class="math inline">\(1\)</span></span> if and only if there is a single string <span><span class="math inline">\(x \in \{0,1\}^*\)</span></span> that matches all of them. Prove that <span><span class="math inline">\(\ensuremath{\mathit{MANYREGS}}\)</span></span> is <span><span class="math inline">\(\mathbf{NP}\)</span></span>-hard.</p>
</div>
<h2 id="bibliographical-notes" data-number="14.8">Bibliographical notes</h2>
<p>Aaronson’s 120 page survey  (<a href="https://scholar.google.com/scholar?hl=en&q=Aaronson+P+=?+NP" target="_blank">Aaronson, 2016</a>)  is a beautiful and extensive exposition to the <span><span class="math inline">\(\mathbf{P}\)</span></span> vs <span><span class="math inline">\(\mathbf{NP}\)</span></span> problem, its importance and status. See also as well as Chapter 3 in Wigderson’s excellent book  (<a href="https://scholar.google.com/scholar?hl=en&q=Wigderson+Mathematics+and+Computation" target="_blank">Wigderson, 2019</a>) . Johnson  (<a href="https://scholar.google.com/scholar?hl=en&q=Johnson+A+brief+history+of+NP-completeness,+1954--2012" target="_blank">Johnson, 2012</a>)  gives a survey of the historical development of the theory of <span><span class="math inline">\(\mathbf{NP}\)</span></span> completeness. The following <a href="https://goo.gl/bFHsd9">web page</a> keeps a catalog of failed attempts at settling <span><span class="math inline">\(\mathbf{P}\)</span></span> vs <span><span class="math inline">\(\mathbf{NP}\)</span></span>. At the time of this writing, it lists about 110 papers claiming to resolve the question, of which about 60 claim to prove that <span><span class="math inline">\(\mathbf{P}=\mathbf{NP}\)</span></span> and about 50 claim to prove that <span><span class="math inline">\(\mathbf{P} \neq \mathbf{NP}\)</span></span>.</p>
<p>Eugene Lawler’s quote on the “mystical power of twoness” was taken from the wonderful book “The Nature of Computation” by Moore and Mertens. See also <a href="https://pure.tue.nl/ws/files/1506049/511307.pdf">this memorial essay on Lawler</a> by Lenstra.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>The resulting formula will have some of the OR’s involving only two variables. If we wanted to insist on each formula involving three distinct variables we can always add a “dummy variable” <span><span class="math inline">\(z_{n+m}\)</span></span> and include it in all the OR’s involving only two variables, and add a constraint requiring this dummy variable to be zero.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p><strong>Hint:</strong> Use the function <span><span class="math inline">\(F\)</span></span> that on input a formula <span><span class="math inline">\(\varphi\)</span></span> and a string of the form <span><span class="math inline">\(1^t\)</span></span>, outputs <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(\varphi\)</span></span> is satisfiable and <span><span class="math inline">\(t=|\varphi|^{\log|\varphi|}\)</span></span>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p><em>Hint:</em> Prove and then use the fact that <span><span class="math inline">\(\mathbf{P}\)</span></span> <em>is</em> closed under complement.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:39:17</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_13_Cook_Levin.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
