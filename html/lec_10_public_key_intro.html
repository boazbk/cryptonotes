<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Public key cryptography</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Public key cryptography" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a></li><li class="chapter" data-level="1.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#counting-number-of-operations."><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash functions and random oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "bitcoin" problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The currency problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The bitcoin ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From proof of work to consensus on ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision resistance hash functions and creating short "unique" identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical constructions of cryptographic hash functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical random-ish functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some history</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions."><i class="fa fa-check"></i><b>7.4.3</b> The NSA and hash functions.</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs non-cryptographic hash functions:</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#an-lwe-based-encryption-scheme"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Public key cryptography</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_10_public_key_intro.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="public-key-cryptography" data-number="10">Public key cryptography</h1>
<p>People have been dreaming about heavier than air flight since at least the days of Leonardo Da Vinci (not to mention Icarus from the greek mythology). Jules Verne wrote with rather insightful details about going to the moon in 1865. But, as far as I know, in all the thousands of years people have been using secret writing, until about 50 years ago no one has considered the possibility of communicating securely without first exchanging a shared secret key. However, in the late 1960’s and early 1970’s, several people started to question this “common wisdom”.</p>
<p>Perhaps the most surprising of these visionaries was an undergraduate student at Berkeley named Ralph Merkle. In the fall of 1974 he wrote a <a href="http://www.merkle.com/1974/">project proposal</a> for his computer security course that while “it might seem intuitively obvious that if two people have never had the opportunity to prearrange an encryption method, then they will be unable to communicate securely over an insecure channel… I believe it is false”. The project proposal was rejected by his professor as “not good enough”. Merkle later submitted a paper to the communication of the ACM where he apologized for the lack of references since he was unable to find any mention of the problem in the scientific literature, and the only source where he saw the problem even <em>raised</em> was in a science fiction story. The paper was rejected with the comment that “Experience shows that it is extremely dangerous to transmit key information in the clear.” Merkle showed that one can design a protocol where Alice and Bob can use <span><span class="math inline">\(T\)</span></span> invocations of a hash function to exchange a key, but an adversary (in the random oracle model, though he of course didn’t use this name) would need roughly <span><span class="math inline">\(T^2\)</span></span> invocations to break it. He conjectured that it may be possible to obtain such protocols where breaking is <em>exponentially harder</em> than using them, but could not think of any concrete way to doing so.</p>
<p>We only found out much later that in the late 1960’s, a few years before Merkle, James Ellis of the British Intelligence agency GCHQ was <a href="http://cryptome.org/jya/ellisdoc.htm">having similar thoughts</a>. His curiosity was spurred by an old World-War II manuscript from Bell labs that suggested the following way that two people could communicate securely over a phone line. Alice would inject noise to the line, Bob would relay his messages, and then Alice would subtract the noise to get the signal. The idea is that an adversary over the line sees only the sum of Alice’s and Bob’s signals, and doesn’t know what came from what. This got James Ellis thinking whether it would be possible to achieve something like that digitally. As he later recollected, in 1970 he realized that in principle this should be possible, since he could think of an hypothetical black box <span><span class="math inline">\(B\)</span></span> that on input a “handle” <span><span class="math inline">\(\alpha\)</span></span> and plaintext <span><span class="math inline">\(p\)</span></span> would give a “ciphertext” <span><span class="math inline">\(c\)</span></span> and that there would be a secret key <span><span class="math inline">\(\beta\)</span></span> corresponding to <span><span class="math inline">\(\alpha\)</span></span>, such that feeding <span><span class="math inline">\(\beta\)</span></span> and <span><span class="math inline">\(c\)</span></span> to the box would recover <span><span class="math inline">\(p\)</span></span>. However, Ellis had no idea how to actually instantiate this box. He and others kept giving this question as a puzzle to bright new recruits until one of them, Clifford Cocks, came up in 1973 with a candidate solution loosely based on the factoring problem; in 1974 another GCHQ recruit, Malcolm Williamson, came up with a solution using modular exponentiation.</p>
<p>But among all those thinking of public key cryptography, probably the people who saw the furthest were two researchers at Stanford, Whit Diffie and Martin Hellman. They realized that with the advent of electronic communication, cryptography would find new applications beyond the military domain of spies and submarines. And they understood that in this new world of many users and point to point communication, cryptography would need to scale up. They envisioned an object which we now call “trapdoor permutation” though they called it “one way trapdoor function” or sometimes simply “public key encryption”. This is a collection of permutations <span><span class="math inline">\(\{ p_k \}\)</span></span> where <span><span class="math inline">\(p_k\)</span></span> is a permutation over (say) <span><span class="math inline">\(\{0,1\}^{|k|}\)</span></span>, and the map <span><span class="math inline">\((x,k)\mapsto p_k(x)\)</span></span> is efficiently computable <em>but</em> the reverse map <span><span class="math inline">\((k,y) \mapsto p_k^{-1}(y)\)</span></span> is computationally hard. Yet, there is also some secret key <span><span class="math inline">\(s(k)\)</span></span> (i.e., the “trapdoor”) such that using <span><span class="math inline">\(s(k)\)</span></span> it is possible to efficiently compute <span><span class="math inline">\(p^{-1}_k\)</span></span>. Their idea was that using such a trapdoor permutation, Alice who knows <span><span class="math inline">\(s(k)\)</span></span> would be able to publish <span><span class="math inline">\(k\)</span></span> on some public file such that everyone who wants to send her a message <span><span class="math inline">\(x\)</span></span> could do so by computing <span><span class="math inline">\(p_k(x)\)</span></span>. (While today we know, due to the work of Goldwasser and Micali, that such a deterministic encryption is not a good idea, at the time Diffie and Hellman had amazing intuitions but didn’t really have proper definitions of security.) But they didn’t stop there. They realized that protecting the <em>integrity</em> of communication is no less important than protecting its <em>secrecy</em>. Thus they imagined that Alice could “run encryption in reverse” in order to certify or <em>sign</em> messages. That is, given some message <span><span class="math inline">\(m\)</span></span>, Alice would send the value <span><span class="math inline">\(x=p_k^{-1}(h(m))\)</span></span> (for a hash function <span><span class="math inline">\(h\)</span></span>) as a way to certify that she endorses <span><span class="math inline">\(m\)</span></span>, and every person who knows <span><span class="math inline">\(k\)</span></span> could verify this by checking that <span><span class="math inline">\(p_k(x)=h(m)\)</span></span>.</p>
<p>However, Diffie and Hellman were in a position not unlike physicists who predicted that a certain particle should exist but without any experimental verification. Luckily they <a href="http://cr.yp.to/bib/1988/diffie.pdf">met Ralph Merkle</a>, and his ideas about a probabilistic <em>key exchange protocol</em>, together with a suggestion from their Stanford colleague <a href="https://profiles.stanford.edu/john-gill">John Gill</a>, inspired them to come up with what today is known as the <em>Diffie-Hellman Key Exchange</em> (which unbeknownst to them was found two years earlier at GCHQ by Malcolm Williamson). They published their paper <a href="https://www-ee.stanford.edu/~hellman/publications/24.pdf">“New Directions in Cryptography”</a> in 1976, and it is considered to have brought about the birth of modern cryptography. However, they still didn’t find their elusive trapdoor function. This was done the next year by Rivest, Shamir and Adleman who came up with the RSA trapdoor function, which through the framework of Diffie and Hellman yielded not just encryption but also signatures (this was essentially the same function discovered earlier by Clifford Cocks at GCHQ, though as far as I can tell Cocks, Ellis and Williamson did not realize the application to digital signatures). From this point on began a flurry of advances in cryptography which hasn’t really died down till this day.</p>
<h2 id="private-key-crypto-recap" data-number="10.1">Private key crypto recap</h2>
<p>Before we embark on the wonderful journey to <em>public key</em> cryptography, let’s briefly look back and see what we learned about <em>private key cryptography</em>. This material is mostly covered in Chapters 1 to 9 of the Katz Lindell (KL) book and Part I (Chapters 1-9) of the Boneh Shoup (BS) book. Now would be a good time for you to read the corresponding proofs in one or both of these books. It is often helpful to see the same proof presented in a slightly different way. Below is a review of some of the various reductions we saw in class, with pointers to the corresponding sections in these books.</p>
<ul>
<li>Pseudorandom generators (PRG) length extension (from <span><span class="math inline">\(n+1\)</span></span> output PRG to <span><span class="math inline">\(poly(n)\)</span></span> output PRG): KL 7.4.2, BS 3.4.2</li>
<li>PRG’s to pseudorandom functions (PRF’s): KL 7.5, BS 4.6</li>
<li>PRF’s to Chosen Plaintext Attack (CPA) secure encryption: KL 3.5.2, BS 5.5</li>
<li>PRF’s to secure Message Authentication Codes (MAC’s): KL 4.3, BS 6.3</li>
<li>MAC’s + CPA secure encryption to chosen ciphertext attack (CCA) secure encryption: BS 4.5.4, BS 9.4</li>
<li>Pseudorandom permutation (PRP’s) to CPA secure encryption / block cipher modes: KL 3.5.2, KL 3.6.2, BS 4.1, 4.4, 5.4</li>
<li>Hash function applications: fingerprinting, Merkle trees, passwords: KL 5.6, BS Chapter 8</li>
<li>Coin tossing over the phone: we saw a construction in class that used a <em>commitment scheme</em> built out of a pseudorandom generator. This is shown in BS 3.12, KL 5.6.5 shows an alternative construction using random oracles.</li>
<li>PRP’s from PRF’s: we only sketched the construction which can be found in KL 7.6 or BS 4.5</li>
</ul>
<p>One major point we did <em>not</em> talk about in this course was <em>one way functions</em>. The definition of a one way function is quite simple:</p>
<div id="owfdef" class="definition" title="One Way Functions" data-number="10.1" name="Definition 10.1 (One Way Functions) ">
<p>A function <span><span class="math inline">\(f:\{0,1\}^*\rightarrow\{0,1\}^*\)</span></span> is a <em>one way function</em> if it is efficiently computable and for every <span><span class="math inline">\(n\)</span></span> and a <span><span class="math inline">\(poly(n)\)</span></span> time adversary <span><span class="math inline">\(A\)</span></span>, the probability over <span><span class="math inline">\(x\leftarrow_R\{0,1\}^n\)</span></span> that <span><span class="math inline">\(A(f(x))\)</span></span> outputs <span><span class="math inline">\(x&#39;\)</span></span> such that <span><span class="math inline">\(f(x&#39;)=f(x)\)</span></span> is negligible.</p>
</div>
<p>The “OWF conjecture” is the conjecture that one way functions exist. It turns out to be a necessary and sufficient condition for much of private key cryptography. That is, the following theorem is known (by combining works of many people):</p>
<div id="privkeydef" class="theorem" title="One way functions and private key cryptography" data-number="10.1" name="Theorem 10.2 (One way functions and private key cryptography) ">
<p>The following are equivalent:<br />
* One way functions exist<br />
* Pseudorandom generators (with non-trivial stretch) exist<br />
* Pseudorandom functions exist<br />
* CPA secure private key encryptions exist<br />
* CCA secure private key encryptions exist<br />
* Message Authentication Codes exist<br />
* Commitment schemes exist</p>
</div>
<p>The key result in the proof of this theorem is the result of Hastad, Impagliazzo, Levin and Luby that if one way functions exist then pseudorandom generators exist. If you are interested in finding out more, Sections 7.2-7.4 in the KL book cover a special case of this theorem for the case that the one way function is a <em>permutation</em> on <span><span class="math inline">\(\{0,1\}^n\)</span></span> for every <span><span class="math inline">\(n\)</span></span>. This proof has been considerably simplified and quantitatively improved in works of Haitner, Holenstein, Reingold, Vadhan, Wee and Zheng. See <a href="http://people.seas.harvard.edu/~salil/research/CompEnt-abs.html">this talk of Salil Vadhan</a> for more on this. See also <a href="http://www.cs.princeton.edu/courses/archive/spring08/cos598D/scribe3.pdf">these lecture notes</a> from a Princeton seminar I gave on this topic (though the proof has been simplified since then by the above works).</p>
<div id="privkeyattacks" class="remark" title="Attacks on private key cryptosystems" data-number="10.1" name="Remark 10.3 (Attacks on private key cryptosystems) ">
<p>Another topic we did not discuss in depth is attacks on private key cryptosystems. These attacks often work by “opening the black box” and looking at the internal operation of block ciphers or hash functions. One then often assigns variables to various internal registers, and then we look to finding collections of inputs that would satisfy some non-trivial relation between those variables. This is a rather vague description, but you can read KL Section 6.2.6 on <em>linear</em> and <em>differential</em> cryptanalysis and BS Sections 3.7-3.9 and 4.3 for more information. See also <a href="http://www.cs.tau.ac.il/~tromer/SKC2006/">this course of Adi Shamir</a>. There is also the fascinating area of <em>side channel</em> attacks on both public and private key crypto.</p>
</div>
<div id="signaturesrem" class="remark" title="Digital Signatures" data-number="10.1" name="Remark 10.4 (Digital Signatures) ">
<p>We will discuss in this lecture <em>Digital signatures</em>, which are the public key analog of message authentication codes. Surprisingly, despite being a “public key” object, it is possible to base digital signatures on one-way functions (this is obtained using ideas of Lamport, Merkle, Goldwasser-Goldreich-Micali, Naor-Yung, and Rompel). However these constructions are not very efficient (and this may be inherent) and so in practice people use digital signatures that are built using similar techniques to those used for public key encryption.</p>
</div>
<h2 id="public-key-encryptions-definition" data-number="10.2">Public Key Encryptions: Definition</h2>
<p>We now discuss how we define security for public key encryption. As mentioned above, it took quite a while for cryptographers to arrive at the “right” definition, but in the interest of time we will skip ahead to what by now is the standard basic notion (see also <a href='#PKCfig'>Figure 10.1</a>):</p>
<figure>
<img src="../figure/pkenccartoon.png" alt="10.1: In a public key encryption, the receiver Bob generates a pair of keys (e,d), The encryption key e is used for encryption, and the decryption key is used for decryption. We call it a public key system since the security of the scheme does not rely on the adversary Eve not knowing the encryption key. Hence Bob can publicize the key e to a great many potential receivers, and still ensure confidentiality of the messages he receives." id="PKCfig" class="margin" /><figcaption>10.1: In a public key encryption, the receiver Bob generates a <em>pair</em> of keys <span><span class="math inline">\((e,d)\)</span></span>, The <em>encryption key</em> <span><span class="math inline">\(e\)</span></span> is used for encryption, and the <em>decryption key</em> is used for decryption. We call it a public key system since the security of the scheme does not rely on the adversary Eve not knowing the encryption key. Hence Bob can publicize the key <span><span class="math inline">\(e\)</span></span> to a great many potential receivers, and still ensure confidentiality of the messages he receives.</figcaption>
</figure>
<div id="pubkeydef" class="definition" title="Public key encryption" data-number="10.2" name="Definition 10.5 (Public key encryption) ">
<p>A triple of efficient algorithms <span><span class="math inline">\((G,E,D)\)</span></span> is a <em>public key encryption scheme</em> if it satisfies the following:<br />
</p>
<ul>
<li><span><span class="math inline">\(G\)</span></span> is a probabilistic algorithm known as the <em>key generation algorithm</em> that on input <span><span class="math inline">\(1^n\)</span></span> outputs a distribution over pair of keys <span><span class="math inline">\((e,d)\)</span></span>.<br />
</li>
<li><span><span class="math inline">\(E\)</span></span> is the <em>encryption algorithm</em> that takes a pair of inputs <span><span class="math inline">\(e,m\)</span></span> with <span><span class="math inline">\(m\in \{0,1\}^n\)</span></span> and outputs <span><span class="math inline">\(c=E_e(m)\)</span></span><br />
</li>
<li><span><span class="math inline">\(D\)</span></span> is the <em>decryption algorithm</em> that takes a pair of inputs <span><span class="math inline">\(d,c\)</span></span> and outputs <span><span class="math inline">\(m&#39;=D_d(c)\)</span></span>.<br />
</li>
<li>For every <span><span class="math inline">\(m\in\{0,1\}^n\)</span></span>, with probability <span><span class="math inline">\(1-negl(n)\)</span></span> over the choice of <span><span class="math inline">\((e,d)\)</span></span> output from <span><span class="math inline">\(G(1^n)\)</span></span> and the coins of <span><span class="math inline">\(E\)</span></span>,<span><span class="math inline">\(D\)</span></span>, <span><span class="math inline">\(D_d(E_e(m))=m\)</span></span>.<br />
</li>
</ul>
<p>We say that <span><span class="math inline">\((G,E,D)\)</span></span> is <em>CPA secure</em> every efficient adversary <span><span class="math inline">\(A\)</span></span> wins the following game with probability at most <span><span class="math inline">\(1/2+negl(n)\)</span></span>:</p>
<ul>
<li><span><span class="math inline">\((e,d) \leftarrow_R G(1^n)\)</span></span><br />
</li>
<li><span><span class="math inline">\(A\)</span></span> is given <span><span class="math inline">\(e\)</span></span> and outputs a pair of messages <span><span class="math inline">\(m_0,m_1 \in \{0,1\}^n\)</span></span>.<br />
</li>
<li><span><span class="math inline">\(A\)</span></span> is given <span><span class="math inline">\(c=E_e(m_b)\)</span></span> for <span><span class="math inline">\(b\leftarrow_R\{0,1\}\)</span></span>.<br />
</li>
<li><span><span class="math inline">\(A\)</span></span> outputs <span><span class="math inline">\(b&#39;\in\{0,1\}\)</span></span> and <em>wins</em> if <span><span class="math inline">\(b&#39;=b\)</span></span>.</li>
</ul>
</div>
<div id="section" class="pause" data-number="10.2" name="Pause">
<p>Despite it being a “chosen plaintext attack”, we don’t explicitly give <span><span class="math inline">\(A\)</span></span> access to the encryption oracle in the public key setting. Make sure you understand why giving it such access would not give it more power.</p>
</div>
<p>One metaphor for a public key encryption is a “self-locking lock” where you don’t need the key to <em>lock it</em> (but rather you simply push the shackle until it clicks and lock) but you do need the key to <em>unlock</em> it. So, if Alice generates <span><span class="math inline">\((e,d)=G(1^n)\)</span></span> then <span><span class="math inline">\(e\)</span></span> serves as the “lock” that can be used to <em>encrypt</em> messages for Alice while only <span><span class="math inline">\(d\)</span></span> can be used to <em>decrypt</em> the messages. Another way to think about it is that <span><span class="math inline">\(e\)</span></span> is a “hobbled key” that can be used for only some of the functions of <span><span class="math inline">\(d\)</span></span>.</p>
<h3 id="the-obfuscation-paradigm" data-number="10.2.1">The obfuscation paradigm</h3>
<p>Why would someone imagine that such a magical object could exist? The writing of both James Ellis as well as Diffie and Hellman suggests that their thought process was roughly as follows. You imagine a “magic black box” <span><span class="math inline">\(B\)</span></span> such that if all parties have access to <span><span class="math inline">\(B\)</span></span> then we could get a public key encryption scheme. Now if public key encryption was impossible it would mean that for every possible program <span><span class="math inline">\(P\)</span></span> that computes the functionality of <span><span class="math inline">\(B\)</span></span>, if we distribute the code of <span><span class="math inline">\(P\)</span></span> to all parties then we don’t get a secure encryption scheme. That means that <em>no matter what program <span><span class="math inline">\(P\)</span></span> the adversary gets</em>, she will always be able to get some information out of that code that helps break the encryption, even though she wouldn’t have been able to break it if <span><span class="math inline">\(P\)</span></span> was a black box. Now intuitively understanding arbitrary code is a very hard problem, so Diffie and Hellman imagined that it might be possible to take this ideal <span><span class="math inline">\(B\)</span></span> and compile it to some sufficiently low level assembly language so that it would behave as a “virtual black box”. In particular, if you took, say, the encoding procedure <span><span class="math inline">\(m \mapsto p_k(m)\)</span></span> of a block cipher with a particular key <span><span class="math inline">\(k\)</span></span>, and ran it through an optimizing compiler you might hope that while it would be possible to perform this map using the resulting executable, it will be hard to extract <span><span class="math inline">\(k\)</span></span> from it, and hence could treat this code as a “public key”. This suggests the following approach for getting an encryption scheme:</p>
<blockquote>
<p><strong>“Obfuscation based public key encyption”:</strong></p>
<p><strong>Ingredients:</strong> <em>(i)</em> A pseudorandom permutation collection <span><span class="math inline">\(\{ p_k \}_{k\in \{0,1\}^*}\)</span></span> where for every <span><span class="math inline">\(k\in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(p_k:\{0,1\}^n \rightarrow \{0,1\}^n\)</span></span>, <em>(ii)</em> An “obfuscating compiler” polynomial-time computable <span><span class="math inline">\(O:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> such that for every circuit <span><span class="math inline">\(C\)</span></span>, <span><span class="math inline">\(O(C)\)</span></span> is a circuit that computes the same function as <span><span class="math inline">\(C\)</span></span></p>
<ul>
<li><p><em>Key Generation:</em> The private key is <span><span class="math inline">\(k \leftarrow_R \{0,1\}^n\)</span></span>, the public key is <span><span class="math inline">\(E=O(C_k)\)</span></span> where <span><span class="math inline">\(C_k\)</span></span> is the circuit that maps <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> to <span><span class="math inline">\(p_k(x)\)</span></span>.</p></li>
<li><p><em>Encryption:</em> To encrypt <span><span class="math inline">\(m\in \{0,1\}^n\)</span></span> with public key <span><span class="math inline">\(E\)</span></span>, choose <span><span class="math inline">\(\ensuremath{\mathit{IV}} \leftarrow_R \{0,1\}^n\)</span></span> and output <span><span class="math inline">\((\ensuremath{\mathit{IV}}, E(x \oplus \ensuremath{\mathit{IV}}))\)</span></span>.</p></li>
<li><p><em>Decryption:</em> To decrypt <span><span class="math inline">\((\ensuremath{\mathit{IV}},y)\)</span></span> with key <span><span class="math inline">\(k\)</span></span>, output <span><span class="math inline">\(\ensuremath{\mathit{IV}} \oplus p_k^{-1}(y)\)</span></span>.</p></li>
</ul>
</blockquote>
<p>Diffie and Hellman couldn’t really find a way to make this work, but it convinced them this notion of public key is not <em>inherently impossible</em>. This concept of compiling a program into a functionally equivalent but “inscrutable” form is known as <em>software obfuscation</em> . It had turned out to be quite a tricky object to both define formally and achieve, but it serves as a very good intuition as to what can be achieved, even if, as the random oracle, this intuition can sometimes be too optimistic. (Indeed, if software obfuscation was possible then we could obtain a “random oracle like” hash function by taking the code of a function <span><span class="math inline">\(f_k\)</span></span> chosen from a PRF family and compiling it through an obfuscating compiler.)</p>
<p>We will not formally define obfuscators yet, but on intuitive level it would be a compiler that takes a program <span><span class="math inline">\(P\)</span></span> and maps into a program <span><span class="math inline">\(P&#39;\)</span></span> such that:</p>
<ul>
<li><span><span class="math inline">\(P&#39;\)</span></span> is not much slower/bigger than <span><span class="math inline">\(P\)</span></span> (e.g., as a Boolean circuit it would be at most polynomially larger)</li>
<li><span><span class="math inline">\(P&#39;\)</span></span> is functionally equivalent to <span><span class="math inline">\(P\)</span></span>, i.e., <span><span class="math inline">\(P&#39;(x)=P(x)\)</span></span> for every input <span><span class="math inline">\(x\)</span></span>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li><span><span class="math inline">\(P&#39;\)</span></span> is “inscrutable” in the sense that seeing the code of <span><span class="math inline">\(P&#39;\)</span></span> is not more informative than getting <em>black box access</em> to <span><span class="math inline">\(P\)</span></span>.</li>
</ul>
<p>Let me stress again that there is no known construction of obfuscators achieving something similar to this definition. In fact, the most natural formalization of this definition is <em>impossible</em> to achieve (as we might see later in this course). Only very recently (exciting!) progress was finally made towards obfuscators-like notions strong enough to achieve these and other applications, and there are some significant caveats (see <a href="https://eprint.iacr.org/2016/210">my survey on this topic</a>).</p>
<p>However, when trying to stretch your imagination to consider the amazing possibilities that could be achieved in cryptography, it is not a bad heuristic to first ask yourself what could be possible if only everyone involved had access to a magic black box. It certainly worked well for Diffie and Hellman.</p>
<h2 id="some-concrete-candidates" data-number="10.3">Some concrete candidates:</h2>
<p>We would have loved to prove a theorem of the form:</p>
<blockquote>
<p><strong>“Theorem”:</strong> If the PRG conjecture is true then there exists a CPA-secure public key encryption.</p>
</blockquote>
<p>This would have meant that we do not need to assume anything more than the already minimal notion of pseudorandom generators (or equivalently, one way functions) to obtain public key cryptography. Unfortunately, no such result is known (and this may be <a href="https://www.cs.virginia.edu/~mohammad/files/papers/MerkleFull.pdf">inherent</a>). The kind of results we know have the following form:</p>
<blockquote>
<p><strong>Theorem:</strong> If problem <span><span class="math inline">\(X\)</span></span> is hard then there exists a CPA-secure public key encryption.</p>
</blockquote>
<p>Where <span><span class="math inline">\(X\)</span></span> is some problem that people have tried to solve and couldn’t. Thus we have various <em>candidates</em> for public key encryption and we fervently hope that at least one of them is actually secure. The <a href="https://eprint.iacr.org/2017/365.pdf">dirty little secret</a> of cryptography is that we actually don’t have that many candidates. We really have only two well studied families.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> One is the “group theoretic” family that relies on the difficulty of the discrete logarithm (over modular arithmetic or elliptic curves) or the integer factoring problem. The other is the “coding/lattice theoretic” family that relies on the difficulty of solving noisy linear equations or related problems such as finding short vectors in a <em>lattice</em> and solving instances of the “knapsack” problem. Moreover, problems from the first family are known to be <em>efficiently solvable</em> in a computational model known as “quantum computing”. If large scale physical devices that simulate this model, known as <em>quantum computers</em>, then they could break all cryptosystems relying on these problems and we’ll be down to only having a <em>single</em> family of candidate public key encryption schemes.</p>
<p>We will start by describing cryptosystems based on the first family (which was discovered before the other, as well as much more widely implemented), and in future lectures talk about the second family.</p>
<h3 id="diffie-hellman-encryption-aka-el-gamal" data-number="10.3.1">Diffie-Hellman Encryption (aka El-Gamal)</h3>
<p>The Diffie-Hellman public key system is built on the presumed difficulty of the <em>discrete logarithm problem</em>:</p>
<p>For any number <span><span class="math inline">\(p\)</span></span>, let <span><span class="math inline">\(\Z_p\)</span></span> be the set of numbers <span><span class="math inline">\(\{0,\ldots,p-1\}\)</span></span> where addition and multiplication are done modulo <span><span class="math inline">\(p\)</span></span>. We will think of numbers <span><span class="math inline">\(p\)</span></span> that are of magnitude roughly <span><span class="math inline">\(2^n\)</span></span>, so they can be described with about <span><span class="math inline">\(n\)</span></span> bits. We can clearly multiply and add such numbers modulo <span><span class="math inline">\(p\)</span></span> in <span><span class="math inline">\(poly(n)\)</span></span> time. If <span><span class="math inline">\(g\in \Z_p\)</span></span> and <span><span class="math inline">\(a\)</span></span> is any natural number, we can define <span><span class="math inline">\(g^a\)</span></span> to be simply <span><span class="math inline">\(g\cdot g \cdots g\)</span></span> (<span><span class="math inline">\(a\)</span></span> times). A priori one might think that it would take <span><span class="math inline">\(a\cdot poly(n)\)</span></span> time to compute <span><span class="math inline">\(g^a\)</span></span>, which might be exponential if <span><span class="math inline">\(a\)</span></span> itself is roughly <span><span class="math inline">\(2^n\)</span></span>. However, we can compute this in <span><span class="math inline">\(poly((\log a) \cdot n)\)</span></span> time using the <em>repeated squaring trick</em>. The idea is that if <span><span class="math inline">\(a=2^{\ell}\)</span></span> then we can compute <span><span class="math inline">\(g^a\)</span></span> in <span><span class="math inline">\(\ell\)</span></span> by squaring <span><span class="math inline">\(g\)</span></span> <span><span class="math inline">\(\ell\)</span></span> times, and a general <span><span class="math inline">\(a\)</span></span> can be decomposed into powers of two using the binary representation.</p>
<p>The <em>discrete logarithm</em> problem is the problem of computing, given <span><span class="math inline">\(g,h \in \Z_p\)</span></span>, a number <span><span class="math inline">\(a\)</span></span> such that <span><span class="math inline">\(g^a=h\)</span></span>. If such a solution <span><span class="math inline">\(a\)</span></span> exists then there is always also a solution of size at most <span><span class="math inline">\(p\)</span></span> (can you see why?) and so the solution can be represented using <span><span class="math inline">\(n\)</span></span> bits. However, currently the best known algorithm for computing the discrete logarithm run in time roughly <span><span class="math inline">\(2^{n^{1/3}}\)</span></span> which currently becomes prohibitively expensive when <span><span class="math inline">\(p\)</span></span> is a prime of length about <span><span class="math inline">\(2048\)</span></span> bits.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<p>John Gill suggested to Diffie and Hellman that modular exponentiation can be a good source for the kind of “easy-to-compute but hard-to-invert” functions they were looking for. Diffie and Hellman based a public key encryption scheme as follows:</p>
<ul>
<li>The <em>key generation algorithm</em>, on input <span><span class="math inline">\(n\)</span></span>, samples a prime number <span><span class="math inline">\(p\)</span></span> of <span><span class="math inline">\(n\)</span></span> bits description (i.e., between <span><span class="math inline">\(2^{n-1}\)</span></span> to <span><span class="math inline">\(2^n\)</span></span>), a number <span><span class="math inline">\(g\leftarrow_R \Z_p\)</span></span> and <span><span class="math inline">\(a \leftarrow_R \{0,\ldots,p-1\}\)</span></span>. We also sample a hash function <span><span class="math inline">\(H:\{0,1\}^n\rightarrow\{0,1\}^\ell\)</span></span>. The public key <span><span class="math inline">\(e\)</span></span> is <span><span class="math inline">\((p,g,g^a,H)\)</span></span> while the secret key <span><span class="math inline">\(d\)</span></span> is <span><span class="math inline">\(a\)</span></span>.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
</ul>
<ul>
<li><p>The <em>encryption algorithm</em>, on input a message <span><span class="math inline">\(m \in \{0,1\}^\ell\)</span></span> and a public key <span><span class="math inline">\(e=(p,g,h,H)\)</span></span> will choose a random <span><span class="math inline">\(b\leftarrow_R \{0,\ldots,p-1\}\)</span></span>, and output <span><span class="math inline">\((g^b,H(h^b)\oplus m)\)</span></span>.</p></li>
<li><p>The <em>decryption algorithm</em>, on input a ciphertext <span><span class="math inline">\((f,y)\)</span></span> and the secret key, will output <span><span class="math inline">\(H(f^a) \oplus y\)</span></span>.</p></li>
</ul>
<p>The correctness of the decryption algorithm follows from the fact that <span><span class="math inline">\((g^a)^b = (g^b)^a = g^{ab}\)</span></span> and hence <span><span class="math inline">\(H(h^b)\)</span></span> computed by the encryption algorithm is the same as the value <span><span class="math inline">\(H(f^a)\)</span></span> computed by the decryption algorithm. A simple relation between the discrete logarithm and the Diffie-Hellman system is the following:</p>
<div id="dhinseclem" class="lemma" data-number="10.3.1" name="Lemma 10.6">
<p>If there is a polynomial time algorithm for the discrete logarithm problem then the Diffie-Hellman system is <em>insecure</em>.</p>
</div>
<div id="section-1" class="proof" data-ref="dhinseclem" data-number="10.3.1" name="Proof">
<p>Using a discrete logarithm algorithm, we can compute the private key <span><span class="math inline">\(a\)</span></span> from the parameters <span><span class="math inline">\(p,g,g^a\)</span></span> present in the public key, and clearly once we know the private key we can decrypt any message of our choice.</p>
</div>
<p>Unfortunately, no such result is known in the other direction. However in the random oracle model, we can prove that this protocol is secure assuming the task of computing <span><span class="math inline">\(g^{ab}\)</span></span> from <span><span class="math inline">\(g^a\)</span></span> and <span><span class="math inline">\(g^b\)</span></span> (which is now known as the <em>Diffie-Hellman problem</em>) is hard.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>
<blockquote>
<p><strong>Computational Diffie-Hellman Assumption:</strong> Let <span><span class="math inline">\(\mathbb{G}\)</span></span> be a group elements of which can be described in <span><span class="math inline">\(n\)</span></span> bits, with an associative and commutative multiplication operation that can be computed in <span><span class="math inline">\(poly(n)\)</span></span> time. The <em>Computational Diffie-Hellman (CDH)</em> assumption holds with respect to the group <span><span class="math inline">\(\mathbb{G}\)</span></span> if for every generator (see below) <span><span class="math inline">\(g\)</span></span> of <span><span class="math inline">\(\mathbb{G}\)</span></span> and efficient algorithm <span><span class="math inline">\(A\)</span></span>, the probability that on input <span><span class="math inline">\(g,g^a,g^b\)</span></span>, <span><span class="math inline">\(A\)</span></span> outputs the element <span><span class="math inline">\(g^{ab}\)</span></span> is negligible as a function of <span><span class="math inline">\(n\)</span></span>.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>
</blockquote>
<p>In particular we can make the following conjecture:</p>
<blockquote>
<p><strong>Computational Diffie-Hellman Conjecture for mod prime groups:</strong> For a random <span><span class="math inline">\(n\)</span></span>-bit prime and random <span><span class="math inline">\(g \in \mathbb{Z}_p\)</span></span>, the CDH holds with respect to the group <span><span class="math inline">\(\mathbb{G} = \{ g^a \mod p \;| a\in \mathbb{Z} \}\)</span></span>.</p>
<p>That is, for every polynomial <span><span class="math inline">\(q:\N \rightarrow \N\)</span></span>, if <span><span class="math inline">\(n\)</span></span> is large enough, then with probability at least <span><span class="math inline">\(1-1/q(n)\)</span></span> over the choice of a uniform prime <span><span class="math inline">\(p\in [2^n]\)</span></span> and <span><span class="math inline">\(g\in \Z_p\)</span></span>, for every circuit <span><span class="math inline">\(A\)</span></span> of size at most <span><span class="math inline">\(q(n)\)</span></span>, the probability that <span><span class="math inline">\(A(g,p,g^a,g^b)\)</span></span> outputs <span><span class="math inline">\(h\)</span></span> such that <span><span class="math inline">\(g^{ab} = h \mod p\)</span></span> is at most <span><span class="math inline">\(1/q(n)\)</span></span> where the probability is taken over <span><span class="math inline">\(a,b\)</span></span> chosen at random in <span><span class="math inline">\(\Z_p\)</span></span>.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p>
</blockquote>
<div id="section-2" class="pause" data-number="10.3.1" name="Pause">
<p>Please take your time to re-read the following conjecture until you are sure you understand what it means. Victor Shoup’s excellent and online available book <a href="http://www.shoup.net/ntb/">A Computational Introduction to Number Theory and Algebra</a> has an in depth treatment of groups, generators, and the discrete log and Diffie-Hellman problem. See also Chapters 10.4 and 10.5 in the Boneh-Shoup book, and Chapters 8.3 and 11.4 in the Katz-Lindell book.</p>
</div>
<div id="DHROMthm" class="theorem" title="Diffie-Hellman security in Random Oracle Model" data-number="10.3.1" name="Theorem 10.7 (Diffie-Hellman security in Random Oracle Model) ">
<p>Suppose that the Computational Diffie-Hellman Conjecture for mod prime groups is true. Then, the Diffie-Hellman public key encryption is CPA secure in the random oracle model.</p>
</div>
<div id="section-3" class="proof" data-ref="DHROMthm" data-number="10.3.1" name="Proof">
<p>For CPA security we need to prove that (for fixed <span><span class="math inline">\(\mathbb{G}\)</span></span> of size <span><span class="math inline">\(p\)</span></span> and random oracle <span><span class="math inline">\(H\)</span></span>) the following two distributions are computationally indistinguishable for every two strings <span><span class="math inline">\(m,m&#39; \in \{0,1\}^\ell\)</span></span>:</p>
<ul>
<li><span><span class="math inline">\((g^a,g^b,H(g^{ab})\oplus m)\)</span></span> for <span><span class="math inline">\(a,b\)</span></span> chosen uniformly and independently in <span><span class="math inline">\(\Z_{p}\)</span></span>.<br />
</li>
<li><span><span class="math inline">\((g^a,g^b,H(g^{ab})\oplus m&#39;)\)</span></span> for <span><span class="math inline">\(a,b\)</span></span> chosen uniformly and independently in <span><span class="math inline">\(\Z_{p}\)</span></span>.</li>
</ul>
<p>(can you see why this implies CPA security? you should pause here and verify this!)</p>
<p>We make the following claim:</p>
<p><strong>CLAIM:</strong> For a fixed <span><span class="math inline">\(\mathbb{G}\)</span></span> of size <span><span class="math inline">\(p\)</span></span>, generator <span><span class="math inline">\(g\)</span></span> for <span><span class="math inline">\(\mathbb{G}\)</span></span>, and given random oracle <span><span class="math inline">\(H\)</span></span>, if there is a size <span><span class="math inline">\(T\)</span></span> distinguisher <span><span class="math inline">\(A\)</span></span> with <span><span class="math inline">\(\epsilon\)</span></span> advantage between the distribution <span><span class="math inline">\((g^a,g^b,H(g^{ab}))\)</span></span> and the distribution <span><span class="math inline">\((g^a,g^b,U_\ell)\)</span></span> (where <span><span class="math inline">\(a,b\)</span></span> are chosen uniformly and independently in <span><span class="math inline">\(\Z_{p}\)</span></span>) then there is a size <span><span class="math inline">\(poly(T)\)</span></span> algorithm <span><span class="math inline">\(A&#39;\)</span></span> to solve the Diffie-Hellman problem with respect to <span><span class="math inline">\(\mathbb{G},g\)</span></span> with success at least <span><span class="math inline">\(\epsilon\)</span></span>. That is, for random <span><span class="math inline">\(a,b \in \Z_p\)</span></span>, <span><span class="math inline">\(A&#39;(g,g^a,g^b)=g^{ab}\)</span></span> with probability at least <span><span class="math inline">\(\epsilon/(2T)\)</span></span>.</p>
<p><strong>Proof of claim:</strong> The proof is simple. We claim that under the assumptions above, <span><span class="math inline">\(a\)</span></span> makes the query <span><span class="math inline">\(g^{ab}\)</span></span> to its oracle <span><span class="math inline">\(H\)</span></span> with probability at least <span><span class="math inline">\(\epsilon/2\)</span></span> since otherwise, by the “lazy evaluation” paradigm, we can assume that <span><span class="math inline">\(H(g^{ab})\)</span></span> is chosen independently at random after <span><span class="math inline">\(A\)</span></span>’s attack is completed and hence (conditioned on the adversary not making that querty), the value <span><span class="math inline">\(H(g^{ab})\)</span></span> is indistinguishable from a uniform output. Therefore, on input <span><span class="math inline">\(g,g^a,g^b\)</span></span>, <span><span class="math inline">\(A&#39;\)</span></span> can simulate <span><span class="math inline">\(A\)</span></span> and simply output one of the at most <span><span class="math inline">\(T\)</span></span> queries that <span><span class="math inline">\(A\)</span></span> makes to <span><span class="math inline">\(H\)</span></span> at random, and will be successful with probability at least <span><span class="math inline">\(\epsilon/(2T)\)</span></span>.</p>
<p>Now given the claim, we can complete the proof of security via the following hybrids. Define the following “hybrid” distributions (where in all cases <span><span class="math inline">\(a,b\)</span></span> are chosen uniformly and independently in <span><span class="math inline">\(\Z_{p}\)</span></span>):</p>
<ul>
<li><span><span class="math inline">\(H_0\)</span></span>: <span><span class="math inline">\((g^a,g^b,H(g^{ab}) \oplus m)\)</span></span><br />
</li>
<li><span><span class="math inline">\(H_1\)</span></span>: <span><span class="math inline">\((g^a,g^b,U_\ell \oplus m)\)</span></span><br />
</li>
<li><span><span class="math inline">\(H_2\)</span></span>: <span><span class="math inline">\((g^a,g^b,U_\ell \oplus m&#39;)\)</span></span><br />
</li>
<li><span><span class="math inline">\(H_3\)</span></span>: <span><span class="math inline">\((g^a,g^b,H(g^{ab}) \oplus m&#39;)\)</span></span></li>
</ul>
<p>The claim implies that <span><span class="math inline">\(H_0 \approx H_1\)</span></span>. Indeed otherwise we could transform a distinguisher <span><span class="math inline">\(T\)</span></span> between <span><span class="math inline">\(H_0\)</span></span> and <span><span class="math inline">\(H_1\)</span></span> to a distinguisher <span><span class="math inline">\(T&#39;\)</span></span> violating the claim by letting <span><span class="math inline">\(T&#39;(h,h&#39;,z) = T(h,h&#39;,z \oplus m)\)</span></span>.</p>
<p>The distributions <span><span class="math inline">\(H_1\)</span></span> and <span><span class="math inline">\(H_2\)</span></span> are <em>identical</em> by the same argument as the security of the one time pad (since <span><span class="math inline">\(U_\ell \oplus m\)</span></span> is identical to <span><span class="math inline">\(U_\ell\)</span></span>).</p>
<p>The distributions <span><span class="math inline">\(H_2\)</span></span> and <span><span class="math inline">\(H_3\)</span></span> are computationally indistinguishable by the same argument that <span><span class="math inline">\(H_0 \approx H_1\)</span></span>.</p>
<p>Together these imply that <span><span class="math inline">\(H_0 \approx H_3\)</span></span> which yields the CPA security of the scheme.</p>
</div>
<div id="curverem" class="remark" title="Elliptic curve cryptography" data-number="10.3.1" name="Remark 10.8 (Elliptic curve cryptography) ">
<p>As mentioned, the Diffie-Hellman systems can be run with many variants of Abelian groups. Of course, for some of those groups the discrete logarithm problem might be easy, and so they would be inappropriate to use for this system. One variant that has been proposed is <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">elliptic curve cryptography</a>. This is a group consisting of points of the form <span><span class="math inline">\((x,y,z)\in \Z_p^3\)</span></span> that satisfy a certain equation, and multiplication can be defined according in a certain way. The main advantage of elliptic curve cryptography is that the best known algorithms run in time <span><span class="math inline">\(2^{\approx n}\)</span></span> as opposed to <span><span class="math inline">\(2^{\approx n^{1/3}}\)</span></span> which allows for much shorter keys. Unfortunately, elliptic curve cryptography is just as susceptible to quantum algorithms as the discrete logarithm problem over <span><span class="math inline">\(\Z_p\)</span></span>.</p>
</div>
<div id="DHKErem" class="remark" title="Encryption vs Key Exchange and El Gamal" data-number="10.3.1" name="Remark 10.9 (Encryption vs Key Exchange and El Gamal) ">
<p>In most of the cryptography literature the protocol above is called the <em>Diffie-Hellman Key Exchange</em> protocol, and when considered as a public key system it is sometimes known as <em>ElGamal encryption</em>.<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> The reason for this mostly stems from the early confusion on what are the right security definitions. Diffie and Hellman thought of encryption as a <em>deterministic</em> process and so they called their scheme a “key exchange protocol”. The work of Goldwasser and Micali showed that encryption must be probabilistic for security. Also, because of efficiency considerations, these days public key encryption is mostly used as a mechanism to exchange a key for a private key encryption, that is then used for the bulk of the communication. Together this means that there is not much point in distinguishing between a two message key exchange algorithm and a public key encryption.</p>
</div>
<h3 id="sampling-random-primes" data-number="10.3.2">Sampling random primes</h3>
<p>To sample a random <span><span class="math inline">\(n\)</span></span> bit prime one can sample a random number <span><span class="math inline">\(0 \leq p &lt; 2^n\)</span></span> and then test if <span><span class="math inline">\(p\)</span></span> is prime. If it is not prime, then we can sample a new random number again. To make this work we need to show two properties:</p>
<p><em>Efficient testing:</em> That there is a <span><span class="math inline">\(poly(n)\)</span></span> time algorithm to test whether an <span><span class="math inline">\(n\)</span></span> bit number is a prime. It turns out that there are such <a href="https://en.wikipedia.org/wiki/Primality_test">known algorithms</a>. <em>Randomized</em> algorithm have been known since the 1970’s. Moreover in a 2002 breakthrough, <a href="https://goo.gl/nycWFA">Manindra Agrawal, Neeraj Kayal, and Nitin Saxena</a> (a professor and two undergraduate students from the Indian Institute of Technology Kanpur) came up with the first deterministic polynomial time algorithm for testing primality.</p>
<p><em>Prime density:</em> That the probability that a random <span><span class="math inline">\(n\)</span></span> bit number is prime is at least <span><span class="math inline">\(1/poly(n)\)</span></span>. This probability is in fact <span><span class="math inline">\(1/\ln(2^n)=\Omega(1/n)\)</span></span> by the <a href="https://goo.gl/ChrXJY">Prime Number Theorem</a>. However, for the sake of completeness, we sketch below a simple argument showing the probability is at least <span><span class="math inline">\(\Omega(1/n^2)\)</span></span>.</p>
<div id="primedensitylem" class="lemma" data-number="10.3.2" name="Lemma 10.10">
<p>The number of primes between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(N\)</span></span> is <span><span class="math inline">\(\Omega(N/\log N)\)</span></span>.</p>
</div>
<div id="section-4" class="proof" data-ref="primedensitylem" data-number="10.3.2" name="Proof">
<p>Recall that the <em>least common multiple (LCM)</em> of two or more <span><span class="math inline">\(a_1,\ldots,a_t\)</span></span> is the smallest number that is a multiple of all of the <span><span class="math inline">\(a_i\)</span></span>’s. One way to compute the LCM of <span><span class="math inline">\(a_1,\ldots,a_t\)</span></span> is to take the prime factorizations of all the <span><span class="math inline">\(a_i\)</span></span>’s, and then the LCM is the product that all the primes that appear in these factorizations, with the highest power that they appear in. Let <span><span class="math inline">\(k\)</span></span> be the number of primes between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(N\)</span></span>. The lemma will follow from the following two claims:</p>
<p><strong>CLAIM 1:</strong> <span><span class="math inline">\(\ensuremath{\mathit{LCM}}(1,\ldots,N) \leq N^k\)</span></span>.</p>
<p><strong>CLAIM 2:</strong> If <span><span class="math inline">\(N\)</span></span> is odd then <span><span class="math inline">\(\ensuremath{\mathit{LCM}}(1,\ldots,N) \geq 2^{N-1}\)</span></span>.</p>
<p>The two claim immediately imply the result since they imply that <span><span class="math inline">\(2^N \leq N^k\)</span></span>, and taking logs we get that <span><span class="math inline">\(N-2 \leq k \log N\)</span></span> or <span><span class="math inline">\(k \geq (N-2)/\log N\)</span></span>. (We can assume that <span><span class="math inline">\(N\)</span></span> is odd without of loss of generality, since changing from <span><span class="math inline">\(N\)</span></span> to <span><span class="math inline">\(N+1\)</span></span> can change the number of primes by at most one.) Thus all that is left is to prove the two claims.</p>
<p><strong>Proof of CLAIM 1:</strong> Let <span><span class="math inline">\(p_1,\ldots,p_k\)</span></span> be all the prime numbers between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(N\)</span></span>, and let <span><span class="math inline">\(e_i\)</span></span> be the largest integer such that <span><span class="math inline">\(p_i^{e_i} \leq N\)</span></span> and <span><span class="math inline">\(L = p_1^{e_1} \cdots p_k^{e_k}\)</span></span>. Since <span><span class="math inline">\(L\)</span></span> is the product of <span><span class="math inline">\(k\)</span></span> terms, each of size at most <span><span class="math inline">\(N\)</span></span>, <span><span class="math inline">\(L \leq N^k\)</span></span>. But we claim that every number <span><span class="math inline">\(1 \leq a \leq N\)</span></span> divides <span><span class="math inline">\(L\)</span></span>. Indeed, every prime <span><span class="math inline">\(p\)</span></span> in the prime factorization of <span><span class="math inline">\(a\)</span></span> is one of the <span><span class="math inline">\(p_i\)</span></span>’s, and since <span><span class="math inline">\(a \leq N\)</span></span>, the power in which <span><span class="math inline">\(p\)</span></span> appears in <span><span class="math inline">\(a\)</span></span> is at most <span><span class="math inline">\(e_i\)</span></span>. By the definition of the least common multiple, this means that <span><span class="math inline">\(\ensuremath{\mathit{LCM}}(1,\ldots,N) \leq L\)</span></span>. QED (CLAIM 1)</p>
<p><strong>Proof of CLAIM 2:</strong> Consider the integral <span><span class="math inline">\(I=\int_0^1 x^{(N-1)/2}(1-x)^{(N-1)/2} dx\)</span></span>. This is clearly some positive number and so <span><span class="math inline">\(I&gt;0\)</span></span>. On one hand, for every <span><span class="math inline">\(x\)</span></span> between zero and one, <span><span class="math inline">\(x(1-x) \leq 1/4\)</span></span> and hence <span><span class="math inline">\(I\)</span></span> is at most <span><span class="math inline">\(4^{-(N-1)/2}=2^{-N+1}\)</span></span>. On the other hand, the polynomial <span><span class="math inline">\(x^{N/2}(1-x)^{N/2}\)</span></span> is some polynomial of degree at most <span><span class="math inline">\(N-1\)</span></span> with integer coefficients, and so <span><span class="math inline">\(I=\sum_{k=1}^{N-1} C_k \int_0^1 x^k dx\)</span></span> for some integer coefficients <span><span class="math inline">\(C_1,\ldots,C_{N-1}\)</span></span>. Since <span><span class="math inline">\(\int_0^1 x^k = \tfrac{1}{k+1}\)</span></span>, we see that <span><span class="math inline">\(I\)</span></span> is a sum of fractions with integer numerators and with denominators that are at most <span><span class="math inline">\(N\)</span></span>. Since all the denominators are at most <span><span class="math inline">\(N\)</span></span> and <span><span class="math inline">\(I&gt;0\)</span></span>, it follows that <span><span class="math inline">\(I \geq \tfrac{1}{LCM(1,\ldots,N)}\)</span></span>, and so <span>
<div class='myequationbox'><span class="math display">\[2^{-N+1} \geq I \geq \tfrac{1}{LCM(1,\ldots,N)}\]</span></div></span> which implies <span><span class="math inline">\(\ensuremath{\mathit{LCM}}(1,\ldots,N) \leq 2^{N-1}\)</span></span>. QED (CLAIM 2 and hence lemma)</p>
</div>
<h3 id="a-little-bit-of-group-theory." data-number="10.3.3">A little bit of group theory.</h3>
<p>If you haven’t seen group theory, it might be useful for you to do a quick review. We will not use much group theory and mostly use the theory of finite commutative (also known as Abelian) groups (in fact often <em>cyclic</em>) which are such a baby version that it might not be considered true “group theory” by many group theorists. Shoup’s <a href="http://www.shoup.net/ntb/">excellent book</a> contains everything we need to know (and much more than that). What you need to remember is the following:</p>
<ul>
<li><p>A <em>finite commutative group</em> <span><span class="math inline">\(\mathbb{G}\)</span></span> is a finite set together with a multiplication operation that satisfies <span><span class="math inline">\(a\cdot b = b\cdot a\)</span></span> and <span><span class="math inline">\((a\cdot b)\cdot c = (a\cdot b)\cdot c)\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(\mathbb{G}\)</span></span> has a special element known as <span><span class="math inline">\(1\)</span></span>, where <span><span class="math inline">\(g1=1g=g\)</span></span> for every <span><span class="math inline">\(g\in\mathbb{G}\)</span></span> and for every <span><span class="math inline">\(g\in \mathbb{G}\)</span></span> there exists an element <span><span class="math inline">\(g^{-1}\in \mathbb{G}\)</span></span> such that <span><span class="math inline">\(gg^{-1}=1\)</span></span>.</p></li>
<li><p>For every <span><span class="math inline">\(g\in \mathbb{G}\)</span></span>, the <em>order</em> of <span><span class="math inline">\(g\)</span></span>, denoted <span><span class="math inline">\(order(g)\)</span></span>, is the smallest positive integer <span><span class="math inline">\(a\)</span></span> such that <span><span class="math inline">\(g^a=1\)</span></span>.</p></li>
</ul>
<p>The following basic facts are all not too hard to prove and would be useful exercises:</p>
<ul>
<li><p>For every <span><span class="math inline">\(g\in \mathbb{G}\)</span></span>, the map <span><span class="math inline">\(a \mapsto g^a\)</span></span> is a <span><span class="math inline">\(k\)</span></span> to <span><span class="math inline">\(1\)</span></span> map from <span><span class="math inline">\(\{0,\ldots,|\mathbb{G}|-1\}\)</span></span> to <span><span class="math inline">\(\mathbb{G}\)</span></span> where <span><span class="math inline">\(k=|\mathbb{G}|/order(g)\)</span></span>. See footnote for hint<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup></p></li>
<li><p>As a corollary, the order of <span><span class="math inline">\(g\)</span></span> is always a divisor of <span><span class="math inline">\(|\mathbb{G}|\)</span></span>. This is a special case of a more general phenomenon: the set <span><span class="math inline">\(\{ g^a \;|\; a\in\mathbb{Z} \}\)</span></span> is a subset of the group <span><span class="math inline">\(\mathbb{G}\)</span></span> that is closed under multiplication, and such subsets are known as <em>subgroups</em> of <span><span class="math inline">\(\mathbb{G}\)</span></span>. It is not hard to show (using the same approach as above) that for every group <span><span class="math inline">\(\mathbb{G}\)</span></span> and subgroup <span><span class="math inline">\(\mathbb{H}\)</span></span>, the size of <span><span class="math inline">\(\mathbb{H}\)</span></span> divides the size of <span><span class="math inline">\(\mathbb{G}\)</span></span>. This is known as <a href="https://goo.gl/Q9VSqn">Lagrange’s Theorem</a> in group theory.</p></li>
<li><p>An element <span><span class="math inline">\(g\)</span></span> of <span><span class="math inline">\(\mathbb{G}\)</span></span> is called a <em>generator</em> if <span><span class="math inline">\(order(g)=|\mathbb{G}|\)</span></span>. A group is called <em>cyclic</em> if it has a generator. If <span><span class="math inline">\(\mathbb{G}\)</span></span> is cyclic then there is a (not necessarily efficiently computable) <em>isomorphism</em> <span><span class="math inline">\(\phi:\mathbb{G}\rightarrow\Z_{|\mathbb{G}|}\)</span></span> which is a one-to-one and onto map satisfying <span><span class="math inline">\(\phi(g\cdot h)=\phi(g)+\phi(h)\)</span></span> for every <span><span class="math inline">\(g,h\in\mathbb{G}\)</span></span>.</p></li>
</ul>
<p>When using a group <span><span class="math inline">\(\mathbb{G}\)</span></span> for the Diffie-Hellman protocol, we want the property that <span><span class="math inline">\(g\)</span></span> is a <em>generator</em> of the group, which also means that the map <span><span class="math inline">\(a \mapsto g^a\)</span></span> is a one to one mapping from <span><span class="math inline">\(\{0,\ldots,|\mathbb{G}|-1\}\)</span></span> to <span><span class="math inline">\(\mathbb{G}\)</span></span>. This can be efficiently tested if we know the order of the group and its factorization, since it will occur if and only if <span><span class="math inline">\(g^a \neq 1\)</span></span> for every <span><span class="math inline">\(a&lt;|\mathbb{G}|\)</span></span> (can you see why this holds?) and we know that if <span><span class="math inline">\(g^a=1\)</span></span> then <span><span class="math inline">\(a\)</span></span> must divide <span><span class="math inline">\(\mathbb{G}\)</span></span> (and this?).<br />
It is not hard to show that a random element <span><span class="math inline">\(g\in \mathbb{G}\)</span></span> will be a generator with non-trivial probability (for similar reasons that a random number is prime with non-trivial probability) and hence an approach to getting such a generator is to simply choose <span><span class="math inline">\(g\)</span></span> at random and test that <span><span class="math inline">\(g^a \neq 1\)</span></span> for all of the fewer than <span><span class="math inline">\(\log |\mathbb{G}|\)</span></span> numbers that are obtained by taking <span><span class="math inline">\(|\mathbb{G}|/q\)</span></span> where <span><span class="math inline">\(q\)</span></span> is a factor of <span><span class="math inline">\(|\mathbb{G}|\)</span></span>.</p>
<div id="section-5" class="pause" data-number="10.3.3" name="Pause">
<p>Try to stop here and verify all the facts on groups mentioned above.</p>
</div>
<h3 id="digital-signatures" data-number="10.3.4">Digital Signatures</h3>
<p>Public key encryption solves the <em>confidentiality</em> problem but we still need to solve the <em>authenticity</em> or <em>integrity</em> problem, which might be even more important in practice. That is, suppose Alice wants to endorse a message <span><span class="math inline">\(m\)</span></span> that <em>everyone</em> can verify but only she can sign. This of course is extremely widely used in many settings, including software updates, web pages, financial transactions, and more.</p>
<div id="sigsdef" class="definition" title="Digital Signatures" data-number="10.3.4" name="Definition 10.11 (Digital Signatures) ">
<p>A triple of algorithms <span><span class="math inline">\((G,S,V)\)</span></span> is a chosen-message-attack secure <em>digital signature scheme</em> if it satisfies the following:</p>
<ul>
<li>On input <span><span class="math inline">\(1^n\)</span></span>, the probabilistic <em>key generation</em> algorithm <span><span class="math inline">\(G\)</span></span> outputs a pair <span><span class="math inline">\((s,v)\)</span></span> of keys, where <span><span class="math inline">\(s\)</span></span> is the private <em>signing key</em> and <span><span class="math inline">\(v\)</span></span> is the public <em>verification</em> key.<br />
</li>
<li>On input a message <span><span class="math inline">\(m\)</span></span> and the signing key <span><span class="math inline">\(s\)</span></span>, the signing algorithm <span><span class="math inline">\(S\)</span></span> outputs a string <span><span class="math inline">\(\sigma = S_{s}(m)\)</span></span> such that with probability <span><span class="math inline">\(1-negl(n)\)</span></span>, <span><span class="math inline">\(V_v(m,S_s(m))=1\)</span></span>.<br />
</li>
<li>Every efficient adversary <span><span class="math inline">\(A\)</span></span> wins the following game with at most negligible probability:<br />
</li>
</ul>
<ol type="1">
<li>The keys <span><span class="math inline">\((s,v)\)</span></span> are chosen by the key generation algorithm.<br />
</li>
<li>The adversary gets the inputs <span><span class="math inline">\(1^n\)</span></span>, <span><span class="math inline">\(v\)</span></span>, and black box access to the signing algorithm <span><span class="math inline">\(S_s(\cdot)\)</span></span>.<br />
</li>
<li>The adversary <em>wins</em> if they output a pair <span><span class="math inline">\((m^*,\sigma^*)\)</span></span> such that <span><span class="math inline">\(m^*\)</span></span> was <em>not</em> queried before to the signing algorithm and <span><span class="math inline">\(V_v(m^*,\sigma^*)=1\)</span></span>.</li>
</ol>
</div>
<div id="strongunforgabilitysigrem" class="remark" title="Strong unforgability" data-number="10.3.4" name="Remark 10.12 (Strong unforgability) ">
<p>Just like for MACs (see <a href='lec_04_pseudorandom-functions.html#MACdef'>Definition 4.5</a>), our definition of security for digital signatures with respect to a chosen message attack does not preclude the ability of the adversary of producing a new signature for the same message that it has seen a signature of. Just like in MACs, people sometimes consider the notion of <em>strong unforgability</em> which requires that it would not be possible for the adversary to produce a new message-signature pair (even if the message itself was queried before). Some signature schemes (such as the full domain hash and the DSA scheme) satisfy this stronger notion while others do not. However, just like MACs, it is possible to transform any signature with standard security into a signature that satisfies this stronger unforgability condition.</p>
</div>
<h3 id="the-digital-signature-algorithm-dsa" data-number="10.3.5">The Digital Signature Algorithm (DSA)</h3>
<p>The Diffie-Hellman protocol can be turned into a signature scheme. This was first done by ElGamal, and a variant of his scheme was developed by the NSA and standardized by NIST as the Digital Signature Algorithm (DSA) standard. When based on an elliptic curve this is known as ECDSA. The starting point is the following generic idea of how to turn an encryption scheme into an <em>identification protocol</em>.</p>
<p>If Alice published a public encryption key <span><span class="math inline">\(e\)</span></span>, then one natural approach for Alice to prove her identity to Bob is as follows. Bob will send an encryption <span><span class="math inline">\(c=E_e(x)\)</span></span> of some random message <span><span class="math inline">\(x \leftarrow_R \{0,1\}^n\)</span></span> to Alice, and Alice will send <span><span class="math inline">\(x&#39;=D_d(c)\)</span></span> back. If <span><span class="math inline">\(x=x&#39;\)</span></span> then she has proven that she can decrypt ciphertexts encrypted with <span><span class="math inline">\(e\)</span></span>, and so Bob can be assured that she is the rightful owner of the public key <span><span class="math inline">\(e\)</span></span>.</p>
<p>However, this falls short of a signature scheme in two aspects:</p>
<ul>
<li>This is only an identification protocol and does not allow Alice to endorse a particular message <span><span class="math inline">\(m\)</span></span>.<br />
</li>
<li>This is an <em>interactive</em> protocol, and so Alice cannot generate a static signature based on <span><span class="math inline">\(m\)</span></span> that can be verified by any party without further interaction.</li>
</ul>
<p>The first issue is not so significant, since we can always have the ciphertext be an encryption of <span><span class="math inline">\(x=H(m)\)</span></span> where <span><span class="math inline">\(H\)</span></span> is some hash function presumed to behave as a random oracle. (We do <em>not</em> want to simply run this protocol with <span><span class="math inline">\(x=m\)</span></span>. Can you see why?)</p>
<p>The second issue is more serious. We could imagine Alice trying to run this protocol on her own by generating the ciphertext and then decrypting it, and then sending over the transcript to Bob. But this does not really prove that she knows the corresponding private key. After all, even without knowing <span><span class="math inline">\(d\)</span></span>, any party can generate a ciphertext <span><span class="math inline">\(c\)</span></span> and its corresponding decryption. The idea behind the DSA protocol is that we require Alice to generate a ciphertext <span><span class="math inline">\(c\)</span></span> and its decryption satisfying some additional extra conditions, which would prove that Alice truly knew the secret key.</p>
<p><strong>DSA Signatures:</strong> The DSA signature algorithm works as follows: (See also Section 12.5.2 in the KL book)</p>
<ul>
<li><em>Key generation:</em> Pick generator <span><span class="math inline">\(g\)</span></span> for <span><span class="math inline">\(\mathbb{G}\)</span></span> and <span><span class="math inline">\(a\in \{0,\ldots,|\mathbb{G}|-1\}\)</span></span> and let <span><span class="math inline">\(h=g^a\)</span></span>. Pick <span><span class="math inline">\(H:\{0,1\}^\ell\rightarrow\mathbb{G}\)</span></span> and <span><span class="math inline">\(F:\mathbb{G}\rightarrow\mathbb{G}\)</span></span> to be some functions that can be thought of as “hash functions”.<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> The public key is <span><span class="math inline">\((g,h)\)</span></span> (as well as the functions <span><span class="math inline">\(H,F\)</span></span>) and secret key is <span><span class="math inline">\(a\)</span></span>.<br />
</li>
<li><em>Signature:</em> To sign a message <span><span class="math inline">\(m\)</span></span> with the key <span><span class="math inline">\(a\)</span></span>, pick <span><span class="math inline">\(b\)</span></span> at random, and let <span><span class="math inline">\(f=g^b\)</span></span>, and then let <span><span class="math inline">\(\sigma = b^{-1}[H(m)+a\cdot F(f)]\)</span></span> where all computation is done modulo <span><span class="math inline">\(|\mathbb{G}|\)</span></span>. The signature is <span><span class="math inline">\((f,\sigma)\)</span></span>.<br />
</li>
<li><em>Verification:</em> To verify a signature <span><span class="math inline">\((f,\sigma)\)</span></span> on a message <span><span class="math inline">\(m\)</span></span>, check that <span><span class="math inline">\(s\neq 0\)</span></span> and <span><span class="math inline">\(f^\sigma=g^{H(m)}h^{F(f)}\)</span></span>.</li>
</ul>
<div id="section-6" class="pause" data-number="10.3.5" name="Pause">
<p>You should pause here and verify that this is indeed a valid signature scheme, in the sense that for every <span><span class="math inline">\(m\)</span></span>, <span><span class="math inline">\(V_s(m,S_s(m))=1\)</span></span>.</p>
</div>
<p>Very roughly speaking, the idea behind security is that on one hand <span><span class="math inline">\(s\)</span></span> does not reveal information about <span><span class="math inline">\(b\)</span></span> and <span><span class="math inline">\(a\)</span></span> because this is “masked” by the “random” value <span><span class="math inline">\(H(m)\)</span></span>. On the other hand, if an adversary is able to come up with valid signatures then at least if we treated <span><span class="math inline">\(H\)</span></span> and <span><span class="math inline">\(F\)</span></span> as oracles, then if the signature passes verification then (by taking <span><span class="math inline">\(\log\)</span></span> to the base of <span><span class="math inline">\(g\)</span></span>) the answers <span><span class="math inline">\(x,y\)</span></span> of these oracles will satisfy <span><span class="math inline">\(bs = x + ay\)</span></span> which means that sufficiently many such equations should be enough to recover the discrete log <span><span class="math inline">\(a\)</span></span>.</p>
<div id="section-7" class="pause" data-number="10.3.5" name="Pause">
<p>Before seeing the actual proof, it is a very good exercise to try to see how to convert the intuition above into a formal proof.</p>
</div>
<div id="DSAsec" class="theorem" title="Random-Oracle Model Security of DSA signatures" data-number="10.3.5" name="Theorem 10.13 (Random-Oracle Model Security of DSA signatures) ">
<p>Suppose that the discrete logarithm assumption holds for the group <span><span class="math inline">\(\mathbb{G}\)</span></span>. Then the DSA signature with <span><span class="math inline">\(\mathbb{G}\)</span></span> is secure when <span><span class="math inline">\(H,F\)</span></span> are modeled as random oracles.</p>
</div>
<div id="section-8" class="proof" data-ref="DSAsec" data-number="10.3.5" name="Proof">
<p>Suppose, towards the sake of contradiction, that there was a <span><span class="math inline">\(T\)</span></span>-time adversary <span><span class="math inline">\(A\)</span></span> that succeeds with probability <span><span class="math inline">\(\epsilon\)</span></span> in a chosen message attack against the DSA scheme. We will show that there is an adversary that can compute the discrete logarithm with running time and probability polynomially related to <span><span class="math inline">\(T\)</span></span> and <span><span class="math inline">\(\epsilon\)</span></span> respectively.</p>
<p>Recall that in a chosen message attack in the random oracle model, the adversary interacts with a signature oracle, and oracles that compute the functions <span><span class="math inline">\(F\)</span></span> and <span><span class="math inline">\(H\)</span></span>. For starters, we consider the following experiment <span><span class="math inline">\(\ensuremath{\mathit{CMA}}&#39;\)</span></span> where in the chosen message attack we replace the signature box with the following “fake signature oracle” and “fake function <span><span class="math inline">\(F\)</span></span> oracle”. On input a message <span><span class="math inline">\(m\)</span></span>, the fake box will choose <span><span class="math inline">\(\sigma,r\)</span></span> at random in <span><span class="math inline">\(\{0,\ldots,p-1\}\)</span></span> (where <span><span class="math inline">\(p=|\mathbb{G}|\)</span></span>), and compute <span>
<div class='myequationbox'><span class="math display">\[f=(g^{H(m)}h^{r})^{\sigma^{-1} \mod p} \;\;(10.2)\]</span><a id='randomfdsaeq'></a></div></span> and output <span><span class="math inline">\(h\)</span></span>. We will then record the value <span><span class="math inline">\(F(f)=r\)</span></span> and answer <span><span class="math inline">\(r\)</span></span> on future queries to <span><span class="math inline">\(F\)</span></span>. If we’ve already answered before <span><span class="math inline">\(F(f)\)</span></span> to be a different value then we halt the experiment and output an error. We claim that the adversary’s chance of succeeding in <span><span class="math inline">\(\ensuremath{\mathit{CMA}}&#39;\)</span></span> is computationally indistinguishable from its chance of succeeding in the original <span><span class="math inline">\(\ensuremath{\mathit{CMA}}\)</span></span> experiment. Indeed, since we choose the value <span><span class="math inline">\(r=F(f)\)</span></span> at random, as long as we don’t repeat a value <span><span class="math inline">\(f\)</span></span> that was queried before, the function <span><span class="math inline">\(F\)</span></span> is completely random. But since the adversary makes at most <span><span class="math inline">\(T\)</span></span> queries, and each <span><span class="math inline">\(f\)</span></span> is chosen according to <a href='#randomfdsaeq'>Equation 10.2</a>, which yields a random element the group <span><span class="math inline">\(\mathbb{G}\)</span></span> (which has size roughly <span><span class="math inline">\(2^n\)</span></span>), the probability that <span><span class="math inline">\(f\)</span></span> is repeated is at most <span><span class="math inline">\(T/|\mathbb{G}|\)</span></span> which is negligible. Now we computed <span><span class="math inline">\(\sigma\)</span></span> in the fake box as a random value, but we can also compute <span><span class="math inline">\(\sigma\)</span></span> as equalling <span><span class="math inline">\(b^{-1}(H(m)+a r) \mod p\)</span></span>, where <span><span class="math inline">\(b=\log_g f \mod \mathbb{G}\)</span></span> is uniform as well, and so the distribution of the signature <span><span class="math inline">\((f,\sigma)\)</span></span> is identical to the distribution by a real box.</p>
<p>Note that we can simulate the result of the experiment <span><span class="math inline">\(\ensuremath{\mathit{CMA}}&#39;\)</span></span> without access to the value <span><span class="math inline">\(a\)</span></span> such that <span><span class="math inline">\(h=g^a\)</span></span>. We now transform an algorithm <span><span class="math inline">\(A&#39;\)</span></span> that manages to forge a signature in the <span><span class="math inline">\(\ensuremath{\mathit{CMA}}&#39;\)</span></span> experiment into an algorithm that given <span><span class="math inline">\(\mathbb{G},g,g^a\)</span></span> manages to recover <span><span class="math inline">\(a\)</span></span>.</p>
<p>We let <span><span class="math inline">\((m^*,f^*,\sigma^*)\)</span></span> be the message and signature that the adversary <span><span class="math inline">\(A&#39;\)</span></span> outputs at the end of a successful attack. We can assume without loss of generality that <span><span class="math inline">\(f^*\)</span></span> is queried to the <span><span class="math inline">\(F\)</span></span> oracle at some point during the attack. (For example, by modifying <span><span class="math inline">\(A&#39;\)</span></span> to make this query just before she outputs the final signature.) So, we split into two cases:</p>
<p><strong>Case I:</strong> The value <span><span class="math inline">\(F(f^*)\)</span></span> is first queried by the signature box.</p>
<p><strong>Case II:</strong> The value <span><span class="math inline">\(F(f^*)\)</span></span> is first queried by the adversary.</p>
<p>If Case I happens with non negligible probability, then we know that the value <span><span class="math inline">\(f^*\)</span></span> is queried when producing the signature <span><span class="math inline">\((f^*,\sigma)\)</span></span> for some message <span><span class="math inline">\(m \neq m^*\)</span></span>, and so we know the following two equations hold: <span>
<div class='myequationbox'><span class="math display">\[ g^{H(m)}h^{F(f^*)} = (f^*)^{\sigma}\]</span></div></span> and <span>
<div class='myequationbox'><span class="math display">\[ g^{H(m^*)}h^{F(f^*)}=  (f^*)^{\sigma^*}\]</span></div></span> Taking logs we get the following equations on <span><span class="math inline">\(a = \log_g h\)</span></span> and <span><span class="math inline">\(b=\log_g f^*\)</span></span>: <span>
<div class='myequationbox'><span class="math display">\[H(m)+aF(f^*) = b\sigma\]</span></div></span> and <span>
<div class='myequationbox'><span class="math display">\[H(m^*)+aF(f^*)=b\sigma^*\]</span></div></span> or <span>
<div class='myequationbox'><span class="math display">\[b= (H(m^*)-H(m))(\sigma-\sigma^*)^{-1} \mod p\]</span></div></span> since all of the valus <span><span class="math inline">\(H(m^*),H(m),\sigma,\sigma^*\)</span></span> are known, this means we can compute <span><span class="math inline">\(b\)</span></span>, and hence also recover the unknown value <span><span class="math inline">\(a\)</span></span>.</p>
<p>If Case II happens, then we split it into two cases as well. <strong>Case IIa</strong> is that this happens and <span><span class="math inline">\(F(f^*)\)</span></span> is queried <em>before</em> <span><span class="math inline">\(H(m^*)\)</span></span> is queried, and <strong>Case IIb</strong> is that this happens and <span><span class="math inline">\(F(f^*)\)</span></span> is queried after <span><span class="math inline">\(H(m^*)\)</span></span> is queried.</p>
<p>We start by considering the setting that <strong>Case IIa</strong> happens with non-negligible probability <span><span class="math inline">\(\epsilon\)</span></span>. By the averaging argument there are some <span><span class="math inline">\(t&#39;&lt; t \in \{1,\ldots,T\}\)</span></span> such that with probability at least <span><span class="math inline">\(\epsilon/T^2\)</span></span>, <span><span class="math inline">\(f^*\)</span></span> is queried by the adversary at the <span><span class="math inline">\(t&#39;\)</span></span>-th query and <span><span class="math inline">\(m^*\)</span></span> is queried by the adversary at its <span><span class="math inline">\(t\)</span></span>-th query. We run the <span><span class="math inline">\(\ensuremath{\mathit{CMA}}&#39;\)</span></span> experiment <em>twice</em>, using the same randomness up until the <span><span class="math inline">\(t-1\)</span></span>-th query and independent randomness from then onwards. With probability at least <span><span class="math inline">\((\epsilon/T^2)^2\)</span></span>, both experiments will result in a successful forge, and since <span><span class="math inline">\(f^*\)</span></span> was queried before at stage <span><span class="math inline">\(t&#39;&lt;t\)</span></span>, we get the following equations <span>
<div class='myequationbox'><span class="math display">\[H_1(m^*)+aF(f^*) = b\sigma\]</span></div></span> and <span>
<div class='myequationbox'><span class="math display">\[H_2(m^*)+aF(f^*)=b\sigma^*\]</span></div></span> where <span><span class="math inline">\(H_1(m^*)\)</span></span> and <span><span class="math inline">\(H_2(m^*)\)</span></span> are the answers of <span><span class="math inline">\(H\)</span></span> to the query <span><span class="math inline">\(m^*\)</span></span> in the first and second time we run the experiment. (The answers of <span><span class="math inline">\(F\)</span></span> to <span><span class="math inline">\(f^*\)</span></span> are the same since this happens before the <span><span class="math inline">\(t\)</span></span>-th step). As before, we can use this to recover <span><span class="math inline">\(a=\log_g h\)</span></span>.</p>
<p>If <strong>Case IIb</strong> happens with non-negligible probability <span><span class="math inline">\(\epsilon&gt;0\)</span></span>. Then again by the averaging argument there are some <span><span class="math inline">\(t&lt; t&#39; \in \{1,\ldots,T\}\)</span></span> such that with probability at least <span><span class="math inline">\(\epsilon/T^2\)</span></span>, <span><span class="math inline">\(m^*\)</span></span> is queried by the adversary at the <span><span class="math inline">\(t\)</span></span>-th query and <span><span class="math inline">\(f^*\)</span></span> is queried by the adversary at its <span><span class="math inline">\(t&#39;\)</span></span>-th query. We run the <span><span class="math inline">\(\ensuremath{\mathit{CMA}}&#39;\)</span></span> experiment <em>twice</em>, using the same randomness up until the <span><span class="math inline">\(t&#39;-1\)</span></span>-th query and independent randomness from then onwards. This time we will get the two equations <span>
<div class='myequationbox'><span class="math display">\[H(m^*)+aF_1(f^*) = b\sigma\]</span></div></span> and <span>
<div class='myequationbox'><span class="math display">\[H(m^*)+aF_2(f^*)=b\sigma^*\]</span></div></span> where <span><span class="math inline">\(F_1(f^*)\)</span></span> and <span><span class="math inline">\(F_2(f^*)\)</span></span> are our two answers in the first and second experiment, and now we can use this to learn <span><span class="math inline">\(a= b(\sigma-\sigma^*)(F_1(f^*)-F_2(f^*))^{-1}\)</span></span>.</p>
<p>The bottom line is that we obtain a probabilistic polynomial time algorithm that on input <span><span class="math inline">\(\mathbb{G},g,g^a\)</span></span> recovers <span><span class="math inline">\(a\)</span></span> with non-negligible probability, hence violating the assumption that the discrete log problem is hard for the group <span><span class="math inline">\(\mathbb{G}\)</span></span>.</p>
</div>
<div id="nonromsec" class="remark" title="Non-random oracle model security" data-number="10.3.5" name="Remark 10.14 (Non-random oracle model security) ">
<p>In this lecture both our encryption scheme and digital signature schemes were not proven secure under a well stated computational assumption, but rather used the random oracle model heuristic. However, it is known how to obtain schemes that do not rely on this heuristic, and we will see such schemes later on in this course.</p>
</div>
<h2 id="putting-everything-together---security-in-practice." data-number="10.4">Putting everything together - security in practice.</h2>
<p>Let us discuss briefly how public key cryptography is used to secure web trafic through the SSL/TLS protocol that we all use when we use <code>https://</code> URLs. The security this achieve is quite amazing. No matter what wired or wireless network you are using, no matter what country you are in, as long as your device (e.g., phone/laptop/etc..) and the server you are talking to (e.g., Google, Amazon, Microsoft etc.) is functioning properly, you can communicate securely without any party in the middle able to either learn or modify the contents of your interaction.<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup></p>
<p>In the web setting, therre are <em>servers</em> who have public keys, and <em>users</em> who generally don’t have such keys. Ideally, as a user, you should already know the public keys of all the entities you communicate with e.g., <code>amazon.com</code>, <code>google.com</code>, etc. However, how are you going to learn those public keys? The traditional answer was that because they are <em>public</em> these keys are much easier to communicate and the servers could even post them as ads on the <em>New York Times</em>. Of course these days everyone reads the <em>Times</em> through <code>nytimes.com</code> and so this seems like a chicken-and-egg type of problem.</p>
<p>The solution goes back again to the quote of Archimedes of “Give me a fulcrum, and I shall move the world”. The idea is that trust can be <em>transitive</em>. Suppose you have a Mac. Then you have already trusted Apple with quite a bit of your personal information, and so you might be fine if this Mac came pre-installed with the Apple public key which you trust to be authentic. Now, suppose that you want to communicate with <code>Amazon.com</code>. Now, <em>you</em> might not know the correct public key for Amazon, but <em>Apple</em> surely does. So Apple can supply Amazon with a signed message to the effect of</p>
<blockquote>
<p><em>“I Apple certify that the public key of Amazon.com is <code>30 82 01 0a 02 82 01 01 00 94 9f 2e fd 07 63 33 53 b1 be e5 d4 21 9d 86 43 70 0e b5 7c 45 bb ab d1 ff 1f b1 48 7b a3 4f be c7 9d 0f 5c 0b f1 dc 13 15 b0 10 e3 e3 b6 21 0b 40 b0 a3 ca af cc bf 69 fb 99 b8 7b 22 32 bc 1b 17 72 5b e5 e5 77 2b bd 65 d0 03 00 10 e7 09 04 e5 f2 f5 36 e3 1b 0a 09 fd 4e 1b 5a 1e d7 da 3c 20 18 93 92 e3 a1 bd 0d 03 7c b6 4f 3a a4 e5 e5 ed 19 97 f1 dc ec 9e 9f 0a 5e 2c ae f1 3a e5 5a d4 ca f6 06 cf 24 37 34 d6 fa c4 4c 7e 0e 12 08 a5 c9 dc cd a0 84 89 35 1b ca c6 9e 3c 65 04 32 36 c7 21 07 f4 55 32 75 62 a6 b3 d6 ba e4 63 dc 01 3a 09 18 f5 c7 49 bc 36 37 52 60 23 c2 10 82 7a 60 ec 9d 21 a6 b4 da 44 d7 52 ac c4 2e 3d fe 89 93 d1 ba 7e dc 25 55 46 50 56 3e e0 f0 8e c3 0a aa 68 70 af ec 90 25 2b 56 f6 fb f7 49 15 60 50 c8 b4 c4 78 7a 6b 97 ec cd 27 2e 88 98 92 db 02 03 01 00 01</code>”</em></p>
</blockquote>
<p>Such a message is known as a <em>certificate</em>, and it allows you to extend your trust in Apple to a trust in Amazon. Now when your browser communicates with amazon, it can request this message, and if it is not present not continue with the interaction or at least display some warning. Clearly a person in the middle can stop this message from travelling and hence not allow the interaction to continue, but they cannot <em>spoof</em> the message and send a certificate for their own public key, unless they know Apple’s secret key. (In today’s actual implementation, for various business and other reasons, the trusted keys that come pre-installed in browsers and devices do not belong to Apple or Microsoft but rather to particular companies such as <em>Verisign</em> known as <em>certificate authorities</em>. The security of these certificate authorities’ private key is crucial to the security of the whole protocol, and it has been <a href="https://en.wikipedia.org/wiki/DigiNotar">attacked</a> <a href="http://www.wired.com/2011/10/son-of-stuxnet-in-the-wild/">before</a>. )</p>
<p>Using certificates, we can assume that Bob the user has the public verification key <span><span class="math inline">\(v\)</span></span> of Alice the server. Now Alice can send Bob also a public <em>encryption</em> key <span><span class="math inline">\(e\)</span></span>, which is authenticated by <span><span class="math inline">\(v\)</span></span> and hence guaranteed to be correct.<sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup> Once Bob knows Alice’s public key they are in business- he can use that to send an encryption of some private key <span><span class="math inline">\(k\)</span></span> which they can then use for all the rest of their communication.</p>
<p>This is in a very high level the SSL/TLS protocol, but there are many details inside it including the exact security notions needed from the encryption, how the two parties negotiate <em>which</em> cryptographic algorithm to use, and more. All these issues can and have been used for attacks on this protocol. For two recent discussions see <a href="http://blog.cryptographyengineering.com/2013/12/how-does-nsa-break-ssl.html">this blog post</a> and <a href="https://weakdh.org/">this website</a>.</p>
<figure>
<img src="../figure/certificate.jpg" alt="21.1: When you connect to a webpage protected by SSL/TLS, the Browswer displays information on the certificate’s authenticity" id="tmplabelfig" style="width:80.0%" /><figcaption>21.1: When you connect to a webpage protected by SSL/TLS, the Browswer displays information on the certificate’s authenticity</figcaption>
</figure>
<figure>
<img src="../figure/googletls.jpg" alt="21.1: The cipher and certificate used by ’‘’Google.com’’’. Note that Google has a 2048bit RSA signature key which it then uses to authenticate an elliptic curve based Diffie-Hellman key exchange protocol to create session keys for the block cipher AES with 128 bit key in Galois Counter Mode." id="tmplabelfig" style="width:40.0%" /><figcaption>21.1: The cipher and certificate used by ’‘’Google.com’’’. Note that Google has a 2048bit RSA signature key which it then uses to authenticate an elliptic curve based Diffie-Hellman key exchange protocol to create session keys for the block cipher AES with 128 bit key in Galois Counter Mode.</figcaption>
</figure>
<figure>
<img src="../figure/docusign.jpg" alt="21.1: Digital signatures and other forms of electronic signatures are legally binding in many jurisdictions. This is some material from the website of the electronic signing company DocuSign." id="tmplabelfig" style="width:80.0%" /><figcaption>21.1: Digital signatures and other forms of electronic signatures are legally binding in many jurisdictions. This is some material from the website of the electronic signing company DocuSign.</figcaption>
</figure>
<blockquote>
<p><strong>Example:</strong> Here is the list of certificate authorities that were trusted by default (as of spring 2016) by Mozilla products: Actalis, Amazon, AS Sertifitseerimiskeskuse (SK), Atos, Autoridad de Certificacion Firmaprofesional, Buypass, CA Disig a.s., Camerfirma, CerticÃ¡mara S.A., Certigna, Certinomis, certSIGN, China Financial Certification Authority (CFCA), China Internet Network Information Center (CNNIC), Chunghwa Telecom Corporation, Comodo, ComSign, Consorci AdministraciÃ³ Oberta de Catalunya (Consorci AOC, CATCert), Cybertrust Japan / JCSI, D-TRUST, Deutscher Sparkassen Verlag GmbH (S-TRUST, DSV-Gruppe), DigiCert, DocuSign (OpenTrust/Keynectis), e-tugra, EDICOM, Entrust, GlobalSign, GoDaddy, Government of France (ANSSI, DCSSI), Government of Hong Kong (SAR), Hongkong Post, Certizen, Government of Japan, Ministry of Internal Affairs and Communications, Government of Spain, Autoritat de CertificaciÃ³ de la Comunitat Valenciana (ACCV), Government of Taiwan, Government Root Certification Authority (GRCA), Government of The Netherlands, PKIoverheid, Government of Turkey, Kamu Sertifikasyon Merkezi (Kamu SM), HARICA, IdenTrust, Izenpe S.A., Microsec e-SzignÃ³ CA, NetLock Ltd., PROCERT, QuoVadis, RSA the Security Division of EMC, SECOM Trust Systems Co. Ltd., Start Commercial (StartCom) Ltd., Swisscom (Switzerland) Ltd, SwissSign AG, Symantec / GeoTrust, Symantec / Thawte, Symantec / VeriSign, T-Systems International GmbH (Deutsche Telekom), Taiwan-CA Inc. (TWCA), TeliaSonera, Trend Micro, Trustis, Trustwave, TurkTrust, Unizeto Certum, Visa, Web.com, Wells Fargo Bank N.A., WISeKey, WoSign CA Limited</p>
</blockquote>
<h2 id="appendix-an-alternative-proof-of-the-density-of-primes" data-number="10.5">Appendix: An alternative proof of the density of primes</h2>
<p>I record here an alternative way to show that the fraction of primes in <span><span class="math inline">\([2^n]\)</span></span> is <span><span class="math inline">\(\Omega(1/n)\)</span></span>.<sup id="fnref:13"><a href="#fn:13" rel="footnote">13</a></sup></p>
<div id="densityprimesaltlem" class="lemma" data-number="10.5" name="Lemma 10.15">
<p>The probability that a random <span><span class="math inline">\(n\)</span></span> bit number is prime is at least <span><span class="math inline">\(\Omega(1/n)\)</span></span>.</p>
</div>
<div id="section-9" class="proof" data-ref="densityprimesaltlem" data-number="10.5" name="Proof">
<p>Let <span><span class="math inline">\(N=2^n\)</span></span>. We need to show that the number of primes between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(N\)</span></span> is at least <span><span class="math inline">\(\Omega(N/\log N)\)</span></span>. Consider the number <span><span class="math inline">\(\binom{2N}{N}=\tfrac{2N!}{N!N!}\)</span></span>. By Stirling’s formula we know that <span><span class="math inline">\(\log \binom{2N}{N} = (1 - o(1))2N\)</span></span> and in particular <span><span class="math inline">\(N \leq \log\binom{2N}{N} \leq 2N\)</span></span>. Also, by the formula using factorials, all the prime factors of <span><span class="math inline">\(\binom{2N}{N}\)</span></span> are between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(2N\)</span></span>, and each factor <span><span class="math inline">\(P\)</span></span> cannot appear more than <span><span class="math inline">\(k=\floor{\tfrac{\log 2N}{\log P}}\)</span></span> times. Indeed, for every <span><span class="math inline">\(N\)</span></span>, the number of times <span><span class="math inline">\(P\)</span></span> appears in the factorization of <span><span class="math inline">\(N!\)</span></span> is <span><span class="math inline">\(\sum_i \floor{\tfrac{N}{P^i}}\)</span></span>, since we get <span><span class="math inline">\(\floor{\tfrac{N}{P}}\)</span></span> times a factor <span><span class="math inline">\(P\)</span></span> in the factorizations of <span><span class="math inline">\(\{1,\ldots,N\}\)</span></span>, <span><span class="math inline">\(\floor{\tfrac{N}{P^2}}\)</span></span> times a factor of the form <span><span class="math inline">\(P^2\)</span></span>, etc… Thus the number of times <span><span class="math inline">\(P\)</span></span> appears in the factorization of <span><span class="math inline">\(\binom{2N}{N}=\tfrac{(2N)!}{N!N!}\)</span></span> is equal to <span><span class="math inline">\(\sum_i \floor{\tfrac{2N}{P^i}}-2\floor{\tfrac{N}{P^i}}\)</span></span>: a sum of at most <span><span class="math inline">\(k\)</span></span> elements (since <span><span class="math inline">\(P^{k+1}&gt;2N\)</span></span>) each of which is either <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>.</p>
<p>Thus, <span><span class="math inline">\(\binom{2N}{N} \leq \prod_{\substack{1 \leq P \leq 2N \\ P \text{ prime }}} P^{\floor{\tfrac{\log 2N}{\log P}}}\)</span></span>. Taking logs we get that <span>
<div class='myequationbox'><span class="math display">\[N \leq \log \binom{2N}{N}\]</span></div></span> <span>
<div class='myequationbox'><span class="math display">\[\leq \sum_{P \text{ prime} \in [2n]} \floor{\tfrac{\log 2N}{\log P}}\log P\]</span></div></span> <span>
<div class='myequationbox'><span class="math display">\[\leq \sum_{P \text{ prime} \in [2n]} \log 2N\]</span></div></span> establishing that the number of primes in <span><span class="math inline">\([1,N]\)</span></span> is <span><span class="math inline">\(\Omega(\tfrac{N}{\log N})\)</span></span>.</p>
</div>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>For simplicity, assume that the program <span><span class="math inline">\(P\)</span></span> is <em>side effect free</em> and hence it simply computes some function, say from <span><span class="math inline">\(\{0,1\}^n\)</span></span> to <span><span class="math inline">\(\{0,1\}^\ell\)</span></span> for some <span><span class="math inline">\(n,\ell\)</span></span>.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>There have been some other more exotic suggestions for public key encryption (including some by <a href="http://www.eng.tau.ac.il/~bennyap/pubs/ncpkcFull1.pdf">yours truly</a> as well as suggestions such as the <a href="http://eprint.iacr.org/2006/291">isogeny star problem</a> , though see also <a href="http://arxiv.org/pdf/1012.4019.pdf">this</a>), but they have not yet received wide scrutiny.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>The running time of the best known algorithms for computing the discrete logarithm modulo <span><span class="math inline">\(n\)</span></span> bit primes is <span><span class="math inline">\(2^{f(n)2^{n^{1/3}}}\)</span></span> where <span><span class="math inline">\(f(n)\)</span></span> is a function that depends polylogarithmically on <span><span class="math inline">\(n\)</span></span>. If <span><span class="math inline">\(f(n)\)</span></span> would equal <span><span class="math inline">\(1\)</span></span> then we’d need numbers of <span><span class="math inline">\(128^3 \approx 2\cdot 10^6\)</span></span> bits to get <span><span class="math inline">\(128\)</span></span> bits of security, but because <span><span class="math inline">\(f(n)\)</span></span> is larger than one, the current <a href="https://goo.gl/ntszsg">estimates</a> are that we need to let <span><span class="math inline">\(n=3072\)</span></span> bit key to get <span><span class="math inline">\(128\)</span></span> bits of of security. Still the existence of such a non-trivial algorithm means that we need much larger keys than those used for private key systems to get the same level of security. In particular, to double the estimated security to <span><span class="math inline">\(256\)</span></span> bits, NIST recommends that we multiply the RSA keysize give-fold to <span><span class="math inline">\(15,360\)</span></span>. (The same document also says that SHA-256 gives <span><span class="math inline">\(256\)</span></span> bits of security as a pseudorandom generator but only <span><span class="math inline">\(128\)</span></span> bits when used to hash documents for digital signatures; can you see why?)</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>Formally the secret key should contain all the information in the public key plus the extra secret information, but we omit the public information for simplicity of notation.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>One can get security results for this protocol without a random oracle if we assume a stronger variant known as the <em>Decisional Diffie-Hellman (DDH)</em> assumption.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>Formally, since it is an asymptotic statement, the CDH assumption needs to be defined with a <em>sequence of groups</em>. However, to make notation simpler we will ignore this issue, and use it only for groups (such as the numbers modulo some <span><span class="math inline">\(n\)</span></span> bit primes) where we can easily increase the “security parameter” <span><span class="math inline">\(n\)</span></span>.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:7"><p>
<div>
<p>In practice people often take <span><span class="math inline">\(g\)</span></span> to be a generator of a group significantly smaller in size than <span><span class="math inline">\(p\)</span></span>, which enables <span><span class="math inline">\(a,b\)</span></span> to be smaller numbers and hence multiplication to be more efficient. We ignore this optimization in our discussions.</p>
</div>
<a href="#fnref:7" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:8"><p>
<div>
<p>ElGamal’s actual contribution was to design a <em>signature scheme</em> based on the Diffie-Hellman problem, a variant of which is the Digital Signature Algorithm (DSA) described below.</p>
</div>
<a href="#fnref:8" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:9"><p>
<div>
<p>For every <span><span class="math inline">\(f\in \mathbb{G}\)</span></span>, you can show a one to one and onto mapping between the set <span><span class="math inline">\(\{ a : g^a = 1 \}\)</span></span> and the set <span><span class="math inline">\(\{b : g^b= f \}\)</span></span> by choosing some element <span><span class="math inline">\(b\)</span></span> from the latter set and looking at the map <span><span class="math inline">\(a \mapsto a+b \mod |\mathbb{G}|\)</span></span>.</p>
</div>
<a href="#fnref:9" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:10"><p>
<div>
<p>It is a bit cumbersome, but not so hard, to transform functions that map strings to strings to functions whose domain or range are group elements. As noted in the KL book, in the actual DSA protocol <span><span class="math inline">\(F\)</span></span> is <em>not</em> a cryptographic hash function but rather some very simple function that is still assumed to be “good enough” for security.</p>
</div>
<a href="#fnref:10" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:11"><p>
<div>
<p>They are able to know that such an interaction took place and the amount of bits exchanged. Preventing these kind of attacks is more subtle and approaches for solutions are known as <em>steganography</em> and <em>anonymous routing</em>.</p>
</div>
<a href="#fnref:11" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:12"><p>
<div>
<p>If this key is <em>ephemeral</em>- generated on the spot for this interaction and deleted afterward- then this has the benefit of ensuring the <em>forward secrecy</em> property that even if some entity that is in the habit of recording all communication later finds out Alice’s private verification key, then it still will not be able to decrypt the information. In applied crypto circles this property is somewhat misnamed as “perfect forward secrecy” and associated with the Diffie-Hellman key exchange (or its elliptic curves variants), since in those protocols there is not much additional overhead for implementing it (see <a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">this blog post</a>). The importance of forward security was emphasized by the discovery of the <a href="http://heartbleed.com/">Heartbleed</a> vulnerability (see <a href="https://jhalderm.com/pub/papers/heartbleed-imc14.pdf">this paper</a>) that allowed via a buffer-overflow attack in OpenSSL to learn the private key of the server.</p>
</div>
<a href="#fnref:12" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:13"><p>
<div>
<p>It might be that the two ways are more or less the same, as if we open up the polynomial <span><span class="math inline">\((1-x)^kx^k\)</span></span> we get the binomial coefficients.</p>
</div>
<a href="#fnref:13" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Public key cryptography+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 01/12/2020 19:20:17</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_10_public_key_intro.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
