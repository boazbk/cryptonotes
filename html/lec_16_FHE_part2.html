<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: FHE II: Construction</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: FHE II: Construction" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#countoperation"><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li><li class="chapter" data-level="5.4" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>5.4</b> Optional, Aside: Broadcast Encryption</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash Functions and Random Oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "Bitcoin" Problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The Currency Problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin Architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The Bitcoin Ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From Proof of Work to Consensus on Ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision Resistance Hash Functions and Creating Short "Unique" Identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical Constructions of Cryptographic Hash Functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical Random-ish Functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some History</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions"><i class="fa fa-check"></i><b>7.4.3</b> The NSA and Hash Functions</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs Non-Cryptographic Hash Functions</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li><li class="chapter" data-level="10.6" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a><ul><li class="chapter" data-level="10.6.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li></ul></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li><ul><li class="chapter" data-level="12.0.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li></ul></li><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">FHE II: Construction</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_16_FHE_part2.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="fully-homomorphic-encryption-construction" data-number="17">Fully homomorphic encryption : Construction</h1>
<p>In the last lecture we defined fully homomorphic encryption, and showed the “bootstrapping theorem” that transforms a partially homomorphic encryption scheme into a fully homomorphic encryption, as long as the original scheme can homomorphically evaluate its own decryption circuit. In this lecture we will show an encryption scheme (due to Gentry, Sahai and Waters, henceforth GSW) meeting the latter property. That is, this lecture is devoted to proving<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> the following theorem:</p>
<div id="LWEFHEthm" class="theorem" title="FHE from LWE" data-number="17" name="Theorem 17.1 (FHE from LWE) ">
<p>Assuming the LWE conjecture, there exists a partially homomorphic public key encryption <span><span class="math inline">\((G,E,D,\ensuremath{\mathit{EVAL}})\)</span></span> that fits the conditions of the bootstrapping theorem (<a href='lec_15_FHE.html#bootstrapthm'>Theorem 16.8</a>). That is, for every two ciphertexts <span><span class="math inline">\(c\)</span></span> and <span><span class="math inline">\(c&#39;\)</span></span>, the function <span><span class="math inline">\(d \mapsto D_d(c)\; \ensuremath{\mathit{NAND}}\; D_d(c&#39;)\)</span></span> can be homomorphically evaluated by <span><span class="math inline">\(\ensuremath{\mathit{EVAL}}\)</span></span>.</p>
</div>
<h2 id="prelude-from-vectors-to-matrices" data-number="17.1">Prelude: from vectors to matrices</h2>
<p>In the linear homomorphic scheme we saw in the last lecture, every ciphertext was a vector <span><span class="math inline">\(c\in\Z_q^n\)</span></span> such that <span><span class="math inline">\(\langle c,s \rangle\)</span></span> equals (up to scaling by <span><span class="math inline">\(\floor{\tfrac{q}{2}}\)</span></span>) the plaintext bit. We saw that adding two ciphertexts modulo <span><span class="math inline">\(q\)</span></span> corresponded to XOR’ing (i.e., adding modulo <span><span class="math inline">\(2\)</span></span>) the corresponding two plaintexts. That is, if we define <span><span class="math inline">\(c \oplus c&#39;\)</span></span> as <span><span class="math inline">\(c+c&#39; \pmod{q}\)</span></span> then performing the <span><span class="math inline">\(\oplus\)</span></span> operation on the ciphertexts corresponds to adding modulo <span><span class="math inline">\(2\)</span></span> the plaintexts.</p>
<p>However, to get to a fully, or even partially, homomorphic scheme, we need to find a way to perform the NAND operation on the two plaintexts. The challenge is that it seems that to do that we need to find a way to evaluate <em>multiplications</em>: find a way to define some operation <span><span class="math inline">\(\otimes\)</span></span> on ciphertexts that corresponds to multiplying the plaintexts. Alas, a priori, there doesn’t seem to be a natural way to <em>multiply</em> two vectors.</p>
<p>The GSW approach to handle this is to move from vectors to <em>matrices</em>. As usual, it is instructive to first consider the cryptographer’s dream world where Gaussian elimination doesn’t exist. In this case, the GSW ciphertext encrypting <span><span class="math inline">\(b\in\{0,1\}\)</span></span> would be an <span><span class="math inline">\(n\times n\)</span></span> matrix <span><span class="math inline">\(C\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span> such that <span><span class="math inline">\(Cs = bs\)</span></span> where <span><span class="math inline">\(s\in\Z_q^n\)</span></span> is the secret key. That is, the encryption of a bit <span><span class="math inline">\(b\)</span></span> is a matrix <span><span class="math inline">\(C\)</span></span> such that the secret key is an <em>eigenvector</em> (modulo <span><span class="math inline">\(q\)</span></span>) of <span><span class="math inline">\(C\)</span></span> with corresponding eigenvalue <span><span class="math inline">\(b\)</span></span>. (We defer discussion of how the encrypting party generates such a ciphertext, since this is in any case only a “dream” toy example.)</p>
<div id="section" class="pause" data-number="17.1" name="Pause">
<p>You should make sure you understand the <em>types</em> of all the identifiers we refer to. In particular, above <span><span class="math inline">\(C\)</span></span> is an <span><span class="math inline">\(n\times n\)</span></span> <em>matrix</em> with entries in <span><span class="math inline">\(\Z_q\)</span></span>, <span><span class="math inline">\(s\)</span></span> is a <em>vector</em> in <span><span class="math inline">\(\Z_q^n\)</span></span>, and <span><span class="math inline">\(b\)</span></span> is a <em>scalar</em> (i.e., just a number) in <span><span class="math inline">\(\{0,1\}\)</span></span>. See <a href='#naivegswfig'>Figure 17.1</a> for a visual representation of the ciphertexts in this “naive” encryption scheme. Keeping track of the dimensions of all objects will become only more important in the rest of this lecture.</p>
</div>
<figure>
<img src="../figure/naivegsw.png" alt="17.1: In the “naive” version of the GSW encryption, to encrypt a bit b we output an n\times n matrix C such that Cs=bs where s \in \Z_q^n is the secret key. In this scheme we can transform encryptions C,C&#39; of b,b&#39; respectively to an encryption C&#39;&#39; of \ensuremath{\mathit{NAND}}(b,b&#39;) by letting C&#39;&#39; = I-CC&#39;." id="naivegswfig" class="margin" /><figcaption>17.1: In the “naive” version of the GSW encryption, to encrypt a bit <span><span class="math inline">\(b\)</span></span> we output an <span><span class="math inline">\(n\times n\)</span></span> matrix <span><span class="math inline">\(C\)</span></span> such that <span><span class="math inline">\(Cs=bs\)</span></span> where <span><span class="math inline">\(s \in \Z_q^n\)</span></span> is the secret key. In this scheme we can transform encryptions <span><span class="math inline">\(C,C&#39;\)</span></span> of <span><span class="math inline">\(b,b&#39;\)</span></span> respectively to an encryption <span><span class="math inline">\(C&#39;&#39;\)</span></span> of <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(b,b&#39;)\)</span></span> by letting <span><span class="math inline">\(C&#39;&#39; = I-CC&#39;\)</span></span>.</figcaption>
</figure>
<p>Given <span><span class="math inline">\(C\)</span></span> and <span><span class="math inline">\(s\)</span></span> we can recover <span><span class="math inline">\(b\)</span></span> by just checking if <span><span class="math inline">\(Cs=s\)</span></span> or <span><span class="math inline">\(Cs=0^n\)</span></span>. The scheme allows homomorphic evaluation of both addition (modulo <span><span class="math inline">\(q\)</span></span>) and multiplication, since if <span><span class="math inline">\(Cs = bs\)</span></span> and <span><span class="math inline">\(C&#39;s=b&#39;s\)</span></span> then we can define <span><span class="math inline">\(C \oplus C&#39; = C + C&#39;\)</span></span> (where on the righthand side, addition is simply done in <span><span class="math inline">\(\Z_q\)</span></span>) and <span><span class="math inline">\(C\otimes C&#39; = \ensuremath{\mathit{CC}}&#39;\)</span></span> (where again this refers to matrix multiplication in <span><span class="math inline">\(\Z_q\)</span></span>).</p>
<p>Indeed, one can verify that both addition and multiplication succeed since</p>
<p><span>
<div class='myequationbox'><span class="math display">\[(C+C&#39;)s = (b+b&#39;)s\]</span></div></span></p>
<p>and</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{CC}}&#39;s = C(b&#39;s) = bb&#39;s\]</span></div></span></p>
<p>where all these equalities are in <span><span class="math inline">\(\Z_q\)</span></span>.</p>
<p>Addition modulo <span><span class="math inline">\(q\)</span></span> is not the same as XOR, but given these multiplication and addition operations, we can implement the NAND operation as well. Specifically, for every <span><span class="math inline">\(b,b&#39; \in \{0,1\}\)</span></span>, <span><span class="math inline">\(b \; \ensuremath{\mathit{NAND}} \; b&#39; = 1-bb&#39;\)</span></span>. Hence we can take a ciphertext <span><span class="math inline">\(C\)</span></span> encrypting <span><span class="math inline">\(b\)</span></span> and a ciphertext <span><span class="math inline">\(C&#39;\)</span></span> encrypting <span><span class="math inline">\(b&#39;\)</span></span> and transform these two ciphertexts to the ciphertext <span><span class="math inline">\(C&#39;&#39;=(I-CC&#39;)\)</span></span> that encrypts <span><span class="math inline">\(b\; \ensuremath{\mathit{NAND}} \; b&#39;\)</span></span> (where <span><span class="math inline">\(I\)</span></span> is the identity matrix). Thus in a world without Gaussian elimination it is not hard to get a fully homomorphic encryption.</p>
<div id="privkeyfhe" class="remark" title="Private key FHE" data-number="17.1" name="Remark 17.2 (Private key FHE) ">
<p>We have not shown how to <em>generate</em> a ciphertext without knowledge of <span><span class="math inline">\(s\)</span></span>, and hence strictly speaking we only showed in this world how to get a <em>private key</em> fully homomorphic encryption. Our “real world” scheme will be a full fledged <em>public key</em> FHE. However we note that private key homomorphic encryption is already very interesting and in fact sufficient for many of the “cloud computing” applications. Moreover, <a href="http://eccc.hpi-web.de/report/2010/146/">Rothblum</a> gave a generic transformation from a <em>private key</em> homomorphic encryption to a <em>public key</em> homomorphic encryption.</p>
</div>
<h2 id="real-world-partially-homomorphic-encryption" data-number="17.2">Real world partially homomorphic encryption</h2>
<p>We now discuss how we can obtain an encryption in the real world where, as much as we’d like to ignore it, there are people who walk among us (not to mention some computer programs) that actually know how to invert matrices. As usual, the idea is to “fool Gaussian elimination with noise” but we will see that we have to be much more careful about “noise management”, otherwise even for the party holding the secret key the noise will overwhelm the signal.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<p>The main idea is that we can expect the following problem to be hard for a random secret <span><span class="math inline">\(s\in\Z_q^n\)</span></span>: distinguish between samples of random matrices <span><span class="math inline">\(C\)</span></span> and matrices where <span><span class="math inline">\(Cs = bs + e\)</span></span> for some <span><span class="math inline">\(b\in\{0,1\}\)</span></span> and “short” <span><span class="math inline">\(e\)</span></span> satisfying <span><span class="math inline">\(|e_i| \leq \sqrt{q}\)</span></span> for all <span><span class="math inline">\(i\)</span></span>. This yields a natural candidate for an encryption scheme where we encrypt <span><span class="math inline">\(b\)</span></span> by a matrix <span><span class="math inline">\(C\)</span></span> satisfying <span><span class="math inline">\(Cs = bs + e\)</span></span> where <span><span class="math inline">\(e\)</span></span> is a “short” vector.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<p>We can now try to check what adding and multiplying two matrices does to the noise. If <span><span class="math inline">\(Cs = bs+e\)</span></span> and <span><span class="math inline">\(C&#39;s=b&#39;s+e&#39;\)</span></span> then</p>
<p><span>
<div class='myequationbox'><span class="math display">\[(C+C&#39;)s = (b+b&#39;)s+(e+e&#39;) \;\;(17.3)\]</span><a id='eqhomadd'></a></div></span></p>
<p>and</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{CC}}&#39;s = C(b&#39;s+e&#39;)+e =bb&#39;s+ (b&#39;e+Ce&#39;)\;. \;\;(17.4) \]</span><a id='eqhommult'></a></div></span></p>
<div id="section-1" class="pause" data-number="17.2" name="Pause">
<p>I recommend you pause here and check for yourself whether it will be the case that if <span><span class="math inline">\(C+C&#39;\)</span></span> encrypts <span><span class="math inline">\(b+b&#39;\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{CC}}&#39;\)</span></span> encrypts <span><span class="math inline">\(bb&#39;\)</span></span> up to small noise or not.</p>
</div>
<p>We would have loved to say that we can define as above <span><span class="math inline">\(C\oplus C&#39; = C+C&#39; (\mod\; q)\)</span></span> and <span><span class="math inline">\(C\otimes C&#39; = \ensuremath{\mathit{CC}}&#39; (\mod \; q)\)</span></span>. For this we would need that <span><span class="math inline">\((C+C&#39;)s\)</span></span> equals <span><span class="math inline">\((b+b&#39;)s\)</span></span> plus a “short” vector and <span><span class="math inline">\(\ensuremath{\mathit{CC}}&#39;s\)</span></span> equals <span><span class="math inline">\(bb&#39;s\)</span></span> plus a “short” vector. The former statement indeed holds. Looking at <a href='#eqhommult'>Equation 17.4</a> we see that <span><span class="math inline">\((C+C&#39;)s\)</span></span> equals <span><span class="math inline">\((b+b&#39;)s\)</span></span> up to the “noise” vector <span><span class="math inline">\(e+e&#39;\)</span></span>, and if <span><span class="math inline">\(e,e&#39;\)</span></span> are “short” then <span><span class="math inline">\(e+e&#39;\)</span></span> is not too long either. That is, if <span><span class="math inline">\(|e_i|&lt;\delta q\)</span></span> and <span><span class="math inline">\(|e&#39;_i|&lt;\delta q\)</span></span> for every <span><span class="math inline">\(i\)</span></span> then <span><span class="math inline">\(|e_i+e&#39;_i|&lt;2\delta q\)</span></span>. So we can at least handle a significant number of additions before the noise gets out of hand.</p>
<p>However, if we consider <a href='#eqhommult'>Equation 17.4</a>, we see that <span><span class="math inline">\(\ensuremath{\mathit{CC}}&#39;\)</span></span> will be equal to <span><span class="math inline">\(bb&#39;s\)</span></span> plus the “noise vector” <span><span class="math inline">\(b&#39;e + Ce&#39;\)</span></span>. The first component <span><span class="math inline">\(b&#39;e\)</span></span> of this noise vector is “short” (after all <span><span class="math inline">\(b\in \{0,1\}\)</span></span> and <span><span class="math inline">\(e\)</span></span> is “short”). However, the second component <span><span class="math inline">\(Ce&#39;\)</span></span> could be a very large vector. Indeed, since <span><span class="math inline">\(C\)</span></span> looks like a random matrix in <span><span class="math inline">\(\Z_q\)</span></span>, no matter how small the entries of <span><span class="math inline">\(e&#39;\)</span></span>, many of the entries of <span><span class="math inline">\(Ce&#39;\)</span></span> are quite likely to be of magnitude at least, say, <span><span class="math inline">\(q/2\)</span></span> and so multiplying <span><span class="math inline">\(e&#39;\)</span></span> by <span><span class="math inline">\(C\)</span></span> takes us “beyond the edge of chaos”.</p>
<h2 id="noise-management-via-encoding" data-number="17.3">Noise management via encoding</h2>
<p>The problem we had above is that the entries of <span><span class="math inline">\(C\)</span></span> are elements in <span><span class="math inline">\(\Z_q\)</span></span> that can be very large, while we would have loved them to be small numbers such as <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>. At this point one could say</p>
<blockquote>
<p><em>“If only there was some way to encode numbers between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(q-1\)</span></span> using only <span><span class="math inline">\(0\)</span></span>’s and <span><span class="math inline">\(1\)</span></span>’s”</em></p>
</blockquote>
<p>If you think about it hard enough, it turns out that there is something known as the “binary basis” that allows us to encode a number <span><span class="math inline">\(x\in\Z_q\)</span></span> as a vector <span><span class="math inline">\(\hat{x}\in\{0,1\}^{\log q}\)</span></span>.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> What’s even more surprising is that this seemingly trivial trick turns out to be immensely useful. We will define the <em>binary encoding</em> of a vector or matrix <span><span class="math inline">\(x\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span> by <span><span class="math inline">\(\hat{x}\)</span></span>. That is, <span><span class="math inline">\(\hat{x}\)</span></span> is obtained by replacing every coordinate <span><span class="math inline">\(x_i\)</span></span> with <span><span class="math inline">\(\log q\)</span></span> coordinates <span><span class="math inline">\(x_{i,0},\ldots,x_{i,\log q-1}\)</span></span> such that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[x_i = \sum_{j=0}^{\log q-1}2^j x_{i,j} \;. \;\;(17.5)\]</span><a id='eqbinaryencoding'></a></div></span></p>
<p>Specifically, if <span><span class="math inline">\(s\in \Z_q^n\)</span></span>, then we denote by <span><span class="math inline">\(\hat{s}\)</span></span> the <span><span class="math inline">\(n\log q\)</span></span>-dimensional vector with entries in <span><span class="math inline">\(\{0,1\}\)</span></span>, such that each <span><span class="math inline">\(\log q\)</span></span>-sized block of <span><span class="math inline">\(\hat{s}\)</span></span> encodes a coordinate of <span><span class="math inline">\(s\)</span></span>. Similarly, if <span><span class="math inline">\(C\)</span></span> is an <span><span class="math inline">\(m\times n\)</span></span> matrix, then we denote by <span><span class="math inline">\(\hat{C}\)</span></span> the <span><span class="math inline">\(m\times n\log q\)</span></span> matrix with entries in <span><span class="math inline">\(\{0,1\}\)</span></span> that corresponds to encoding every <span><span class="math inline">\(n\)</span></span>-dimensional row of <span><span class="math inline">\(C\)</span></span> by an <span><span class="math inline">\(n\log q\)</span></span>-dimensional row where each <span><span class="math inline">\(\log q\)</span></span>-sized block corresponds to a single entry. (We still think of the entries of these vectors and matrices as elements of <span><span class="math inline">\(\Z_q\)</span></span> and so all calculations are still done modulo <span><span class="math inline">\(q\)</span></span>.)</p>
<p>While encoding in the binary basis is not a linear operation, the <em>decoding</em> operation is linear as one can see in <a href='#eqbinaryencoding'>Equation 17.5</a>. We let <span><span class="math inline">\(Q\)</span></span> be the <span><span class="math inline">\(n \times (n\log q)\)</span></span> “decoding” matrix that maps an encoding vector <span><span class="math inline">\(\hat{v}\)</span></span> back to the original vector <span><span class="math inline">\(v\)</span></span>. Specifically, every row of <span><span class="math inline">\(Q\)</span></span> is composed of <span><span class="math inline">\(n\)</span></span> blocks each of <span><span class="math inline">\(\log q\)</span></span> size, where the <span><span class="math inline">\(i\)</span></span>-th row has only the <span><span class="math inline">\(i\)</span></span>-th block nonzero, and equal to the values <span><span class="math inline">\((1,2,4,\ldots,2^{\log q-1})\)</span></span>. It’s a good exercise to verify that for every vector <span><span class="math inline">\(v\)</span></span> and matrix <span><span class="math inline">\(C\)</span></span>, <span><span class="math inline">\(Q\hat{v}=v\)</span></span> and <span><span class="math inline">\(\hat{C}Q^\top =C\)</span></span>. (See <a href='#encodevecfig'>Figure 17.2</a> amd <a href='#encodematrixfig'>Figure 17.3</a>.)</p>
<figure>
<img src="../figure/encodevec.png" alt="17.2: We can encode a vector s\in \Z_q^n as a vector \hat{s} \in \Z_q^{n\log q} that has only entries in \{0,1\} by using the binary encoding, replacing every coordinate of s with a \log q-sized block in \hat{s}. The decoding operation is linear and so we can write s=Q\hat{s} for a specific (simple) n \times (n\log q) matrix Q." id="encodevecfig" class="margin" /><figcaption>17.2: We can encode a vector <span><span class="math inline">\(s\in \Z_q^n\)</span></span> as a vector <span><span class="math inline">\(\hat{s} \in \Z_q^{n\log q}\)</span></span> that has only entries in <span><span class="math inline">\(\{0,1\}\)</span></span> by using the binary encoding, replacing every coordinate of <span><span class="math inline">\(s\)</span></span> with a <span><span class="math inline">\(\log q\)</span></span>-sized block in <span><span class="math inline">\(\hat{s}\)</span></span>. The decoding operation is <em>linear</em> and so we can write <span><span class="math inline">\(s=Q\hat{s}\)</span></span> for a specific (simple) <span><span class="math inline">\(n \times (n\log q)\)</span></span> matrix <span><span class="math inline">\(Q\)</span></span>.</figcaption>
</figure>
<figure>
<img src="../figure/encodematrix.png" alt="17.3: We can encode an n\times n matrix C over \Z_q by an n\times (n \log q) matrix \hat{C} using the binary basis. We have the equation C=\hat{C}Q^\top where Q is the same matrix we use to decode a vector." id="encodematrixfig" class="margin" /><figcaption>17.3: We can encode an <span><span class="math inline">\(n\times n\)</span></span> matrix <span><span class="math inline">\(C\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span> by an <span><span class="math inline">\(n\times (n \log q)\)</span></span> matrix <span><span class="math inline">\(\hat{C}\)</span></span> using the binary basis. We have the equation <span><span class="math inline">\(C=\hat{C}Q^\top\)</span></span> where <span><span class="math inline">\(Q\)</span></span> is the same matrix we use to decode a vector.</figcaption>
</figure>
<p>In our final scheme the ciphertext encrypting <span><span class="math inline">\(b\)</span></span> will be an <span><span class="math inline">\((n\log q)\times (n\log q)\)</span></span> matrix <span><span class="math inline">\(C\)</span></span> with small coefficients such that <span><span class="math inline">\(Cv =bv + e\)</span></span> for a “short” <span><span class="math inline">\(e \in \Z_q^{n\log q}\)</span></span> and <span><span class="math inline">\(v=Q^\top s\)</span></span> for <span><span class="math inline">\(s\in\Z_q^n\)</span></span>. Now given ciphertexts <span><span class="math inline">\(C,C&#39;\)</span></span> that encrypt <span><span class="math inline">\(b,b&#39;\)</span></span> respectively, we will define <span><span class="math inline">\(C \oplus C&#39; = C + C&#39; \pmod{q}\)</span></span> and <span><span class="math inline">\(C \otimes C&#39; = \widehat{(\ensuremath{\mathit{CQ}}^\top)}C&#39;\)</span></span>.</p>
<p>Since we have <span><span class="math inline">\(Cv = bv + e\)</span></span> and <span><span class="math inline">\(C&#39;v = b&#39;v + e&#39;\)</span></span> we get that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[(C\oplus C&#39;)v = (C+C&#39;)v = (b+b&#39;)v + (e+e&#39;) \;\;(17.6)\]</span><a id='eqfheaddfinal'></a></div></span></p>
<p>and</p>
<p><span>
<div class='myequationbox'><span class="math display">\[(C\otimes C&#39;)v = \widehat{(\ensuremath{\mathit{CQ}}^\top)}C&#39;v = \widehat{(\ensuremath{\mathit{CQ}}^\top)}(bv+e&#39;) \;. \;\;(17.7)\]</span><a id='fhemultfinaleqfirst'></a></div></span></p>
<p>But since <span><span class="math inline">\(v=Q^\top s\)</span></span> and <span><span class="math inline">\(\hat{A}Q^\top = A\)</span></span> for every matrix <span><span class="math inline">\(A\)</span></span>, the righthand side of <a href='#fhemultfinaleqfirst'>Equation 17.7</a> equals</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\widehat{(\ensuremath{\mathit{CQ}}^\top)}(b&#39;Q^\top s+e&#39;)=b&#39;C Q^\top s+\widehat{(\ensuremath{\mathit{CQ}}^\top)}e&#39; = b&#39;Cv + \widehat{(\ensuremath{\mathit{CQ}}^\top)}e&#39; \;\;(17.8)\]</span><a id='fhemultfinaleqsec'></a></div></span></p>
<p>but since <span><span class="math inline">\(\widehat{B}\)</span></span> is a matrix with small coefficients for every <span><span class="math inline">\(B\)</span></span> and <span><span class="math inline">\(e&#39;\)</span></span> is short, the righthand side of <a href='#fhemultfinaleqsec'>Equation 17.8</a> equals <span><span class="math inline">\(b&#39;Cv\)</span></span> up to a short vector, and since <span><span class="math inline">\(Cv=bv+e\)</span></span> and <span><span class="math inline">\(b&#39;e\)</span></span> is short, we get that <span><span class="math inline">\((C\otimes C&#39;)v\)</span></span> equals <span><span class="math inline">\(b&#39;bv\)</span></span> plus a short vector as desired.</p>
<p>If we keep track of the parameters in the above analysis, we can see that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[C \overline{\wedge} C&#39; = (I - C \otimes C&#39;)\]</span></div></span></p>
<p>then if <span><span class="math inline">\(C\)</span></span> encrypts <span><span class="math inline">\(b\)</span></span> and <span><span class="math inline">\(C&#39;\)</span></span> encrypts <span><span class="math inline">\(b&#39;\)</span></span> with noise vectors <span><span class="math inline">\(e,e&#39;\)</span></span> satisfying <span><span class="math inline">\(\max |e_i| \leq \mu\)</span></span> and <span><span class="math inline">\(\max |e&#39;_i| \leq \mu&#39;\)</span></span> then <span><span class="math inline">\(C \overline{\wedge} C&#39;\)</span></span> encrypts <span><span class="math inline">\(b \; \ensuremath{\mathit{NAND}}\; b&#39;\)</span></span> up to a vector of maximum magnitude at most <span><span class="math inline">\(O(\mu + n\log q \mu&#39;)\)</span></span>.</p>
<h2 id="putting-it-all-together" data-number="17.4">Putting it all together</h2>
<p>We now describe the full scheme. We are going to use a quantitatively stronger version of LWE. Namely, the <span><span class="math inline">\(q(n)\)</span></span>-dLWE assumption for <span><span class="math inline">\(q(n)=2^{\sqrt{n}}\)</span></span>. It is not hard to show that we can relax our assumption to <span><span class="math inline">\(q(n)\)</span></span>-LWE <span><span class="math inline">\(q(n)=2^{polylog(n)}\)</span></span> and Brakerski and Vaikuntanathan showed how to relax the assumption to standard (i.e. <span><span class="math inline">\(q(n)=poly(n)\)</span></span>) LWE though we will not present this here.</p>
<blockquote>
<p><strong>FHEENC:</strong></p>
<ul>
<li><p><strong>Key generation:</strong> As in the scheme of last lecture the secret key is <span><span class="math inline">\(s\in\Z_s^n\)</span></span> and the public key is a generator <span><span class="math inline">\(G_s\)</span></span> such that samples from <span><span class="math inline">\(G_s(1^n)\)</span></span> are indistinguishable from independent random samples from <span><span class="math inline">\(\Z_q^n\)</span></span> but if <span><span class="math inline">\(c\)</span></span> is output by <span><span class="math inline">\(G_s\)</span></span> then <span><span class="math inline">\(|\langle c,s \rangle|&lt;\sqrt{q}\)</span></span>, where the inner product (as all other computations) is done modulo <span><span class="math inline">\(q\)</span></span> and for every <span><span class="math inline">\(x\in\Z_q=\{0,\ldots,q-1\}\)</span></span> we define <span><span class="math inline">\(|x|=\min \{ x, q-x \}\)</span></span>. As before, we can assume that <span><span class="math inline">\(s_1 = \floor{q/2}\)</span></span> which implies that <span><span class="math inline">\((Q^\top s)_1\)</span></span> is also <span><span class="math inline">\(\floor{q/2}\)</span></span> since (as can be verified by direct inspection) the first row of <span><span class="math inline">\(Q^\top\)</span></span> is <span><span class="math inline">\((1,0,\ldots,0)\)</span></span>.</p></li>
<li><p><strong>Encryption:</strong> To encrypt <span><span class="math inline">\(b\in\{0,1\}\)</span></span>, let <span><span class="math inline">\(d_1,\ldots,d_(n\log q) \leftarrow_R G_s(1^n)\)</span></span> output <span><span class="math inline">\(C=\widehat{(bQ^\top +D)}\)</span></span> where <span><span class="math inline">\(D\)</span></span> is the matrix whose rows are <span><span class="math inline">\(d_1,\ldots,d_{n\log q}\)</span></span> generated from <span><span class="math inline">\(G_s\)</span></span>. (See <a href='#fheencfig'>Figure 17.4</a>)</p></li>
<li><p><strong>Decryption:</strong> To decrypt the ciphertext <span><span class="math inline">\(C\)</span></span>, we output <span><span class="math inline">\(0\)</span></span> if <span><span class="math inline">\(|(\ensuremath{\mathit{CQ}}^\top s)_1|&lt;0.1q\)</span></span> and output <span><span class="math inline">\(1\)</span></span> if <span><span class="math inline">\(0.6q&gt;|(\ensuremath{\mathit{CQ}}^\top s)_1|&gt;0.4q\)</span></span>, see <a href='#fhedecfig'>Figure 17.5</a>. (It doesn’t matter what we output on other cases.)</p></li>
<li><p><strong>NAND evaluation:</strong> Given ciphertexts <span><span class="math inline">\(C,C&#39;\)</span></span>, we define <span><span class="math inline">\(C \overline{\wedge} C&#39;\)</span></span> (sometimes also denoted as <span><span class="math inline">\(\ensuremath{\mathit{NANDEVAL}}(C,C&#39;)\)</span></span>) to equal <span><span class="math inline">\(I- \widehat{(\ensuremath{\mathit{CQ}}^\top)}C&#39;\)</span></span>, where <span><span class="math inline">\(I\)</span></span> is the <span><span class="math inline">\((n\log q)\times (n\log q)\)</span></span> identity matrix.</p></li>
</ul>
</blockquote>
<p><br />
</p>
<p><br />
</p>
<div id="section-2" class="pause" data-number="17.4" name="Pause">
<p>Please take your time to read the definition of the scheme, and go over <a href='#fheencfig'>Figure 17.4</a> and <a href='#fhedecfig'>Figure 17.5</a> to make sure you understand it.</p>
</div>
<figure>
<img src="../figure/fheenc.png" alt="17.4: In our fully homomorphic encryption, the public key is a trapdoor generator G_s. To encrypt a bit b, we output C=\widehat{(bQ^\top +D)} where D is a (n\log q) \times n matrix whose rows are generated using G_s." id="fheencfig" class="margin" /><figcaption>17.4: In our fully homomorphic encryption, the public key is a trapdoor generator <span><span class="math inline">\(G_s\)</span></span>. To encrypt a bit <span><span class="math inline">\(b\)</span></span>, we output <span><span class="math inline">\(C=\widehat{(bQ^\top +D)}\)</span></span> where <span><span class="math inline">\(D\)</span></span> is a <span><span class="math inline">\((n\log q) \times n\)</span></span> matrix whose rows are generated using <span><span class="math inline">\(G_s\)</span></span>.</figcaption>
</figure>
<figure>
<img src="../figure/fhedec.png" alt="17.5: We decrypt a ciphertext C=\widehat{(bQ^\top +D)} by looking at the first coordinate of \ensuremath{\mathit{CQ}}^\top s (or equivalently, \ensuremath{\mathit{CQ}}^\top Q\hat{s}). If b=0 then this equals to the first coordinate of Ds, which is at most \sqrt{q} in magintude. If b=1 then we get an extra factor of Q^\top s which we set to be in the interval (0.499q,0.51q). We can think of either s or \hat{s} as our secret key." id="fhedecfig" class="margin" /><figcaption>17.5: We decrypt a ciphertext <span><span class="math inline">\(C=\widehat{(bQ^\top +D)}\)</span></span> by looking at the first coordinate of <span><span class="math inline">\(\ensuremath{\mathit{CQ}}^\top s\)</span></span> (or equivalently, <span><span class="math inline">\(\ensuremath{\mathit{CQ}}^\top Q\hat{s}\)</span></span>). If <span><span class="math inline">\(b=0\)</span></span> then this equals to the first coordinate of <span><span class="math inline">\(Ds\)</span></span>, which is at most <span><span class="math inline">\(\sqrt{q}\)</span></span> in magintude. If <span><span class="math inline">\(b=1\)</span></span> then we get an extra factor of <span><span class="math inline">\(Q^\top s\)</span></span> which we set to be in the interval <span><span class="math inline">\((0.499q,0.51q)\)</span></span>. We can think of either <span><span class="math inline">\(s\)</span></span> or <span><span class="math inline">\(\hat{s}\)</span></span> as our secret key.</figcaption>
</figure>
<h2 id="analysis-of-our-scheme" data-number="17.5">Analysis of our scheme</h2>
<p>To show that that this scheme is a valid partially homomorphic scheme we need to show the following properties:</p>
<ol type="1">
<li><p><strong>Correctness:</strong> The decryption of an encryption of <span><span class="math inline">\(b\in\{0,1\}\)</span></span> equals <span><span class="math inline">\(b\)</span></span>.</p></li>
<li><p><strong>CPA security:</strong> An encryption of <span><span class="math inline">\(0\)</span></span> is computationally indistinguishable from an encryption of <span><span class="math inline">\(1\)</span></span> to someone that got the public key.</p></li>
<li><p><strong>Homomorphism:</strong> If <span><span class="math inline">\(C\)</span></span> encrypts <span><span class="math inline">\(b\)</span></span> and <span><span class="math inline">\(C&#39;\)</span></span> encrypts <span><span class="math inline">\(b&#39;\)</span></span> then <span><span class="math inline">\(C \overline{\wedge} C&#39;\)</span></span> encrypts <span><span class="math inline">\(b\; \ensuremath{\mathit{NAND}}\; b&#39;\)</span></span> (with a higher amount of noise). The growth of the noise will be the reason that we will not get immediately a fully homomorphic encryption.</p></li>
<li><p><strong>Shallow decryption circuit:</strong> To plug this scheme into the bootstrapping theorem we will need to show that its decryption algorithm (or more accurately, the function in the statement of the bootstrapping theorem) can be evaluated in depth <span><span class="math inline">\(polylog(n)\)</span></span> (independently of <span><span class="math inline">\(q\)</span></span>), and that moreover, the noise grows slowly enough that our scheme is homomorphic with respect to such circuits.</p></li>
</ol>
<p>Once we obtain 1-4 above, we can plug FHEENC into the Bootstrapping Theorem (<a href='lec_15_FHE.html#bootstrapthm'>Theorem 16.8</a>) and thus complete the proof of existence of a fully homomorphic encryption scheme. We now address those points one by one.</p>
<h3 id="correctness" data-number="17.5.1">Correctness</h3>
<p>Correctness of the scheme will follow from the following stronger condition:</p>
<div id="fhecorrectlem" class="lemma" data-number="17.5.1" name="Lemma 17.3">
<p>For every <span><span class="math inline">\(b \in \{0,1\}\)</span></span>, if <span><span class="math inline">\(C\)</span></span> is the encryption of <span><span class="math inline">\(b\)</span></span> then it is an <span><span class="math inline">\((n\log q)\times (n \log q)\)</span></span> matrix satisfying <span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{CQ}}^\top s = bQ^\top s + e\]</span></div></span> where <span><span class="math inline">\(\max |e_i| \ll \sqrt{q}\)</span></span>.</p>
</div>
<div id="section-3" class="proof" data-ref="fhecorrectlem" data-number="17.5.1" name="Proof">
<p>For starters, let us see that the dimensions make sense: the encryption of <span><span class="math inline">\(b\)</span></span> is computed by <span><span class="math inline">\(C=\widehat{(bQ^\top +D)}\)</span></span> where <span><span class="math inline">\(D\)</span></span> is an <span><span class="math inline">\((n\log q)\times n\)</span></span> matrix satisfying <span><span class="math inline">\(|Ds|_i \leq \sqrt{q}\)</span></span> for every <span><span class="math inline">\(i\)</span></span> and <span><span class="math inline">\(I\)</span></span> is the <span><span class="math inline">\((n\log q)\times (n\log q)\)</span></span>.</p>
<p>Since <span><span class="math inline">\(Q^\top\)</span></span> is also an <span><span class="math inline">\((n \log q) \times n\)</span></span> matrix, adding <span><span class="math inline">\(bQ^\top\)</span></span> (i.e. either <span><span class="math inline">\(Q^\top\)</span></span> or the all-zeroes matrix, depending on whether or not <span><span class="math inline">\(b=1\)</span></span>) to <span><span class="math inline">\(D\)</span></span> makes sense and applying the <span><span class="math inline">\(\hat{\cdot}\)</span></span> operation will transform every row to length <span><span class="math inline">\(n\log q\)</span></span> and hence <span><span class="math inline">\(C\)</span></span> is indeed a square <span><span class="math inline">\((n\log q)\times (n \log q)\)</span></span> matrix.</p>
<p>Let us now see what this matrix <span><span class="math inline">\(C\)</span></span> does to the vector <span><span class="math inline">\(v=Q^\top s\)</span></span>. Using the fact that <span><span class="math inline">\(\hat{M}Q^\top = M\)</span></span> for every matrix <span><span class="math inline">\(M\)</span></span>, we get that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[Cv = (bQ^\top + D) s = bv+  Ds\]</span></div></span></p>
<p>but by construction <span><span class="math inline">\(|(Ds)_i| \leq \sqrt{q}\)</span></span> for every <span><span class="math inline">\(i\)</span></span>.</p>
</div>
<p><a href='#fhecorrectlem'>Lemma 17.3</a> implies correctness of decryption since by construction we ensured that <span><span class="math inline">\((Q^\top s)_1 \in (0.499q,0.5001q)\)</span></span> and hence we get that if <span><span class="math inline">\(b=0\)</span></span> then <span><span class="math inline">\(|(Cv)_1|=o(q)\)</span></span> and if <span><span class="math inline">\(b=1\)</span></span> then <span><span class="math inline">\(0.499q-o(q) \leq |(C_v)_1| \leq 0.501q + o(q)\)</span></span>.</p>
<h3 id="cpa-security" data-number="17.5.2">CPA Security</h3>
<p>To show CPA security we need to show that an encryption of <span><span class="math inline">\(0\)</span></span> is indistinguishable from an encryption of <span><span class="math inline">\(1\)</span></span>. However, by the security of the trapdoor generator, an encryption of <span><span class="math inline">\(b\)</span></span> computed according to our algorithm will be indistinguishable from an encryption of <span><span class="math inline">\(b\)</span></span> obtained when the matrix <span><span class="math inline">\(D\)</span></span> is a random <span><span class="math inline">\((q\log n)\times n\)</span></span> matrix. Now in this case the encryption is obtained by applying the <span><span class="math inline">\(\hat{\cdot}\)</span></span> operation to <span><span class="math inline">\(bQ^\top +D\)</span></span> but if <span><span class="math inline">\(D\)</span></span> is uniformly random then for every choice of <span><span class="math inline">\(b\)</span></span>, <span><span class="math inline">\(bQ^\top + D\)</span></span> is uniformly random (since a fixed matrix plus a random matrix yields a random matrix) and hence the matrix <span><span class="math inline">\(bQ^\top + D\)</span></span> (and so also the matrix <span><span class="math inline">\(\widehat{bQ^\top+D}\)</span></span>) contains no information about <span><span class="math inline">\(b\)</span></span>. This completes the proof of CPA security (can you see why?).</p>
<p>If we want to plug in this scheme in the bootstrapping theorem, then we will also assume that it is <em>circular secure</em>. It seems a reasonable assumption though unfortuantely at the moment we do not know how to derive it from LWE. (If we don’t want to make this assumption we can still obtained a <em>leveled</em> fully homomorphic encryption as discussed in the previous lecture.)</p>
<h3 id="homomorphism" data-number="17.5.3">Homomorphism</h3>
<p>Let <span><span class="math inline">\(v=Qs\)</span></span>, <span><span class="math inline">\(b\in\{0,1\}\)</span></span> and <span><span class="math inline">\(C\)</span></span> be a ciphertext such that <span><span class="math inline">\(Cv = bv + e\)</span></span>. We define the <em>noise</em> of <span><span class="math inline">\(C\)</span></span>, denoted as <span><span class="math inline">\(\mu(C)\)</span></span> to be the maximum of <span><span class="math inline">\(|e_i|\)</span></span> over all <span><span class="math inline">\(i\in[n\log q]\)</span></span>. We make the following lemma, which we’ll call the “noisy homomorphism lemma”:</p>
<div id="noisehomolem" class="lemma" data-number="17.5.3" name="Lemma 17.4">
<p>Let <span><span class="math inline">\(C,C&#39;\)</span></span> be ciphertexts encrypting <span><span class="math inline">\(b,b&#39;\)</span></span> respectively with <span><span class="math inline">\(\mu(C),\mu(C&#39;)\leq q/4\)</span></span>. Then <span><span class="math inline">\(C&#39;&#39;=C \overline{\wedge} C&#39;\)</span></span> encrypts <span><span class="math inline">\(b\; \ensuremath{\mathit{NAND}}\; b&#39;\)</span></span> and satisfies <span>
<div class='myequationbox'><span class="math display">\[\mu(C&#39;&#39;) \leq (2n\log q)\max\{ \mu(C), \mu(C&#39;) \} \;\;(17.12)\]</span><a id='eqnoisebound'></a></div></span></p>
</div>
<div id="section-4" class="proof" data-ref="noisehomolem" data-number="17.5.3" name="Proof">
<p>This follows from the calculations we have done before. As we’ve seen, <span>
<div class='myequationbox'><span class="math display">\[\widehat{CQ^\top}C&#39;v = \widehat{CQ^\top}(b&#39;v+e&#39;) = b&#39;\widehat{CQ^\top}Q^\top s + \widehat{CQ^\top}e&#39; = b&#39;(Cv)+ \widehat{CQ^\top}e&#39; = bb&#39;v + b&#39;e+ \widehat{CQ^\top}e&#39;\]</span></div></span> But since <span><span class="math inline">\(\widehat{CQ^\top}\)</span></span> is a <span><span class="math inline">\(0/1\)</span></span> matrix with every row of length <span><span class="math inline">\(n\log q\)</span></span>, for every <span><span class="math inline">\(i\)</span></span> <span><span class="math inline">\((\widehat{CQ^\top}e&#39;)_i \leq (n\log q)\max_j |e_j|\)</span></span>. We see that the noise vector in the product has magnitude at most <span><span class="math inline">\(\mu(C)+n\log q \mu(C&#39;)\)</span></span>. Adding the identity for the NAND operation adds at most <span><span class="math inline">\(\mu(C)+\mu(C&#39;)\)</span></span> to the noise, and so the total noise magnitude is bounded by the righthand side of <a href='#eqnoisebound'>Equation 17.12</a>.</p>
</div>
<h3 id="shallow-decryption-circuit" data-number="17.5.4">Shallow decryption circuit</h3>
<p>Recall that to plug in our homomorphic encryption scheme into the bootstrapping theorem, we needed to show that for every ciphertexts <span><span class="math inline">\(C,C&#39;\)</span></span> (generated by the encryption algorithm) the function <span><span class="math inline">\(f:\{0,1\}^{n \log q} \rightarrow \{0,1\}\)</span></span> defined as</p>
<p><span>
<div class='myequationbox'><span class="math display">\[f(d) = D_d(C) \;\ensuremath{\mathit{NAND}}\; D_d(C&#39;)\]</span></div></span></p>
<p>can be homomorphically evaluated where <span><span class="math inline">\(d\)</span></span> is the secret key and <span><span class="math inline">\(D_d(C)\)</span></span> denotes the decryption algorithm applied to <span><span class="math inline">\(C\)</span></span>.</p>
<p>In our case we can think of the secret key as the binary string <span><span class="math inline">\(\hat{s}\)</span></span> which describes our vector <span><span class="math inline">\(s\)</span></span> as a bit string of length <span><span class="math inline">\(n\log q\)</span></span>. Given a ciphertext <span><span class="math inline">\(C\)</span></span>, the decryption algorithm takes the dot product modulo <span><span class="math inline">\(q\)</span></span> of <span><span class="math inline">\(s\)</span></span> with the first row of <span><span class="math inline">\(\ensuremath{\mathit{CQ}}^\top\)</span></span> (or, equivalently, the dot product of <span><span class="math inline">\(\hat{q}\)</span></span> with <span><span class="math inline">\(\ensuremath{\mathit{CQ}}^\top Q\)</span></span>) and outputs <span><span class="math inline">\(0\)</span></span> (respectively <span><span class="math inline">\(1\)</span></span>) if the resulting number is small (respectively large).</p>
<p>By repeatedly applying the noisy homomorphism lemma (<a href='#noisehomolem'>Lemma 17.4</a>), we can show that can homorphically evaluate every circuit of NAND gates whose <em>depth</em> <span><span class="math inline">\(\ell\)</span></span> satisfies <span><span class="math inline">\((2n\log q)^\ell \ll q\)</span></span>. If <span><span class="math inline">\(q = 2^{\sqrt{n}}\)</span></span> then (assuming <span><span class="math inline">\(n\)</span></span> is sufficiently large) then as long as <span><span class="math inline">\(\ell &lt; n^{0.49}\)</span></span> this will be satisfied.</p>
<p>In particular to show that <span><span class="math inline">\(f(\cdot)\)</span></span> can be homomorphically evaluated it will suffice to show that for every fixed vector <span><span class="math inline">\(c\in \Z_q^{n\log q}\)</span></span> there is a <span><span class="math inline">\(polylog(n) \ll n^{0.49}\)</span></span> depth circuit <span><span class="math inline">\(F\)</span></span> that on input a string <span><span class="math inline">\(\hat{s}\in\{0,1\}^{n \log q}\)</span></span> will output <span><span class="math inline">\(0\)</span></span> if <span><span class="math inline">\(|\langle c,\hat{s \rangle}| &lt; q/10\)</span></span> and output <span><span class="math inline">\(1\)</span></span> if <span><span class="math inline">\(|\langle c,\hat{s \rangle}| &gt; q/5\)</span></span>. (We don’t care what <span><span class="math inline">\(F\)</span></span> does otherwise. The above suffices since given a ciphertext <span><span class="math inline">\(C\)</span></span> we can use <span><span class="math inline">\(F\)</span></span> with the vector <span><span class="math inline">\(c\)</span></span> being the top row of <span><span class="math inline">\(\ensuremath{\mathit{CQ}}^\top Q\)</span></span>, and hence <span><span class="math inline">\(\langle c,\hat{s \rangle}\)</span></span> would correspond to the first entry of <span><span class="math inline">\(\ensuremath{\mathit{CQ}}^\top s\)</span></span>. Note that if <span><span class="math inline">\(F\)</span></span> has depth <span><span class="math inline">\(\ell\)</span></span> then the function <span><span class="math inline">\(f()\)</span></span> above has depth at most <span><span class="math inline">\(\ell+1\)</span></span>.)</p>
<div id="section-5" class="pause" data-number="17.5.4" name="Pause">
<p>Please make sure you understand the above argument.</p>
</div>
<p>If <span><span class="math inline">\(c=(c_1,\ldots,c_{n\log q})\)</span></span> is a vector then to compute its inner product with a <span><span class="math inline">\(0/1\)</span></span> vector <span><span class="math inline">\(\hat{s}\)</span></span> we simply need to sum up the numbers <span><span class="math inline">\(c_i\)</span></span> where <span><span class="math inline">\(\hat{s}_i=1\)</span></span>. Summing up <span><span class="math inline">\(m\)</span></span> numbers can be done via the obvious recursion in depth that is <span><span class="math inline">\(\log m\)</span></span> times the depth for a single addition of two numbers. However, the naive way to add two numbers in <span><span class="math inline">\(\Z_q\)</span></span> (each represented by <span><span class="math inline">\(\log q\)</span></span> bits) will have depth <span><span class="math inline">\(O(\log q)\)</span></span> which is too much for us.</p>
<div id="section-6" class="pause" data-number="17.5.4" name="Pause">
<p>Please stop here and see if you understand why the natural circuit to compute the addition of two numbers modulo <span><span class="math inline">\(q\)</span></span> (represented as <span><span class="math inline">\(\log q\)</span></span>-length binary strings) will require depth <span><span class="math inline">\(O(\log q)\)</span></span>. As a hint, one needs to keep track of the “carry”.</p>
</div>
<p>Fortunately, because we only care about accuracy up to <span><span class="math inline">\(q/10\)</span></span>, if we add <span><span class="math inline">\(m\)</span></span> numbers, we can drop all but the first <span><span class="math inline">\(100\log m\)</span></span> most significant digits of our numbers, since including them can change the sum of the <span><span class="math inline">\(n\)</span></span> numbers by at most <span><span class="math inline">\(m(q/m^{100}) \ll q\)</span></span>. Hence we can easily do this work in <span><span class="math inline">\(poly(\log m)\)</span></span> depth, which is <span><span class="math inline">\(poly(\log n)\)</span></span> since <span><span class="math inline">\(m=poly(n)\)</span></span>.</p>
<p>Let us now show this more formally:</p>
<div id="decdepthlem" class="lemma" data-number="17.5.4" name="Lemma 17.5">
<p>For every <span><span class="math inline">\(c\in\Z_q^m\)</span></span> there exists some function <span><span class="math inline">\(f:\{0,1\}^m\rightarrow\{0,1\}\)</span></span> such that:<br />
1. For every <span><span class="math inline">\(\hat{s}\in \{0,1\}^n\)</span></span> such that <span><span class="math inline">\(|\langle \hat{s \rangle,c}|&lt;0.1q\)</span></span>, <span><span class="math inline">\(f(\hat{s})=0\)</span></span><br />
2. For every <span><span class="math inline">\(\hat{s}\in \{0,1\}^n\)</span></span> such that <span><span class="math inline">\(0.4q&lt;|\langle \hat{s \rangle,c}|&lt;0.6q\)</span></span>, <span><span class="math inline">\(f(\hat{s})=1\)</span></span><br />
3. There is a circuit computing <span><span class="math inline">\(f\)</span></span> of depth at most <span><span class="math inline">\(100(\log m)^3\)</span></span>.</p>
</div>
<div id="section-7" class="proof" data-ref="decdepthlem" data-number="17.5.4" name="Proof">
<p>For every number <span><span class="math inline">\(x\in\Z_q\)</span></span>, write <span><span class="math inline">\(\tilde{x}\)</span></span> to be the number that is obtained by writing <span><span class="math inline">\(x\)</span></span> in the binary basis and setting all digits except the <span><span class="math inline">\(10\log m\)</span></span> most significant ones to zero.<br />
Note that <span><span class="math inline">\(\tilde{x} \leq x \leq \tilde{x} + q/m^{10}\)</span></span>. We define <span><span class="math inline">\(f(\hat{s})\)</span></span> to equal <span><span class="math inline">\(1\)</span></span> if <span><span class="math inline">\(|\sum \hat{s}_i \tilde{c}_i (\mod \tilde{q})| \geq 0.3\tilde{q}\)</span></span> and to equal <span><span class="math inline">\(0\)</span></span> otherwise (where as usual the absolute value of <span><span class="math inline">\(x\)</span></span> modulo <span><span class="math inline">\(\tilde{q}\)</span></span> is the minimum of <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(\tilde{q}-x\)</span></span>.) Note that all numbers involved have zeroes in all but the <span><span class="math inline">\(10\log m\)</span></span> most significant digits and so these less significant digits can be ignored. Hence we can add any pair of such numbers modulo <span><span class="math inline">\(\tilde{q}\)</span></span> in depth <span><span class="math inline">\(O(\log m)^2\)</span></span> using the standard elementary school algorithm to add two <span><span class="math inline">\(\ell\)</span></span>-digit numbers in <span><span class="math inline">\(O(\ell^2)\)</span></span> steps. Now we can add the <span><span class="math inline">\(m\)</span></span> numbers by adding pairs, and then adding up the results, and this way in a binary tree of depth <span><span class="math inline">\(\log m\)</span></span> to get a total depth of <span><span class="math inline">\(O(\log m)^3\)</span></span>. So, all that is left to prove is that this function <span><span class="math inline">\(f\)</span></span> satisfies the conditions (1) and (2).</p>
<p>Note that <span><span class="math inline">\(|\sum \hat{s}_i \tilde{c}_i - \sum \hat{s}_i c_i | &lt; mq/m^10 = q/m^9\)</span></span> so now we want to show that the effect of taking modulo <span><span class="math inline">\(\tilde{q}\)</span></span> is not much different from taking modulo <span><span class="math inline">\(q\)</span></span>. Indeed, note that this sum (before a modular reduction) is an integer between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(qm\)</span></span>. If <span><span class="math inline">\(x\)</span></span> is such an integer and we divide <span><span class="math inline">\(x\)</span></span> by <span><span class="math inline">\(q\)</span></span> to write <span><span class="math inline">\(x = kq+ r\)</span></span> for <span><span class="math inline">\(r&lt;q\)</span></span>, then since <span><span class="math inline">\(x&lt;qm\)</span></span>, <span><span class="math inline">\(k&lt;m\)</span></span>, and so we can write <span><span class="math inline">\(x = k\tilde{q} + k(q-\tilde{q})+r\)</span></span> so the difference between <span><span class="math inline">\(k \mod q\)</span></span> and <span><span class="math inline">\(k \mod{\tilde{q}}\)</span></span> will be (in our standard modular metric) at most <span><span class="math inline">\(mq/m^{10}=q/m^9\)</span></span>. Overall we get that if <span><span class="math inline">\(\sum \hat{s}_i c_i \mod{q}\)</span></span> is in the interval <span><span class="math inline">\([0.4q, 0.6q]\)</span></span> then <span><span class="math inline">\(\sum \hat{s}_i \tilde{c}_i ( \mod{\tilde{q}})\)</span></span> will be in the interval <span><span class="math inline">\([0.4q-100q/m^9, 0.6q+100q/m^9]\)</span></span> which is contained in <span><span class="math inline">\([0.3\tilde{q},0.7\tilde{q}]\)</span></span>.</p>
</div>
<p>This completes the proof that our scheme can fit into the bootstrapping theorem (i.e., of <a href='#LWEFHEthm'>Theorem 17.1</a>), hence completing the description of the fully homomorphic encryption scheme.</p>
<div id="section-8" class="pause" data-number="17.5.4" name="Pause">
<p>Now would be a good point to go back and see you understand how all the pieces fit together to obtain the complete construction of the fully homomorphic encryption scheme.</p>
</div>
<h2 id="example-application-private-information-retrieval" data-number="17.6">Example application: Private information retrieval</h2>
<p>To be completed</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>This theorem as stated was proven by Brakerski and Vaikuntanathan (ITCS 2014) building a line of work initiated by Gentry’s original STOC 2009 work. We will actually prove a weaker version of this theorem, due to Brakerski and Vaikuntanathan (FOCS 2011), which assumes a quantitative strengthening of LWE. However, we will not follow the proof of Brakerski and Vaikuntanathan but rather a scheme of Gentry, Sahai and Waters (CRYPTO 2013). Also note that, as noted in the previous lecture, all of these results require the extra assumption of <em>circular security</em> on top of LWE to achieve a non-leveled fully homomorphic encryption scheme.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>For this reason, Craig Gentry called his highly recommended survey on fully homomorphic encryption and other advanced constructions <a href="https://eprint.iacr.org/2014/610">computing on the edge of chaos</a>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>We deliberately leave some flexibility in the definition of “short”. While initially “short” might mean that <span><span class="math inline">\(|e_i|&lt;\sqrt{q}\)</span></span> for every <span><span class="math inline">\(i\)</span></span>, decryption will succeed as long as long as <span><span class="math inline">\(|e_i|\)</span></span> is, say, at most <span><span class="math inline">\(q/100\)</span></span>.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>If we were being pedantic the length of the vector (and other constant below) should be the integer <span><span class="math inline">\(\ceil{\log q}\)</span></span> but I omit the ceiling symbols for simplicity of notation.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=FHE II: Construction+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 03/06/2020 09:07:04</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_16_FHE_part2.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
