<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Quantum computing</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Quantum computing" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#countoperation"><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash functions and random oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "bitcoin" problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The currency problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The bitcoin ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From proof of work to consensus on ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision resistance hash functions and creating short "unique" identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical constructions of cryptographic hash functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical random-ish functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some history</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions."><i class="fa fa-check"></i><b>7.4.3</b> The NSA and hash functions.</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs non-cryptographic hash functions:</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#an-lwe-based-encryption-scheme"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Quantum computing</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_19_quantum.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="quantum-computing-and-cryptography-i" data-number="20">Quantum computing and cryptography I</h1>
<blockquote>
<p><em>“I think I can safely say that nobody understands quantum mechanics.”</em> , Richard Feynman, 1965</p>
</blockquote>
<blockquote>
<p><em>“The only difference between a probabilistic classical world and the equations of the quantum world is that somehow or other it appears as if the probabilities would have to go negative”</em>, Richard Feynman, 1982</p>
</blockquote>
<p>For much of the history of mankind, people believed that the ultimate “theory of everything” would be of the “billiard ball” type. That is, at the end of the day, everything is composed of some elementary particles and adjacent particles interact with one another according to some well specified laws. The types of particles and laws might differ, but not the general shape of the theory. Note that this in particular means that a system of <span><span class="math inline">\(N\)</span></span> particles can be simulated by a computer with <span><span class="math inline">\(poly(N)\)</span></span> memory and time.</p>
<p>Alas, in the beginning of the 20th century, several experimental results were calling into question the “billiard ball” theory of the world. One such experiment is the famous “double slit” experiment. Suppose we shoot an electron at a wall that has a single slit at position <span><span class="math inline">\(i\)</span></span> and put somewhere behind this slit a detector. If we let <span><span class="math inline">\(p_i\)</span></span> be the probability that the electron goes through the slit and let <span><span class="math inline">\(q_i\)</span></span> be the probability that conditioned on this event, the electron hits this detector, then the fraction of times the electron hits our detector should be (and indeed is) <span><span class="math inline">\(\alpha = p_iq_i\)</span></span>. Similarly, if we close this slit and open a second slit at position <span><span class="math inline">\(j\)</span></span> then the new fraction of times the electron hits our detector will be <span><span class="math inline">\(\beta=p_jq_j\)</span></span>. Now if we open both slits then it seems that the fraction should be <span><span class="math inline">\(\alpha+\beta\)</span></span> and in particular, “obviously” the probability that the electron hits our detector should only <em>increase</em> if we open a second slit. However, this is not what actually happens when we run this experiment. It can be that the detector is hit a <em>smaller</em> number of times when two slits are open than when only a single one hits. It’s almost as if the electron checks whether two slits are open, and if they are, it changes the path it takes. If we try to “catch the electron in the act” and place a detector right next to each slit so we can count which electron went through which slit then something even more bizarre happened. The mere fact that we <em>measured</em> the electron path changes the actual path it takes, and now this “destructive interference” pattern is gone and the detector will be hit <span><span class="math inline">\(\alpha+\beta\)</span></span> fraction of the time.</p>
<figure>
<img src="../figure/double-slit-setup.PNG" alt="21.1: The setup of the double slit experiment" id="tmplabelfig" class="margin" /><figcaption>21.1: The setup of the double slit experiment</figcaption>
</figure>
<figure>
<img src="../figure/double_slit2.jpg" alt="21.1: In the double slit experiment, opening two slits can actually cause some positions to receive fewer electrons than before." id="tmplabelfig" class="margin" /><figcaption>21.1: In the double slit experiment, opening two slits can actually cause some positions to receive <em>fewer</em> electrons than before.</figcaption>
</figure>
<p>Quantum mechanics is a mathematical theory that allows us to calculate and predict the results of this and many other examples. If you think of quantum as an explanation as to what “really” goes on in the world, it can be rather confusing. However, if you simply “shut up and calculate” then it works amazingly well at predicting the results of a great many experiments.</p>
<p>In the double slit experiment, quantum mechanics still allows to compute numbers <span><span class="math inline">\(\alpha\)</span></span> and <span><span class="math inline">\(\beta\)</span></span> that denote “probabilities” that the first and second electrons hit the detector. The only difference that in quantum mechanics these probabilities might be <em>negative</em> numbers. However, probabilities can only be negative when no one is looking at them. When we actually measure what happened to the detector, we make the probabilities positive by <em>squaring</em> them. So, if only the first slit is open, the detector will be hit <span><span class="math inline">\(\alpha^2\)</span></span> fraction of the time. If only the second slit is open, the detector will be hit <span><span class="math inline">\(\beta^2\)</span></span> fraction of the time. And if both slits are open, the detector will be hit <span><span class="math inline">\((\alpha+\beta)^2\)</span></span> fraction of the time. Note that it can well be that <span><span class="math inline">\((\alpha+\beta)^2 &lt; \alpha^2 + \beta^2\)</span></span> and so this calculation explains why the number of times a detector is hit when two slits are open might be <em>smaller</em> than the number of times it is hit when either slit is open. If you haven’t seen it before, it may seem like complete nonsense and at this point I’ll have to politely point you back to the part where I said we should not question quantum mechanics but simply “shut up and calculate”.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>Some of the counterintuitive properties that arise from these negative probabilities include:</p>
<ul>
<li><strong>Interference</strong> - As we see here, probabilities can “cancel each other out”.</li>
<li><strong>Measurement</strong> - The idea that probabilities are negative as long as “no one is looking” and “collapse” to positive probabilities when they are <em>measured</em> is deeply disturbing. Indeed, people have shown that it can yield to various strange outcomes such as “spooky actions at a distance”, where we can measure an object at one place and instantaneously (faster than the speed of light) cause a difference in the results of a measurements in a place far removed. Unfortunately (or fortunately?) these strange outcomes have been confirmed experimentally.</li>
<li><strong>Entanglement</strong> - The notion that two parts of the system could be connected in this weird way where measuring one will affect the other is known as <em>quantum entanglement</em>.</li>
</ul>
<p>Again, as counter-intuitive as these concepts are, they have been experimentally confirmed, so we just have to live with them.</p>
<h3 id="quantum-computing-and-computation---an-executive-summary." data-number="20.0.1">Quantum computing and computation - an executive summary.</h3>
<p>One of the strange aspects of the quantum-mechanical picture of the world is that unlike in the billiard ball example, there is no obvious algorithm to simulate the evolution of <span><span class="math inline">\(n\)</span></span> particles over <span><span class="math inline">\(t\)</span></span> time periods in <span><span class="math inline">\(poly(n,t)\)</span></span> steps. In fact, the natural way to simulate <span><span class="math inline">\(n\)</span></span> quantum particles will require a number of steps that is <em>exponential</em> in <span><span class="math inline">\(n\)</span></span>. This is a huge headache for scientists that actually need to do these calculations in practice.</p>
<p>In the 1981, physicist Richard Feynman proposed to “turn this lemon to lemonade” by making the following almost tautological observation:</p>
<blockquote>
<p><em>If a physical system cannot be simulated by a computer in <span><span class="math inline">\(T\)</span></span> steps, the system can be considered as performing a computation that would take more than <span><span class="math inline">\(T\)</span></span> steps</em></p>
</blockquote>
<p>So, he asked whether one could design a quantum system such that its outcome <span><span class="math inline">\(y\)</span></span> based on the initial condition <span><span class="math inline">\(x\)</span></span> would be some function <span><span class="math inline">\(y=f(x)\)</span></span> such that <strong>(a)</strong> we don’t know how to efficiently compute in any other way, and <strong>(b)</strong> is actually useful for something.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> In 1985, David Deutsch formally suggested the notion of a quantum Turing machine, and the model has been since refined in works of Detusch and Josza and Bernstein and Vazirani. Such a system is now known as a <em>quantum computer</em>.</p>
<p>For a while these hypothetical quantum computers seemed useful for one of two things. First, to provide a general-purpose mechanism to simulate a variety of the real quantum systems that people care about. Second, as a challenge to the theory of computation’s approach to model efficient computation by Turing machines, though a challenge that has little bearing to practice, given that this theoretical “extra power” of quantum computer seemed to offer little advantage in the problems people actually want to solve such as combinatorial optimization, machine learning, data structures, etc..</p>
<p>To a significant extent, this is still true today. We have no real evidence that quantum computers, if built, will offer truly significant<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> advantage in 99 percent of the applications of computing.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> However, there is one cryptography-sized exception: In 1994 Peter Shor showed that quantum computers can solve the integer factoring and discrete logarithm in polynomial time. This result has captured the imagination of a great many people, and completely energized research into quantum computing.<br />
This is both because the hardness of these particular problems provides the foundations for securing such a huge part of our communications (and these days, our economy), as well as it was a powerful demonstration that quantum computers could turn out to be useful for problems that a-priori seemd to have nothing to do with quantum physics. As we’ll discuss later, at the moment there are several intensive efforts to construct large scale quantum computers. It seems safe to say that, as far as we know, in the next five years or so there will not be a quantum computer large enough to factor, say, a <span><span class="math inline">\(1024\)</span></span> bit number, but it is quite possible that some quantum computer will be built that is strong enough to achieve some task that is too inefficient to achieve with a non-quantum or “classical” computer (or at least requires more resources classically than it would for this computer). When and if such a computer is built that can break reasonable parameters of Diffie Hellman, RSA and elliptic curve cryptography is anybody’s guess. It could also be a “self destroying prophecy” whereby the existence of a small-scale quantum computer would cause everyone to shift away to lattice-based crypto which in turn will diminish the motivation to invest the huge resources needed to build a large scale quantum computer.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>
<p>The above summary might be all that you need to know as a cryptographer, and enough motivation to study lattice-based cryptography as we do in this course. However, because quantum computing is such a beautiful and (like cryptography) counter-intuitive concept, we will try to give at least a hint of what it is about and how Shor’s algorithm works.</p>
<h2 id="quantum-101" data-number="20.1">Quantum 101</h2>
<p>We now present some of the basic notions in quantum information. It is very useful to contrast these notions to the setting of <em>probabilistic</em> systems and see how “negative probabilities” make a difference. This discussion is somewhat brief. The chapter on quantum computation in my <a href="http://theory.cs.princeton.edu/complexity/">book with Arora</a> (see <a href="http://theory.cs.princeton.edu/complexity/ab_quantumchap.pdf">draft here</a>) is one relatively short resource that contains essentially everything we discuss here. See also this <a href="http://www.scottaaronson.com/blog/?p=208">blog post of Aaronson</a> for a high level explanation of Shor’s algorithm which ends with links to several more detailed expositions. See also <a href="http://www.scottaaronson.com/democritus/lec14.html">this lecture</a> of Aaronson for a great discussion of the feasibility of quantum computing (Aaronson’s <a href="http://www.scottaaronson.com/democritus/default.html">course lecture notes</a> and the <a href="http://www.amazon.com/Quantum-Computing-since-Democritus-Aaronson/dp/0521199565">book</a> that they spawned are fantastic reads as well).</p>
<p><strong>States:</strong> We will consider a simple quantum system that includes <span><span class="math inline">\(n\)</span></span> objects (e.g., electrons/photons/transistors/etc..) each of which can be in either an “on” or “off” state - i.e., each of them can encode a single <em>bit</em> of information, but to emphasize the “quantumness” we will call it a <em>qubit</em>. A <em>probability distribution</em> over such a system can be described as a <span><span class="math inline">\(2^n\)</span></span> dimensional vector <span><span class="math inline">\(v\)</span></span> with non-negative entries summing up to <span><span class="math inline">\(1\)</span></span>, where for every <span><span class="math inline">\(x\in\{0,1\}^n\)</span></span>, <span><span class="math inline">\(v_x\)</span></span> denotes the probability that the system is in state <span><span class="math inline">\(x\)</span></span>. As we mentioned, quantum mechanics allows negative (in fact even complex) probabilities and so a <em>quantum state</em> of the system can be described as a <span><span class="math inline">\(2^n\)</span></span> dimensional vector <span><span class="math inline">\(v\)</span></span> such that <span><span class="math inline">\(\|v\|^2 = \sum_x |v_x|^2 = 1\)</span></span>.</p>
<p><strong>Measurement:</strong> Suppose that we were in the classical probabilistic setting, and that the <span><span class="math inline">\(n\)</span></span> bits are simply random coins. Thus we can describe the <em>state</em> of the system by the <span><span class="math inline">\(2^n\)</span></span>-dimensional vector <span><span class="math inline">\(v\)</span></span> such that <span><span class="math inline">\(v_x=2^{-n}\)</span></span> for all <span><span class="math inline">\(x\)</span></span>. If we <em>measure</em> the system and see what the coins came out, we will get the value <span><span class="math inline">\(x\)</span></span> with probability <span><span class="math inline">\(v_x\)</span></span>. Naturally, if we measure the system twice we will get the same result. Thus, after we see that the coin is <span><span class="math inline">\(x\)</span></span>, the new state of the system <em>collapses</em> to a vector <span><span class="math inline">\(v\)</span></span> such that <span><span class="math inline">\(v_y = 1\)</span></span> if <span><span class="math inline">\(y=x\)</span></span> and <span><span class="math inline">\(v_y=0\)</span></span> if <span><span class="math inline">\(y\neq x\)</span></span>. In a quantum state, we do the same thing: if we <em>measure</em> a vector <span><span class="math inline">\(v\)</span></span> corresponds to turning it with probability <span><span class="math inline">\(|v_x|^2\)</span></span> into a vector that has <span><span class="math inline">\(1\)</span></span> on coordinate <span><span class="math inline">\(x\)</span></span> and zero on all the other coordinates.</p>
<p><strong>Operations:</strong> In the classical probabilistic setting, if we have a system in state <span><span class="math inline">\(v\)</span></span> and we apply some function <span><span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}^n\)</span></span> then this transforms <span><span class="math inline">\(v\)</span></span> to the state <span><span class="math inline">\(w\)</span></span> such that <span><span class="math inline">\(w_y = \sum_{x:f(x)=y} v_x\)</span></span>.<br />
Another way to state this, is that <span><span class="math inline">\(w=M_f\)</span></span> where <span><span class="math inline">\(M_f\)</span></span> is the matrix such that <span><span class="math inline">\(M_{f(x),x}=1\)</span></span> for all <span><span class="math inline">\(x\)</span></span> and all other entries are <span><span class="math inline">\(0\)</span></span>. If we toss a coin and decide with probability <span><span class="math inline">\(1/2\)</span></span> to apply <span><span class="math inline">\(f\)</span></span> and with probability <span><span class="math inline">\(1/2\)</span></span> to apply <span><span class="math inline">\(g\)</span></span>, this corresponds to the matrix <span><span class="math inline">\((1/2)M_f + (1/2)M_g\)</span></span>. More generally, the set of operations that we can apply can be captured as the set of convex combinations of all such matrices- this is simply the set of non-negative matrices whose columns all sum up to <span><span class="math inline">\(1\)</span></span>- the <em>stochastic</em> matrices. In the quantum case, the operations we can apply to a quantum state are encoded as a <em>unitary</em> matrix, which is a matrix <span><span class="math inline">\(M\)</span></span> such that <span><span class="math inline">\(\|Mv\|=\|v\|\)</span></span> for all vectors <span><span class="math inline">\(v\)</span></span>.</p>
<p><strong>Elementary operations:</strong> Of course, even in the probabilistic setting, not every function <span><span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}^n\)</span></span> is efficiently computable. We think of a function as efficiently computable if it is composed of polynomially many elementary operations, that involve at most <span><span class="math inline">\(2\)</span></span> or <span><span class="math inline">\(3\)</span></span> bits or so (i.e., Boolean <em>gates</em>). That is, we say that a matrix <span><span class="math inline">\(M\)</span></span> is <em>elementary</em> if it only modifies three bits. That is, <span><span class="math inline">\(M\)</span></span> is obtained by “lifting” some <span><span class="math inline">\(8\times 8\)</span></span> matrix <span><span class="math inline">\(M&#39;\)</span></span> that operates on three bits <span><span class="math inline">\(i,j,k\)</span></span>, leaving all the rest of the bits intact. Formally, given an <span><span class="math inline">\(8\times 8\)</span></span> matrix <span><span class="math inline">\(M&#39;\)</span></span> (indexed by strings in <span><span class="math inline">\(\{0,1\}^3\)</span></span>) and three distinct indices <span><span class="math inline">\(i&lt;j&lt;k \in \{1,\ldots,n\}\)</span></span> we define the <em><span><span class="math inline">\(n\)</span></span>-lift of <span><span class="math inline">\(M&#39;\)</span></span> with indices <span><span class="math inline">\(i,j,k\)</span></span></em> to be the <span><span class="math inline">\(2^n\times 2^n\)</span></span> matrix <span><span class="math inline">\(M\)</span></span> such that for every strings <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span> that agree with each other on all coordinates except possibly <span><span class="math inline">\(i,j,k\)</span></span>, <span><span class="math inline">\(M_{x,y}=M&#39;_{x_ix_jx_k,y_iy_jy_k}\)</span></span> and otherwise <span><span class="math inline">\(M_{x,y}=0\)</span></span>. Note that if <span><span class="math inline">\(M&#39;\)</span></span> is of the form <span><span class="math inline">\(M&#39;_f\)</span></span> for some function <span><span class="math inline">\(f:\{0,1\}^3\rightarrow\{0,1\}^3\)</span></span> then <span><span class="math inline">\(M=M_g\)</span></span> where <span><span class="math inline">\(g:\{0,1\}^n\rightarrow\{0,1\}^n\)</span></span> is defined as <span><span class="math inline">\(g(x)=f(x_ix_jx_k)\)</span></span>. We define <span><span class="math inline">\(M\)</span></span> as an <em>elementary stochastic matrix</em> or a <em>probabilistic gate</em> if <span><span class="math inline">\(M\)</span></span> is equal to an <span><span class="math inline">\(n\)</span></span> lift of some stochastic <span><span class="math inline">\(8\times 8\)</span></span> matrix <span><span class="math inline">\(M&#39;\)</span></span>. The quantum case is similar: a <em>quantum gate</em> is a <span><span class="math inline">\(2^n\times 2^n\)</span></span> matrix that is an <span><span class="math inline">\(N\)</span></span> lift of some unitary <span><span class="math inline">\(8\times 8\)</span></span> matrix <span><span class="math inline">\(M&#39;\)</span></span>. It is an exercise to prove that lifting preserves stochasticity and unitarity. That is, every probabilistic gate is a stochastic matrix and every quantum gate is a unitary matrix.</p>
<p><strong>Complexity:</strong> For every stochastic matrix <span><span class="math inline">\(M\)</span></span> we can define its <em>randomized complexity</em>, denoted as <span><span class="math inline">\(R(M)\)</span></span> to be the minimum number <span><span class="math inline">\(T\)</span></span> such that <span><span class="math inline">\(M\)</span></span> is can be (approximately) obtained by combining <span><span class="math inline">\(T\)</span></span> elementary probabilistic gates. To be concrete, we can define <span><span class="math inline">\(R(M)\)</span></span> to be the minimum <span><span class="math inline">\(T\)</span></span> such that there exists <span><span class="math inline">\(T\)</span></span> elementary matrices <span><span class="math inline">\(M_1,\ldots,M_T\)</span></span> such that for every <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(\sum_y |M_{y,x}-(M_T\cdots M_1)_{y,x}|&lt;0.1\)</span></span>. (It can be shown that <span><span class="math inline">\(R(M)\)</span></span> is finite and in fact at most <span><span class="math inline">\(10^n\)</span></span> for every <span><span class="math inline">\(M\)</span></span>; we can do so by writing <span><span class="math inline">\(M\)</span></span> as a convex combination of function and writing every function as a composition of functions that map a single string <span><span class="math inline">\(x\)</span></span> to <span><span class="math inline">\(y\)</span></span>, keeping all other inputs intact.) We will say that a probabilistic process <span><span class="math inline">\(M\)</span></span> mapping distributions on <span><span class="math inline">\(\{0,1\}^n\)</span></span> to distributions on <span><span class="math inline">\(\{0,1\}^n\)</span></span> is <em>efficiently classically computable</em> if <span><span class="math inline">\(R(M) \leq poly(n)\)</span></span>. If <span><span class="math inline">\(M\)</span></span> is a unitary matrix, then we define the <em>quantum complexity</em> of <span><span class="math inline">\(M\)</span></span>, denoted as <span><span class="math inline">\(Q(M)\)</span></span>, to be the minimum number <span><span class="math inline">\(T\)</span></span> such that there are quantum gates <span><span class="math inline">\(M_1,\ldots,M_T\)</span></span> satisfying that for every <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(\sum_y |M_{y,x}-(M_T \cdots M_1)_{y,x}|^2 &lt; 0.1\)</span></span>.<br />
We say that <span><span class="math inline">\(M\)</span></span> is <em>efficiently quantumly computable</em> if <span><span class="math inline">\(Q(M)\leq poly(n)\)</span></span>.</p>
<p><strong>Computing functions:</strong> We have defined what it means for an operator to be probabilistically or quantumly efficiently computable, but we typically are interested in computing some function <span><span class="math inline">\(f:\{0,1\}^m\rightarrow\{0,1\}^\ell\)</span></span>. The idea is that we say that <span><span class="math inline">\(f\)</span></span> is efficiently computable if the corresponding operator is efficiently computable, except that we also allow to use extra memory and so to embed <span><span class="math inline">\(f\)</span></span> in some <span><span class="math inline">\(n=poly(m)\)</span></span>. We define <span><span class="math inline">\(f\)</span></span> to be <em>efficiently classically computable</em> if there is some <span><span class="math inline">\(n=poly(m)\)</span></span> such that the operator <span><span class="math inline">\(M_g\)</span></span> is efficiently classically computable where <span><span class="math inline">\(g:\{0,1\}^n\rightarrow\{0,1\}^n\)</span></span> is defined such that <span><span class="math inline">\(g(x_1,\ldots,x_n)=f(x_1,\ldots,x_m)\)</span></span>. In the quantum case we have a slight twist since the operator <span><span class="math inline">\(M_g\)</span></span> is not necessarily a unitary matrix.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> Therefore we say that <span><span class="math inline">\(f\)</span></span> is <em>efficiently quantumly computable</em> if there is <span><span class="math inline">\(n=poly(m)\)</span></span> such that the operator <span><span class="math inline">\(M_q\)</span></span> is efficiently quantumly computable where <span><span class="math inline">\(g:\{0,1\}^n\rightarrow\{0,1\}^n\)</span></span> is defined as <span><span class="math inline">\(g(x_1,\ldots,x_n) = x_1\cdots x_m \|( f(x_1\cdots x_m)0^{n-m-\ell}\; \oplus \; x_{m+1}\cdots x_n)\)</span></span>.</p>
<p><strong>Quantum and classical computation:</strong> The way we defined what it means for a function to be efficiently quantumly computable, it might not be clear that if <span><span class="math inline">\(f:\{0,1\}^m\rightarrow\{0,1\}^\ell\)</span></span> is a function that we can compute by a polynomial size Boolean circuit (e.g., combining polynomially many AND, OR and NOT gates) then it is also quantumly efficiently computable. The idea is that for every gate <span><span class="math inline">\(g:\{0,1\}^2\rightarrow\{0,1\}\)</span></span> we can define an <span><span class="math inline">\(8\times 8\)</span></span> unitary matrix <span><span class="math inline">\(M_h\)</span></span> where <span><span class="math inline">\(h:\{0,1\}^3\rightarrow\{0,1\}^3\)</span></span> has the form <span><span class="math inline">\(h(a,b,c)=a,b,c\oplus g(a,b)\)</span></span>. So, if <span><span class="math inline">\(f\)</span></span> has a circuit of <span><span class="math inline">\(s\)</span></span> gates, then we can dedicate an extra bit for every one of these gates and then run the corresponding <span><span class="math inline">\(s\)</span></span> unitary operations one by one, at the end of which we will get an operator that computes the mapping <span><span class="math inline">\(x_1,\ldots,x_{m+\ell+s} = x_1\cdots x_m \| x_{m+1}\cdots x_{m+s} \oplus f(x_1,\ldots,x_m)\|g(x_1\ldots x_m)\)</span></span> where the the <span><span class="math inline">\(\ell+i^{th}\)</span></span> bit of <span><span class="math inline">\(g(x_1,\ldots,x_n)\)</span></span> is the result of applying the <span><span class="math inline">\(i^{th}\)</span></span> gate in the calculation of <span><span class="math inline">\(f(x_1,\ldots,x_m)\)</span></span>. So this is “almost” what we wanted except that we have this “extra junk” that we need to get rid of. The idea is that we now simply run the same computation again which will basically we mean we XOR another copy of <span><span class="math inline">\(g(x_1,\ldots,x_m)\)</span></span> to the last <span><span class="math inline">\(s\)</span></span> bits, but since <span><span class="math inline">\(g(x)\oplus g(x) = 0^s\)</span></span> we get that we compute the map <span><span class="math inline">\(x \mapsto x_1\cdots x_m \| (f(x_1,\ldots,x_m)0^s \;\oplus\; x_{m+1}\cdots x_{m+\ell+s})\)</span></span> as desired.</p>
<p><strong>The “obviously exponential” fallacy:</strong> A priori it might seem “obvious” that quantum computing is exponentially powerful, since to compute a quantum computation on <span><span class="math inline">\(n\)</span></span> bits we need to maintain the <span><span class="math inline">\(2^n\)</span></span> dimensional state vector and apply <span><span class="math inline">\(2^n\times 2^n\)</span></span> matrices to it. Indeed popular descriptions of quantum computing (too) often say something along the lines that the difference between quantum and classical computer is that a classic bit can either be zero or one while a qubit can be in both states at once, and so in many qubits a quantum computer can perform exponentially many computations at once. Depending on how you interpret this, this description is either false or would apply equally well to <em>probabilistic computation</em>. However, for probabilistic computation it is a not too hard exercise to show that if <span><span class="math inline">\(f:\{0,1\}^m\rightarrow\{0,1\}^n\)</span></span> is an efficiently computable function then it has a polynomial size circuit of AND, OR and NOT gates.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> Moreover, this “obvious” approach for simulating a quantum computation will take not just exponential time but <em>exponential space</em> as well, while it is not hard to show that using a simple recursive formula one can calculate the final quantum state using <em>polynomial space</em> (in physics parlance this is known as “Feynman path integrals”). So, the exponentially long vector description by itself does not imply that quantum computers are exponentially powerful. Indeed, we cannot <em>prove</em> that they are (since in particular we can’t prove that <em>every</em> polynomial space calculation can be done in polynomial time, in complexity parlance we don’t know how to rule out that <span><span class="math inline">\(P=\ensuremath{\mathit{PSPACE}}\)</span></span>), but we do have some problems (integer factoring most prominently) for which they do provide exponential speedup over the currently best <em>known</em> classical (deterministic or probabilistic) algorithms.</p>
<h3 id="physically-realizing-quantum-computation" data-number="20.1.1">Physically realizing quantum computation</h3>
<p>To realize quantum computation one needs to create a system with <span><span class="math inline">\(n\)</span></span> independent binary states (i.e., “qubits”), and be able to manipulate small subsets of two or three of these qubits to change their state. While by the way we defined operations above it might seem that one needs to be able to perform arbitrary unitary operations on these two or three qubits, it turns out that there several choices for <em>universal sets</em> - a small constant number of gates that generate all others. The biggest challenge is how to keep the system from being measured and <em>collapsing</em> to a single classical combination of states. This is sometimes known as the <em>coherence time</em> of the system. The <a href="https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes19.pdf">threshold theorem</a> says that there is some absolute constant level of errors <span><span class="math inline">\(\tau\)</span></span> so that if errors are created at every gate at rate smaller than <span><span class="math inline">\(\tau\)</span></span> then we can recover from those and perform arbitrary long computations. (Of course there are different ways to model the errors and so there are actually several threshold <em>theorems</em> corresponding to various noise models).</p>
<p>There have been several proposals to build quantum computers:</p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Superconducting_quantum_computing">Superconducting quantum computers</a> use super-conducting electric circuits to do quantum computation. <a href="http://arxiv.org/abs/1411.7403">Recent works</a> have shown one can keep these superconducting qubits fairly robust to the point one can do some error correction on them (see also <a href="http://arxiv.org/abs/1508.05882v2">here</a>).</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Trapped_ion_quantum_computer">Trapped ion quantum computers</a> Use the states of an ion to simulate a qubit. People have made some <a href="http://iontrap.umd.edu/wp-content/uploads/2016/02/1602.02840v1.pdf">recent advances</a> on these computers too. While it’s not clear that’s the right measuring yard, the <a href="http://arxiv.org/abs/1507.08852">current best implementation</a> of Shor’s algorithm (for factoring 15) is done using an ion-trap computer.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Topological_quantum_computer">Topological quantum computers</a> use a different technology, which is more stable by design but arguably harder to manipulate to create quantum computers.</p></li>
</ul>
<p>These approaches are not mutually exclusive and it could be that ultimately quantum computers are built by combining all of them together. I am not at all an expert on this matter, but it seems that progress has been slow but steady and it is quite possible that we’ll see a 20-50 qubit computer sometime in the next 5-10 years.</p>
<h3 id="bra-ket-notation" data-number="20.1.2">Bra-ket notation</h3>
<p>Quantum computing is very confusing and counterintuitive for many reasons. But there is also a “cultural” reason why people sometimes find quantum arguments hard to follow. Quantum folks follow their own special <a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation">notation</a> for vectors. Many non quantum people find it ugly and confusing, while quantum folks secretly wish they people used it all the time, not just for non-quantum linear algebra, but also for restaurant bills and elemntary school math classes.</p>
<p>The notation is actually not so confusing. If <span><span class="math inline">\(x\in\{0,1\}^n\)</span></span> then <span><span class="math inline">\(|x\rangle\)</span></span> denotes the <span><span class="math inline">\(x^{th}\)</span></span> standard basis vector in <span><span class="math inline">\(2^n\)</span></span> dimension. That is <span><span class="math inline">\(|x\rangle\)</span></span> <span><span class="math inline">\(2^n\)</span></span>-dimensional column vector that has <span><span class="math inline">\(1\)</span></span> in the <span><span class="math inline">\(x^{th}\)</span></span> coordinate and zero everywhere else. So, we can describe the column vector that has <span><span class="math inline">\(\alpha_x\)</span></span> in the <span><span class="math inline">\(x^{th}\)</span></span> entry as <span><span class="math inline">\(\sum_{x\in\{0,1\}^n} \alpha_x |x\rangle\)</span></span>. One more piece of notation that is useful is that if <span><span class="math inline">\(x\in\{0,1\}^n\)</span></span> and <span><span class="math inline">\(y\in\{0,1\}^m\)</span></span> then we identify <span><span class="math inline">\(|x\rangle|y\rangle\)</span></span> with <span><span class="math inline">\(|xy\rangle\)</span></span> (that is, the <span><span class="math inline">\(2^{n+m}\)</span></span> dimensional vector that has <span><span class="math inline">\(1\)</span></span> in the coordinate corresponding to the concatenation of <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span>, and zero everywhere else). This is more or less all you need to know about this notation to follow this lecture.<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p>
<p>A quantum gate is an operation on at most three bits, and so it can be completely specified by what it does to the <span><span class="math inline">\(8\)</span></span> vectors <span><span class="math inline">\(|000\rangle,\ldots,|111\rangle\)</span></span>. Quantum states are always unit vectors and so we sometimes omit the normalization for convenience; for example we will identify the state <span><span class="math inline">\(|0\rangle+|1\rangle\)</span></span> with its normalized version <span><span class="math inline">\(\tfrac{1}{\sqrt{2}}|0\rangle + \tfrac{1}{\sqrt{2}}|1\rangle\)</span></span>.</p>
<h3 id="bells-inequality" data-number="20.1.3">Bell’s Inequality</h3>
<p>There is something weird about quantum mechanics. In 1935 <a href="http://plato.stanford.edu/entries/qt-epr/">Einstein, Podolsky and Rosen (EPR)</a> tried to pinpoint this issue by highlighting a previously unrealized corollary of this theory. It was already realized that the fact that quantum measurement collapses the state to a definite aspect yields the <em>uncertainty principle</em>, whereby if you measure a quantum system in one orthogonal basis, you will not know how it would have measured in an incohrent basis to it (such as position vs. momentum). What EPR showed was that quantum mechanics results in so called “spooky action at a distance” where if you have a system of two particles then measuring one of them would instantenously effect the state of the other. Since this “state” is just a mathematical description, as far as I know the EPR paper was considered to be a thought experiment showing troubling aspects of quantum mechanics, without bearing on experiment. This changed when in 1965 John Bell showed an actual experiment to test the predictions of EPR and hence pit intuitive common sense against the predictions of quantum mechanics. Quantum mechanics won. Nonetheless, since the results of these experiments are so obviously wrong to anyone that has ever sat in an armchair, that there are still a number of <a href="http://www.scottaaronson.com/blog/?p=2464">Bell denialists</a> arguing that quantum mechanics is wrong in some way.</p>
<p>So, what is this Bell’s Inequality? Suppose that Alice and Bob try to convince you they have telepathic ability, and they aim to prove it via the following experiment. Alice and Bob will be in separate closed rooms.<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup> You will interrogate Alice and your associate will interrogate Bob. You choose a random bit <span><span class="math inline">\(x\in\{0,1\}\)</span></span> and your associate chooses a random <span><span class="math inline">\(y\in\{0,1\}\)</span></span>. We let <span><span class="math inline">\(a\)</span></span> be Alice’s response and <span><span class="math inline">\(b\)</span></span> be Bob’s response. We say that Alice and Bob win this experiment if <span><span class="math inline">\(a \oplus b = x \wedge y\)</span></span>.</p>
<p>Now if Alice and Bob are not telepathic, then they need to agree in advance on some strategy. The most general form of such a strategy is that Alice and Bob agree on some distribution over a pair of functions <span><span class="math inline">\(d,g:\{0,1\}\rightarrow\{0,1\}\)</span></span>, such that Alice will set <span><span class="math inline">\(a=f(x)\)</span></span> and Bob will set <span><span class="math inline">\(b=g(x)\)</span></span>. Therefore, the following claim, which is basically Bell’s Inequality,<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> implies that Alice and Bob cannot succeed in this game with probability higher than <span><span class="math inline">\(3/4\)</span></span>:</p>
<p><strong>Claim:</strong> For every two functions <span><span class="math inline">\(f,g:\{0,1\}\rightarrow\{0,1\}\)</span></span> there exist some <span><span class="math inline">\(x,y\in\{0,1\}\)</span></span> such that <span><span class="math inline">\(f(x) \oplus g(y) \neq x \wedge y\)</span></span>.</p>
<p><strong>Proof:</strong> Suppose toward a contradiction that <span><span class="math inline">\(f,g\)</span></span> satisfy <span><span class="math inline">\(f(x) \oplus g(y) = x \wedge y \;(*)\)</span></span> or <span><span class="math inline">\(f(x) = (x \wedge y) \oplus g(y)\;(*)\)</span></span> ;. So if <span><span class="math inline">\(y=0\)</span></span> it must be that <span><span class="math inline">\(f(x)=0\)</span></span> for all <span><span class="math inline">\(x\)</span></span>, but on the other hand, if <span><span class="math inline">\(y=1\)</span></span> then for <span><span class="math inline">\((*)\)</span></span> to hold then it must be that <span><span class="math inline">\(f(x) = x \oplus g(1)\)</span></span> but that means that <span><span class="math inline">\(f\)</span></span> cannot be constant. QED</p>
<p>An amazing <a href="http://arxiv.org/abs/1508.05949">experimentally verified</a> fact is that quantum mechanics allows for telepathy:<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup></p>
<p><strong>Claim:</strong> There is a strategy for Alice and Bob to succeed in this game with probability at least <span><span class="math inline">\(0.8\)</span></span>.</p>
<p><strong>Proof:</strong> The main idea is for Alice and Bob to first prepare a 2-qubit quantum system in the state (up to normalization) <span><span class="math inline">\(|00\rangle+|11\rangle\)</span></span> (this is known as an <em>EPR pair</em>). Alice takes the first qubit in this system to her room, and Bob takes the qubit to his room. Now, when Alice receives <span><span class="math inline">\(x\)</span></span> if <span><span class="math inline">\(x=0\)</span></span> she does nothing and if <span><span class="math inline">\(x=1\)</span></span> she applies the unitary map <span><span class="math inline">\(R_{\pi/8}\)</span></span> to her qubit where <span><span class="math inline">\(R_\theta = \left( \begin{smallmatrix} cos \theta &amp; \sin -\theta \\ \sin \theta &amp; \cos \theta \end{smallmatrix} \right)\)</span></span>. When Bob receives <span><span class="math inline">\(y\)</span></span>, if <span><span class="math inline">\(y=0\)</span></span> he does nothing and if <span><span class="math inline">\(y=1\)</span></span> he applies the unitary map <span><span class="math inline">\(R_{-\pi/8}\)</span></span> to his qubit. Then each one of them measures their qubit and sends this as their response. Recall that to win the game Bob and Alice want their outputs to be more likely to differ if <span><span class="math inline">\(x=y=1\)</span></span> and to be more likely to agree otherwise.</p>
<p>If <span><span class="math inline">\(x=y=0\)</span></span> then the state does not change and Alice and Bob always output either both <span><span class="math inline">\(0\)</span></span> or both <span><span class="math inline">\(1\)</span></span>, and hence in both case <span><span class="math inline">\(a\oplus b = x \wedge y\)</span></span>. If <span><span class="math inline">\(x=0\)</span></span> and <span><span class="math inline">\(y=1\)</span></span> then after Alice measures her bit, if she gets <span><span class="math inline">\(0\)</span></span> then Bob’s state is equal to <span><span class="math inline">\(-\cos (\pi/8)|0\rangle-\sin(\pi/8)|1\rangle\)</span></span> which will equal <span><span class="math inline">\(0\)</span></span> with probability <span><span class="math inline">\(\cos^2 (\pi/8)\)</span></span>. The case that Alice gets <span><span class="math inline">\(1\)</span></span>, or that <span><span class="math inline">\(x=1\)</span></span> and <span><span class="math inline">\(y=0\)</span></span>, is symmetric, and so in all the cases where <span><span class="math inline">\(x\neq y\)</span></span> (and hence <span><span class="math inline">\(x \wedge y=0\)</span></span>) the probability that <span><span class="math inline">\(a=b\)</span></span> will be <span><span class="math inline">\(\cos^2(\pi/8) \geq 0.85\)</span></span>. For the case that <span><span class="math inline">\(x=1\)</span></span> and <span><span class="math inline">\(y=1\)</span></span>, direct calculation via trigonomertic identities yields that all four options for <span><span class="math inline">\((a,b)\)</span></span> are equally likely and hence in this case <span><span class="math inline">\(a=b\)</span></span> with probability <span><span class="math inline">\(0.5\)</span></span>. The overall probability of winning the game is at least <span><span class="math inline">\(\tfrac{1}{4}\cdot 1 + \tfrac{1}{2}\cdot 0.85 + \tfrac{1}{4} \cdot 0.5 =0.8\)</span></span>. QED</p>
<blockquote>
<p><strong>Quantum vs probabilistic strategies:</strong> It is instructive to understand what is it about quantum mechanics that enabled this gain in Bell’s Inequality. For this, consider the following analogous probabilistic strategy for Alice and Bob. They agree that each one of them output <span><span class="math inline">\(0\)</span></span> if he or she get <span><span class="math inline">\(0\)</span></span> as input and outputs <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p\)</span></span> if they get <span><span class="math inline">\(1\)</span></span> as input. In this case one can see that their success probability would be <span><span class="math inline">\(\tfrac{1}{4}\cdot 1 + \tfrac{1}{2}(1-p)+\tfrac{1}{4}[2p(1-p)]=0.75 -0.5p^2 \leq 0.75\)</span></span>. The quantum strategy we described above can be thought of as a variant of the probabilistic strategy for <span><span class="math inline">\(p\)</span></span> is <span><span class="math inline">\(\sin^2 (\pi/8)=0.15\)</span></span>. But in the case <span><span class="math inline">\(x=y=1\)</span></span>, instead of disagreeing only with probability <span><span class="math inline">\(2p(1-p)=1/4\)</span></span>, because we can use these negative probabilities in the quantum world and rotate the state in opposite directions, the probability of disagreement ends up being <span><span class="math inline">\(\sin^2 (\pi/4)=0.5\)</span></span>.</p>
</blockquote>
<!--

Now for every $x,y$, the state of the two qubits before measurement is the $4$ dimensional vector:
$v_{x,y} = \tfrac{1}{\sqrt{2}}\left[ R_{x\pi/8}|0\rangle \otimes R_{-y\pi/8}|1\rangle \;+\; R_{x\pi/8}|0\rangle \otimes R_{-y\pi/8}|1\rangle  \right] \;(**)$

If $v \in \mathbb{R}^4$ is the state of the two qubits,[^real] then the probability that we get a particular output $(a,b)$ is simply the dot product squared of $v$ with $|ab\rangle$.
Since $|1\rangle=R_{\pi/2}|0\rangle$, and $\langle R_\alpha u,R_\beta u \rangle^2 = \cos^2 (\beta-\alpha)$, we get that for every choice of the coins $x,y$ and $a,b$
the probability that we get $a,b$ as output conditioned on $x,y$ is:

$\tfrac{1}{2}\left[ \cos^2(a\pi/2-x\pi/8)\cos^2(b\pi/2+y\pi/8) + \sin^2(a\pi/2-x\pi/8)\sin^2(b\pi/2+y\pi/8) right]$

One can calculate that if $x=y=0$ then this equals $1$ if $a=b$ and $0$ if $a \neq b$, which implies they win the game with probability $1$.
If $x=y=1$ then this equals
which by calculation yields success probability of at least 0.8 QED

[^real]: In general the state of two qubits is a _complex_ $2^2=4$ dimensional vector but in this case since the initial state was real and our transformations are real, the state will always be a real vector with no imaginary components.
-->
<!--
[Bell's overview paper](http://philosophyfaculty.ucsd.edu/faculty/wuthrich/GSSPP09/Files/BellJohnS1981Speakable_BertlmannsSocks.pdf)
-->
<h2 id="grovers-algorithm" data-number="20.2">Grover’s Algorithm</h2>
<p>Shor’s Algorithm, which we’ll see in the next lecture, is an amazing achievement, but it only applies to very particular problems. It does not seem to be relevant to breaking AES, lattice based cryptography, or problems not related to quantum computing at all such as scheduling, constraint satisfaction, traveling salesperson etc.. etc.. Indeed, for the most general form of these search problems, classically we don’t how to do anything much better than brute force search, which takes <span><span class="math inline">\(2^n\)</span></span> time over an <span><span class="math inline">\(n\)</span></span>-bit domain. Lev Grover showed that quantum computers can obtain a quadratic improvement over this brute force search, solving SAT in <span><span class="math inline">\(2^{n/2}\)</span></span> time. The effect of Grover’s algorithm on cryptography is fairly mild: one essentially needs to double the key lengths of symmetric primitives. But beyond cryptography, if large scale quantum computers end up being built, Grover search and its variants might end up being some of the most useful computational problems they will tackle. Grover’s theorem is the following:</p>
<p><strong>Theorem (Grover search , 1996):</strong> There is a quantum <span><span class="math inline">\(O(2^{n/2}poly(n))\)</span></span>-time algorithm that given a <span><span class="math inline">\(poly(n)\)</span></span>-sized circuit computing a function <span><span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}\)</span></span> outputs a string <span><span class="math inline">\(x^*\in\{0,1\}^n\)</span></span> such that <span><span class="math inline">\(f(x^*)=1\)</span></span>.</p>
<p><strong>Proof sketch:</strong> The proof is not hard but we only sketch it here. The general idea can be illustrated in the case that there exists a single <span><span class="math inline">\(x^*\)</span></span> satisfying <span><span class="math inline">\(f(x^*)=1\)</span></span>. (There is a classical reduction from the general case to this problem.) As in Simon’s algorithm, we can efficiently initialize an <span><span class="math inline">\(n\)</span></span>-qubit system to the uniform state <span><span class="math inline">\(u = 2^{-n/2}\sum_{x\in\{0,1\}^n}|x\rangle\)</span></span> which has <span><span class="math inline">\(2^{-n/2}\)</span></span> dot product with <span><span class="math inline">\(|x^*\rangle\)</span></span>. Of course if we measure <span><span class="math inline">\(u\)</span></span>, we only have probability <span><span class="math inline">\((2^{-n/2})^2 = 2^{-n}\)</span></span> of obtaining the value <span><span class="math inline">\(x^*\)</span></span>. Our goal would be to use <span><span class="math inline">\(O(2^{n/2})\)</span></span> calls to the oracle to transform the system to a state <span><span class="math inline">\(v\)</span></span> with dot product at least some constant <span><span class="math inline">\(\epsilon&gt;0\)</span></span> with the state <span><span class="math inline">\(|x^*\rangle\)</span></span>.</p>
<p>It is an exercise to show that using <span><span class="math inline">\(Had\)</span></span> gets we can efficiently compute the unitary operator <span><span class="math inline">\(U\)</span></span> such that <span><span class="math inline">\(Uu = u\)</span></span> and <span><span class="math inline">\(Uv = -v\)</span></span> for every <span><span class="math inline">\(v\)</span></span> orthogonal to <span><span class="math inline">\(u\)</span></span>. Also, using the circuit for <span><span class="math inline">\(f\)</span></span>, we can efficiently compute the unitary operator <span><span class="math inline">\(U^*\)</span></span> such that <span><span class="math inline">\(U^*|x\rangle=|x\rangle\)</span></span> for all <span><span class="math inline">\(x\neq x^*\)</span></span> and <span><span class="math inline">\(U^*|x^*\rangle=-|x^*\rangle\)</span></span>. It turns out that <span><span class="math inline">\(O(2^{n/2})\)</span></span> applications of <span><span class="math inline">\(\ensuremath{\mathit{UU}}^*\)</span></span> to <span><span class="math inline">\(u\)</span></span> yield a vector <span><span class="math inline">\(v\)</span></span> with <span><span class="math inline">\(\Omega(1)\)</span></span> inner product with <span><span class="math inline">\(|x^*\rangle\)</span></span>. To see why, consider what these operators do in the two dimensional linear subspace spanned by <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(|x^*\rangle\)</span></span>. (Note that the initial state <span><span class="math inline">\(u\)</span></span> is in this subspace and all our operators preserve this property.) Let <span><span class="math inline">\(u_\perp\)</span></span> be the unit vector orthogonal to <span><span class="math inline">\(u\)</span></span> in this subspace and let <span><span class="math inline">\(x^*_\perp\)</span></span> be the unit vector orthogonal to <span><span class="math inline">\(|x^*\rangle\)</span></span> in this subspace. Restricted to this subspace, <span><span class="math inline">\(U^*\)</span></span> is a reflection along the axis <span><span class="math inline">\(x^*_\perp\)</span></span> and <span><span class="math inline">\(U\)</span></span> is a reflection along the axis <span><span class="math inline">\(u\)</span></span>.</p>
<p>Now, let <span><span class="math inline">\(\theta\)</span></span> be the angle between <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(x^*_\perp\)</span></span>. These vectors are very close to each other and so <span><span class="math inline">\(\theta\)</span></span> is very small but not zero - it is equal to <span><span class="math inline">\(\sin^{-1}( 2^{-n/2})\)</span></span> which is roughly <span><span class="math inline">\(2^{-n/2}\)</span></span>. Now if our state <span><span class="math inline">\(v\)</span></span> has angle <span><span class="math inline">\(\alpha \geq 0\)</span></span> with <span><span class="math inline">\(u\)</span></span>, then as long as <span><span class="math inline">\(\alpha\)</span></span> is not too large (say <span><span class="math inline">\(\alpha&lt;\pi/8\)</span></span>) then this means that <span><span class="math inline">\(v\)</span></span> has angle <span><span class="math inline">\(u+\theta\)</span></span> with <span><span class="math inline">\(x^*_\perp\)</span></span>. That means that <span><span class="math inline">\(U^*v\)</span></span> will have angle <span><span class="math inline">\(-\alpha-\theta\)</span></span> with <span><span class="math inline">\(x^*_\perp\)</span></span> or <span><span class="math inline">\(-\alpha-2\theta\)</span></span> with <span><span class="math inline">\(u\)</span></span>, and hence <span><span class="math inline">\(\ensuremath{\mathit{UU}}^*v\)</span></span> will have angle <span><span class="math inline">\(\alpha+2\theta\)</span></span> with <span><span class="math inline">\(u\)</span></span>. Hence in one application from <span><span class="math inline">\(\ensuremath{\mathit{UU}}^*\)</span></span> we move <span><span class="math inline">\(2\theta\)</span></span> radians away from <span><span class="math inline">\(u\)</span></span>, and in <span><span class="math inline">\(O(2^{-n/2})\)</span></span> steps the angle between <span><span class="math inline">\(u\)</span></span> and our state will be at least some constant <span><span class="math inline">\(\epsilon&gt;0\)</span></span>. Since we live in the two dimensional space spanned by <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(|x\rangle\)</span></span>, it would mean that the dot product of our state and <span><span class="math inline">\(|x\rangle\)</span></span> will be at least some constant as well. QED</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>If you <em>have</em> seen quantum mechanics before, I should warn that I am making here many simplifications. In particular in quantum mechanics the “probabilities” can actually be <em>complex</em> numbers, though one gets most of the qualitative understanding by considering them as potentially negative real numbers. I will also be focusing throughout this presentation on so called “pure” quantum states, and ignore the fact that generally the states of a quantum subsystem are <em>mixed</em> states that are a convex combination of pure states and can be described by a so called <em>density matrix</em>. This issue does not arise as much in quantum algorithms precisely because the goal is for a quantum computer is to be an isolated system that can evolve to continue to be in a pure state; in real world quantum computers however there will be interference from the outside world that causes the state to become mixed and increase its so called “von Neumann entropy”- fighting this interference and the second law of thermodynamics is much of what the challenge of building quantum computers is all about . More generally, this lecture is not meant to be a complete or accurate description of quantum mechanics, quantum information theory, or quantum computing, but rather just give a sense of the main points that are different about it from classical computing and how they relate to cryptography.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>As its title suggests, Feynman’s <a href="https://www.cs.berkeley.edu/~christos/classics/Feynman.pdf">lecture</a> was actually focused on the other side of simulating physics with a computer, but he mentioned that as a “side remark” one could wonder if it’s possible to simulate physics with a new kind of computer - a “quantum computer” which would “not [be] a Turing machine, but a machine of a different kind”. As far as I know, Feynman did not suggest that such a computer could be useful for computations completely outside the domain of quantum simulation, and in fact he found the question of whether quantum mechanics could be simulated by a classical computer to be more interesting.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>I am using the theorist’ definition of conflating “significant” with “super-polynomial”. As we’ll see, Grover’s algorithm does offer a very generic <em>quadratic</em> advantage in computation. Whether that quadratic advantage will ever be good enough to offset in practice the significant overhead in building a quantum computer remains an open question. We also don’t have evidence that super-polynomial speedups <em>can’t</em> be achieved for some problems outside the Factoring/Dlog or quantum simulation domains, and there is at least <a href="http://www.dwavesys.com/">one company</a> banking on such speedups actually being feasible.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>This “99 percent” is a figure of speech, but not completely so. It seems that for many web servers, the TLS protocol (which based on the current non-lattice based systems would be completely broken by quantum computing) is responsible <a href="https://goo.gl/Gekjrc">for about 1 percent of the CPU usage</a>.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>Of course, given that <a href="http://blog.cryptographyengineering.com/2016/03/attack-of-week-drown.html">we’re still hearing</a> of attacks exploiting “export grade” cryptography that was supposed to disappear with 1990’s, I imagine that we’ll still have products running 1024 bit RSA when everyone has a quantum laptop.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>It is a good exercise to verify that for every <span><span class="math inline">\(g:\{0,1\}^n\rightarrow\{0,1\}^n\)</span></span>, <span><span class="math inline">\(M_g\)</span></span> is unitary if and only if <span><span class="math inline">\(g\)</span></span> is a permutation.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:7"><p>
<div>
<p>It is a good exercise to show that if <span><span class="math inline">\(M\)</span></span> is a probabilistic process with <span><span class="math inline">\(R(M) \leq T\)</span></span> then there exists a probabilistic circuit of size, say, <span><span class="math inline">\(100 T n^2\)</span></span> that approximately computes <span><span class="math inline">\(M\)</span></span> in the sense that for every input <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(\sum_{y\in\{0,1\}^n} \left| \Pr[C(x)=y] - M_{x,y} \right| &lt; 1/3\)</span></span>.</p>
</div>
<a href="#fnref:7" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:8"><p>
<div>
<p>If you are curious, there is an analog notation for <em>row</em> vectors as <span><span class="math inline">\(\langle x|\)</span></span>. Generally if <span><span class="math inline">\(u\)</span></span> is a vector then <span><span class="math inline">\(|u\rangle\)</span></span> would be its form as a column vector and <span><span class="math inline">\(\langle u|\)</span></span> would be its form as a row product. Hence since <span><span class="math inline">\(u^\top v = \langle u,v \rangle\)</span></span> the inner product of <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(b\)</span></span> can be thought of as <span><span class="math inline">\(\langle u||v\rangle\)</span></span> . The <em>outer product</em> (the matrix whose <span><span class="math inline">\(i,j\)</span></span> entry is <span><span class="math inline">\(u_iv_j\)</span></span>) is denoted as <span><span class="math inline">\(|u\rangle\langle v|\)</span></span>.</p>
</div>
<a href="#fnref:8" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:9"><p>
<div>
<p>If you are extremely paranoid about Alice and Bob communicating with one another, you can coordinate with your assistant to perform the experiment exactly at the same time, and make sure that the rooms are so that Alice and Bob couldn’t communicate to each other in time the results of the coin even if they do so at the speed of light.</p>
</div>
<a href="#fnref:9" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:10"><p>
<div>
<p>This form of Bell’s game was shown by CHSH</p>
</div>
<a href="#fnref:10" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:11"><p>
<div>
<p>More accurately, one either has to give up on a “billiard ball type” theory of the universe or believe in telepathy (believe it or not, some scientists went for the <a href="https://en.wikipedia.org/wiki/Superdeterminism">latter option</a>).</p>
</div>
<a href="#fnref:11" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Quantum computing+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 02/18/2020 18:17:38</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_19_quantum.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
