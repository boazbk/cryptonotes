<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: Syntactic sugar, and computing every function</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: Syntactic sugar, and computing every function" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->



<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.1</b> Exercises</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Syntactic sugar, and computing every function</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_03a_computing_every_function.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="finiteuniversalchap" data-number="4">Syntactic sugar, and computing every function</h1>
<div id="section" class="objectives" name="Objectives">
<ul>
<li>Get comfortable with syntactic sugar or automatic translation of higher level logic to low level gates.<br />
</li>
<li>Learn proof of major result: every finite function can be computed by a Boolean circuit.<br />
</li>
<li>Start thinking <em>quantitatively</em> about number of lines required for computation.</li>
</ul>
</div>
<blockquote>
<p><em>“[In 1951] I had a running compiler and nobody would touch it because, they carefully told me, computers could only do arithmetic; they could not do programs.”</em>, Grace Murray Hopper, 1986.</p>
</blockquote>
<blockquote>
<p><em>“Syntactic sugar causes cancer of the semicolon.”</em>, Alan Perlis, 1982.</p>
</blockquote>
<p>The computational models we considered thus far are as “bare bones” as they come. For example, our NAND-CIRC “programming language” has only the single operation <code>foo = NAND(bar,blah)</code>. In this chapter we will see that these simple models are actually <em>equivalent</em> to more sophisticated ones. The key observation is that we can implement more complex features using our basic building blocks, and then use these new features themselves as building blocks for even more sophisticated features. This is known as “syntactic sugar” in the field of programming language design since we are not modifying the underlying programming model itself, but rather we merely implement new features by syntactically transforming a program that uses such features into one that doesn’t.</p>
<p>This chapter provides a “toolkit” that can be used to show that many functions can be computed by NAND-CIRC programs, and hence also by Boolean circuits. We will also use this toolkit to prove a fundamental theorem: <em>every</em> finite function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> can be computed by a Boolean circuit, see <a href='#circuit-univ-thm'>Theorem 4.13</a> below. While the syntactic sugar toolkit is important in its own right, <a href='#circuit-univ-thm'>Theorem 4.13</a> can also be proven directly without using this toolkit. We present this alternative proof in <a href='#seccomputalternative'>Section 4.5</a>. See <a href='#computefuncoverviewfig'>Figure 4.1</a> for an outline of the results of this chapter.</p>
<figure>
<img src="../figure/compute_every_function_overview.png" alt="4.1: An outline of the results of this chapter. In  we give a toolkit of “syntactic sugar” transformations showing how to implement features such as programmer-defined functions and conditional statements in NAND-CIRC. We use these tools in  to give a NAND-CIRC program (or alternatively a Boolean circuit) to compute the \ensuremath{\mathit{LOOKUP}} function. We then build on this result to show in  that NAND-CIRC programs (or equivalently, Boolean circuits) can compute every finite function. An alternative direct proof of the same result is given in ." id="computefuncoverviewfig" /><figcaption>4.1: An outline of the results of this chapter. In <a href='#secsyntacticsugar'>Section 4.1</a> we give a toolkit of “syntactic sugar” transformations showing how to implement features such as programmer-defined functions and conditional statements in NAND-CIRC. We use these tools in <a href='#seclookupfunc'>Section 4.3</a> to give a NAND-CIRC program (or alternatively a Boolean circuit) to compute the <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}\)</span></span> function. We then build on this result to show in <a href='#seccomputeallfunctions'>Section 4.4</a> that NAND-CIRC programs (or equivalently, Boolean circuits) can compute <em>every</em> finite function. An alternative direct proof of the same result is given in <a href='#seccomputalternative'>Section 4.5</a>.</figcaption>
</figure>
<h2 id="secsyntacticsugar" data-number="4.1">Some examples of syntactic sugar</h2>
<p>We now present some examples of “syntactic sugar” transformations that we can use in constructing straightline programs or circuits. We focus on the <em>straight-line programming language</em> view of our computational models, and specifically (for the sake of concreteness) on the NAND-CIRC programming language. This is convenient because many of the syntactic sugar transformations we present are easiest to think about in terms of applying “search and replace” operations to the source code of a program. However, by <a href='lec_03_computation.html#equivalencemodelsthm'>Theorem 3.19</a>, all of our results hold equally well for circuits, whether ones using NAND gates or Boolean circuits that use the AND, OR, and NOT operations. Enumerating the examples of such syntactic sugar transformations can be a little tedious, but we do it for two reasons:</p>
<ol type="1">
<li><p>To convince you that despite their seeming simplicity and limitations, simple models such as Boolean circuits or the NAND-CIRC programming language are actually quite powerful.</p></li>
<li><p>So you can realize how lucky you are to be taking a theory of computation course and not a compilers course… <code>:)</code></p></li>
</ol>
<h3 id="user-defined-procedures" data-number="4.1.1">User-defined procedures</h3>
<p>One staple of almost any programming language is the ability to define and then execute <em>procedures</em> or <em>subroutines</em>. (These are often known as <em>functions</em> in some programming languages, but we prefer the name <em>procedures</em> to avoid confusion with the function that a program computes.) The NAND-CIRC programming language does not have this mechanism built in. However, we can achieve the same effect using the time honored technique of “copy and paste”. Specifically, we can replace code which defines a procedure such as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> Proc(a,b):</a>
<a class="sourceLine" id="cb1-2" title="2">    proc_code</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">return</span> c</a>
<a class="sourceLine" id="cb1-4" title="4">some_code</a>
<a class="sourceLine" id="cb1-5" title="5">f <span class="op">=</span> Proc(d,e)</a>
<a class="sourceLine" id="cb1-6" title="6">some_more_code</a></code></pre></div>
<p>with the following code where we “paste” the code of <code>Proc</code></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">some_code</a>
<a class="sourceLine" id="cb2-2" title="2">proc_code<span class="st">&#39;</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="st">some_more_code</span></a></code></pre></div>
<p>and where <code>proc_code'</code> is obtained by replacing all occurrences of <code>a</code> with <code>d</code>, <code>b</code> with <code>e</code>, and <code>c</code> with <code>f</code>. When doing that we will need to ensure that all other variables appearing in <code>proc_code'</code> don’t interfere with other variables. We can always do so by renaming variables to new names that were not used before. The above reasoning leads to the proof of the following theorem:</p>
<div id="functionsynsugarthm" class="theorem" title="Procedure definition synctatic sugar" name="Theorem 4.1 (Procedure definition synctatic sugar) ">
<p>Let NAND-CIRC-PROC be the programming language NAND-CIRC augmented with the syntax above for defining procedures. Then for every NAND-CIRC-PROC program <span><span class="math inline">\(P\)</span></span>, there exists a standard (i.e., “sugar free”) NAND-CIRC program <span><span class="math inline">\(P&#39;\)</span></span> that computes the same function as <span><span class="math inline">\(P\)</span></span>.</p>
</div>
<div id="norecursion" class="remark" title="No recursive procedure" name="Remark 4.2 (No recursive procedure) ">
<p>NAND-CIRC-PROC only allows <em>non recursive</em> procedures. In particular, the code of a procedure <code>Proc</code> cannot call <code>Proc</code> but only use procedures that were defined before it. Without this restriction, the above “search and replace” procedure might never terminate and <a href='#functionsynsugarthm'>Theorem 4.1</a> would not be true.</p>
</div>
<p><a href='#functionsynsugarthm'>Theorem 4.1</a> can be proven using the transformation above, but since the formal proof is somewhat long and tedious, we omit it here.</p>
<div id="majcircnand" class="example" title="Computing Majority from NAND using syntactic sugar" name="Example 4.3 (Computing Majority from NAND using syntactic sugar) ">
<p>Procedures allow us to express NAND-CIRC programs much more cleanly and succinctly. For example, because we can compute AND, OR, and NOT using NANDs, we can compute the <em>Majority</em> function as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> NOT(a):</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="cf">return</span> NAND(a,a)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">def</span> AND(a,b):</a>
<a class="sourceLine" id="cb3-4" title="4">    temp <span class="op">=</span> NAND(a,b)</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">return</span> NOT(temp)</a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">def</span> OR(a,b):</a>
<a class="sourceLine" id="cb3-7" title="7">    temp1 <span class="op">=</span> NOT(a)</a>
<a class="sourceLine" id="cb3-8" title="8">    temp2 <span class="op">=</span> NOT(b)</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="cf">return</span> NAND(temp1,temp2)</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="kw">def</span> MAJ(a,b,c):</a>
<a class="sourceLine" id="cb3-12" title="12">    and1 <span class="op">=</span> AND(a,b)</a>
<a class="sourceLine" id="cb3-13" title="13">    and2 <span class="op">=</span> AND(a,c)</a>
<a class="sourceLine" id="cb3-14" title="14">    and3 <span class="op">=</span> AND(b,c)</a>
<a class="sourceLine" id="cb3-15" title="15">    or1 <span class="op">=</span> OR(and1,and2)</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="cf">return</span> OR(or1,and3)</a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="bu">print</span>(MAJ(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb3-19" title="19"><span class="co"># 1</span></a></code></pre></div>
<p><a href='#progcircmajfig'>Figure 4.2</a> presents the “sugar free” NAND-CIRC program (and the corresponding circuit) that is obtained by “expanding out” this program, replacing the calls to procedures with their definitions.</p>
</div>
<div id="synsugar" class="bigidea" name="Bigidea 4">
<p>Once we show that a computational model <span><span class="math inline">\(X\)</span></span> is equivalent to a model that has feature <span><span class="math inline">\(Y\)</span></span>, we can assume we have <span><span class="math inline">\(Y\)</span></span> when showing that a function <span><span class="math inline">\(f\)</span></span> is computable by <span><span class="math inline">\(X\)</span></span>.</p>
</div>
<figure>
<img src="../figure/progcircmaj.png" alt="4.2: A standard (i.e., “sugar free”) NAND-CIRC program that is obtained by expanding out the procedure definitions in the program for Majority of . The corresponding circuit is on the right. Note that this is not the most efficient NAND circuit/program for majority: we can save on some gates by “short cutting” steps where a gate u computes \ensuremath{\mathit{NAND}}(v,v) and then a gate w computes \ensuremath{\mathit{NAND}}(u,u) (as indicated by the dashed green arrows in the above figure)." id="progcircmajfig" /><figcaption>4.2: A standard (i.e., “sugar free”) NAND-CIRC program that is obtained by expanding out the procedure definitions in the program for Majority of <a href='#majcircnand'>Example 4.3</a>. The corresponding circuit is on the right. Note that this is not the most efficient NAND circuit/program for majority: we can save on some gates by “short cutting” steps where a gate <span><span class="math inline">\(u\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(v,v)\)</span></span> and then a gate <span><span class="math inline">\(w\)</span></span> computes <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(u,u)\)</span></span> (as indicated by the dashed green arrows in the above figure).</figcaption>
</figure>
<div id="countinglines" class="remark" title="Counting lines" name="Remark 4.4 (Counting lines) ">
<p>While we can use syntactic sugar to <em>present</em> NAND-CIRC programs in more readable ways, we did not change the definition of the language itself. Therefore, whenever we say that some function <span><span class="math inline">\(f\)</span></span> has an <span><span class="math inline">\(s\)</span></span>-line NAND-CIRC program we mean a standard “sugar free” NAND-CIRC program, where all syntactic sugar has been expanded out. For example, the program of <a href='#majcircnand'>Example 4.3</a> is a <span><span class="math inline">\(12\)</span></span>-line program for computing the <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span> function, even though it can be written in fewer lines using NAND-CIRC-PROC.</p>
</div>
<h3 id="functionsynsugarthmpython" data-number="4.1.2">Proof by Python (optional)</h3>
<p>We can write a Python program that implements the proof of <a href='#functionsynsugarthm'>Theorem 4.1</a>. This is a Python program that takes a NAND-CIRC-PROC program <span><span class="math inline">\(P\)</span></span> that includes procedure definitions and uses simple “search and replace” to transform <span><span class="math inline">\(P\)</span></span> into a standard (i.e., “sugar free”) NAND-CIRC program <span><span class="math inline">\(P&#39;\)</span></span> that computes the same function as <span><span class="math inline">\(P\)</span></span> without using any procedures. The idea is simple: if the program <span><span class="math inline">\(P\)</span></span> contains a definition of a procedure <code>Proc</code> of two arguments <code>x</code> and <code>y</code>, then whenever we see a line of the form <code>foo = Proc(bar,blah)</code>, we can replace this line by:</p>
<ol type="1">
<li><p>The body of the procedure <code>Proc</code> (replacing all occurrences of <code>x</code> and <code>y</code> with <code>bar</code> and <code>blah</code> respectively).</p></li>
<li><p>A line <code>foo = exp</code>, where <code>exp</code> is the expression following the <code>return</code> statement in the definition of the procedure <code>Proc</code>.</p></li>
</ol>
<p>To make this more robust we add a prefix to the internal variables used by <code>Proc</code> to ensure they don’t conflict with the variables of <span><span class="math inline">\(P\)</span></span>; for simplicity we ignore this issue in the code below though it can be easily added.</p>
<p>The code in <a href='#desugarcode'>?? ??</a> achieves such a transformation.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="sourceCode" id="desugarcode" title="Python code for transforming NAND-CIRC-PROC programs into standard sugar free NAND-CIRC programs."><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="desugarcode-1" title="1"><span class="kw">def</span> inline_proc(code, proc_name, proc_args,proc_body):</a>
<a class="sourceLine" id="desugarcode-2" title="2">    <span class="co">&#39;&#39;&#39;Takes code of a program and name, arguments, body of a procedure.</span></a>
<a class="sourceLine" id="desugarcode-3" title="3"><span class="co">    Returns new code where all lines in program of the</span></a>
<a class="sourceLine" id="desugarcode-4" title="4"><span class="co">    form &quot;foo = proc_name(bar,blah,..)&quot; are replaced with</span></a>
<a class="sourceLine" id="desugarcode-5" title="5"><span class="co">    the body of the procedure with  arguments instantiated</span></a>
<a class="sourceLine" id="desugarcode-6" title="6"><span class="co">    with the variables bar, blah, etc.&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="desugarcode-7" title="7">    arglist <span class="op">=</span> <span class="st">&quot;,&quot;</span>.join([<span class="vs">r&quot;([a-zA-Z0-9\_\[\]]+)&quot;</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(proc_args))])</a>
<a class="sourceLine" id="desugarcode-8" title="8">    regexp <span class="op">=</span> <span class="vs">fr&#39;([a-zA-Z0-9\_\[\]]+)\s*=\s*</span><span class="sc">{</span>proc_name<span class="sc">}</span><span class="vs">\(</span><span class="sc">{</span>arglist<span class="sc">}</span><span class="vs">\)\s*$&#39;</span></a>
<a class="sourceLine" id="desugarcode-9" title="9">    <span class="co">#  captures &quot;variable = func_name(arguments)&quot;    </span></a>
<a class="sourceLine" id="desugarcode-10" title="10">    <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="desugarcode-11" title="11">        m <span class="op">=</span> re.search(regexp, code, re.MULTILINE)</a>
<a class="sourceLine" id="desugarcode-12" title="12">        <span class="cf">if</span> <span class="kw">not</span> m: <span class="cf">break</span></a>
<a class="sourceLine" id="desugarcode-13" title="13">        newcode <span class="op">=</span> proc_body</a>
<a class="sourceLine" id="desugarcode-14" title="14">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(proc_args)):</a>
<a class="sourceLine" id="desugarcode-15" title="15">            newcode <span class="op">=</span> newcode.replace(proc_args[i], m.group(i<span class="op">+</span><span class="dv">2</span>))</a>
<a class="sourceLine" id="desugarcode-16" title="16">        newcode <span class="op">=</span> newcode.replace(<span class="st">&#39;return&#39;</span>, m.group(<span class="dv">1</span>) <span class="op">+</span> <span class="st">&quot; = &quot;</span>)</a>
<a class="sourceLine" id="desugarcode-17" title="17">        code <span class="op">=</span> code[:m.start()] <span class="op">+</span> newcode <span class="op">+</span> code[m.end()<span class="op">+</span><span class="dv">1</span>:]</a>
<a class="sourceLine" id="desugarcode-18" title="18">    <span class="cf">return</span> code</a></code></pre></div>
<p><a href='#progcircmajfig'>Figure 4.2</a> shows the result of applying the code of <a href='#desugarcode'>?? ??</a> to the program of <a href='#majcircnand'>Example 4.3</a> that uses syntactic sugar to compute the Majority function. Specifically, we first apply <code>desugar</code> to remove usage of the OR function, then apply it to remove usage of the AND function, and finally apply it a third time to remove usage of the NOT function.</p>
<div id="parsingdeg" class="remark" title="Parsing function definitions (optional)" name="Remark 4.5 (Parsing function definitions (optional)) ">
<p>The function <code>desugar</code> in <a href='#desugarcode'>?? ??</a> assumes that it is given the procedure already split up into its name, arguments, and body. It is not crucial for our purposes to describe precisely how to scan a definition and split it up into these components, but in case you are curious, it can be achieved in Python via the following code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> parse_procs(code):</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">&quot;&quot;&quot;Parse code that contain procedure definitions into a list of</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">    triples (name, arguments, body)&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-4" title="4">    lines <span class="op">=</span> [l <span class="cf">for</span> l <span class="kw">in</span> code.split(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>) <span class="cf">if</span> l ]</a>
<a class="sourceLine" id="cb4-5" title="5">    regexp <span class="op">=</span> <span class="vs">r&#39;def\s+([a-zA-Z\_0-9]+)\(([\sa-zA-Z0-9\_,]+)\)\s*:\s*&#39;</span></a>
<a class="sourceLine" id="cb4-6" title="6">    procs <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-7" title="7">    current_line <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-8" title="8">    rest <span class="op">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="cf">while</span> current_line <span class="op">&lt;</span> <span class="bu">len</span>(lines):</a>
<a class="sourceLine" id="cb4-10" title="10">        m <span class="op">=</span> re.match(regexp,lines[current_line])</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="cf">if</span> m:</a>
<a class="sourceLine" id="cb4-12" title="12">            current_line<span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-13" title="13">            code <span class="op">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-14" title="14">            <span class="cf">while</span> current_line <span class="op">&lt;</span> <span class="bu">len</span>(lines) <span class="kw">and</span> lines[current_line][<span class="dv">0</span>]<span class="op">==</span><span class="st">&#39; &#39;</span>:</a>
<a class="sourceLine" id="cb4-15" title="15">                code <span class="op">+=</span> lines[current_line].strip()<span class="op">+</span><span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span></a>
<a class="sourceLine" id="cb4-16" title="16">                current_line <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-17" title="17">            procs.append((m.group(<span class="dv">1</span>) , m.group(<span class="dv">2</span>).split(<span class="st">&#39;,&#39;</span>), code))</a>
<a class="sourceLine" id="cb4-18" title="18">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-19" title="19">            rest <span class="op">+=</span> lines[current_line]<span class="op">+</span><span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span></a>
<a class="sourceLine" id="cb4-20" title="20">            current_line <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="cf">return</span> rest, procs</a></code></pre></div>
</div>
<h3 id="ifstatementsec" data-number="4.1.3">Conditional statements</h3>
<p>Another sorely missing feature in NAND-CIRC is a conditional statement such as the <code>if</code>/<code>then</code> constructs that are found in many programming languages. However, using procedures, we can obtain an ersatz if/then construct. First we can compute the function <span><span class="math inline">\(\ensuremath{\mathit{IF}}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{IF}}(a,b,c)\)</span></span> equals <span><span class="math inline">\(b\)</span></span> if <span><span class="math inline">\(a=1\)</span></span> and <span><span class="math inline">\(c\)</span></span> if <span><span class="math inline">\(a=0\)</span></span>.</p>
<div id="section-1" class="pause" name="Pause">
<p>Before reading onward, try to see how you could compute the <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span> function using <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>’s. Once you do that, see how you can use that to emulate <code>if</code>/<code>then</code> types of constructs.</p>
</div>
<p>The <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span> function can be implemented from NANDs as follows (see <a href='#mux-ex'>Exercise 4.2</a>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> IF(cond,a,b):</a>
<a class="sourceLine" id="cb5-2" title="2">    notcond <span class="op">=</span> NAND(cond,cond)</a>
<a class="sourceLine" id="cb5-3" title="3">    temp <span class="op">=</span> NAND(b,notcond)</a>
<a class="sourceLine" id="cb5-4" title="4">    temp1 <span class="op">=</span> NAND(a,cond)</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="cf">return</span> NAND(temp,temp1)</a></code></pre></div>
<p>The <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span> function is also known as a <em>multiplexing</em> function, since <span><span class="math inline">\(cond\)</span></span> can be thought of as a switch that controls whether the output is connected to <span><span class="math inline">\(a\)</span></span> or <span><span class="math inline">\(b\)</span></span>. Once we have a procedure for computing the <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span> function, we can implement conditionals in NAND. The idea is that we replace code of the form</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="cf">if</span> (condition):  assign blah to variable foo</a></code></pre></div>
<p>with code of the form</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">foo   <span class="op">=</span> IF(condition, blah, foo)</a></code></pre></div>
<p>that assigns to <code>foo</code> its old value when <code>condition</code> equals <span><span class="math inline">\(0\)</span></span>, and assign to <code>foo</code> the value of <code>blah</code> otherwise. More generally we can replace code of the form</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="cf">if</span> (cond):</a>
<a class="sourceLine" id="cb8-2" title="2">    a <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb8-3" title="3">    b <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb8-4" title="4">    c <span class="op">=</span> ...</a></code></pre></div>
<p>with code of the form</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">temp_a <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb9-2" title="2">temp_b <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb9-3" title="3">temp_c <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb9-4" title="4">a <span class="op">=</span> IF(cond,temp_a,a)</a>
<a class="sourceLine" id="cb9-5" title="5">b <span class="op">=</span> IF(cond,temp_b,b)</a>
<a class="sourceLine" id="cb9-6" title="6">c <span class="op">=</span> IF(cond,temp_c,c)</a></code></pre></div>
<p>Using such transformations, we can prove the following theorem. Once again we omit the (not too insightful) full formal proof, though see <a href='#functionsynsugarthmpython'>Subsection 4.1.2</a> for some hints on how to obtain it.</p>
<div id="conditionalsugarthm" class="theorem" title="Conditional statements synctatic sugar" name="Theorem 4.6 (Conditional statements synctatic sugar) ">
<p>Let NAND-CIRC-IF be the programming language NAND-CIRC augmented with <code>if</code>/<code>then</code>/<code>else</code> statements for allowing code to be conditionally executed based on whether a variable is equal to <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>.<br />
Then for every NAND-CIRC-IF program <span><span class="math inline">\(P\)</span></span>, there exists a standard (i.e., “sugar free”) NAND-CIRC program <span><span class="math inline">\(P&#39;\)</span></span> that computes the same function as <span><span class="math inline">\(P\)</span></span>.</p>
</div>
<h2 id="addexample" data-number="4.2">Extended example: Addition and Multiplication (optional)</h2>
<p>Using “syntactic sugar”, we can write the integer addition function as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"><span class="co"># Add two n-bit integers</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co"># Use LSB first notation for simplicity</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">def</span> ADD(A,B):</a>
<a class="sourceLine" id="cb10-4" title="4">    Result <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-5" title="5">    Carry  <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-6" title="6">    Carry[<span class="dv">0</span>] <span class="op">=</span> zero(A[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</a>
<a class="sourceLine" id="cb10-8" title="8">        Result[i] <span class="op">=</span> XOR(Carry[i],XOR(A[i],B[i]))</a>
<a class="sourceLine" id="cb10-9" title="9">        Carry[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> MAJ(Carry[i],A[i],B[i])</a>
<a class="sourceLine" id="cb10-10" title="10">    Result[n] <span class="op">=</span> Carry[n]</a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="cf">return</span> Result</a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13">ADD([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])<span class="op">;;</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="co"># [0, 0, 0, 1, 0, 0]</span></a></code></pre></div>
<p>where <code>zero</code> is the constant zero function, and <code>MAJ</code> and <code>XOR</code> correspond to the majority and XOR functions respectively. In the above we used the <em>loop</em> <code>for i in range(n)</code> but we can expand this out by simply repeating the code <span><span class="math inline">\(n\)</span></span> times, replacing the value of <code>i</code> with <span><span class="math inline">\(0,1,2,\ldots,n-1\)</span></span>. By expanding out all the features, for every value of <span><span class="math inline">\(n\)</span></span> we can translate the above program into a standard (“sugar free”) NAND-CIRC program. <a href='#add2bitnumbersfig'>Figure 4.3</a> depicts what we get for <span><span class="math inline">\(n=2\)</span></span>.</p>
<figure>
<img src="../figure/add2bitnumbers.png" alt="4.3: The NAND-CIRC program and corresponding NAND circuit for adding two-digit binary numbers that are obtained by “expanding out” all the syntactic sugar. The program/circuit has 43 lines/gates which is by no means necessary. It is possible to add n bit numbers using 9n NAND gates, see ." id="add2bitnumbersfig" class="class" /><figcaption>4.3: The NAND-CIRC program and corresponding NAND circuit for adding two-digit binary numbers that are obtained by “expanding out” all the syntactic sugar. The program/circuit has 43 lines/gates which is by no means necessary. It is possible to add <span><span class="math inline">\(n\)</span></span> bit numbers using <span><span class="math inline">\(9n\)</span></span> NAND gates, see <a href='#halffulladderex'>Exercise 4.5</a>.</figcaption>
</figure>
<p>By going through the above program carefully and accounting for the number of gates, we can see that it yields a proof of the following theorem (see also <a href='#addnumoflinesfig'>Figure 4.4</a>):</p>
<div id="addition-thm" class="theorem" title="Addition using NAND-CIRC programs" name="Theorem 4.7 (Addition using NAND-CIRC programs) ">
<p>For every <span><span class="math inline">\(n\in \N\)</span></span>, let <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n:\{0,1\}^{2n}\rightarrow \{0,1\}^{n+1}\)</span></span> be the function that, given <span><span class="math inline">\(x,x&#39;\in \{0,1\}^n\)</span></span> computes the representation of the sum of the numbers that <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(x&#39;\)</span></span> represent. Then there is a constant <span><span class="math inline">\(c \leq 30\)</span></span> such that for every <span><span class="math inline">\(n\)</span></span> there is a NAND-CIRC program of at most <span><span class="math inline">\(cn\)</span></span> lines computing <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n\)</span></span>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
</div>
<figure>
<img src="../figure/addnumberoflines.png" alt="4.4: The number of lines in our NAND-CIRC program to add two n bit numbers, as a function of n, for n’s between 1 and 100. This is not the most efficient program for this task, but the important point is that it has the form O(n)." id="addnumoflinesfig" class="margin" /><figcaption>4.4: The number of lines in our NAND-CIRC program to add two <span><span class="math inline">\(n\)</span></span> bit numbers, as a function of <span><span class="math inline">\(n\)</span></span>, for <span><span class="math inline">\(n\)</span></span>’s between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(100\)</span></span>. This is not the most efficient program for this task, but the important point is that it has the form <span><span class="math inline">\(O(n)\)</span></span>.</figcaption>
</figure>
<p>Once we have addition, we can use the grade-school algorithm to obtain multiplication as well, thus obtaining the following theorem:</p>
<div id="theoremid" class="theorem" title="Multiplication using NAND-CIRC programs" name="Theorem 4.8 (Multiplication using NAND-CIRC programs) ">
<p>For every <span><span class="math inline">\(n\)</span></span>, let <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n:\{0,1\}^{2n}\rightarrow \{0,1\}^{2n}\)</span></span> be the function that, given <span><span class="math inline">\(x,x&#39;\in \{0,1\}^n\)</span></span> computes the representation of the product of the numbers that <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(x&#39;\)</span></span> represent. Then there is a constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(n\)</span></span>, there is a NAND-CIRC program of at most <span><span class="math inline">\(cn^2\)</span></span> that computes the function <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n\)</span></span>.</p>
</div>
<p>We omit the proof, though in <a href='#multiplication-ex'>Exercise 4.7</a> we ask you to supply a “constructive proof” in the form of a program (in your favorite programming language) that on input a number <span><span class="math inline">\(n\)</span></span>, outputs the code of a NAND-CIRC program of at most <span><span class="math inline">\(1000n^2\)</span></span> lines that computes the <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n\)</span></span> function. In fact, we can use Karatsuba’s algorithm to show that there is a NAND-CIRC program of <span><span class="math inline">\(O(n^{\log_2 3})\)</span></span> lines to compute <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n\)</span></span> (and can get even further asymptotic improvements using better algorithms).</p>
<h2 id="seclookupfunc" data-number="4.3">The LOOKUP function</h2>
<p>The <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}\)</span></span> function will play an important role in this chapter and later. It is defined as follows:</p>
<div id="lookup-def" class="definition" title="Lookup function" name="Definition 4.9 (Lookup function) ">
<p>For every <span><span class="math inline">\(k\)</span></span>, the <em>lookup</em> function of order <span><span class="math inline">\(k\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k: \{0,1\}^{2^k+k}\rightarrow \{0,1\}\)</span></span> is defined as follows: For every <span><span class="math inline">\(x\in\{0,1\}^{2^k}\)</span></span> and <span><span class="math inline">\(i\in \{0,1\}^k\)</span></span>, <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{LOOKUP}}_k(x,i)=x_i
\]</span></div></span> where <span><span class="math inline">\(x_i\)</span></span> denotes the <span><span class="math inline">\(i^{th}\)</span></span> entry of <span><span class="math inline">\(x\)</span></span>, using the binary representation to identify <span><span class="math inline">\(i\)</span></span> with a number in <span><span class="math inline">\(\{0,\ldots,2^k - 1 \}\)</span></span>.</p>
</div>
<figure>
<img src="../figure/lookupfunc.png" alt="4.5: The \ensuremath{\mathit{LOOKUP}}_k function takes an input in \{0,1\}^{2^k+k}, which we denote by x,i (with x\in \{0,1\}^{2^k} and i \in \{0,1\}^k). The output is x_i: the i-th coordinate of x, where we identify i as a number in [k] using the binary representation. In the above example x\in \{0,1\}^{16} and i\in \{0,1\}^4. Since i=0110 is the binary representation of the number 6, the output of \ensuremath{\mathit{LOOKUP}}_4(x,i) in this case is x_6 = 1." id="lookupfig" /><figcaption>4.5: The <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span> function takes an input in <span><span class="math inline">\(\{0,1\}^{2^k+k}\)</span></span>, which we denote by <span><span class="math inline">\(x,i\)</span></span> (with <span><span class="math inline">\(x\in \{0,1\}^{2^k}\)</span></span> and <span><span class="math inline">\(i \in \{0,1\}^k\)</span></span>). The output is <span><span class="math inline">\(x_i\)</span></span>: the <span><span class="math inline">\(i\)</span></span>-th coordinate of <span><span class="math inline">\(x\)</span></span>, where we identify <span><span class="math inline">\(i\)</span></span> as a number in <span><span class="math inline">\([k]\)</span></span> using the binary representation. In the above example <span><span class="math inline">\(x\in \{0,1\}^{16}\)</span></span> and <span><span class="math inline">\(i\in \{0,1\}^4\)</span></span>. Since <span><span class="math inline">\(i=0110\)</span></span> is the binary representation of the number <span><span class="math inline">\(6\)</span></span>, the output of <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_4(x,i)\)</span></span> in this case is <span><span class="math inline">\(x_6 = 1\)</span></span>.</figcaption>
</figure>
<p>See <a href='#lookupfig'>Figure 4.5</a> for an illustration of the LOOKUP function. It turns out that for every <span><span class="math inline">\(k\)</span></span>, we can compute <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span> using a NAND-CIRC program:</p>
<div id="lookup-thm" class="theorem" title="Lookup function" data-number="4.3" name="Theorem 4.10 (Lookup function) ">
<p>For every <span><span class="math inline">\(k&gt;0\)</span></span>, there is a NAND-CIRC program that computes the function <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k: \{0,1\}^{2^k+k}\rightarrow \{0,1\}\)</span></span>. Moreover, the number of lines in this program is at most <span><span class="math inline">\(4\cdot 2^k\)</span></span>.</p>
</div>
<p>An immediate corollary of <a href='#lookup-thm'>Theorem 4.10</a> is that for every <span><span class="math inline">\(k&gt;0\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span> can be computed by a Boolean circuit (with AND, OR and NOT gates) of at most <span><span class="math inline">\(8 \cdot 2^k\)</span></span> gates.</p>
<h3 id="constructing-a-nand-circ-program-for-lookup" data-number="4.3.1">Constructing a NAND-CIRC program for <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}\)</span></span></h3>
<p>We prove <a href='#lookup-thm'>Theorem 4.10</a> by induction. For the case <span><span class="math inline">\(k=1\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_1\)</span></span> maps <span><span class="math inline">\((x_0,x_1,i) \in \{0,1\}^3\)</span></span> to <span><span class="math inline">\(x_i\)</span></span>. In other words, if <span><span class="math inline">\(i=0\)</span></span> then it outputs <span><span class="math inline">\(x_0\)</span></span> and otherwise it outputs <span><span class="math inline">\(x_1\)</span></span>, which (up to reordering variables) is the same as the <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span> function presented in <a href='#ifstatementsec'>Subsection 4.1.3</a>, which can be computed by a 4-line NAND-CIRC program.</p>
<p>As a warm-up for the case of general <span><span class="math inline">\(k\)</span></span>, let us consider the case of <span><span class="math inline">\(k=2\)</span></span>. Given input <span><span class="math inline">\(x=(x_0,x_1,x_2,x_3)\)</span></span> for <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_2\)</span></span> and an index <span><span class="math inline">\(i=(i_0,i_1)\)</span></span>, if the most significant bit <span><span class="math inline">\(i_0\)</span></span> of the index is <span><span class="math inline">\(0\)</span></span> then <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_2(x,i)\)</span></span> will equal <span><span class="math inline">\(x_0\)</span></span> if <span><span class="math inline">\(i_1=0\)</span></span> and equal <span><span class="math inline">\(x_1\)</span></span> if <span><span class="math inline">\(i_1=1\)</span></span>. Similarly, if the most significant bit <span><span class="math inline">\(i_0\)</span></span> is <span><span class="math inline">\(1\)</span></span> then <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_2(x,i)\)</span></span> will equal <span><span class="math inline">\(x_2\)</span></span> if <span><span class="math inline">\(i_1=0\)</span></span> and will equal <span><span class="math inline">\(x_3\)</span></span> if <span><span class="math inline">\(i_1=1\)</span></span>. Another way to say this is that we can write <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_2\)</span></span> as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">def</span> LOOKUP2(X[<span class="dv">0</span>],X[<span class="dv">1</span>],X[<span class="dv">2</span>],X[<span class="dv">3</span>],i[<span class="dv">0</span>],i[<span class="dv">1</span>]):</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="cf">if</span> i[<span class="dv">0</span>]<span class="op">==</span><span class="dv">1</span>:</a>
<a class="sourceLine" id="cb11-3" title="3">        <span class="cf">return</span> LOOKUP1(X[<span class="dv">2</span>],X[<span class="dv">3</span>],i[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-5" title="5">        <span class="cf">return</span> LOOKUP1(X[<span class="dv">0</span>],X[<span class="dv">1</span>],i[<span class="dv">1</span>])</a></code></pre></div>
<p>or in other words,</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">def</span> LOOKUP2(X[<span class="dv">0</span>],X[<span class="dv">1</span>],X[<span class="dv">2</span>],X[<span class="dv">3</span>],i[<span class="dv">0</span>],i[<span class="dv">1</span>]):</a>
<a class="sourceLine" id="cb12-2" title="2">    a <span class="op">=</span> LOOKUP1(X[<span class="dv">2</span>],X[<span class="dv">3</span>],i[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb12-3" title="3">    b <span class="op">=</span> LOOKUP1(X[<span class="dv">0</span>],X[<span class="dv">1</span>],i[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="cf">return</span> IF( i[<span class="dv">0</span>],a,b)</a></code></pre></div>
<p>More generally, as shown in the following lemma, we can compute <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span> using two invocations of <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_{k-1}\)</span></span> and one invocation of <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span>:</p>
<div id="lookup-rec-lem" class="lemma" title="Lookup recursion" name="Lemma 4.11 (Lookup recursion) ">
<p>For every <span><span class="math inline">\(k \geq 2\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k(x_0,\ldots,x_{2^k-1},i_0,\ldots,i_{k-1})\)</span></span> is equal to <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{IF}} \left(i_0, \ensuremath{\mathit{LOOKUP}}_{k-1}(x_{2^{k-1}},\ldots,x_{2^k-1},i_1,\ldots,i_{k-1}), \ensuremath{\mathit{LOOKUP}}_{k-1}(x_0,\ldots,x_{2^{k-1}-1},i_1,\ldots,i_{k-1}) \right)
\]</span></div></span></p>
</div>
<div id="section-2" class="proof" data-ref="lookup-rec-lem" name="Proof">
<p>If the most significant bit <span><span class="math inline">\(i_{0}\)</span></span> of <span><span class="math inline">\(i\)</span></span> is zero, then the index <span><span class="math inline">\(i\)</span></span> is in <span><span class="math inline">\(\{0,\ldots,2^{k-1}-1\}\)</span></span> and hence we can perform the lookup on the “first half” of <span><span class="math inline">\(x\)</span></span> and the result of <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k(x,i)\)</span></span> will be the same as <span><span class="math inline">\(a=\ensuremath{\mathit{LOOKUP}}_{k-1}(x_0,\ldots,x_{2^{k-1}-1},i_1,\ldots,i_{k-1})\)</span></span>. On the other hand, if this most significant bit <span><span class="math inline">\(i_{0}\)</span></span> is equal to <span><span class="math inline">\(1\)</span></span>, then the index is in <span><span class="math inline">\(\{2^{k-1},\ldots,2^k-1\}\)</span></span>, in which case the result of <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k(x,i)\)</span></span> is the same as <span><span class="math inline">\(b=\ensuremath{\mathit{LOOKUP}}_{k-1}(x_{2^{k-1}},\ldots,x_{2^k-1},i_1,\ldots,i_{k-1})\)</span></span>. Thus we can compute <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k(x,i)\)</span></span> by first computing <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(b\)</span></span> and then outputting <span><span class="math inline">\(\ensuremath{\mathit{IF}}(i_{k-1},a,b)\)</span></span>.</p>
</div>
<p><strong>Proof of <a href='#lookup-thm'>Theorem 4.10</a> from <a href='#lookup-rec-lem'>Lemma 4.11</a>.</strong> Now that we have <a href='#lookup-rec-lem'>Lemma 4.11</a>, we can complete the proof of <a href='#lookup-thm'>Theorem 4.10</a>. We will prove by induction on <span><span class="math inline">\(k\)</span></span> that there is a NAND-CIRC program of at most <span><span class="math inline">\(4\cdot (2^k-1)\)</span></span> lines for <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span>. For <span><span class="math inline">\(k=1\)</span></span> this follows by the four line program for <span><span class="math inline">\(\ensuremath{\mathit{IF}}\)</span></span> we’ve seen before. For <span><span class="math inline">\(k&gt;1\)</span></span>, we use the following pseudocode:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">a <span class="op">=</span> LOOKUP_(k<span class="dv">-1</span>)(X[<span class="dv">0</span>],...,X[<span class="dv">2</span><span class="op">^</span>(k<span class="dv">-1</span>)<span class="op">-</span><span class="dv">1</span>],i[<span class="dv">1</span>],...,i[k<span class="dv">-1</span>])</a>
<a class="sourceLine" id="cb13-2" title="2">b <span class="op">=</span> LOOKUP_(k<span class="dv">-1</span>)(X[<span class="dv">2</span><span class="op">^</span>(k<span class="dv">-1</span>)],...,Z[<span class="dv">2</span><span class="op">^</span>(k<span class="dv">-1</span>)],i[<span class="dv">1</span>],...,i[k<span class="dv">-1</span>])</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="cf">return</span> IF(i[<span class="dv">0</span>],b,a)</a></code></pre></div>
<p>If we let <span><span class="math inline">\(L(k)\)</span></span> be the number of lines required for <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span>, then the above pseudo-code shows that <span>
<div class='myequationbox'><span class="math display">\[
L(k) \leq 2L(k-1)+4 \;. \;\;(4.3)
\]</span><a id='induction-lookup'></a></div></span> Since under our induction hypothesis <span><span class="math inline">\(L(k-1) \leq 4(2^{k-1}-1)\)</span></span>, we get that <span><span class="math inline">\(L(k) \leq 2\cdot 4 (2^{k-1}-1) + 4 = 4(2^k - 1)\)</span></span> which is what we wanted to prove. See <a href='#lookuplinesfig'>Figure 4.6</a> for a plot of the actual number of lines in our implementation of <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_k\)</span></span>.</p>
<figure>
<img src="../figure/lookup_numlines.png" alt="4.6: The number of lines in our implementation of the LOOKUP_k function as a function of k (i.e., the length of the index). The number of lines in our implementation is roughly 3 \cdot 2^k." id="lookuplinesfig" class="margin" /><figcaption>4.6: The number of lines in our implementation of the <code>LOOKUP_k</code> function as a function of <span><span class="math inline">\(k\)</span></span> (i.e., the length of the index). The number of lines in our implementation is roughly <span><span class="math inline">\(3 \cdot 2^k\)</span></span>.</figcaption>
</figure>
<h2 id="seccomputeallfunctions" data-number="4.4">Computing <em>every</em> function</h2>
<p>At this point we know the following facts about NAND-CIRC programs (and so equivalently about Boolean circuits and our other equivalent models):</p>
<ol type="1">
<li><p>They can compute at least some non trivial functions.</p></li>
<li><p>Coming up with NAND-CIRC programs for various functions is a very tedious task.</p></li>
</ol>
<p>Thus I would not blame the reader if they were not particularly looking forward to a long sequence of examples of functions that can be computed by NAND-CIRC programs. However, it turns out we are not going to need this, as we can show in one fell swoop that NAND-CIRC programs can compute <em>every</em> finite function:</p>
<div id="NAND-univ-thm" class="theorem" title="Universality of NAND" name="Theorem 4.12 (Universality of NAND) ">
<p>There exists some constant <span><span class="math inline">\(c&gt;0\)</span></span> such that for every <span><span class="math inline">\(n,m&gt;0\)</span></span> and function <span><span class="math inline">\(f: \{0,1\}^n\rightarrow \{0,1\}^m\)</span></span>, there is a NAND-CIRC program with at most <span><span class="math inline">\(c \cdot m 2^n\)</span></span> lines that computes the function <span><span class="math inline">\(f\)</span></span> .</p>
</div>
<p>By <a href='lec_03_computation.html#equivalencemodelsthm'>Theorem 3.19</a>, the models of NAND circuits, NAND-CIRC programs, AON-CIRC programs, and Boolean circuits, are all equivalent to one another, and hence <a href='#NAND-univ-thm'>Theorem 4.12</a> holds for all these models. In particular, the following theorem is equivalent to <a href='#NAND-univ-thm'>Theorem 4.12</a>:</p>
<div id="circuit-univ-thm" class="theorem" title="Universality of Boolean circuits" name="Theorem 4.13 (Universality of Boolean circuits) ">
<p>There exists some constant <span><span class="math inline">\(c&gt;0\)</span></span> such that for every <span><span class="math inline">\(n,m&gt;0\)</span></span> and function <span><span class="math inline">\(f: \{0,1\}^n\rightarrow \{0,1\}^m\)</span></span>, there is a Boolean circuit with at most <span><span class="math inline">\(c \cdot m 2^n\)</span></span> gates that computes the function <span><span class="math inline">\(f\)</span></span> .</p>
</div>
<div id="finitecomputation" class="bigidea" name="Bigidea 5">
<p><em>Every</em> finite function can be computed by a large enough Boolean circuit.</p>
</div>
<p><em>Improved bounds.</em> Though it will not be of great importance to us, it is possible to improve on the proof of <a href='#NAND-univ-thm'>Theorem 4.12</a> and shave an extra factor of <span><span class="math inline">\(n\)</span></span>, as well as optimize the constant <span><span class="math inline">\(c\)</span></span>, and so prove that for every <span><span class="math inline">\(\epsilon&gt;0\)</span></span>, <span><span class="math inline">\(m\in \N\)</span></span> and sufficiently large <span><span class="math inline">\(n\)</span></span>, if <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> then <span><span class="math inline">\(f\)</span></span> can be computed by a NAND circuit of at most <span><span class="math inline">\((1+\epsilon)\tfrac{m\cdot 2^n}{n}\)</span></span> gates. The proof of this result is beyond the scope of this book, but we do discuss how to obtain a bound of the form <span><span class="math inline">\(O(\tfrac{m \cdot 2^n}{n})\)</span></span> in <a href='#tight-upper-bound'>Subsection 4.4.2</a>; see also the biographical notes.</p>
<h3 id="proof-of-nands-universality" data-number="4.4.1">Proof of NAND’s Universality</h3>
<p>To prove <a href='#NAND-univ-thm'>Theorem 4.12</a>, we need to give a NAND circuit, or equivalently a NAND-CIRC program, for <em>every</em> possible function. We will restrict our attention to the case of Boolean functions (i.e., <span><span class="math inline">\(m=1\)</span></span>). <a href='#mult-bit-ex'>Exercise 4.9</a> asks you to extend the proof for all values of <span><span class="math inline">\(m\)</span></span>. A function <span><span class="math inline">\(F: \{0,1\}^n\rightarrow \{0,1\}\)</span></span> can be specified by a table of its values for each one of the <span><span class="math inline">\(2^n\)</span></span> inputs. For example, the table below describes one particular function <span><span class="math inline">\(G: \{0,1\}^4 \rightarrow \{0,1\}\)</span></span>:<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<table>
<caption>An example of a function <span><span class="math inline">\(G:\{0,1\}^4 \rightarrow \{0,1\}\)</span></span>. { .table #tablefunctiong }</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Input (<span><span class="math inline">\(x\)</span></span>)</th>
<th style="text-align: left;">Output (<span><span class="math inline">\(G(x)\)</span></span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(0000\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(0001\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(0010\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(0011\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(0100\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(0101\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(0110\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(0111\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(1000\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(1001\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(1010\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(1011\)</span></span></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(1100\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(1101\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><span class="math inline">\(1110\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><span class="math inline">\(1111\)</span></span></td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>For every <span><span class="math inline">\(x\in \{0,1\}^4\)</span></span>, <span><span class="math inline">\(G(x)=\ensuremath{\mathit{LOOKUP}}_4(1100100100001111,x)\)</span></span>, and so the following is NAND-CIRC “pseudocode” to compute <span><span class="math inline">\(G\)</span></span> using syntactic sugar for the <code>LOOKUP_4</code> procedure.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">G0000 <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-2" title="2">G1000 <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-3" title="3">G0100 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-4" title="4">...</a>
<a class="sourceLine" id="cb14-5" title="5">G0111 <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-6" title="6">G1111 <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-7" title="7">Y[<span class="dv">0</span>] <span class="op">=</span> LOOKUP_4(G0000,G1000,...,G1111,</a>
<a class="sourceLine" id="cb14-8" title="8">                X[<span class="dv">0</span>],X[<span class="dv">1</span>],X[<span class="dv">2</span>],X[<span class="dv">3</span>])</a></code></pre></div>
<p>We can translate this pseudocode into an actual NAND-CIRC program by adding three lines to define variables <code>zero</code> and <code>one</code> that are initialized to <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span> respectively, and then replacing a statement such as <code>Gxxx = 0</code> with <code>Gxxx = NAND(one,one)</code> and a statement such as <code>Gxxx = 1</code> with <code>Gxxx = NAND(zero,zero)</code>. The call to <code>LOOKUP_4</code> will be replaced by the NAND-CIRC program that computes <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_4\)</span></span>, plugging in the appropriate inputs.</p>
<p>There was nothing about the above reasoning that was particular to the function <span><span class="math inline">\(G\)</span></span> of <a href='#tablefunctiong'>?? ??</a>. Given <em>every</em> function <span><span class="math inline">\(F: \{0,1\}^n \rightarrow \{0,1\}\)</span></span>, we can write a NAND-CIRC program that does the following:</p>
<ol type="1">
<li><p>Initialize <span><span class="math inline">\(2^n\)</span></span> variables of the form <code>F00...0</code> till <code>F11...1</code> so that for every <span><span class="math inline">\(z\in\{0,1\}^n\)</span></span>, the variable corresponding to <span><span class="math inline">\(z\)</span></span> is assigned the value <span><span class="math inline">\(F(z)\)</span></span>.</p></li>
<li><p>Compute <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_n\)</span></span> on the <span><span class="math inline">\(2^n\)</span></span> variables initialized in the previous step, with the index variable being the input variables <code>X[</code><span><span class="math inline">\(0\)</span></span> <code>]</code>,…,<code>X[</code><span><span class="math inline">\(2^n-1\)</span></span> <code>]</code>. That is, just like in the pseudocode for <code>G</code> above, we use <code>Y[0] = LOOKUP(F00..00,...,F11..1,X[0],..,x[</code><span><span class="math inline">\(n-1\)</span></span><code>])</code></p></li>
</ol>
<p>The total number of lines in the resulting program is <span><span class="math inline">\(3+2^n\)</span></span> lines for initializing the variables plus the <span><span class="math inline">\(4\cdot 2^n\)</span></span> lines that we pay for computing <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_n\)</span></span>. This completes the proof of <a href='#NAND-univ-thm'>Theorem 4.12</a>.</p>
<div id="discusscomputation" class="remark" title="Result in perspective" name="Remark 4.14 (Result in perspective) ">
<p>While <a href='#NAND-univ-thm'>Theorem 4.12</a> seems striking at first, in retrospect, it is perhaps not that surprising that every finite function can be computed with a NAND-CIRC program. After all, a finite function <span><span class="math inline">\(F: \{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> can be represented by simply the list of its outputs for each one of the <span><span class="math inline">\(2^n\)</span></span> input values. So it makes sense that we could write a NAND-CIRC program of similar size to compute it. What is more interesting is that <em>some</em> functions, such as addition and multiplication, have a much more efficient representation: one that only requires <span><span class="math inline">\(O(n^2)\)</span></span> or even fewer lines.</p>
</div>
<h3 id="tight-upper-bound" data-number="4.4.2">Improving by a factor of <span><span class="math inline">\(n\)</span></span> (optional)</h3>
<p>By being a little more careful, we can improve the bound of <a href='#NAND-univ-thm'>Theorem 4.12</a> and show that every function <span><span class="math inline">\(F:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> can be computed by a NAND-CIRC program of at most <span><span class="math inline">\(O(m 2^n/n)\)</span></span> lines. In other words, we can prove the following improved version:</p>
<div id="NAND-univ-thm-improved" class="theorem" title="Universality of NAND circuits, improved bound" name="Theorem 4.15 (Universality of NAND circuits, improved bound) ">
<p>There exists a constant <span><span class="math inline">\(c&gt;0\)</span></span> such that for every <span><span class="math inline">\(n,m&gt;0\)</span></span> and function <span><span class="math inline">\(f: \{0,1\}^n\rightarrow \{0,1\}^m\)</span></span>, there is a NAND-CIRC program with at most <span><span class="math inline">\(c \cdot m 2^n / n\)</span></span> lines that computes the function <span><span class="math inline">\(f\)</span></span>.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
</div>
<div class="proof" data-ref="NAND-univ-thm-improved" name="Proof 4.4.2">
<p>As before, it is enough to prove the case that <span><span class="math inline">\(m=1\)</span></span>. Hence we let <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>, and our goal is to prove that there exists a NAND-CIRC program of <span><span class="math inline">\(O(2^n/n)\)</span></span> lines (or equivalently a Boolean circuit of <span><span class="math inline">\(O(2^n/n)\)</span></span> gates) that computes <span><span class="math inline">\(f\)</span></span>.</p>
<p>We let <span><span class="math inline">\(k= \log(n-2\log n)\)</span></span> (the reasoning behind this choice will become clear later on). We define the function <span><span class="math inline">\(g:\{0,1\}^k \rightarrow \{0,1\}^{2^{n-k}}\)</span></span> as follows: <span>
<div class='myequationbox'><span class="math display">\[
g(a) = f(a0^{n-k})f(a0^{n-k-1}1) \cdots f(a1^{n-k}) \;.
\]</span></div></span> In other words, if we use the usual binary representation to identify the numbers <span><span class="math inline">\(\{0,\ldots, 2^{n-k}-1 \}\)</span></span> with the strings <span><span class="math inline">\(\{0,1\}^{n-k}\)</span></span>, then for every <span><span class="math inline">\(a\in \{0,1\}^k\)</span></span> and <span><span class="math inline">\(b\in \{0,1\}^{n-k}\)</span></span> <span>
<div class='myequationbox'><span class="math display">\[
g(a)_b = f(ab) \;. \;\;(4.5)
\]</span><a id='eqcomputefusinggeffcircuit'></a></div></span></p>
<figure>
<img src="../figure/efficient_circuit_allfunc.png" alt="4.7: We can compute f:\{0,1\}^n \rightarrow \{0,1\} on input x=ab where a\in \{0,1\}^k and b\in \{0,1\}^{n-k} by first computing the 2^{n-k} long string g(a) that corresponds to all f’s values on inputs that begin with a, and then outputting the b-th coordinate of this string." id="efficient_circuit_allfuncfig" class="margin" /><figcaption>4.7: We can compute <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> on input <span><span class="math inline">\(x=ab\)</span></span> where <span><span class="math inline">\(a\in \{0,1\}^k\)</span></span> and <span><span class="math inline">\(b\in \{0,1\}^{n-k}\)</span></span> by first computing the <span><span class="math inline">\(2^{n-k}\)</span></span> long string <span><span class="math inline">\(g(a)\)</span></span> that corresponds to all <span><span class="math inline">\(f\)</span></span>’s values on inputs that begin with <span><span class="math inline">\(a\)</span></span>, and then outputting the <span><span class="math inline">\(b\)</span></span>-th coordinate of this string.</figcaption>
</figure>
<p><a href='#eqcomputefusinggeffcircuit'>Equation 4.5</a> means that for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, if we write <span><span class="math inline">\(x=ab\)</span></span> with <span><span class="math inline">\(a\in \{0,1\}^k\)</span></span> and <span><span class="math inline">\(b\in \{0,1\}^{n-k}\)</span></span> then we can compute <span><span class="math inline">\(f(x)\)</span></span> by first computing the string <span><span class="math inline">\(T=g(a)\)</span></span> of length <span><span class="math inline">\(2^{n-k}\)</span></span>, and then computing <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_{n-k}(T\;,\; b)\)</span></span> to retrieve the element of <span><span class="math inline">\(T\)</span></span> at the position corresponding to <span><span class="math inline">\(b\)</span></span> (see <a href='#efficient_circuit_allfuncfig'>Figure 4.7</a>). The cost to compute the <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_{n-k}\)</span></span> is <span><span class="math inline">\(O(2^{n-k})\)</span></span> lines/gates and the cost in NAND-CIRC lines (or Boolean gates) to compute <span><span class="math inline">\(f\)</span></span> is at most <span>
<div class='myequationbox'><span class="math display">\[
cost(g) + O(2^{n-k}) \;, \;\;(4.6)
\]</span><a id='eqcostcomputefusingg'></a></div></span> where <span><span class="math inline">\(cost(g)\)</span></span> is the number of operations (i.e., lines of NAND-CIRC programs or gates in a circuit) needed to compute <span><span class="math inline">\(g\)</span></span>.</p>
<p>To complete the proof we need to give a bound on <span><span class="math inline">\(cost(g)\)</span></span>. Since <span><span class="math inline">\(g\)</span></span> is a function mapping <span><span class="math inline">\(\{0,1\}^k\)</span></span> to <span><span class="math inline">\(\{0,1\}^{2^{n-k}}\)</span></span>, we can also think of it as a collection of <span><span class="math inline">\(2^{n-k}\)</span></span> functions <span><span class="math inline">\(g_0,\ldots, g_{2^{n-k}-1}: \{0,1\}^k \rightarrow \{0,1\}\)</span></span>, where <span><span class="math inline">\(g_i(x) = g(a)_i\)</span></span> for every <span><span class="math inline">\(a\in \{0,1\}^k\)</span></span> and <span><span class="math inline">\(i\in [2^{n-k}]\)</span></span>. (That is, <span><span class="math inline">\(g_i(a)\)</span></span> is the <span><span class="math inline">\(i\)</span></span>-th bit of <span><span class="math inline">\(g(a)\)</span></span>.) Naively, we could use <a href='#NAND-univ-thm'>Theorem 4.12</a> to compute each <span><span class="math inline">\(g_i\)</span></span> in <span><span class="math inline">\(O(2^k)\)</span></span> lines, but then the total cost is <span><span class="math inline">\(O(2^{n-k} \cdot 2^k) = O(2^n)\)</span></span> which does not save us anything. However, the crucial observation is that there are only <span><span class="math inline">\(2^{2^k}\)</span></span> <em>distinct functions</em> mapping <span><span class="math inline">\(\{0,1\}^k\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>. For example, if <span><span class="math inline">\(g_{17}\)</span></span> is an identical function to <span><span class="math inline">\(g_{67}\)</span></span> that means that if we already computed <span><span class="math inline">\(g_{17}(a)\)</span></span> then we can compute <span><span class="math inline">\(g_{67}(a)\)</span></span> using only a constant number of operations: simply copy the same value! In general, if you have a collection of <span><span class="math inline">\(N\)</span></span> functions <span><span class="math inline">\(g_0,\ldots,g_{N-1}\)</span></span> mapping <span><span class="math inline">\(\{0,1\}^k\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>, of which at most <span><span class="math inline">\(S\)</span></span> are distinct then for every value <span><span class="math inline">\(a\in \{0,1\}^k\)</span></span> we can compute the <span><span class="math inline">\(N\)</span></span> values <span><span class="math inline">\(g_0(a),\ldots,g_{N-1}(a)\)</span></span> using at most <span><span class="math inline">\(O(S\cdot 2^k + N)\)</span></span> operations (see <a href='#computemanyfunctionsfig'>Figure 4.8</a>).</p>
<figure>
<img src="../figure/computemanyfunctions.png" alt="4.8: If g_0,\ldots, g_{N-1} is a collection of functions each mapping \{0,1\}^k to \{0,1\} such that at most S of them are distinct then for every a\in \{0,1\}^k, we can compute all the values g_0(a),\ldots,g_{N-1}(a) using at most O(S \cdot 2^k + N) operations by first computing the distinct functions and then copying the resulting values." id="computemanyfunctionsfig" class="margin" /><figcaption>4.8: If <span><span class="math inline">\(g_0,\ldots, g_{N-1}\)</span></span> is a collection of functions each mapping <span><span class="math inline">\(\{0,1\}^k\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span> such that at most <span><span class="math inline">\(S\)</span></span> of them are distinct then for every <span><span class="math inline">\(a\in \{0,1\}^k\)</span></span>, we can compute all the values <span><span class="math inline">\(g_0(a),\ldots,g_{N-1}(a)\)</span></span> using at most <span><span class="math inline">\(O(S \cdot 2^k + N)\)</span></span> operations by first computing the distinct functions and then copying the resulting values.</figcaption>
</figure>
<p>In our case, because there are at most <span><span class="math inline">\(2^{2^k}\)</span></span> distinct functions mapping <span><span class="math inline">\(\{0,1\}^k\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>, we can compute the function <span><span class="math inline">\(g\)</span></span> (and hence by <a href='#eqcomputefusinggeffcircuit'>Equation 4.5</a> also <span><span class="math inline">\(f\)</span></span>) using at most<br />
<span>
<div class='myequationbox'><span class="math display">\[O(2^{2^k} \cdot 2^k + 2^{n-k}) \;\;(4.7)\]</span><a id='eqboundoncostg'></a></div></span> operations. Now all that is left is to plug into <a href='#eqboundoncostg'>Equation 4.7</a> our choice of <span><span class="math inline">\(k = \log (n-2\log n)\)</span></span>. By definition, <span><span class="math inline">\(2^k = n-2\log n\)</span></span>, which means that <a href='#eqboundoncostg'>Equation 4.7</a> can be bounded <span>
<div class='myequationbox'><span class="math display">\[
O\left(2^{n-2\log n} \cdot (n-2\log n) +  2^{n-\log(n-2\log n)}\right) \leq
\]</span></div></span></p>
<p><span>
<div class='myequationbox'><span class="math display">\[
O\left(\tfrac{2^n}{n^2} \cdot n + \tfrac{2^n}{n-2\log n} \right)
\leq
O\left(\tfrac{2^n}{n}  + \tfrac{2^n}{0.5n} \right)  = O\left( \tfrac{2^n}{n} \right)
\]</span></div></span> which is what we wanted to prove. (We used above the fact that <span><span class="math inline">\(n - 2\log n \geq 0.5 \log n\)</span></span> for sufficiently large <span><span class="math inline">\(n\)</span></span>.)</p>
</div>
<p>Using the connection between NAND-CIRC programs and Boolean circuits, an immediate corollary of <a href='#NAND-univ-thm-improved'>Theorem 4.15</a> is the following improvement to <a href='#circuit-univ-thm'>Theorem 4.13</a>:</p>
<div id="circuit-univ-thm-improved" class="theorem" title="Universality of Boolean circuits,  improved bound" name="Theorem 4.16 (Universality of Boolean circuits,  improved bound) ">
<p>There exists some constant <span><span class="math inline">\(c&gt;0\)</span></span> such that for every <span><span class="math inline">\(n,m&gt;0\)</span></span> and function <span><span class="math inline">\(f: \{0,1\}^n\rightarrow \{0,1\}^m\)</span></span>, there is a Boolean circuit with at most <span><span class="math inline">\(c \cdot m 2^n / n\)</span></span> gates that computes the function <span><span class="math inline">\(f\)</span></span> .</p>
</div>
<h2 id="seccomputalternative" data-number="4.5">Computing every function: An alternative proof</h2>
<p><a href='#circuit-univ-thm'>Theorem 4.13</a> is a fundamental result in the theory (and practice!) of computation. In this section we present an alternative proof of this basic fact that Boolean circuits can compute every finite function. This alternative proof gives a somewhat worse quantitative bound on the number of gates but it has the advantage of being simpler, working directly with circuits and avoiding the usage of all the syntactic sugar machinery. (However, that machinery is useful in its own right, and will find other applications later on.)</p>
<div id="circuit-univ-alt-thm" class="theorem" title="Universality of Boolean circuits (alternative phrasing)" name="Theorem 4.17 (Universality of Boolean circuits (alternative phrasing)) ">
<p>There exists some constant <span><span class="math inline">\(c&gt;0\)</span></span> such that for every <span><span class="math inline">\(n,m&gt;0\)</span></span> and function <span><span class="math inline">\(f: \{0,1\}^n\rightarrow \{0,1\}^m\)</span></span>, there is a Boolean circuit with at most <span><span class="math inline">\(c \cdot m\cdot n 2^n\)</span></span> gates that computes the function <span><span class="math inline">\(f\)</span></span> .</p>
</div>
<figure>
<img src="../figure/computeallfunctionalt.png" alt="4.9: Given a function f:\{0,1\}^n \rightarrow \{0,1\}, we let \{ x_0, x_1, \ldots, x_{N-1} \} \subseteq \{0,1\}^n be the set of inputs such that f(x_i)=1, and note that N \leq 2^n. We can express f as the OR of \delta_{x_i} for i\in [N] where the function \delta_\alpha:\{0,1\}^n \rightarrow \{0,1\} (for \alpha \in \{0,1\}^n) is defined as follows: \delta_\alpha(x)=1 iff x=\alpha. We can compute the OR of N values using N two-input OR gates. Therefore if we have a circuit of size O(n) to compute \delta_\alpha for every \alpha \in \{0,1\}^n, we can compute f using a circuit of size O(n \cdot N) = O(n \cdot 2^n)." id="computeallfuncaltfig" /><figcaption>4.9: Given a function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>, we let <span><span class="math inline">\(\{ x_0, x_1, \ldots, x_{N-1} \} \subseteq \{0,1\}^n\)</span></span> be the set of inputs such that <span><span class="math inline">\(f(x_i)=1\)</span></span>, and note that <span><span class="math inline">\(N \leq 2^n\)</span></span>. We can express <span><span class="math inline">\(f\)</span></span> as the OR of <span><span class="math inline">\(\delta_{x_i}\)</span></span> for <span><span class="math inline">\(i\in [N]\)</span></span> where the function <span><span class="math inline">\(\delta_\alpha:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> (for <span><span class="math inline">\(\alpha \in \{0,1\}^n\)</span></span>) is defined as follows: <span><span class="math inline">\(\delta_\alpha(x)=1\)</span></span> iff <span><span class="math inline">\(x=\alpha\)</span></span>. We can compute the OR of <span><span class="math inline">\(N\)</span></span> values using <span><span class="math inline">\(N\)</span></span> two-input OR gates. Therefore if we have a circuit of size <span><span class="math inline">\(O(n)\)</span></span> to compute <span><span class="math inline">\(\delta_\alpha\)</span></span> for every <span><span class="math inline">\(\alpha \in \{0,1\}^n\)</span></span>, we can compute <span><span class="math inline">\(f\)</span></span> using a circuit of size <span><span class="math inline">\(O(n \cdot N) = O(n \cdot 2^n)\)</span></span>.</figcaption>
</figure>
<div id="section-3" class="proofidea" data-ref="circuit-univ-alt-thm" name="Proofidea">
<p>The idea of the proof is illustrated in <a href='#computeallfuncaltfig'>Figure 4.9</a>. As before, it is enough to focus on the case that <span><span class="math inline">\(m=1\)</span></span> (the function <span><span class="math inline">\(f\)</span></span> has a single output), since we can always extend this to the case of <span><span class="math inline">\(m&gt;1\)</span></span> by looking at the composition of <span><span class="math inline">\(m\)</span></span> circuits each computing a different output bit of the function <span><span class="math inline">\(f\)</span></span>. We start by showing that for every <span><span class="math inline">\(\alpha \in \{0,1\}^n\)</span></span>, there is an <span><span class="math inline">\(O(n)\)</span></span> sized circuit that computes the function <span><span class="math inline">\(\delta_\alpha:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> defined as follows: <span><span class="math inline">\(\delta_\alpha(x)=1\)</span></span> iff <span><span class="math inline">\(x=\alpha\)</span></span> (that is, <span><span class="math inline">\(\delta_\alpha\)</span></span> outputs <span><span class="math inline">\(0\)</span></span> on all inputs except the input <span><span class="math inline">\(\alpha\)</span></span>). We can then write any function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> as the OR of at most <span><span class="math inline">\(2^n\)</span></span> functions <span><span class="math inline">\(\delta_\alpha\)</span></span> for the <span><span class="math inline">\(\alpha\)</span></span>’s on which <span><span class="math inline">\(f(\alpha)=1\)</span></span>.</p>
</div>
<div class="proof" data-ref="circuit-univ-alt-thm" name="Proof 4.5">
<p>We prove the theorem for the case <span><span class="math inline">\(m=1\)</span></span>. The result can be extended for <span><span class="math inline">\(m&gt;1\)</span></span> as before (see also <a href='#mult-bit-ex'>Exercise 4.9</a>). Let <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>. We will prove that there is an <span><span class="math inline">\(O(n\cdot 2^n)\)</span></span>-sized Boolean circuit to compute <span><span class="math inline">\(f\)</span></span> in the following steps:</p>
<ol type="1">
<li><p>We show that for every <span><span class="math inline">\(\alpha\in \{0,1\}^n\)</span></span>, there is an <span><span class="math inline">\(O(n)\)</span></span> sized circuit that computes the function <span><span class="math inline">\(\delta_\alpha:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>, where <span><span class="math inline">\(\delta_\alpha(x)=1\)</span></span> iff <span><span class="math inline">\(x=\alpha\)</span></span>.</p></li>
<li><p>We then show that this implies the existence of an <span><span class="math inline">\(O(n\cdot 2^n)\)</span></span>-sized circuit that computes <span><span class="math inline">\(f\)</span></span>, by writing <span><span class="math inline">\(f(x)\)</span></span> as the OR of <span><span class="math inline">\(\delta_\alpha(x)\)</span></span> for all <span><span class="math inline">\(\alpha\in \{0,1\}^n\)</span></span> such that <span><span class="math inline">\(f(\alpha)=1\)</span></span>.</p></li>
</ol>
<p>We start with Step 1:</p>
<p><strong>CLAIM:</strong> For <span><span class="math inline">\(\alpha \in \{0,1\}^n\)</span></span>, define <span><span class="math inline">\(\delta_\alpha:\{0,1\}^n\)</span></span> as follows: <span>
<div class='myequationbox'><span class="math display">\[
\delta_\alpha(x) = \begin{cases}1 &amp; x=\alpha \\ 0 &amp; \text{otherwise} \end{cases} \;.
\]</span></div></span> then there is a Boolean circuit using at most <span><span class="math inline">\(2n\)</span></span> gates that computes <span><span class="math inline">\(\delta_\alpha\)</span></span>.</p>
<p><strong>PROOF OF CLAIM:</strong> The proof is illustrated in <a href='#deltafuncfig'>Figure 4.10</a>. As an example, consider the function <span><span class="math inline">\(\delta_{011}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span>. This function outputs <span><span class="math inline">\(1\)</span></span> on <span><span class="math inline">\(x\)</span></span> if and only if <span><span class="math inline">\(x_0=0\)</span></span>, <span><span class="math inline">\(x_1=1\)</span></span> and <span><span class="math inline">\(x_2=1\)</span></span>, and so we can write <span><span class="math inline">\(\delta_{011}(x) = \overline{x_0} \wedge x_1 \wedge x_2\)</span></span>, which translates into a Boolean circuit with one NOT gate and two AND gates. More generally, for every <span><span class="math inline">\(\alpha \in \{0,1\}^n\)</span></span>, we can express <span><span class="math inline">\(\delta_{\alpha}(x)\)</span></span> as <span><span class="math inline">\((x_0 = \alpha_0) \wedge (x_1 = \alpha_1) \wedge \cdots \wedge (x_{n-1} = \alpha_{n-1})\)</span></span>, where if <span><span class="math inline">\(\alpha_i=0\)</span></span> we replace <span><span class="math inline">\(x_i = \alpha_i\)</span></span> with <span><span class="math inline">\(\overline{x_i}\)</span></span> and if <span><span class="math inline">\(\alpha_i=1\)</span></span> we replace <span><span class="math inline">\(x_i=\alpha_i\)</span></span> by simply <span><span class="math inline">\(x_i\)</span></span>. This yields a circuit that computes <span><span class="math inline">\(\delta_\alpha\)</span></span> using <span><span class="math inline">\(n\)</span></span> AND gates and at most <span><span class="math inline">\(n\)</span></span> NOT gates, so a total of at most <span><span class="math inline">\(2n\)</span></span> gates.</p>
<p>Now for every function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>, we can write</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
f(x) = \delta_{x_0}(x) \vee \delta_{x_1}(x) \vee \cdots \vee \delta_{x_{N-1}}(x) \;\;(4.11)
\]</span><a id='eqorofdeltafunc'></a></div></span></p>
<p>where <span><span class="math inline">\(S=\{ x_0 ,\ldots, x_{N-1}\}\)</span></span> is the set of inputs on which <span><span class="math inline">\(f\)</span></span> outputs <span><span class="math inline">\(1\)</span></span>. (To see this, you can verify that the right-hand side of <a href='#eqorofdeltafunc'>Equation 4.11</a> evaluates to <span><span class="math inline">\(1\)</span></span> on <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> if and only if <span><span class="math inline">\(x\)</span></span> is in the set <span><span class="math inline">\(S\)</span></span>.)</p>
<p>Therefore we can compute <span><span class="math inline">\(f\)</span></span> using a Boolean circuit of at most <span><span class="math inline">\(2n\)</span></span> gates for each of the <span><span class="math inline">\(N\)</span></span> functions <span><span class="math inline">\(\delta_{x_i}\)</span></span> and combine that with at most <span><span class="math inline">\(N\)</span></span> OR gates, thus obtaining a circuit of at most <span><span class="math inline">\(2n\cdot N + N\)</span></span> gates. Since <span><span class="math inline">\(S \subseteq \{0,1\}^n\)</span></span>, its size <span><span class="math inline">\(N\)</span></span> is at most <span><span class="math inline">\(2^n\)</span></span> and hence the total number of gates in this circuit is <span><span class="math inline">\(O(n\cdot 2^n)\)</span></span>.</p>
</div>
<figure>
<img src="../figure/deltafunc.png" alt="4.10: For every string \alpha\in \{0,1\}^n, there is a Boolean circuit of O(n) gates to compute the function \delta_\alpha:\{0,1\}^n \rightarrow \{0,1\} such that \delta_\alpha(x)=1 if and only if x=\alpha. The circuit is very simple. Given input x_0,\ldots,x_{n-1} we compute the AND of z_0,\ldots,z_{n-1} where z_i=x_i if \alpha_i=1 and z_i = \ensuremath{\mathit{NOT}}(x_i) if \alpha_i=0. While formally Boolean circuits only have a gate for computing the AND of two inputs, we can implement an AND of n inputs by composing n two-input ANDs." id="deltafuncfig" class="margin" /><figcaption>4.10: For every string <span><span class="math inline">\(\alpha\in \{0,1\}^n\)</span></span>, there is a Boolean circuit of <span><span class="math inline">\(O(n)\)</span></span> gates to compute the function <span><span class="math inline">\(\delta_\alpha:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(\delta_\alpha(x)=1\)</span></span> if and only if <span><span class="math inline">\(x=\alpha\)</span></span>. The circuit is very simple. Given input <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span> we compute the AND of <span><span class="math inline">\(z_0,\ldots,z_{n-1}\)</span></span> where <span><span class="math inline">\(z_i=x_i\)</span></span> if <span><span class="math inline">\(\alpha_i=1\)</span></span> and <span><span class="math inline">\(z_i = \ensuremath{\mathit{NOT}}(x_i)\)</span></span> if <span><span class="math inline">\(\alpha_i=0\)</span></span>. While formally Boolean circuits only have a gate for computing the AND of two inputs, we can implement an AND of <span><span class="math inline">\(n\)</span></span> inputs by composing <span><span class="math inline">\(n\)</span></span> two-input ANDs.</figcaption>
</figure>
<h2 id="secdefinesizeclasses" data-number="4.6">The class <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}(T)\)</span></span></h2>
<p>We have seen that <em>every</em> function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> can be computed by a circuit of size <span><span class="math inline">\(O(m\cdot 2^n)\)</span></span>, and <em>some</em> functions (such as addition and multiplication) can be computed by much smaller circuits. We define <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}(s)\)</span></span> to be the set of functions that can be computed by NAND circuits of at most <span><span class="math inline">\(s\)</span></span> gates (or equivalently, by NAND-CIRC programs of at most <span><span class="math inline">\(s\)</span></span> lines). Formally, the definition is as follows:</p>
<div id="sizedef" class="definition" title="Size class of functions" name="Definition 4.18 (Size class of functions) ">
<p>For every <span><span class="math inline">\(n,m \in \{ 1, \ldots , 2s\}\)</span></span>, we let set <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,m}(s)\)</span></span> denotes the set of all functions <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> such that <span><span class="math inline">\(f\in \ensuremath{\mathit{SIZE}}(s)\)</span></span>.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> We denote by <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_n(s)\)</span></span> the set <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,1}(s)\)</span></span>. For every integer <span><span class="math inline">\(s \geq 1\)</span></span>, we let <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}(s) = \cup_{n,m \leq 2s} \ensuremath{\mathit{SIZE}}_{n,m}(s)\)</span></span> be the set of all functions <span><span class="math inline">\(f\)</span></span> for which there exists a NAND circuit of at most <span><span class="math inline">\(s\)</span></span> gates that compute <span><span class="math inline">\(f\)</span></span>.</p>
</div>
<p><a href='#funcvscircfig'>Figure 4.11</a> depicts the sets <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,1}(s)\)</span></span>. Note that <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,m}(s)\)</span></span> is a set of <em>functions</em>, not of <em>programs!</em> (asking if a program or a circuit is a member of <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,m}(s)\)</span></span> is a <em>category error</em> as in the sense of <a href='#cucumberfig'>Figure 4.12</a>). As we discussed in <a href='lec_03_computation.html#specvsimplrem'>Subsection 3.6.2</a> (and <a href='lec_02_representation.html#secimplvsspec'>Subsection 2.5.1</a>), the distinction between <em>programs</em> and <em>functions</em> is absolutely crucial. You should always remember that while a program <em>computes</em> a function, it is not <em>equal</em> to a function. In particular, as we’ve seen, there can be more than one program to compute the same function.</p>
<figure>
<img src="../figure/funcvscircs.png" alt="4.11: There are 2^{2^n} functions mapping \{0,1\}^n to \{0,1\}, and an infinite number of circuits with n bit inputs and a single bit of output. Every circuit computes one function, but every function can be computed by many circuits. We say that f \in \ensuremath{\mathit{SIZE}}_{n,1}(s) if the smallest circuit that computes f has s or fewer gates. For example \ensuremath{\mathit{XOR}}_n \in \ensuremath{\mathit{SIZE}}_{n,1}(4n).  shows that every function g is computable by some circuit of at most c\cdot 2^n/n gates, and hence \ensuremath{\mathit{SIZE}}_{n,1}(c\cdot 2^n/n) corresponds to the set of all functions from \{0,1\}^n to \{0,1\}." id="funcvscircfig" class="class" /><figcaption>4.11: There are <span><span class="math inline">\(2^{2^n}\)</span></span> functions mapping <span><span class="math inline">\(\{0,1\}^n\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>, and an infinite number of circuits with <span><span class="math inline">\(n\)</span></span> bit inputs and a single bit of output. Every circuit computes one function, but every function can be computed by many circuits. We say that <span><span class="math inline">\(f \in \ensuremath{\mathit{SIZE}}_{n,1}(s)\)</span></span> if the smallest circuit that computes <span><span class="math inline">\(f\)</span></span> has <span><span class="math inline">\(s\)</span></span> or fewer gates. For example <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_n \in \ensuremath{\mathit{SIZE}}_{n,1}(4n)\)</span></span>. <a href='#NAND-univ-thm'>Theorem 4.12</a> shows that <em>every</em> function <span><span class="math inline">\(g\)</span></span> is computable by some circuit of at most <span><span class="math inline">\(c\cdot 2^n/n\)</span></span> gates, and hence <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,1}(c\cdot 2^n/n)\)</span></span> corresponds to the set of <em>all</em> functions from <span><span class="math inline">\(\{0,1\}^n\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>.</figcaption>
</figure>
<p>While we defined <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}(s)\)</span></span> with respect to NAND gates, we would get essentially the same class if we defined it with respect to AND/OR/NOT gates:</p>
<div id="nandaonsizelem" class="lemma" name="Lemma 4.19">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}^{AON}_{n,m}(s)\)</span></span> denote the set of all functions <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> that can be computed by an AND/OR/NOT Boolean circuit of at most <span><span class="math inline">\(s\)</span></span> gates. Then, <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{SIZE}}_{n,m}(s/2) \subseteq \ensuremath{\mathit{SIZE}}^{AON}_{n,m}(s) \subseteq \ensuremath{\mathit{SIZE}}_{n,m}(3s)
\]</span></div></span></p>
</div>
<div class="proof" data-ref="nandaonsizelem" name="Proof 4.6">
<p>If <span><span class="math inline">\(f\)</span></span> can be computed by a NAND circuit of at most <span><span class="math inline">\(s/2\)</span></span> gates, then by replacing each NAND with the two gates NOT and AND, we can obtain an AND/OR/NOT Boolean circuit of at most <span><span class="math inline">\(s\)</span></span> gates that computes <span><span class="math inline">\(f\)</span></span>. On the other hand, if <span><span class="math inline">\(f\)</span></span> can be computed by a Boolean AND/OR/NOT circuit of at most <span><span class="math inline">\(s\)</span></span> gates, then by <a href='lec_03_computation.html#NANDuniversamthm'>Theorem 3.12</a> it can be computed by a NAND circuit of at most <span><span class="math inline">\(3s\)</span></span> gates.</p>
</div>
<figure>
<img src="../figure/cucumber.png" alt="4.12: A “category error” is a question such as “is a cucumber even or odd?” which does not even make sense. In this book one type of category error you should watch out for is confusing functions and programs (i.e., confusing specifications and implementations). If C is a circuit or program, then asking if C \in \ensuremath{\mathit{SIZE}}_{n,1}(s) is a category error, since \ensuremath{\mathit{SIZE}}_{n,1}(s) is a set of functions and not programs or circuits." id="cucumberfig" class="margin" /><figcaption>4.12: A “category error” is a question such as “is a cucumber even or odd?” which does not even make sense. In this book one type of category error you should watch out for is confusing <em>functions</em> and <em>programs</em> (i.e., confusing <em>specifications</em> and <em>implementations</em>). If <span><span class="math inline">\(C\)</span></span> is a circuit or program, then asking if <span><span class="math inline">\(C \in \ensuremath{\mathit{SIZE}}_{n,1}(s)\)</span></span> is a category error, since <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,1}(s)\)</span></span> is a set of <em>functions</em> and not programs or circuits.</figcaption>
</figure>
<p>The results we have seen in this chapter can be phrased as showing that <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n \in \ensuremath{\mathit{SIZE}}_{2n,n+1}(100 n)\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n \in \ensuremath{\mathit{SIZE}}_{2n,2n}(10000 n^{\log_2 3})\)</span></span>. <a href='#NAND-univ-thm'>Theorem 4.12</a> shows that for some constant <span><span class="math inline">\(c\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_{n,m}(c m 2^n)\)</span></span> is equal to the set of all functions from <span><span class="math inline">\(\{0,1\}^n\)</span></span> to <span><span class="math inline">\(\{0,1\}^m\)</span></span>.</p>
<div id="infinitefunc" class="remark" title="Finite vs infinite functions" name="Remark 4.20 (Finite vs infinite functions) ">
<p>A NAND-CIRC program <span><span class="math inline">\(P\)</span></span> can only compute a function with a certain number <span><span class="math inline">\(n\)</span></span> of inputs and a certain number <span><span class="math inline">\(m\)</span></span> of outputs. Hence, for example, there is no single NAND-CIRC program that can compute the increment function <span><span class="math inline">\(\ensuremath{\mathit{INC}}:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> that maps a string <span><span class="math inline">\(x\)</span></span> (which we identify with a number via the binary representation) to the string that represents <span><span class="math inline">\(x+1\)</span></span>. Rather for every <span><span class="math inline">\(n&gt;0\)</span></span>, there is a NAND-CIRC program <span><span class="math inline">\(P_n\)</span></span> that computes the restriction <span><span class="math inline">\(\ensuremath{\mathit{INC}}_n\)</span></span> of the function <span><span class="math inline">\(\ensuremath{\mathit{INC}}\)</span></span> to inputs of length <span><span class="math inline">\(n\)</span></span>. Since it can be shown that for every <span><span class="math inline">\(n&gt;0\)</span></span> such a program <span><span class="math inline">\(P_n\)</span></span> exists of length at most <span><span class="math inline">\(10n\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{INC}}_n \in \ensuremath{\mathit{SIZE}}(10n)\)</span></span> for every <span><span class="math inline">\(n&gt;0\)</span></span>.</p>
<p>If <span><span class="math inline">\(T:\N \rightarrow \N\)</span></span> and <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span>, we will write <span><span class="math inline">\(F \in \ensuremath{\mathit{SIZE}}_{*}(T(n))\)</span></span> (or sometimes slightly abuse notation and write simply <span><span class="math inline">\(F \in \ensuremath{\mathit{SIZE}}(T(n))\)</span></span>) to indicate that for every <span><span class="math inline">\(n\)</span></span> the restriction <span><span class="math inline">\(F_{\upharpoonright n}\)</span></span> of <span><span class="math inline">\(F\)</span></span> to inputs in <span><span class="math inline">\(\{0,1\}^n\)</span></span> is in <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}(T(n))\)</span></span>. Hence we can write <span><span class="math inline">\(\ensuremath{\mathit{INC}} \in \ensuremath{\mathit{SIZE}}_*(10n)\)</span></span>. We will come back to this issue of finite vs infinite functions later in this course.</p>
</div>
<div id="sizeclosundercomp" class="solvedexercise" title="$SIZE$ closed under complement." name="Solvedexercise 4.1 ($SIZE$ closed under complement.) ">
<p>In this exercise we prove a certain “closure property” of the class <span><span class="math inline">\(\ensuremath{\mathit{SIZE}}_n(s)\)</span></span>. That is, we show that if <span><span class="math inline">\(f\)</span></span> is in this class then (up to some small additive term) so is the complement of <span><span class="math inline">\(f\)</span></span>, which is the function <span><span class="math inline">\(g(x)=1-f(x)\)</span></span>.</p>
<p>Prove that there is a constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> and <span><span class="math inline">\(s\in \N\)</span></span>, if <span><span class="math inline">\(f \in \ensuremath{\mathit{SIZE}}_n(s)\)</span></span> then <span><span class="math inline">\(1-f \in \ensuremath{\mathit{SIZE}}_n(s+c)\)</span></span>.</p>
</div>
<div class="solution" data-ref="sizeclosundercomp" name="Solution 4.6">
<p>If <span><span class="math inline">\(f\in \ensuremath{\mathit{SIZE}}(s)\)</span></span> then there is an <span><span class="math inline">\(s\)</span></span>-line NAND-CIRC program <span><span class="math inline">\(P\)</span></span> that computes <span><span class="math inline">\(f\)</span></span>. We can rename the variable <code>Y[0]</code> in <span><span class="math inline">\(P\)</span></span> to a variable <code>temp</code> and add the line</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1">Y[<span class="dv">0</span>] <span class="op">=</span> NAND(temp,temp)</a></code></pre></div>
<p>at the very end to obtain a program <span><span class="math inline">\(P&#39;\)</span></span> that computes <span><span class="math inline">\(1-f\)</span></span>.</p>
</div>
<div id="section-4" class="recap" name="Recap">
<ul>
<li>We can define the notion of computing a function via a simplified “programming language”, where computing a function <span><span class="math inline">\(F\)</span></span> in <span><span class="math inline">\(T\)</span></span> steps would correspond to having a <span><span class="math inline">\(T\)</span></span>-line NAND-CIRC program that computes <span><span class="math inline">\(F\)</span></span>.</li>
<li>While the NAND-CIRC programming only has one operation, other operations such as functions and conditional execution can be implemented using it.</li>
<li>Every function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> can be computed by a circuit of at most <span><span class="math inline">\(O(m 2^n)\)</span></span> gates (and in fact at most <span><span class="math inline">\(O(m 2^n/n)\)</span></span> gates).</li>
<li>Sometimes (or maybe always?) we can translate an <em>efficient</em> algorithm to compute <span><span class="math inline">\(f\)</span></span> into a circuit that computes <span><span class="math inline">\(f\)</span></span> with a number of gates comparable to the number of steps in this algorithm.</li>
</ul>
</div>
<h2 id="exercises" data-number="4.7">Exercises</h2>
<div id="embedtuples-ex" class="exercise" title="Pairing" name="Exercise 4.1 (Pairing) ">
<p>This exercise asks you to give a one-to-one map from <span><span class="math inline">\(\N^2\)</span></span> to <span><span class="math inline">\(\N\)</span></span>. This can be useful to implement two-dimensional arrays as “syntactic sugar” in programming languages that only have one-dimensional array.</p>
<ol type="1">
<li><p>Prove that the map <span><span class="math inline">\(F(x,y)=2^x3^y\)</span></span> is a one-to-one map from <span><span class="math inline">\(\N^2\)</span></span> to <span><span class="math inline">\(\N\)</span></span>.</p></li>
<li><p>Show that there is a one-to-one map <span><span class="math inline">\(F:\N^2 \rightarrow \N\)</span></span> such that for every <span><span class="math inline">\(x,y\)</span></span>, <span><span class="math inline">\(F(x,y) \leq 100\cdot \max\{x,y\}^2+100\)</span></span>.</p></li>
<li><p>For every <span><span class="math inline">\(k\)</span></span>, show that there is a one-to-one map <span><span class="math inline">\(F:\N^k \rightarrow \N\)</span></span> such that for every <span><span class="math inline">\(x_0,\ldots,x_{k-1} \in \N\)</span></span>, <span><span class="math inline">\(F(x_0,\ldots,x_{k-1}) \leq 100 \cdot (x_0+x_1+\ldots+x_{k-1}+100k)^k\)</span></span>.</p></li>
</ol>
</div>
<div id="mux-ex" class="exercise" title="Computing MUX" name="Exercise 4.2 (Computing MUX) ">
<p>Prove that the NAND-CIRC program below computes the function <span><span class="math inline">\(\ensuremath{\mathit{MUX}}\)</span></span> (or <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_1\)</span></span>) where <span><span class="math inline">\(\ensuremath{\mathit{MUX}}(a,b,c)\)</span></span> equals <span><span class="math inline">\(a\)</span></span> if <span><span class="math inline">\(c=0\)</span></span> and equals <span><span class="math inline">\(b\)</span></span> if <span><span class="math inline">\(c=1\)</span></span>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1">t <span class="op">=</span> NAND(X[<span class="dv">2</span>],X[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb16-2" title="2">u <span class="op">=</span> NAND(X[<span class="dv">0</span>],t)</a>
<a class="sourceLine" id="cb16-3" title="3">v <span class="op">=</span> NAND(X[<span class="dv">1</span>],X[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb16-4" title="4">Y[<span class="dv">0</span>] <span class="op">=</span> NAND(u,v)</a></code></pre></div>
</div>
<div id="atleasttwo-ex" class="exercise" title="At least two / Majority" name="Exercise 4.3 (At least two / Majority) ">
<p>Give a NAND-CIRC program of at most 6 lines to compute the function <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> where <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(a,b,c) = 1\)</span></span> iff <span><span class="math inline">\(a+b+c \geq 2\)</span></span>.</p>
</div>
<div id="conditionalsugarthmex" class="exercise" title="Conditional statements" name="Exercise 4.4 (Conditional statements) ">
<p>In this exercise we will explore <a href='#conditionalsugarthm'>Theorem 4.6</a>: transforming NAND-CIRC-IF programs that use code such as <code>if .. then .. else ..</code> to standard NAND-CIRC programs.</p>
<ol type="1">
<li><p>Give a “proof by code” of <a href='#conditionalsugarthm'>Theorem 4.6</a>: a program in a programming language of your choice that transforms a NAND-CIRC-IF program <span><span class="math inline">\(P\)</span></span> into a “sugar free” NAND-CIRC program <span><span class="math inline">\(P&#39;\)</span></span> that computes the same function. See footnote for hint.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p></li>
<li><p>Prove the following statement, which is the heart of <a href='#conditionalsugarthm'>Theorem 4.6</a>: suppose that there exists an <span><span class="math inline">\(s\)</span></span>-line NAND-CIRC program to compute <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> and an <span><span class="math inline">\(s&#39;\)</span></span>-line NAND-CIRC program to compute <span><span class="math inline">\(g:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>. Prove that there exist a NAND-CIRC program of at most <span><span class="math inline">\(s+s&#39;+10\)</span></span> lines to compute the function <span><span class="math inline">\(h:\{0,1\}^{n+1} \rightarrow \{0,1\}\)</span></span> where <span><span class="math inline">\(h(x_0,\ldots,x_{n-1},x_n)\)</span></span> equals <span><span class="math inline">\(f(x_0,\ldots,x_{n-1})\)</span></span> if <span><span class="math inline">\(x_n=0\)</span></span> and equals <span><span class="math inline">\(g(x_0,\ldots,x_{n-1})\)</span></span> otherwise. (All programs in this item are standard “sugar-free” NAND-CIRC programs.)</p></li>
</ol>
</div>
<div id="halffulladderex" class="exercise" title="Half and full adders" name="Exercise 4.5 (Half and full adders) ">
<ol type="1">
<li><p>A <em>half adder</em> is the function <span><span class="math inline">\(\ensuremath{\mathit{HA}}:\{0,1\}^2 :\rightarrow \{0,1\}^2\)</span></span> that corresponds to adding two binary bits. That is, for every <span><span class="math inline">\(a,b \in \{0,1\}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{HA}}(a,b)= (e,f)\)</span></span> where <span><span class="math inline">\(2e+f = a+b\)</span></span>. Prove that there is a NAND circuit of at most five NAND gates that computes <span><span class="math inline">\(\ensuremath{\mathit{HA}}\)</span></span>.</p></li>
<li><p>A <em>full adder</em> is the function <span><span class="math inline">\(\ensuremath{\mathit{FA}}:\{0,1\}^3 \rightarrow \{0,1\}^{2}\)</span></span> that takes in two bits and a “carry” bit and outputs their sum. That is, for every <span><span class="math inline">\(a,b,c \in \{0,1\}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{FA}}(a,b,c) = (e,f)\)</span></span> such that <span><span class="math inline">\(2e+f = a+b+c\)</span></span>. Prove that there is a NAND circuit of at most nine NAND gates that computes <span><span class="math inline">\(\ensuremath{\mathit{FA}}\)</span></span>.</p></li>
<li><p>Prove that if there is a NAND circuit of <span><span class="math inline">\(c\)</span></span> gates that computes <span><span class="math inline">\(\ensuremath{\mathit{FA}}\)</span></span>, then there is a circuit of <span><span class="math inline">\(cn\)</span></span> gates that computes <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n\)</span></span> where (as in <a href='#addition-thm'>Theorem 4.7</a>) <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n:\{0,1\}^{2n} \rightarrow \{0,1\}^{n+1}\)</span></span> is the function that outputs the addition of two input <span><span class="math inline">\(n\)</span></span>-bit numbers. See footnote for hint.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p></li>
<li><p>Show that for every <span><span class="math inline">\(n\)</span></span> there is a NAND-CIRC program to compute <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n\)</span></span> with at most <span><span class="math inline">\(9n\)</span></span> lines.</p></li>
</ol>
</div>
<div id="addition-ex" class="exercise" title="Addition" name="Exercise 4.6 (Addition) ">
<p>Write a program using your favorite programming language that on input of an integer <span><span class="math inline">\(n\)</span></span>, outputs a NAND-CIRC program that computes <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n\)</span></span>. Can you ensure that the program it outputs for <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n\)</span></span> has fewer than <span><span class="math inline">\(10n\)</span></span> lines?</p>
</div>
<div id="multiplication-ex" class="exercise" title="Multiplication" name="Exercise 4.7 (Multiplication) ">
<p>Write a program using your favorite programming language that on input of an integer <span><span class="math inline">\(n\)</span></span>, outputs a NAND-CIRC program that computes <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n\)</span></span>. Can you ensure that the program it outputs for <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n\)</span></span> has fewer than <span><span class="math inline">\(1000\cdot n^2\)</span></span> lines?</p>
</div>
<div id="eff-multiplication-ex" class="exercise" title="Efficient multiplication (challenge)" name="Exercise 4.8 (Efficient multiplication (challenge)) ">
<p>Write a program using your favorite programming language that on input of an integer <span><span class="math inline">\(n\)</span></span>, outputs a NAND-CIRC program that computes <span><span class="math inline">\(\ensuremath{\mathit{MULT}}_n\)</span></span> and has at most <span><span class="math inline">\(10000 n^{1.9}\)</span></span> lines.<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> What is the smallest number of lines you can use to multiply two 2048 bit numbers?</p>
</div>
<div id="mult-bit-ex" class="exercise" title="Multibit function" name="Exercise 4.9 (Multibit function) ">
<p>In the text <a href='#NAND-univ-thm'>Theorem 4.12</a> is only proven for the case <span><span class="math inline">\(m=1\)</span></span>. In this exercise you will extend the proof for every <span><span class="math inline">\(m\)</span></span>.</p>
<p>Prove that</p>
<ol type="1">
<li><p>If there is an <span><span class="math inline">\(s\)</span></span>-line NAND-CIRC program to compute <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> and an <span><span class="math inline">\(s&#39;\)</span></span>-line NAND-CIRC program to compute <span><span class="math inline">\(f&#39;:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> then there is an <span><span class="math inline">\(s+s&#39;\)</span></span>-line program to compute the function <span><span class="math inline">\(g:\{0,1\}^n \rightarrow \{0,1\}^2\)</span></span> such that <span><span class="math inline">\(g(x)=(f(x),f&#39;(x))\)</span></span>.</p></li>
<li><p>For every function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span>, there is a NAND-CIRC program of at most <span><span class="math inline">\(10m\cdot 2^n\)</span></span> lines that computes <span><span class="math inline">\(f\)</span></span>. (You can use the <span><span class="math inline">\(m=1\)</span></span> case of <a href='#NAND-univ-thm'>Theorem 4.12</a>, as well as Item 1.)</p></li>
</ol>
</div>
<div id="usesugarex" class="exercise" title="Simplifying using syntactic sugar" name="Exercise 4.10 (Simplifying using syntactic sugar) ">
<p>Let <span><span class="math inline">\(P\)</span></span> be the following NAND-CIRC program:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1">Temp[<span class="dv">0</span>] <span class="op">=</span> NAND(X[<span class="dv">0</span>],X[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb17-2" title="2">Temp[<span class="dv">1</span>] <span class="op">=</span> NAND(X[<span class="dv">1</span>],X[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb17-3" title="3">Temp[<span class="dv">2</span>] <span class="op">=</span> NAND(Temp[<span class="dv">0</span>],Temp[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb17-4" title="4">Temp[<span class="dv">3</span>] <span class="op">=</span> NAND(X[<span class="dv">2</span>],X[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb17-5" title="5">Temp[<span class="dv">4</span>] <span class="op">=</span> NAND(X[<span class="dv">3</span>],X[<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb17-6" title="6">Temp[<span class="dv">5</span>] <span class="op">=</span> NAND(Temp[<span class="dv">3</span>],Temp[<span class="dv">4</span>])</a>
<a class="sourceLine" id="cb17-7" title="7">Temp[<span class="dv">6</span>] <span class="op">=</span> NAND(Temp[<span class="dv">2</span>],Temp[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb17-8" title="8">Temp[<span class="dv">7</span>] <span class="op">=</span> NAND(Temp[<span class="dv">5</span>],Temp[<span class="dv">5</span>])</a>
<a class="sourceLine" id="cb17-9" title="9">Y[<span class="dv">0</span>] <span class="op">=</span> NAND(Temp[<span class="dv">6</span>],Temp[<span class="dv">7</span>])</a></code></pre></div>
<ol type="1">
<li><p>Write a program <span><span class="math inline">\(P&#39;\)</span></span> with at most three lines of code that uses both <code>NAND</code> as well as the syntactic sugar <code>OR</code> that computes the same function as <span><span class="math inline">\(P\)</span></span>.</p></li>
<li><p>Draw a circuit that computes the same function as <span><span class="math inline">\(P\)</span></span> and uses only <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> gates.</p></li>
</ol>
</div>
<p>In the following exercises you are asked to compare the <em>power</em> of pairs programming languages. By “comparing the power” of two programming languages <span><span class="math inline">\(X\)</span></span> and <span><span class="math inline">\(Y\)</span></span> we mean determining the relation between the set of functions that are computable using programs in <span><span class="math inline">\(X\)</span></span> and <span><span class="math inline">\(Y\)</span></span> respectively. That is, to answer such a question you need to do both of the following:</p>
<ol type="1">
<li>Either prove that for every program <span><span class="math inline">\(P\)</span></span> in <span><span class="math inline">\(X\)</span></span> there is a program <span><span class="math inline">\(P&#39;\)</span></span> in <span><span class="math inline">\(Y\)</span></span> that computes the same function as <span><span class="math inline">\(P\)</span></span>, <em>or</em> give an example for a function that is computable by an <span><span class="math inline">\(X\)</span></span>-program but not computable by a <span><span class="math inline">\(Y\)</span></span>-program.</li>
</ol>
<p><em>and</em></p>
<ol type="1">
<li>Either prove that for every program <span><span class="math inline">\(P\)</span></span> in <span><span class="math inline">\(Y\)</span></span> there is a program <span><span class="math inline">\(P&#39;\)</span></span> in <span><span class="math inline">\(X\)</span></span> that computes the same function as <span><span class="math inline">\(P\)</span></span>, <em>or</em> give an example for a function that is computable by a <span><span class="math inline">\(Y\)</span></span>-program but not computable by an <span><span class="math inline">\(X\)</span></span>-program.</li>
</ol>
<p>When you give an example as above of a function that is computable in one programming language but not the other, you need to <em>prove</em> that the function you showed is <em>(1)</em> computable in the first programming language and <em>(2)</em> <em>not computable</em> in the second programming language.</p>
<div id="compareif" class="exercise" title="Compare IF and NAND" name="Exercise 4.11 (Compare IF and NAND) ">
<p>Let IF-CIRC be the programming language where we have the following operations <code>foo = 0</code>, <code>foo = 1</code>, <code>foo = IF(cond,yes,no)</code> (that is, we can use the constants <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span>, and the <span><span class="math inline">\(\ensuremath{\mathit{IF}}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> function such that <span><span class="math inline">\(\ensuremath{\mathit{IF}}(a,b,c)\)</span></span> equals <span><span class="math inline">\(b\)</span></span> if <span><span class="math inline">\(a=1\)</span></span> and equals <span><span class="math inline">\(c\)</span></span> if <span><span class="math inline">\(a=0\)</span></span>). Compare the power of the NAND-CIRC programming language and the IF-CIRC programming language.</p>
</div>
<div id="comparexor" class="exercise" title="Compare XOR and NAND" name="Exercise 4.12 (Compare XOR and NAND) ">
<p>Let XOR-CIRC be the programming language where we have the following operations <code>foo = XOR(bar,blah)</code>, <code>foo = 1</code> and <code>bar = 0</code> (that is, we can use the constants <span><span class="math inline">\(0\)</span></span>, <span><span class="math inline">\(1\)</span></span> and the <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> function that maps <span><span class="math inline">\(a,b \in \{0,1\}^2\)</span></span> to <span><span class="math inline">\(a+b \mod 2\)</span></span>). Compare the power of the NAND-CIRC programming language and the XOR-CIRC programming language. See footnote for hint.<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup></p>
</div>
<div id="majasymp" class="exercise" title="Circuits for majority" name="Exercise 4.13 (Circuits for majority) ">
<p>Prove that there is some constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(n&gt;1\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_n \in Size(cn)\)</span></span> where <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_n:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> is the majority function on <span><span class="math inline">\(n\)</span></span> input bits. That is <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_n(x)=1\)</span></span> iff <span><span class="math inline">\(\sum_{i=0}^{n-1}x_i &gt; n/2\)</span></span>. See footnote for hint.<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup></p>
</div>
<div id="thresholdcirc" class="exercise" title="Circuits for threshold" name="Exercise 4.14 (Circuits for threshold) ">
<p>Prove that there is some constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(n&gt;1\)</span></span>, and integers <span><span class="math inline">\(a_0,\ldots,a_{n-1},b \in \{-2^n,-2^n+1,\ldots,-1,0,+1,\ldots,2^n\}\)</span></span>, there is a NAND circuit with at most <span><span class="math inline">\(n^c\)</span></span> gates that computes the <em>threshold</em> function <span><span class="math inline">\(f_{a_0,\ldots,a_{n-1},b}:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> that on input <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(\sum_{i=0}^{n-1} a_i x_i &gt; b\)</span></span>.</p>
</div>
<h2 id="computeeveryfunctionbibnotes" data-number="4.8">Bibliographical notes</h2>
<p>See Jukna’s and Wegener’s books  (<a href="https://scholar.google.com/scholar?hl=en&q=Jukna+Boolean+function+complexity:+advances+and+frontiers" target="_blank">Jukna, 2012</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=Wegener+The+complexity+of+Boolean+functions" target="_blank">Wegener, 1987</a>)  for much more extensive discussion on circuits. Shannon showed that every Boolean function can be computed by a circuit of exponential size  (<a href="https://scholar.google.com/scholar?hl=en&q=Shannon+A+symbolic+analysis+of+relay+and+switching+circuits" target="_blank">Shannon, 1938</a>) . The improved bound of <span><span class="math inline">\(c \cdot 2^n/n\)</span></span> (with the optimal value of <span><span class="math inline">\(c\)</span></span> for many bases) is due to Lupanov  (<a href="https://scholar.google.com/scholar?hl=en&q=Lupanov+A+circuit+synthesis+method" target="_blank">Lupanov, 1958</a>) . An exposition of this for the case of NAND (where <span><span class="math inline">\(c=1\)</span></span>) is given in Chapter 4 of his book  (<a href="https://scholar.google.com/scholar?hl=en&q=Lupanov+Asymptotic+complexity+bounds+for+control+circuits" target="_blank">Lupanov, 1984</a>) . (Thanks to Sasha Golovnev for tracking down this reference!)</p>
<p>The concept of “syntactic sugar” is also known as “macros” or “meta-programming” and is sometimes implemented via a preprocessor or macro language in a programming language or a text editor. One modern example is the <a href="https://babeljs.io/">Babel</a> JavaScript syntax transformer, that converts JavaScript programs written using the latest features into a format that older Browsers can accept. It even has a <a href="https://babeljs.io/docs/plugins/">plug-in</a> architecture, that allows users to add their own syntactic sugar to the language.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>This code uses <em>regular expressions</em> to make the search and replace parts a little easier. We will see the theoretical basis for regular expressions in <a href='lec_08a_restricted_models.html#restrictedchap'>Chapter 9</a>.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>The value of <span><span class="math inline">\(c\)</span></span> can be improved to <span><span class="math inline">\(9\)</span></span>, see <a href='#halffulladderex'>Exercise 4.5</a>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>In case you are curious, this is the function on input <span><span class="math inline">\(i\in \{0,1\}^4\)</span></span> (which we interpret as a number in <span><span class="math inline">\([16]\)</span></span>), that outputs the <span><span class="math inline">\(i\)</span></span>-th digit of <span><span class="math inline">\(\pi\)</span></span> in the binary basis.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>The constant <span><span class="math inline">\(c\)</span></span> in this theorem is at most <span><span class="math inline">\(10\)</span></span> and in fact can be arbitrarily close to <span><span class="math inline">\(1\)</span></span>, see <a href='#computeeveryfunctionbibnotes'>Section 4.8</a>.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>The restriction that <span><span class="math inline">\(m,n \leq 2s\)</span></span> makes no difference; see <a href='lec_03_computation.html#nandcircsizeex'>Exercise 3.11</a>.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>You can start by transforming <span><span class="math inline">\(P\)</span></span> into a NAND-CIRC-PROC program that uses procedure statements, and then use the code of <a href='#desugarcode'>?? ??</a> to transform the latter into a “sugar free” NAND-CIRC program.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:7"><p>
<div>
<p>Use a “cascade” of adding the bits one after the other, starting with the least significant digit, just like in the elementary-school algorithm.</p>
</div>
<a href="#fnref:7" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:8"><p>
<div>
<p><strong>Hint:</strong> Use Karatsuba’s algorithm.</p>
</div>
<a href="#fnref:8" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:9"><p>
<div>
<p>You can use the fact that <span><span class="math inline">\((a+b)+c \mod 2 = a+b+c \mod 2\)</span></span>. In particular it means that if you have the lines <code>d = XOR(a,b)</code> and <code>e = XOR(d,c)</code> then <code>e</code> gets the sum modulo <span><span class="math inline">\(2\)</span></span> of the variable <code>a</code>, <code>b</code> and <code>c</code>.</p>
</div>
<a href="#fnref:9" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:10"><p>
<div>
<p>One approach to solve this is using recursion and the so-called <a href="https://en.wikipedia.org/wiki/Master%5Ftheorem%5F(analysis%5Fof%5Falgorithms)">Master Theorem</a>.</p>
</div>
<a href="#fnref:10" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:39:29</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_03a_computing_every_function.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
