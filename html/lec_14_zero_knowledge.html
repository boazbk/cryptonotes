<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: </title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: " />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path=".html"><a href=".html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path=".html"><a href=".html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path=".html"><a href=".html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path=".html"><a href=".html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path=".html"><a href=".html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path=".html"><a href=".html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path=".html"><a href=".html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path=".html"><a href=".html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path=".html"><a href=".html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path=".html"><a href=".html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path=".html"><a href=".html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path=".html"><a href=".html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path=".html"><a href=".html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path=".html"><a href=".html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path=".html"><a href=".html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path=".html"><a href=".html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path=".html"><a href=".html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path=".html"><a href=".html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path=".html"><a href=".html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path=".html"><a href=".html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path=".html"><a href=".html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path=".html"><a href=".html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path=".html"><a href=".html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path=".html"><a href=".html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path=".html"><a href=".html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path=".html"><a href=".html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path=".html"><a href=".html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path=".html"><a href=".html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path=".html"><a href=".html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path=".html"><a href=".html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path=".html"><a href=".html#countoperation"><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path=".html"><a href=".html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path=".html"><a href=".html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path=".html"><a href=".html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path=".html"><a href=".html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path=".html"><a href=".html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li><ul><li class="chapter" data-level="3.0.1" data-path=".html"><a href=".html#unpredictability-an-alternative-approach-for-proving-the-length-extension-theorem"><i class="fa fa-check"></i><b>3.0.1</b> Unpredictability: an alternative approach for proving the length extension theorem</a></li></ul></li><li class="chapter" data-level="3.1" data-path=".html"><a href=".html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path=".html"><a href=".html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path=".html"><a href=".html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path=".html"><a href=".html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path=".html"><a href=".html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path=".html"><a href=".html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path=".html"><a href=".html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path=".html"><a href=".html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path=".html"><a href=".html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path=".html"><a href=".html#case-study-3-b.b.s."><i class="fa fa-check"></i><b>3.4</b> Case Study 3: B.B.S.</a></li><li class="chapter" data-level="3.5" data-path=".html"><a href=".html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.5</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path=".html"><a href=".html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path=".html"><a href=".html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path=".html"><a href=".html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path=".html"><a href=".html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path=".html"><a href=".html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path=".html"><a href=".html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path=".html"><a href=".html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path=".html"><a href=".html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path=".html"><a href=".html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li><li class="chapter" data-level="5.4" data-path=".html"><a href=".html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>5.4</b> Optional, Aside: Broadcast Encryption</a></li></ul></li><li class="chapter" data-level="6" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path=".html"><a href=".html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path=".html"><a href=".html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path=".html"><a href=".html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path=".html"><a href=".html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path=".html"><a href=".html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path=".html"><a href=".html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path=".html"><a href=".html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path=".html"><a href=".html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>7</b> Hash Functions and Random Oracles</a><ul><li class="chapter" data-level="7.1" data-path=".html"><a href=".html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "Bitcoin" Problem</a><ul><li class="chapter" data-level="7.1.1" data-path=".html"><a href=".html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The Currency Problem</a></li><li class="chapter" data-level="7.1.2" data-path=".html"><a href=".html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin Architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path=".html"><a href=".html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The Bitcoin Ledger</a><ul><li class="chapter" data-level="7.2.1" data-path=".html"><a href=".html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From Proof of Work to Consensus on Ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path=".html"><a href=".html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision Resistance Hash Functions and Creating Short "Unique" Identifiers</a></li><li class="chapter" data-level="7.4" data-path=".html"><a href=".html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical Constructions of Cryptographic Hash Functions</a><ul><li class="chapter" data-level="7.4.1" data-path=".html"><a href=".html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical Random-ish Functions</a></li><li class="chapter" data-level="7.4.2" data-path=".html"><a href=".html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some History</a></li><li class="chapter" data-level="7.4.3" data-path=".html"><a href=".html#the-nsa-and-hash-functions"><i class="fa fa-check"></i><b>7.4.3</b> The NSA and Hash Functions</a></li><li class="chapter" data-level="7.4.4" data-path=".html"><a href=".html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs Non-Cryptographic Hash Functions</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path=".html"><a href=".html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path=".html"><a href=".html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path=".html"><a href=".html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path=".html"><a href=".html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path=".html"><a href=".html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path=".html"><a href=".html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path=".html"><a href=".html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path=".html"><a href=".html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path=".html"><a href=".html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path=".html"><a href=".html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path=".html"><a href=".html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path=".html"><a href=".html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path=".html"><a href=".html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path=".html"><a href=".html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path=".html"><a href=".html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path=".html"><a href=".html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path=".html"><a href=".html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li><li class="chapter" data-level="10.6" data-path=".html"><a href=".html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a><ul><li class="chapter" data-level="10.6.1" data-path=".html"><a href=".html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li></ul></li></ul></li><li class="chapter" data-level="11" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path=".html"><a href=".html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path=".html"><a href=".html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path=".html"><a href=".html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path=".html"><a href=".html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path=".html"><a href=".html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path=".html"><a href=".html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path=".html"><a href=".html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path=".html"><a href=".html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path=".html"><a href=".html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a><ul><li class="chapter" data-level="11.2.1" data-path=".html"><a href=".html#extending-to-more-than-one-hardcore-bit"><i class="fa fa-check"></i><b>11.2.1</b> Extending to more than one hardcore bit</a></li></ul></li></ul></li><li class="chapter" data-level="12" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li><ul><li class="chapter" data-level="12.0.1" data-path=".html"><a href=".html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li></ul></li><li class="chapter" data-level="12.1" data-path=".html"><a href=".html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path=".html"><a href=".html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path=".html"><a href=".html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path=".html"><a href=".html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path=".html"><a href=".html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path=".html"><a href=".html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path=".html"><a href=".html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path=".html"><a href=".html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path=".html"><a href=".html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path=".html"><a href=".html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path=".html"><a href=".html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path=".html"><a href=".html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path=".html"><a href=".html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path=".html"><a href=".html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path=".html"><a href=".html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path=".html"><a href=".html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path=".html"><a href=".html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path=".html"><a href=".html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path=".html"><a href=".html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path=".html"><a href=".html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path=".html"><a href=".html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path=".html"><a href=".html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path=".html"><a href=".html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path=".html"><a href=".html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path=".html"><a href=".html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path=".html"><a href=".html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path=".html"><a href=".html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path=".html"><a href=".html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path=".html"><a href=".html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path=".html"><a href=".html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path=".html"><a href=".html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path=".html"><a href=".html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path=".html"><a href=".html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path=".html"><a href=".html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path=".html"><a href=".html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption: Construction</a><ul><li class="chapter" data-level="17.1" data-path=".html"><a href=".html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path=".html"><a href=".html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path=".html"><a href=".html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path=".html"><a href=".html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path=".html"><a href=".html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path=".html"><a href=".html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path=".html"><a href=".html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path=".html"><a href=".html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path=".html"><a href=".html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path=".html"><a href=".html#advanced-topics"><i class="fa fa-check"></i><b>17.6</b> Advanced topics:</a><ul><li class="chapter" data-level="17.6.1" data-path=".html"><a href=".html#fully-homomorphic-encryption-for-approximate-computation-over-the-real-numbers-ckks"><i class="fa fa-check"></i><b>17.6.1</b> Fully homomorphic encryption for approximate computation over the real numbers: CKKS</a></li><li class="chapter" data-level="17.6.2" data-path=".html"><a href=".html#bandwidth-efficient-fully-homomorphic-encryption-gh"><i class="fa fa-check"></i><b>17.6.2</b> Bandwidth efficient fully homomorphic encryption GH</a></li><li class="chapter" data-level="17.6.3" data-path=".html"><a href=".html#using-fully-homomorphic-encryption-to-achieve-private-information-retrieval."><i class="fa fa-check"></i><b>17.6.3</b> Using fully homomorphic encryption to achieve private information retrieval.</a></li></ul></li></ul></li><li class="chapter" data-level="18" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path=".html"><a href=".html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path=".html"><a href=".html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path=".html"><a href=".html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path=".html"><a href=".html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path=".html"><a href=".html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path=".html"><a href=".html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path=".html"><a href=".html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path=".html"><a href=".html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path=".html"><a href=".html#hbctomalred"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path=".html"><a href=".html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation II: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path=".html"><a href=".html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path=".html"><a href=".html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a><ul><li class="chapter" data-level="19.2.1" data-path=".html"><a href=".html#bottom-line-a-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.2.1</b> Bottom line: A two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="19.3" data-path=".html"><a href=".html#beyond-two-parties"><i class="fa fa-check"></i><b>19.3</b> Beyond two parties</a></li></ul></li><li class="chapter" data-level="20" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path=".html"><a href=".html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path=".html"><a href=".html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path=".html"><a href=".html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path=".html"><a href=".html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path=".html"><a href=".html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path=".html"><a href=".html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path=".html"><a href=".html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path=".html"><a href=".html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path=".html"><a href=".html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path=".html"><a href=".html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path=".html"><a href=".html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path=".html"><a href=".html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path=".html"><a href=".html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path=".html"><a href=".html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path=".html"><a href=".html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path=".html"><a href=".html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path=".html"><a href=".html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path=".html"><a href=".html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path=".html"><a href=".html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path=".html"><a href=".html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path=".html"><a href=".html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path=".html"><a href=".html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path=".html"><a href=".html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path=".html"><a href=".html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path=".html"><a href=".html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path=".html"><a href=".html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path=".html"><a href=".html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path=".html"><a href=".html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path=".html"><a href=".html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path=".html"><a href=".html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path=".html"><a href=".html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path=".html"><a href=".html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path=".html"><a href=".html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path=".html"><a href=".html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path=".html"><a href=".html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path=".html"><a href=".html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path=".html"><a href=".html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path=".html"><a href=".html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path=".html"><a href=".html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path=".html"><a href=".html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path=".html"><a href=".html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 data-number="15" id="zero-knowledge-proofs">Zero knowledge proofs</h1>
<p>The notion of <em>proof</em> is central to so many fields. In mathematics, we want to prove that a certain assertion is correct. In other sciences, we often want to accumulate a preponderance of evidence (or statistical significance) to reject certain hypothesis. In criminal law the prosecution famously needs to prove its case “beyond a reasonable doubt”. Cryptography turns out to give some new twists on this ancient notion.</p>
<p>Typically a proof that some assertion X is true, also reveals some information about <em>why</em> X is true. When Hercule Poirot proves that Norman Gale killed Madame Giselle he does so by showing <em>how</em> Gale committed the murder by dressing up as a flight attendant and stabbing Madame Gisselle with a poisoned dart. Could Hercule convince us beyond a reasonable doubt that Gale did the crime without giving any information on <em>how</em> the crime was committed? Can the Russians prove to the U.S. that a sealed box contains an authentic nuclear warhead without revealing anything about its design? Can I prove to you that the number <span><span class="math inline">\(m=385,608,108,395,369,363,400,501,273,594,475,104,405,448,848,047,062,278,473,983\)</span></span> has a prime factor whose last digit is <span><span class="math inline">\(7\)</span></span> without giving you any information about <span><span class="math inline">\(m\)</span></span>’s prime factors? We won’t answer the first question, but will show some insights on the latter two.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p><em>Zero knowledge proofs</em> are proofs that fully convince that a statement is true without yielding <em>any additional knowledge</em>. So, after seeing a zero knowledge proof that <span><span class="math inline">\(m\)</span></span> has a factor ending with <span><span class="math inline">\(7\)</span></span>, you’ll be no closer to knowing <span><span class="math inline">\(m\)</span></span>’s factorization than you were before. Zero knowledge proofs were invented by Goldwasser, Micali and Rackoff in 1982 and have since been used in great many settings. How would you achieve such a thing, or even define it? And why on earth would it be useful? This is the topic of this lecture.</p>
<h2 data-number="15.1" id="applications-for-zero-knowledge-proofs.">Applications for zero knowledge proofs.</h2>
<p>Before we talk about how to achieve zero knowledge, let us discuss some of its potential applications:</p>
<h3 data-number="15.1.1" id="nuclear-disarmament">Nuclear disarmament</h3>
<p>The United States and Russia have reached a dangerous and expensive equilibrium by which each has about <a href="https://www.armscontrol.org/factsheets/Nuclearweaponswhohaswhat">7000 nuclear warheads</a>, much more than is needed to decimate each others’ population (and the population of much of the rest of the world).<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Having so many weapons increases the chance of “leakage” of weapons, or of an accidental launch (which can result in an all out war) through fault in communications or rogue commanders. This also threatens the delicate balance of the <a href="https://en.wikipedia.org/wiki/Treaty_on_the_Non-Proliferation_of_Nuclear_Weapons">Non-Proliferation Treaty</a> which at its core is a bargain where non-weapons states agree not to pursue nuclear weapons and the five nuclear weapon states agree to make progress on nuclear disarmament. These huge quantities of nuclear weapons are not only dangerous, as they increase the chance of a leak or of an individual failure or rogue commander causing a world catastrophe, but also extremely expensive to maintain.</p>
<p>For all of these reasons, in 2009, U.S. President Obama called to set as a long term goal a “world without nuclear weapons” and in 2012 talked about concretely talking to Russia about reducing “not only our strategic nuclear warheads, but also tactical weapons and warheads in reserve”. On the other side, Russian President Putin has said already in 2000 that he sees “no obstacles that could hamper future deep cuts of strategic offensive armaments”. (Though as of 2018, political winds on both sides have shifted away from disarmament and more toward armament.)</p>
<p>There are many reasons why progress on nuclear disarmament has been so slow, and most of them have nothing to do with zero knowledge or any other piece of technology. But there are some technical hurdles as well. One of those hurdles is that for the U.S. and Russia to go beyond restricting the number of <em>deployed</em> weapons to significantly reducing the <em>stockpiles</em>, they need to find a way for one country to verifiably prove that it has dismantled warheads. As mentioned in my <a href="http://www.nature.com/nature/journal/v510/n7506/full/nature13457.html">work with Glaser and Goldston</a> (see also <a href="http://nuclearfutures.princeton.edu/warhead-verification/">this page</a>), a key stumbling block is that the design of a nuclear warhard is of course highly classified and about the last thing in the world that the U.S. would like to share with Russia and vice versa. So, how can the U.S. convince the Russian that it has destroyed a warhead, when it cannot let Russian experts anywhere near it?</p>
<h3 data-number="15.1.2" id="voting">Voting</h3>
<p>Electronic voting has been of great interest for many reasons. One potential advantage is that it could allow completely transparent vote counting, where every citizen could verify that the votes were counted correctly. For example, Chaum suggested an approach to do so by publishing an encryption of every vote and then having the central authority <em>prove</em> that the final outcome corresponds to the counts of all the plaintexts. But of course to maintain voter privacy, we need to prove this without actually revealing those plaintexts. Can we do so?</p>
<h3 data-number="15.1.3" id="more-applications">More applications</h3>
<p>I chose these two examples above precisely because they are hardly the first that come to mind when thinking about zero knowledge. Zero knowledge has been used for many cryptographic applications. One such application (originating from work of Fiat and Shamir) is the use for <em>identification protocols</em>. Here Alice knows a solution <span><span class="math inline">\(x\)</span></span> to a puzzle <span><span class="math inline">\(P\)</span></span>, and proves her identity to Bob by, for example, providing an encryption <span><span class="math inline">\(c\)</span></span> of <span><span class="math inline">\(x\)</span></span> and proving in zero knowledge that <span><span class="math inline">\(c\)</span></span> is indeed an encryption of a solution for <span><span class="math inline">\(P\)</span></span>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> Bob can verify the proof, but because it is zero knowledge, learns nothing about the solution of the puzzle and will not be able to impersonate Alice. An alternative approach to such identification protocols is through using <em>digital signatures</em>; this connection goes both ways and zero knowledge proofs have been used by Schnorr and others as a basis for signature schemes.</p>
<p>Another very generic application is for “compiling protocols”. As we’ve seen time and again, it is often much easier to handle <em>passive</em> adversaries than <em>active</em> ones. (For example, it’s much easier to get CPA security against the eavesdropping Eve than CCA security against the person-in-the-middle Mallory.) Thus it would be wonderful if we could “compile” a protocol that is secure with respect to passive attacks into one that is secure with respect to active ones. As was first shown by Goldreich, Micali, and Wigderson, zero knowledge proofs yield a very general such compiler. The idea is that all parties prove in zero knowledge that they follow the protocol’s specifications. Normally, such proofs might require the parties to reveal their secret inputs, hence violating security, but zero knowledge precisely guarantees that we can verify correct behaviour without access to these inputs.</p>
<h2 data-number="15.2" id="defining-and-constructing-zero-knowledge-proofs">Defining and constructing zero knowledge proofs</h2>
<p>So, zero knowledge proofs are wonderful objects, but how do we get them? In fact, we haven’t answered the even more basic question of how do we <em>define</em> zero knowledge? We have to start by the most basic task of defining what we mean by a <em>proof</em>.</p>
<p>A <em>proof system</em> can be thought of as an algorithm <span><span class="math inline">\(V\)</span></span> (for “verifier”) that takes as input a <em>statement</em> which is some string <span><span class="math inline">\(x\)</span></span> and another string <span><span class="math inline">\(\pi\)</span></span> known as the <em>proof</em> and outputs <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(\pi\)</span></span> is a valid proof that the statement <span><span class="math inline">\(x\)</span></span> is correct. For example:</p>
<ul>
<li><p>In <em>Euclidean geometry</em>, <em>statements</em> are geometric facts such as “in any triangle the degrees sum to 180 degrees” and the <em>proofs</em> are step by step derivations of the statements from the five basic <a href="https://en.wikipedia.org/wiki/Euclidean_geometry">postulates</a>.</p></li>
<li><p>In <a href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory"><em>Zermelo-Fraenkel + Axiom of Choice (ZFC)</em></a> a <em>statement</em> is some purported fact about sets (e.g., the Riemann Hypothesis<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>), and a <em>proof</em> is a step by step derivation of it from the axioms.</p></li>
<li><p>We can many define other “theories”. For example, a theory where the statements are pairs <span><span class="math inline">\((x,m)\)</span></span> such that <span><span class="math inline">\(x\)</span></span> is a quadratic residue modulo <span><span class="math inline">\(m\)</span></span> and a proof for <span><span class="math inline">\(x\)</span></span> is the number <span><span class="math inline">\(s\)</span></span> such that <span><span class="math inline">\(x=s^2 \pmod{m}\)</span></span>, or a theory where the theorems are <em>Hamiltonian</em> graphs <span><span class="math inline">\(G\)</span></span> (graphs on <span><span class="math inline">\(n\)</span></span> vertices that contain an <span><span class="math inline">\(n\)</span></span>-long cycle) and the proofs are the description of the cycle.</p></li>
</ul>
<p>All these proof systems have the property that the verifying algorithm <span><span class="math inline">\(V\)</span></span> is <em>efficient</em>. Indeed, that’s the whole point of a proof <span><span class="math inline">\(\pi\)</span></span>- it’s a sequence of symbols that makes it easy to verify that the statement is true.</p>
<!-- We will also assume for the sake of simplicity that the proof $\pi$ is always of length at most polynomial in the statement $x$.
While this is not necessarily always the case, in our setting, we can always think of the length of the proof as an extra input, but it's convenient to think of it as simply being contained in the statement.   -->
<p>To achieve the notion of zero knowledge proofs, Goldwasser and Micali had to consider a generalization of proofs from static sequences of symbols to <em>interactive probabilistic protocols</em> between a prover and a verifier. Let’s start with an informal example. The vast majority of humans have three types of cone cells in their eyes. This is the reason why <a href="http://www.patarnott.com/atms749/pdf/blueSkyHumanResponse.pdf">we perceive the sky as blue</a> (see also <a href="https://www.forbes.com/sites/briankoberlein/2017/01/11/earths-skies-are-violet-we-just-see-them-as-blue/#33aaaf0f735f">this</a>), despite its color being quite a different spectrum than the blue of the rainbow, is that the projection of the sky’s color to our cones is closest to the projection of blue. It has been suggested that a tiny fraction of the human population might have four functioning cones (in fact, only women, as it would require two X chromosomes and a certain mutation). How would a person <em>prove</em> to another that she is a in fact such a <a href="https://en.wikipedia.org/wiki/Tetrachromacy">tetrachromat</a> ?</p>
<blockquote>
<p><strong>Proof of tetrachromacy:</strong></p>
<p>Suppose that Alice is a tetrachromat and can distinguish between the colors of two pieces of plastic that would be identical to a trichromat. She wants to prove to a trichromat Bob that the two pieces are not identical. She can do this as follows:</p>
<p>Alice and Bob will repeat the following experiment <span><span class="math inline">\(n\)</span></span> times: Alice turns her back and Bob tosses a coin and with probability 1/2 leaves the pieces as they are, and with probability 1/2 switches the right piece with the left piece. Alice needs to guess whether Bob switched the pieces or not.</p>
<p>If Alice is successful in all of the <span><span class="math inline">\(n\)</span></span> repetitions then Bob will have <span><span class="math inline">\(1-2^{-n}\)</span></span> confidence that the pieces are truly different.</p>
</blockquote>
<p>We now consider a more “mathematical” example along similar lines. Recall that if <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(m\)</span></span> are numbers then we say that <span><span class="math inline">\(x\)</span></span> is a <em>quadratic residue</em> modulo <span><span class="math inline">\(m\)</span></span> if there is some <span><span class="math inline">\(s\)</span></span> such that <span><span class="math inline">\(x=s^2 \pmod{m}\)</span></span>. Let us define the function <span><span class="math inline">\(\ensuremath{\mathit{NQR}}(m,x)\)</span></span> to output <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(x \neq s^2 \pmod{m}\)</span></span> for every <span><span class="math inline">\(s \in \{0,\ldots, m-1\}\)</span></span>. There is a very simple way to prove statements of the form “<span><span class="math inline">\(\ensuremath{\mathit{NQR}}(m,x)=0\)</span></span>”: just give out <span><span class="math inline">\(s\)</span></span>. However, here is an interactive proof system to prove statements of the form “<span><span class="math inline">\(\ensuremath{\mathit{NQR}}(m,x)=1\)</span></span>”:</p>
<ul>
<li><p>We have two parties: <strong>Alice</strong> and <strong>Bob</strong>. The <strong>common input</strong> is <span><span class="math inline">\((m,x)\)</span></span> and Alice wants to convince Bob that <span><span class="math inline">\(\ensuremath{\mathit{NQR}}(m,x)=1\)</span></span>. (That is, that <span><span class="math inline">\(x\)</span></span> is <em>not</em> a quadratic residue modulo <span><span class="math inline">\(m\)</span></span>).</p></li>
<li><p>We assume that Alice can compute <span><span class="math inline">\(\ensuremath{\mathit{NQR}}(m,w)\)</span></span> for every <span><span class="math inline">\(w\in \{0,\ldots,m-1\}\)</span></span> but Bob is polynomial time.</p></li>
<li><p>The protocol will work as follows:</p></li>
</ul>
<ol type="1">
<li><p>Bob will pick some random <span><span class="math inline">\(s\in \Z^*_m\)</span></span> (e.g., by picking a random number in <span><span class="math inline">\(\{1,\ldots,m-1\}\)</span></span> and discard it if it has nontrivial g.c.d. with <span><span class="math inline">\(m\)</span></span>) and toss a coin <span><span class="math inline">\(b\in\{0,1\}\)</span></span>. If <span><span class="math inline">\(b=0\)</span></span> then Bob will send <span><span class="math inline">\(s^2 \pmod{m}\)</span></span> to Alice and otherwise he will send <span><span class="math inline">\(xs^2 \pmod{m}\)</span></span> to Alice.</p></li>
<li><p>Alice will use her ability to compute <span><span class="math inline">\(\ensuremath{\mathit{NQR}}(m,\cdot)\)</span></span> to respond with <span><span class="math inline">\(b&#39;=0\)</span></span> if Bob sent a quadratic residue and with <span><span class="math inline">\(b&#39;=1\)</span></span> otherwise.</p></li>
<li><p>Bob <em>accepts</em> the proof if <span><span class="math inline">\(b=b&#39;\)</span></span>.</p></li>
</ol>
<p>To see that Bob will indeed accept the proof, note that if <span><span class="math inline">\(x\)</span></span> is a non-residue then <span><span class="math inline">\(xs^2\)</span></span> will have to be a non-residue as well (since if it had a root <span><span class="math inline">\(s&#39;\)</span></span> then <span><span class="math inline">\(s&#39;s^{-1}\)</span></span> would be a root of <span><span class="math inline">\(x\)</span></span>). Hence it will always be the case that <span><span class="math inline">\(b&#39;=b\)</span></span>.</p>
<p>Moreover, if <span><span class="math inline">\(x\)</span></span> <em>was</em> a quadratic residue of the form <span><span class="math inline">\(x=s&#39;^2 \pmod{m}\)</span></span> for some <span><span class="math inline">\(s&#39;\)</span></span>, then <span><span class="math inline">\(xs^2=(s&#39;s)^2\)</span></span> is simply a random quadratic residue, which means that in this case Bob’s message is distributed the same regardless of whether <span><span class="math inline">\(b=0\)</span></span> or <span><span class="math inline">\(b=1\)</span></span>, and no matter what she does, Alice has probability at most <span><span class="math inline">\(1/2\)</span></span> of guessing <span><span class="math inline">\(b\)</span></span>. Hence if Alice is always successful than after <span><span class="math inline">\(n\)</span></span> repetitions Bob would have <span><span class="math inline">\(1-2^{-n}\)</span></span> confidence that <span><span class="math inline">\(x\)</span></span> is indeed a non-residue modulo <span><span class="math inline">\(m\)</span></span>.</p>
<div id="section" class="pause" data-number="15.2" name="Pause">
<p>Please stop and make sure you see the similarities between this protocol and the one for demonstrating that the two pieces of plastic do not have identical colors.</p>
</div>
<!-- Recall that two graphs $G_0$ and $G_1$ are isomorphic if one can permute the vertices of $G_0$ to make it into $G_1$.
There have been some recent great advances by Babai for this problem, but there is still not a truly efficient algorithm to test whether a pair of graphs has this property.
Suppose though Alice is an "isomorphomat" - she does have the computational ability to find such isomorphisms, if they exist, and wants to convince Bob that a pair of $n$-vertex graphs $G_0$ and $G_1$ are not _isomorphic_.
She can tell him "trust me, I know how to find isomorphisms and couldn't find one for this pair", but he may view this as less than fully convincing.
However, he could be convinced by the following protocol: he will repeat the following experiements: pick $b$ at random in $\{0,1\}$  and pick $\sigma$ to be a random permutation of $\{1,\ldots,n \}$. He then lets $H$ be the graph obtained by permuting the vertices of $G_b$ according to $\sigma$ and sends $H$ to Alice.
Now Alice using her isomorphism powers finds out whether $H$ is isomorphic to $G_0$ or $G_1$ and sends the index $b'\in\{0,1\}$ of the isomorphic graph to Bob.
If the graphs were _not_  isomorphic, then $b'$ would equal $b$ with probability $1$, since $H$ can only be isomorphic to one of the graphs.
On ther other hand, if the graphs were isomorphic then $H$ is distributed identically no matter what $b$ was, and so no matter what she does Alice has probability at most $1/2$ of finding $b'$ that equals $b$.
Thus if Alice always succeeds then after $n$ repetitions Bob can have $1-2^{-n}$ confidence that the graphs are _not_ isomorphic.
-->
<p>Let us now make the formal definition:</p>
<div id="proofsystemdef" class="definition" title="Proof systems" data-number="15.2" name="Definition 15.1 (Proof systems) ">
<p>Let <span><span class="math inline">\(f:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be some function. A <em>probabilistic proof for <span><span class="math inline">\(f\)</span></span></em> (i.e., a proof for statements of the form “<span><span class="math inline">\(f(x)=1\)</span></span>”) is a pair of interactive algorithms <span><span class="math inline">\((P,V)\)</span></span> such that <span><span class="math inline">\(V\)</span></span> runs in polynomial time and they satisfy:</p>
<ul>
<li><p><strong>Completeness:</strong> If <span><span class="math inline">\(f(x)=1\)</span></span> then on input <span><span class="math inline">\(x\)</span></span>, if <span><span class="math inline">\(P\)</span></span> and <span><span class="math inline">\(V\)</span></span> are given input <span><span class="math inline">\(x\)</span></span> and interact, then at the end of the interaction <span><span class="math inline">\(V\)</span></span> will output <code>Accept</code> with probability at least <span><span class="math inline">\(0.9\)</span></span>.</p></li>
<li><p><strong>Soundness:</strong> If If <span><span class="math inline">\(f(x)=0\)</span></span> then for any arbitrary (efficient or non efficient) algorithm <span><span class="math inline">\(P^*\)</span></span>, if <span><span class="math inline">\(P^*\)</span></span> and <span><span class="math inline">\(V\)</span></span> are given input <span><span class="math inline">\(x\)</span></span> and interact then at the end <span><span class="math inline">\(V\)</span></span> will output <code>Accept</code> with probability at most <span><span class="math inline">\(0.1\)</span></span></p></li>
</ul>
</div>
<div id="funclangrem" class="remark" title="Functions vs languages" data-number="15.2" name="Remark 15.2 (Functions vs languages) ">
<p>In many texts proof systems are defined with respect to <em>languages</em> as opposed to <em>functions</em>. That is, instead of talking about a function <span><span class="math inline">\(f:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> we talk about a <em>lanugage</em> <span><span class="math inline">\(L \subseteq \{0,1\}^*\)</span></span>. These two viewpoints are completely equivalent via the mapping <span><span class="math inline">\(f \longleftrightarrow L\)</span></span> where <span><span class="math inline">\(L = \{ x \;| f(x) = 1 \}\)</span></span>.</p>
</div>
<p>Note that we don’t necessarily require the prover to be efficient (and indeed, in some cases it might not be). On the other hand, our soundness condition holds even if the prover uses a non efficient strategy.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> We say that a proof system has an <em>efficient prover</em> if there is an NP-type proof system <span><span class="math inline">\(\Pi\)</span></span> for <span><span class="math inline">\(L\)</span></span> (that is some efficient algorithm <span><span class="math inline">\(\Pi\)</span></span> such that there exists <span><span class="math inline">\(\pi\)</span></span> with <span><span class="math inline">\(\Pi(x,\pi)=1\)</span></span> iff <span><span class="math inline">\(x\in L\)</span></span> and such that <span><span class="math inline">\(\Pi(x,\pi)=1\)</span></span> implies that <span><span class="math inline">\(|\pi|\leq poly(|x|)\)</span></span>), such that the strategy for <span><span class="math inline">\(P\)</span></span> can be implemented efficiently given any static proof <span><span class="math inline">\(\pi\)</span></span> for <span><span class="math inline">\(x\)</span></span> in this system.</p>
<div id="strategies" class="remark" title="Notation for strategies" data-number="15.2" name="Remark 15.3 (Notation for strategies) ">
<p>Up until now, we always considered cryptographic protocols where Alice and Bob trusted one another, but were worried about some adversary controlling the channel between them. Now we are in a somewhat more “suspicious” setting where the parties do not fully trust one another. In such protocols there is always a “prescribed” or <strong>honest</strong> strategy that a particular party <em>should</em> follow, but we generally don’t want the other parties’ security to rely on someone else’s good intention, and hence analyze also the case where a party uses an arbitrary <strong>malicious</strong> strategy. We sometimes also consider the <strong>honest but curious</strong> case where the adversary is passive and only collects information, but does not deviate from the prescribed strategy.</p>
<p>Protocols typically only guarantee security for party A when it behaves honestly - a party can always chose to violate its own security and there is not much we can (or should?) do about it.</p>
</div>
<h2 data-number="15.3" id="defining-zero-knowledge">Defining zero knowledge</h2>
<p>So far we merely defined the notion of an interactive proof system, but we need to define what it means for a proof to be <em>zero knowledge</em>. Before we attempt a definition, let us consider an example. Going back to the notion of quadratic residuosity, suppose that <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(m\)</span></span> are public and Alice knows <span><span class="math inline">\(s\)</span></span> such that <span><span class="math inline">\(x=s^2 \pmod{m}\)</span></span>. She wants to convince Bob that this is the case. However she prefers not to reveal <span><span class="math inline">\(s\)</span></span>. Can she convince Bob that such an <span><span class="math inline">\(s\)</span></span> exist without revealing any information about it? Here is a way to do so:</p>
<p><strong>Protocol ZK-QR:</strong> Public input for Alice and Bob: <span><span class="math inline">\(x,m\)</span></span>; Alice’s private input is <span><span class="math inline">\(s\)</span></span> such that <span><span class="math inline">\(x=s^2 \pmod{m}\)</span></span>.</p>
<ol type="1">
<li><p>Alice will pick a random <span><span class="math inline">\(s&#39;\)</span></span> and send to Bob <span><span class="math inline">\(x&#39; = xs&#39;^2 \pmod{m}\)</span></span>.</p></li>
<li><p>Bob will pick a random bit <span><span class="math inline">\(b\in\{0,1\}\)</span></span> and send <span><span class="math inline">\(b\)</span></span> to Alice.</p></li>
<li><p>If <span><span class="math inline">\(b=0\)</span></span> then Alice reveals <span><span class="math inline">\(ss&#39;\)</span></span>, hence giving out a root for <span><span class="math inline">\(x&#39;\)</span></span>; if <span><span class="math inline">\(b=1\)</span></span> then Alice reveals <span><span class="math inline">\(s&#39;\)</span></span>, hence showing a root for <span><span class="math inline">\(x&#39;x^{-1}\)</span></span>.</p></li>
<li><p>Bob checks that the value <span><span class="math inline">\(s&#39;&#39;\)</span></span> revealed by Alice is indeed a root of <span><span class="math inline">\(x&#39;x^{-b}\)</span></span>, if so then it “accepts” the proof.</p></li>
</ol>
<p>If <span><span class="math inline">\(x\)</span></span> was <em>not</em> a quadratic residue then no matter how <span><span class="math inline">\(x&#39;\)</span></span> was chosen, either <span><span class="math inline">\(x&#39;\)</span></span> or <span><span class="math inline">\(x&#39;x^{-1}\)</span></span> is <em>not</em> a residue and hence Bob will reject the proof with probability at least <span><span class="math inline">\(1/2\)</span></span>. By repeating this <span><span class="math inline">\(n\)</span></span> times, we can reduce the probability of Bob accepting a the proof of a non residue to <span><span class="math inline">\(2^{-n}\)</span></span>.</p>
<p>On the other hand, we claim that we didn’t really reveal anything about <span><span class="math inline">\(s\)</span></span>. Indeed, if Bob chooses <span><span class="math inline">\(b=0\)</span></span>, then the two messages <span><span class="math inline">\((x&#39;,ss&#39;)\)</span></span> he sees can be thought of as a random quadratic residue <span><span class="math inline">\(x&#39;\)</span></span> and its root. If Bob chooses <span><span class="math inline">\(b=1\)</span></span> then after dividing by <span><span class="math inline">\(x\)</span></span> (which he could have done by himself) he still gets a random residue <span><span class="math inline">\(x&#39;&#39;\)</span></span> and its root <span><span class="math inline">\(s&#39;\)</span></span>. In both cases, the distribution of these two messages is completely independent of <span><span class="math inline">\(s\)</span></span>, and hence intuitively yields no additional information about it beyond whatever Bob knew before.</p>
<p>To define zero knowledge mathematically we follow the following intuition:</p>
<blockquote>
<p><em>A proof system is zero knowledge if the verifier did not learn anything after the interaction that he could not have learned on his own.</em></p>
</blockquote>
<p>Here is how we formally define this:</p>
<div id="zkpdef" class="definition" title="Zero knowledge proofs" data-number="15.3" name="Definition 15.4 (Zero knowledge proofs) ">
<p>A proof system <span><span class="math inline">\((P,V)\)</span></span> for <span><span class="math inline">\(f\)</span></span> is <em>zero knowledge</em> if for every efficient verifier strategy <span><span class="math inline">\(V^*\)</span></span> there exists an efficient probabilistic algorithm <span><span class="math inline">\(S^*\)</span></span> (known as the <em>simulator</em>) such that for every <span><span class="math inline">\(x\)</span></span> s.t. <span><span class="math inline">\(f(x)=1\)</span></span>, the following random variables are computationally indistinguishable:</p>
<ul>
<li><p>The output of <span><span class="math inline">\(V^*\)</span></span> after interacting with <span><span class="math inline">\(P\)</span></span> on input <span><span class="math inline">\(x\)</span></span>.</p></li>
<li><p>The output of <span><span class="math inline">\(S^*\)</span></span> on input <span><span class="math inline">\(x\)</span></span>.</p></li>
</ul>
</div>
<p>That is, we can show the verifier does not gain anything from the interaction, because no matter what algorithm <span><span class="math inline">\(V^*\)</span></span> he uses, whatever he learned as a result of interacting with the prover, he could have just as equally learned by simply running the standalone algorithm <span><span class="math inline">\(S^*\)</span></span> on the same input.</p>
<div id="simulationrem" class="remark" title="The simulation paradigm" data-number="15.3" name="Remark 15.5 (The simulation paradigm) ">
<p>The natural way to define security is to say that a system is secure if some “laundry list” of bad outcomes X,Y,Z can’t happen. The definition of zero knowledge is different. Rather than giving a list of the events that are <em>not allowed</em> to occur, it gives a maximalist <em>simulation</em> condition.</p>
<p>At its heart the definition of zero knowledge says the following: clearly, we cannot prevent the verifier from running an efficient algorithm <span><span class="math inline">\(S^*\)</span></span> on the public input, but we want to ensure that this is the most he can learn from the interaction. This <em>simulation paradigm</em> has become the standard way to define security of a great many cryptographic applications. That is, we bound what an adversary Eve can learn by postulating some hypothetical adversary Lilith that is under much harsher conditions (e.g., does not get to interact with the prover) and ensuring that Eve cannot learn anything that Lilith couldn’t have learned either. This has an advantage of being the most conservative definition possible, and also phrasing security in <em>positive</em> terms- there exists a simulation - as opposed to the typical <em>negative</em> terms - events X,Y,Z can’t happen. Since it’s often easier for us to think of positive terms, paradoxically sometimes this stronger security condition is easier to prove. Zero knowledge is in some sense the simplest setting of the simulation paradigm and we’ll see it time and again in dealing with more advanced notions.</p>
</div>
<p>The definition of zero knowledge is confusing since intuitively one thing that if the verifier gained confidence that the statement is true than surely he must have learned <em>something</em>. This is another one of those cases where cryptography is counterintuitive. To understand it better, it is worthwhile to see the formal proof that the protocol above for quadratic residousity is zero knowledge:</p>
<div id="zkqrthm" class="theorem" title="Zero knowledge for quadratic residuosity" data-number="15.3" name="Theorem 15.6 (Zero knowledge for quadratic residuosity) ">
<p>Protocol ZK-QR above is a zero knowledge protocol.</p>
</div>
<div id="section-1" class="proof" data-ref="zkqrthm" data-number="15.3" name="Proof">
<p>Let <span><span class="math inline">\(V^*\)</span></span> be an arbitrary efficient strategy for Bob. Since Bob only sends a single bit, we can think of this strategy as composed of two functions:</p>
<ul>
<li><p><span><span class="math inline">\(V_1(x,m,x&#39;)\)</span></span> outputs the bit <span><span class="math inline">\(b\)</span></span> that Bob chooses on input <span><span class="math inline">\(x,m\)</span></span> and after Alice’s first message is <span><span class="math inline">\(x&#39;\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(V_2(x,m,x&#39;,s&#39;&#39;)\)</span></span> is whatever Bob outputs after seeing Alice’s response <span><span class="math inline">\(s&#39;&#39;\)</span></span> to the bit <span><span class="math inline">\(b\)</span></span>.</p></li>
</ul>
<p>Both <span><span class="math inline">\(V_1\)</span></span> and <span><span class="math inline">\(V_2\)</span></span> are efficiently computable. We now need to come up with an efficient simulator <span><span class="math inline">\(S^*\)</span></span> that is a standalone algorithm that on input <span><span class="math inline">\(x,m\)</span></span> will output a distribution indistinguishable from the output <span><span class="math inline">\(V^*\)</span></span>. The simulator <span><span class="math inline">\(S^*\)</span></span> will work as follows:</p>
<ol type="1">
<li><p>Pick <span><span class="math inline">\(b&#39;\leftarrow_R\{0,1\}\)</span></span>.</p></li>
<li><p>Pick <span><span class="math inline">\(s&#39;&#39;\)</span></span> at random in <span><span class="math inline">\(\Z^*_m\)</span></span>. If <span><span class="math inline">\(b=0\)</span></span> then let <span><span class="math inline">\(x&#39;={s&#39;&#39;}^2 \pmod{m}\)</span></span>. Otherwise output <span><span class="math inline">\(x&#39;=x{s&#39;&#39;}^2 \pmod{m}\)</span></span>.</p></li>
<li><p>Let <span><span class="math inline">\(b=V_1(x,m,x&#39;)\)</span></span>. If <span><span class="math inline">\(b \neq b&#39;\)</span></span> then go back to step 1.</p></li>
<li><p>Output <span><span class="math inline">\(V_2(x,m,x&#39;,s&#39;&#39;)\)</span></span>.</p></li>
</ol>
<p>The correctness of the simulator follows from the following claims (all of which assume that <span><span class="math inline">\(x\)</span></span> is actually a quadratic residue, since otherwise we don’t need to make any guarantees and in any case Alice’s behaviour is not well defined):</p>
<p><strong>Claim 1:</strong> The distribution of <span><span class="math inline">\(x&#39;\)</span></span> computed by <span><span class="math inline">\(S^*\)</span></span> is identical to the distribution of <span><span class="math inline">\(x&#39;\)</span></span> chosen by Alice.</p>
<p><strong>Claim 2:</strong> With probability at least <span><span class="math inline">\(1/2\)</span></span>, <span><span class="math inline">\(b&#39;=b\)</span></span>.</p>
<p><strong>Claim 3:</strong> Conditioned on <span><span class="math inline">\(b=b&#39;\)</span></span> and the value <span><span class="math inline">\(x&#39;\)</span></span> computed in step 2, the value <span><span class="math inline">\(s&#39;&#39;\)</span></span> computed by <span><span class="math inline">\(S^*\)</span></span> is identical to the value that Alice sends when her first message is <span><span class="math inline">\(X&#39;\)</span></span> and Bob’s response is <span><span class="math inline">\(b\)</span></span>.</p>
<p>Together these three claims imply that in expectation <span><span class="math inline">\(S^*\)</span></span> only invokes <span><span class="math inline">\(V_1\)</span></span> and <span><span class="math inline">\(V_2\)</span></span> a constant number of times (since every time it goes back to step 1 with probability at most <span><span class="math inline">\(1/2\)</span></span>). They also imply that the output of <span><span class="math inline">\(S^*\)</span></span> is in fact identical to the output of <span><span class="math inline">\(V^*\)</span></span> in a true interaction with Alice. Thus, we only need to prove the claims, which is actually quite easy:</p>
<p><strong>Proof of Claim 1:</strong> In both cases, <span><span class="math inline">\(x&#39;\)</span></span> is a random quadratic residue. QED</p>
<p><strong>Proof of Claim 2:</strong> This is a corollary of Claim 1; since the distribution of <span><span class="math inline">\(x&#39;\)</span></span> is identical to the distribution chosen by Alice, in particular <span><span class="math inline">\(x&#39;\)</span></span> gives out no information about the choice of <span><span class="math inline">\(b&#39;\)</span></span>. QED</p>
<p><strong>Proof of Claim 3:</strong> This follows from a direct calculation. The value <span><span class="math inline">\(s&#39;&#39;\)</span></span> sent by Alice is a square root of <span><span class="math inline">\(x&#39;\)</span></span> if <span><span class="math inline">\(b=0\)</span></span> and of <span><span class="math inline">\(x&#39;x^{-1}\)</span></span> if <span><span class="math inline">\(x=1\)</span></span>. But this is identical to what happens for <span><span class="math inline">\(S^*\)</span></span> if <span><span class="math inline">\(b=b&#39;\)</span></span>. QED</p>
<p>Together these complete the proof of the theorem.</p>
</div>
<p><a href='lec_14_zero_knowledge.html#zkqrthm'>Theorem 15.6</a> is interesting but not yet good enough to guarantee security in practice. After all, the protocol that we really need to show is zero knowledge is the one where we repeat this procedure <span><span class="math inline">\(n\)</span></span> times. This is a general theorem that if a protocol is zero knowledge then repeating it polynomially many times one after the other (so called “sequential repetition”) preserves zero knowledge. You can think of this as cryptography’s version of the equality “<span><span class="math inline">\(0+0=0\)</span></span>”, but as usual, intuitive things are not always correct and so this theorem does require (a not super trivial) proof. It is a good exercise to try to prove it on your own. There are known ways to achieve zero knowledge with negligible soundness error and a <em>constant</em> number of communication rounds, see Goldreich’s book (Vol 1, Sec 4.9).</p>
<h2 data-number="15.4" id="zero-knowledge-proof-for-hamiltonicity.">Zero knowledge proof for Hamiltonicity.</h2>
<p>We now show a proof for another language. Suppose that Alice and Bob know an <span><span class="math inline">\(n\)</span></span>-vertex graph <span><span class="math inline">\(G\)</span></span> and Alice knows a <em>Hamiltonian cycle</em> <span><span class="math inline">\(C\)</span></span> in this graph (i.e.. a length <span><span class="math inline">\(n\)</span></span> simple cycle- one that traverses all vertices exactly once). Here is how Alice can prove that such a cycle exists without revealing any information about it:</p>
<p><strong>Protocol ZK-Ham:</strong></p>
<ol start="0" type="1">
<li><p><strong>Common input:</strong> graph <span><span class="math inline">\(H\)</span></span> (in the form of an <span><span class="math inline">\(n\times n\)</span></span> adjacency matrix); <strong>Alice’s private input:</strong> a Hamiltonian cycle <span><span class="math inline">\(C=(C_1,\ldots,C_n)\)</span></span> which are distinct vertices such that <span><span class="math inline">\((C_\ell,C_{\ell+1})\)</span></span> is an edge in <span><span class="math inline">\(H\)</span></span> for all <span><span class="math inline">\(\ell\in\{1,\ldots,n-1\}\)</span></span> and <span><span class="math inline">\((C_n,C_1)\)</span></span> is an edge as well.</p></li>
<li><p>Bob chooses a random string <span><span class="math inline">\(z\in \{0,1\}^{3n}\)</span></span></p></li>
<li><p>Alice chooses a random permutation <span><span class="math inline">\(\pi\)</span></span> on <span><span class="math inline">\(\{1,\ldots, n\}\)</span></span> and let <span><span class="math inline">\(M\)</span></span> be the <span><span class="math inline">\(\pi\)</span></span>-permuted adjacency matrix of <span><span class="math inline">\(H\)</span></span> (i.e., <span><span class="math inline">\(M_{\pi(i),\pi(j)}=1\)</span></span> iff <span><span class="math inline">\((i,j)\)</span></span> is an edge in <span><span class="math inline">\(H\)</span></span>). For every <span><span class="math inline">\(i,j\)</span></span>, Alice chooses a random string <span><span class="math inline">\(x_{i,j} \in \{0,1\}^n\)</span></span> and let <span><span class="math inline">\(y_{i,j}=G(x_{i,j})\oplus M_{i,j}z\)</span></span>, where <span><span class="math inline">\(G:\{0,1\}^n\rightarrow\{0,1\}^{3n}\)</span></span> is a pseudorandom generator. She sends <span><span class="math inline">\(\{ y_{i,j} \}_{i,j \in [n]}\)</span></span> to Bob.</p></li>
<li><p>Bob chooses a bit <span><span class="math inline">\(b\in\{0,1\}\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(b=0\)</span></span> then Alice sends out <span><span class="math inline">\(\pi\)</span></span> and the strings <span><span class="math inline">\(\{ x_{i,j} \}\)</span></span> for all <span><span class="math inline">\(i,j\)</span></span>; If <span><span class="math inline">\(b=1\)</span></span> then Alice sends out the <span><span class="math inline">\(n\)</span></span> strings <span><span class="math inline">\(x_{\pi(C_1),\pi(C_2)}\)</span></span>,<span><span class="math inline">\(\ldots\)</span></span>,<span><span class="math inline">\(x_{\pi(C_n),\pi(C_1)}\)</span></span> together with their indices.</p></li>
<li><p>If <span><span class="math inline">\(b=0\)</span></span> then Bob computes <span><span class="math inline">\(M\)</span></span> to be the <span><span class="math inline">\(\pi\)</span></span>-permuted adjacency matrix of <span><span class="math inline">\(H\)</span></span> and verifies that all the <span><span class="math inline">\(y_{i,j}\)</span></span>’s were computed from the <span><span class="math inline">\(x_{i,j}\)</span></span>’s appropriately. If <span><span class="math inline">\(b=1\)</span></span> then verify that the indices of the strings <span><span class="math inline">\(\{ x_{i,j } \}\)</span></span> sent by Alice form a cycle and that indeed <span><span class="math inline">\(y_{i,j}=G(x_{i,j})\oplus z\)</span></span> for every string <span><span class="math inline">\(x_{i,j}\)</span></span> that was sent by Alice.</p></li>
</ol>
<div id="zkhamthm" class="theorem" title="Zero Knowledge proof for Hamiltonian Cycle" data-number="15.4" name="Theorem 15.7 (Zero Knowledge proof for Hamiltonian Cycle) ">
<p>Protocol ZK-Ham is a zero knowledge proof system for the language of Hamiltonian graphs.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>
</div>
<div id="section-2" class="proof" data-ref="zkhamthm" data-number="15.4" name="Proof">
<p>We need to prove <strong>completeness</strong>, <strong>soundness</strong>, and <strong>zero knowledge</strong>.</p>
<p><strong>Completeness</strong> can be easily verified, and so we leave this to the reader.</p>
<p>For <strong>soundness</strong>, we recall that (as we’ve seen before) with extremely high probability the sets <span><span class="math inline">\(S_0=\{ G(x) : x\in\{0,1\}^n \}\)</span></span> and <span><span class="math inline">\(S_1 = \{ G(x)\oplus z : x\in\{0,1\}^n \}\)</span></span> will be disjoint (this probability is over the choice of <span><span class="math inline">\(z\)</span></span> that is done by the verifier). Now, assuming this is the case, given the messages <span><span class="math inline">\(\{ y_{i,j} \}\)</span></span> sent by the prover in the first step, define an <span><span class="math inline">\(n\times n\)</span></span> matrix <span><span class="math inline">\(M&#39;\)</span></span> with entries in <span><span class="math inline">\(\{0,1,?\}\)</span></span> as follows: <span><span class="math inline">\(M&#39;_{i,j}=0\)</span></span> if <span><span class="math inline">\(y_{i,j}\in S_0\)</span></span> , <span><span class="math inline">\(M&#39;_{i,j}=1\)</span></span> if <span><span class="math inline">\(y_{i,j}\in S_1\)</span></span> and <span><span class="math inline">\(M&#39;_{i,j}=?\)</span></span> otherwise.</p>
<p>We split into two cases. The first case is that there exists some permutation <span><span class="math inline">\(\pi\)</span></span> such that <strong>(i)</strong> <span><span class="math inline">\(M&#39;\)</span></span> is a <span><span class="math inline">\(\pi\)</span></span>-permuted version of the input graph <span><span class="math inline">\(G\)</span></span> and <strong>(ii)</strong> <span><span class="math inline">\(M&#39;\)</span></span> contains a Hamiltonian cycle. Clearly in this case <span><span class="math inline">\(G\)</span></span> contains a Hamiltonian cycle as well, and hence we don’t need to consider it when analyzing soundness. In the other case we claim that with probability at least <span><span class="math inline">\(1/2\)</span></span> the verifier will reject the proof. Indeed, if <strong>(i)</strong> is violated then the proof will be rejected if Bob chooses <span><span class="math inline">\(b=0\)</span></span> and if <strong>(ii)</strong> is violated then the proof will be rejected if Bob chooses <span><span class="math inline">\(b=1\)</span></span>.</p>
<p>We now turn to showing <strong>zero knowledge</strong>. For this we need to build a <em>simulator</em> <span><span class="math inline">\(S^*\)</span></span> for an arbitrary efficient strategy <span><span class="math inline">\(V^*\)</span></span> of Bob. Recall that <span><span class="math inline">\(S^*\)</span></span> gets as input the graph <span><span class="math inline">\(H\)</span></span> (but not the <em>Hamiltonian</em> cycle <span><span class="math inline">\(C\)</span></span>) and needs to produce an output that is indistinguishable from the output of <span><span class="math inline">\(V^*\)</span></span>. It will do so as follows:</p>
<ol start="0" type="1">
<li><p>Pick <span><span class="math inline">\(b&#39;\in\{0,1\}\)</span></span>.</p></li>
<li><p>Let <span><span class="math inline">\(z\in \{0,1\}^{3n}\)</span></span> be the first message computed by <span><span class="math inline">\(V^*\)</span></span> on input <span><span class="math inline">\(H\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(b&#39;=0\)</span></span> then <span><span class="math inline">\(S^*\)</span></span> computes the second message as Alice does: chooses a random permutation <span><span class="math inline">\(\pi\)</span></span> on <span><span class="math inline">\(\{1,\ldots, n\}\)</span></span> and let <span><span class="math inline">\(M\)</span></span> be the <span><span class="math inline">\(\pi\)</span></span>-permuted adjacency matrix of <span><span class="math inline">\(H\)</span></span> (i.e., <span><span class="math inline">\(M_{\pi(i),\pi(j)}=1\)</span></span> iff <span><span class="math inline">\((i,j)\)</span></span> is an edge in <span><span class="math inline">\(H\)</span></span>). In contrast, if <span><span class="math inline">\(b&#39;=1\)</span></span> then <span><span class="math inline">\(S^*\)</span></span> lets <span><span class="math inline">\(M\)</span></span> be the all <span><span class="math inline">\(1&#39;\)</span></span> matrix. For every <span><span class="math inline">\(i,j\)</span></span>, <span><span class="math inline">\(S^*\)</span></span> chooses a random string <span><span class="math inline">\(x_{i,j} \in \{0,1\}^n\)</span></span> and let <span><span class="math inline">\(y_{i,j}=G(x_{i,j})\oplus M_{i,j}z\)</span></span>, where <span><span class="math inline">\(G:\{0,1\}^n\rightarrow\{0,1\}^{3n}\)</span></span> is a pseudorandom generator.</p></li>
<li><p>Let <span><span class="math inline">\(b\)</span></span> be the output of <span><span class="math inline">\(V^*\)</span></span> when given the input <span><span class="math inline">\(H\)</span></span> and the first message <span><span class="math inline">\(\{ y_{i,j} \}\)</span></span> computed as above. If <span><span class="math inline">\(b\neq b&#39;\)</span></span> then go back to step 0.</p></li>
<li><p>We compute the fourth message of the protocol similarly to how Alice does it: if <span><span class="math inline">\(b=0\)</span></span> then it consists of <span><span class="math inline">\(\pi\)</span></span> and the strings <span><span class="math inline">\(\{ x_{i,j} \}\)</span></span> for all <span><span class="math inline">\(i,j\)</span></span>; If <span><span class="math inline">\(b=1\)</span></span> then we pick a random length-<span><span class="math inline">\(n\)</span></span> cycle <span><span class="math inline">\(C&#39;\)</span></span> and the message consists of the <span><span class="math inline">\(n\)</span></span> strings <span><span class="math inline">\(x_{C&#39;_1,C&#39;_2}\)</span></span>,<span><span class="math inline">\(\ldots\)</span></span>,<span><span class="math inline">\(x_{C&#39;_n,C&#39;_1}\)</span></span> together with their indices.</p></li>
<li><p>Output whatever <span><span class="math inline">\(V^*\)</span></span> outputs when given the prior message.</p></li>
</ol>
<p>We prove the output of the simulator is indistinguishable from the output of <span><span class="math inline">\(V^*\)</span></span> in an actual interaction by the following claims:</p>
<p><strong>Claim 1:</strong> The message <span><span class="math inline">\(\{ y_{i,j} \}\)</span></span> computed by <span><span class="math inline">\(S^*\)</span></span> is computationally indistinguishable from the first message computed by Alice.</p>
<p><strong>Claim 2:</strong> The probability that <span><span class="math inline">\(b=b&#39;\)</span></span> is at least <span><span class="math inline">\(1/3\)</span></span>.</p>
<p><strong>Claim 3:</strong> The fourth message computed by <span><span class="math inline">\(S^*\)</span></span> is computationally indistinguishable from the fourth message computed by Alice.</p>
<p>We will simply sketch here the proofs (again see Goldreich’s book for full proofs):</p>
<p>For Claim 1, note that if <span><span class="math inline">\(b&#39;=0\)</span></span> then the message is <em>identical</em> to the way Alice computes it. If <span><span class="math inline">\(b&#39;=1\)</span></span> then the difference is that <span><span class="math inline">\(S^*\)</span></span> computes some strings <span><span class="math inline">\(y_{i,j}\)</span></span> of the form <span><span class="math inline">\(G(x_{i,j})+z\)</span></span> where Alice would compute the corresponding strings as <span><span class="math inline">\(G(x_{i,j})\)</span></span> this is indistinguishable because <span><span class="math inline">\(G\)</span></span> is a pseudorandom generator (and the distribution <span><span class="math inline">\(U_{3n}\oplus z\)</span></span> is the same as <span><span class="math inline">\(U_{3n}\)</span></span>).</p>
<p>Claim 2 is a corollary of Claim 1. If <span><span class="math inline">\(V^*\)</span></span> managed to pick a message <span><span class="math inline">\(b\)</span></span> such that <span><span class="math inline">\(\Pr[ b=b&#39; ] &lt; 1/2 - negl(n)\)</span></span> then in particular it could distinguish between the first message of Alice (that is computed independently of <span><span class="math inline">\(b&#39;\)</span></span> and hence contains no information about it) from the first message of <span><span class="math inline">\(V^*\)</span></span>.</p>
<p>For Claim 3, note that again if <span><span class="math inline">\(b=0\)</span></span> then the message is computed in a way identical to what Alice does. If <span><span class="math inline">\(b=1\)</span></span> then this message is also computed in a way identical to Alice, since it does not matter if instead of picking <span><span class="math inline">\(C&#39;\)</span></span> at random, we picked a random permutation <span><span class="math inline">\(\pi\)</span></span> and let <span><span class="math inline">\(C&#39;\)</span></span> be the image of the Hamiltonian cycle under this permutation.</p>
<p>This completes the proof of the theorem.</p>
</div>
<h3 data-number="15.4.1" id="why-is-this-interesting">Why is this interesting?</h3>
<p>The reason that a protocol for Hamiltonicity is more interesting than a protocol for quadratic residuosity is that Hamiltonicity is an NP-complete question. This means that for every other NP language <span><span class="math inline">\(L\)</span></span>, we can use the reduction from <span><span class="math inline">\(L\)</span></span> to Hamiltonicity combined with protocol ZK-Ham to give a zero knowledge proof system for <span><span class="math inline">\(L\)</span></span>. In particular this means that we can have zero knowledge proofs for the following languages:</p>
<ul>
<li><p>The language of numbers <span><span class="math inline">\(m\)</span></span> such that there exists a prime <span><span class="math inline">\(p\)</span></span> dividing <span><span class="math inline">\(m\)</span></span> whose remainder modulo <span><span class="math inline">\(10\)</span></span> is <span><span class="math inline">\(7\)</span></span>.</p></li>
<li><p>The language of tuples <span><span class="math inline">\(X,e,c_1,\ldots,c_n\)</span></span> such that <span><span class="math inline">\(c_i\)</span></span> is an encryption of a number <span><span class="math inline">\(x_i\)</span></span> with <span><span class="math inline">\(\sum x_i = X\)</span></span>. (This is essentially what we needed in the voting example above).</p></li>
<li><p>For every efficient function <span><span class="math inline">\(F\)</span></span>, the language of pairs <span><span class="math inline">\(x,y\)</span></span> such that there exists some input <span><span class="math inline">\(r\)</span></span> satisfying <span><span class="math inline">\(y=F(x\|r)\)</span></span>. (This is what we often need in the “protocol compiling” applications to show that a particular output was produced by the correct program <span><span class="math inline">\(F\)</span></span> on public input <span><span class="math inline">\(x\)</span></span> and private input <span><span class="math inline">\(r\)</span></span>.)</p></li>
</ul>
<figure>
<img src="../figure/zk-ham.jpg" id="tmplabelfig" style="width:80.0%" alt="" /><figcaption>21.1: Using a zero knowledge protocol for Hamiltonicity we can obtain a zero knowledge protocol for any language <span><span class="math inline">\(L\)</span></span> in NP. For example, if the public input is a SAT formula <span><span class="math inline">\(\varphi\)</span></span> and the Prover’s secret input is a satisfying assignment <span><span class="math inline">\(x\)</span></span> for <span><span class="math inline">\(\varphi\)</span></span> then the verifier can run the reduction on <span><span class="math inline">\(\varphi\)</span></span> to obtain a graph <span><span class="math inline">\(H\)</span></span> and the prover can run the same reduction to obtain from <span><span class="math inline">\(x\)</span></span> a Hamiltonian cycle <span><span class="math inline">\(C\)</span></span> in <span><span class="math inline">\(H\)</span></span>. They can then run the ZK-Ham protocol to prove that indeed <span><span class="math inline">\(H\)</span></span> is Hamiltonian (and hence the original formula was satisfiable) without revealing any information the verifier could not have obtain on his own.</figcaption>
</figure>
<h2 data-number="15.5" id="parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures.">Parallel repetition and turning zero knowledge proofs to signatures.</h2>
<p>While we talked about amplifying zero knowledge proofs by running them <span><span class="math inline">\(n\)</span></span> times one <em>after</em> the other, one could also imagine running the <span><span class="math inline">\(n\)</span></span> copies <em>in parallel</em>. It is not trivial that we get the same benefit of reducing the error to <span><span class="math inline">\(2^{-n}\)</span></span> but it turns out that we do in the cases we are interested in here. Unfortunately, zero knowledge is not necessarily preserved. It’s an important open problem whether zero knowledge is preserved for the ZK-Ham protocol mentioned above.<br />
However, Fiat and Shamir showed that in protocols (such as the ones we showed here) where the verifier only sends random bits, then if we replaced this verifier by a <em>random function</em>, then both soundness and zero knowledge are preserved. This suggests a <em>non-interactive</em> version of these protocols in the random oracle model, and this is indeed widely used. Schnorr designed signatures based on this non interactive version.</p>
<h3 data-number="15.5.1" id="bonus-features-of-zero-knowledge">“Bonus features” of zero knowledge</h3>
<ul>
<li><p>Proof of knowledge</p></li>
<li><p>Deniability / non-transferability</p></li>
</ul>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>In case you are curious, the factors of <span><span class="math inline">\(m\)</span></span> are <span><span class="math inline">\(1,172,192,558,529,627,184,841,954,822,099\)</span></span> and <span><span class="math inline">\(328,963,108,995,562,790,517,498,071,717\)</span></span>.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>To be fair, “only” about 170 million Americans live in the <a href="https://www.currentresults.com/Weather-Extremes/US/largest-cities-list.php">50 largest metropolitan areas</a> and so arguably many people will survive at least the initial impact of a nuclear war, though it had been estimated that even a “small” nuclear war involving detonation of 100 not too large warheads could have <a href="http://onlinelibrary.wiley.com/doi/10.1002/2013EF000205/full">devastating global consequences</a>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>As we’ll see, technically what Alice needs to do in such a scenario is use a <em>zero knowledge proof of knowledge</em> of a solution for <span><span class="math inline">\(P\)</span></span>.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>Integers can be coded as sets in various ways. For example, one can encode <span><span class="math inline">\(0\)</span></span> as <span><span class="math inline">\(\emptyset\)</span></span> and if <span><span class="math inline">\(N\)</span></span> is the set encoding <span><span class="math inline">\(n\)</span></span>, we can encode <span><span class="math inline">\(n+1\)</span></span> using the <span><span class="math inline">\(n+1\)</span></span>-element set <span><span class="math inline">\(\{ N \} \cup N\)</span></span>.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>People have considered the notion of zero knowledge systems where soundness holds only with respect to efficient provers; these are known as <em>argument systems</em>.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>Goldreich, Micali and Wigderson were the first to come up with a zero knowledge proof for an NP complete problem, though the Hamiltoncity protocol here is from a later work by Blum. We use Naor’s commitment scheme.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/crypto" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 07/22/2020 10:34:56</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
