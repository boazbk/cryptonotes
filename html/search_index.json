[["lec_14_PvsNP.html", "What if P equals NP?", " what if p equals np  search-to-decision  you dont have to believe in god but you should believe in the book no more half measures walter the evidence in favor of  p   np and  its algebraic counterpart  is so overwhelming and the consequences of their failure are so grotesque that their status may perhaps be compared to that of physical laws rather than that of ordinary mathematical conjectures suppose aliens invade the earth and threaten to obliterate it in a years time unless human beings can find the fifth ramsey number we could marshal the worlds best minds and fastest computers and within a year we could probably calculate the value if the aliens demanded the sixth ramsey number however we would have no choice but to launch a preemptive attack what if  p np but the best algorithm for sat takes n time sat is very easy sat is very hard search-to-decision reduction if find  search vs decision     some  optimization optimal longest   yes optimization from  p np    binary search   optimization problems linear programming integer  valued integer programming weighted objective function is need for binary search example supervised learning supervised learning examples labels hypothesis predictor predict occams razor principle parameters example breaking cryptosystems cryptography finding mathematical proofs proof system proof system verifier statement candidate proof sequence axiom inference rule quantifier elimination advanced search optimization yes we can there exists independent set there exists for every smallest there exists for every there exists polynomial hierarchy collapse   negation  quantified boolean formula application self improving algorithm for   sat best possible there exists for every there exists approximating counting problems and posterior sampling advanced optional approximate counting if  p np witnesses posterior sampling and probabilistic programming sampling posterior sampling what does all of this imply how the laws of nature have this amazing feeling of inevitability which is associated with local perfection the classical picture of the world is the top of a local mountain in the space of ideas and you go up to the top and it looks amazing up there and absolutely incredible and you learn that there is a taller mountain out there find it mount quantum theyre not smoothly connected  youve got to make a jump to go from classical to quantum  this also tells you why we have such major challenges in trying to extend our understanding of physics we dont have these knobs and little wheels and twiddles that we can turn we have to learn how to make these jumps and it is a tall order and thats why things are difficult new type of understanding  can  p    np be neither true nor false no failure programs short is  p np in practice worst case not heuristics some proxy measures what if  p    np cannot cannot be broken public key cryptography electronic cash secure multiparty computation randomness positive proving restricted forms general exist  exercises bibliographical notes"], ["lec_24_proofs.html", "Proofs and algorithms", " proofs and algorithms lets not try to define knowledge but try to define zero-knowledge proofs elements exercises bibliographical notes"], ["lec_07_other_models.html", "Equivalent models of computation", " equivalent models of computation   all problems in computer science can be solved by another level of indirection because we shall later compute with expressions for functions we need a distinction between functions and forms and a notation for expressing this distinction this distinction and a notation for describing it from which we deviate trivially is given by church turing completeness turing equivalence church-turing thesis every ram machines random access memory ram turing equivalence cellular automata configurations gdels incompleteness theorem   calculus infinite finite ram machines and nand-ram random access memory ram pointer ram machine word ram model word word size registers ram machine data movement computation control flow nand-ram programming language integer valued indexed access false true  turing machines aka nand-tm programs and ram machines aka nand-ram programs are equivalent indexed access a indexed access b boolean valued integer valued indexed access of bit arrays a two dimensional bit arrays two dimensional arrays two indices two dimensional arrays arrays of integers integers bits  primary memory    ram machines  nand-ram and assembly language optional the gory details optional is you indexed access in nand-tm indexed access while two dimensional arrays in nand-tm one to one all the rest recursion stack machine languages recursion in nand-ram advanced turing equivalence discussion turing equivalent turing complete the best of both worlds paradigm prove a theorem can not can be computed cant can have our cake and eat it too cant can  lets talk about abstractions the talk level of abstraction implementation level pseudocode formal low level implementation pseudocode representation low level specification intermediate implementation level defining algorithms algorithm turing completeness and equivalence a formal definition optional computational model program function computational model turing complete turing equivalent computational model  m-computes turing complete turing equivalent turing completeness and equivalence optional cellular automata cellular automata two dimensional cellular automaton state one dimensional cellular automaton two dimensional cellular automaton one dimensional cellular automaton one dimensional cellular automation transition rule configuration one dimensional cellular automata finite configuration finite one dimensional cellular automata are turing complete one dimensional automata are turing complete configurations configuration configurations of turing machines and the next-step function configurations configuration configuration of m configuration of turing machines you  snapshot   completing the proof of a hrefonedimcathmtheorem a one dimensional automata are turing complete formal statement  nand-tm program configurations of nand-tm programs lambda calculus and functional programming languages the  operator python javascript scheme dropping parenthesis applying functions to functions    obtaining multi-argument functions via currying formal description of the  calculus  expression application abstraction  expression recursive definition arithmetic expression free and bound variables free bound precedence and parenthesis equivalence of  expressions equivalent form equivalence equivalent evaluation aka   reduction variable renaming aka   conversion equivalence of  expressions call by name lazy evaluation call by value eager evaluation pure simplification evaluation    reduction renaming    conversion canonical simplification equivalent simplification of  expressions equivalence of  expressions  infinite loops in the  calculus the enhanced  calculus enhanced  calculus boolean constants and if function pairs pairing lists and strings empty list lists string list operations list-processing functions recursion recursive functions anonymous compute nand using  calculus  compute xor using  calculus  link pointer reference computing a function in the enhanced  calculus enhanced  expression application abstraction exp computes f computing a function via  calculus enhanced  calculus is turing-complete  lambda calculus and nand-tm      every initial configuration  from enhanced to pure  calculus all   enhanced  calculus equivalent to pure  calculus natural numbers church numerals optional list processing the y combinator or recursion without recursion python itself non recursive two inputs  two from python to the   calculus fixed point operators fixed point fixed point the y combinator the church-turing thesis discussion in  church had been speculating and finally definitely proposed that the -definable functions are all the effectively calculable functions  when church proposed this thesis i sat down to disprove it  but quickly realizing that my approach failed i became overnight a supporter of the thesis the thesis is not so much a definition or to an axiom but  a natural law computable church-turing thesis efficient extended efficiently different models of computation computational problems type of model examples memory bounded finite automata finite state machines regular languages   exercises key value alternative proof for tmram equivalence nand-tm lookup pairing shortest path longest simple path efficient longest path shortest path  expression next-step function is local  hint  calculus requires at most three variables evaluation order example in  calculus list of n pairs zip function without using   recurse next-step function without recurse  calculus to nand-tm compiler challenging at least two at least two in   calculus locality of the next step function not configuration locality of next-step function bibliographical notes haskell types"], ["lec_10_efficient_alg.html", "Efficient computation", " efficient computation   the problem of distinguishing prime numbers from composite and of resolving the latter into their prime factors is  one of the most important and useful in arithmetic  nevertheless we must confess that all methods  are either restricted to very special cases or are so laborious  they try the patience of even the practiced calculator  and do not apply at all to larger numbers for practical purposes the difference between algebraic and exponential order is often more crucial than the difference between finite and non-finite what is the most efficient way to sort a million -bit integers i think the bubble sort would be the wrong way to go  computable time function of their input length best best known number function  exponential polynomial exponential insensitive polynomial not-too-large exponent exponential np completeness part i quantitative study finite functions part ii qualitative study infinite functions unbounded input length qualitative question part iii quantitative study infinite functions scale polynomially relations between parts of this book problems on graphs graphs vertices edges directed undirected adjacency list adjacency matrix finding the shortest path in a graph shortest path problem exponential queue queue weighted degree data structures lists arrays queues stacks heaps search trees hash tables some on data structures finding the longest path in a graph longest path problem longest maximally long longest path problem knights tour finding the minimum cut in a graph cut st cut minimum st cut problem cut cut bottlenecks polynomial min-cut max-flow and linear programming flow maximum st flow at most at least maximum flow flow linear programming global global minimum cut reduction  finding the maximum cut in a graph maximum cut maximizes maximum cut a note on convexity convex local minimum global minimum non convex convex convex local minimum global minimum maximizing concave linear discrete maximum empirical risk minimization training examples classifier errors loss function square loss linear function linear regression non convex beyond graphs sat propositional formula conjunctive normal form literal satisfiability problem satisfying assignment true sat sat problem satisfies literals implication sat solving linear equations inequalities integer exponential bit complexity of numbers solving quadratic equations linear quadratic more advanced examples determinant of a matrix nonsingular orthogonal inversions triangular triangular permanent of a matrix permanent permanent modulo  boolean permanent modulo  finding a zero-sum equilibrium zero sum game distribution finding a nash equilibrium equilibrium primality testing exponential probabilistic integer factoring find non existence our current knowledge factoring inherently require exponential gap  exercises  hint exponential time algorithm for longest path  sat algorithm bipartite cliques reductions for showing algorithms bibliographical notes further explorations"], ["lec_00_0_preface.html", "Preface", " preface we make ourselves no promises but we cherish the hope that the unobstructed pursuit of useless knowledge will prove to have consequences in the future as in the past an institution which sets free successive generations of human souls is amply justified whether or not this graduate or that makes a so-called useful contribution to human knowledge a poem a symphony a painting a mathematical truth a new scientific fact all bear in themselves all the justification that universities colleges and institutes of research need or require i suggest that you take the hardest courses that you can because you learn the most when you challenge yourself cs  i found pretty hard tool lens universality code data proofs reduction inherently intractable notion python c lisp to the student actively before definitions theorems theorem statement proof precise is the effort worth it different way of thinking energy matter computation information to potential instructors finite automata boolean circuits every code data universality restricted computational model liveness safety tractable semantic questions after time complexity functions languages decides a language computes a function specification function implementation program proofs programs acknowledgements"], ["lec_08a_restricted_models.html", "Restricted computational models", " restricted computational models  regular expressions context-free grammars semantic properties  happy families are all alike every unhappy family is unhappy in its own way turing equivalent uncomputable restricted computational models a b restricted computational models semantic questions  can not turing completeness as a bug the dao is borne from immutable unstoppable and irrefutable computer code the dao hack regular expressions searching search problem matched function program python not restricted computational models rich enough restricted regular expression or regular expression regular expression matches  matches regular function notation languages regular matching a regular expression   a regular function binary case generative models regular expression always halt  computing  smaller case  case  case   deterministic finite automata and efficient matching of regular expressions optional linear matching regular expressions in linear time  restriction input goal operation regular expression matching in linear time running time claim proof of claim i ii i ii   matching regular expressions using constant memory single pass if and only if  dfa for regular expression matching   input goals operation copy the variables  ve  to temporary variables update the variables  ve  based on the i-th bit of x constant memory regular expression matching  deterministic finite automata deterministic finite automaton dfa finite state machine dfa for xor transition function accepting states computes deterministic finite automaton   dfa and regular expression equivalency   with all intermediate states being in the set t  t- base case inductive step  regular functions are closed under complement  regular expressions closed under complement  limitations of regular expressions  matching parenthesis pumping lemma pumping lemma   if a string matching a regular expression is long enough one of its substrings must be matched using the  operator  somewhere base case inductive step a b c a b c   recursively defined induction recursive definitions and inductive proofs  not not there exists for every there exists for every there exists for every palindrome palindromes is not regular  other semantic properties of regular expressions tokens semantic questions equivalent  emptiness of regular languages is computable     equivalence of regular expressions is computable    context free grammars syntax error infinite loop syntax do not restricted context free grammars digit number operation expression number sub-expression operation sub-expression sub-expression recursive rules recursive context free grammar cfg over   variables initial variable rules can be derived context free grammar context free grammar for arithmetic expressions context-free grammars as a computational model can be derived in one step can be derived matched function computed by context free language function context free deriving a string from a grammar  context-free grammars always halt chomsky normal form  deciding tree root leaves parse tree parser parse trees the power of context free grammars  context free grammars and regular expressions case  case  case  recursion  context free grammar for palindromes  not non palindromes not  limitations of context-free grammars optional not  context-free pumping lemma if a long enough string is matched by a grammar there must be a variable that is repeated in the derivation  recursion  equality is not context-free  semantic properties of context free languages  emptiness for cfgs is decidable  non empty   uncomputability of context-free grammar equivalence optional uncomputable  fullness of cfgs is uncomputable not configurations configuration not every  configurations configuration initial halting configuration computation history reversed claim not at least one is not  summary of semantic properties for regular expressions and context-free grammars expressiveness amenability to analysis not  semantic regular expressions context free grammars  exercises closure properties of regular functions  non regularity closure properties of context-free functions  variables statement program syntax for programming languages bibliographical notes non deterministic finite automata always context general aka type  grammars recursively enumerable context sensitive grammars"], ["lec_20_alg_society.html", "Algorithms and society", " algorithms and society exercises bibliographical notes"], ["lec_06_loops.html", "Loops and infinity", " loops and infinity  turing machines arbitrary input lengths loops arrays  an algorithm is a finite answer to an infinite number of questions the bounds of arithmetic were however outstepped the moment the idea of applying the punched cards had occurred and the analytical engine does not occupy common ground with merecalculating machines  in enabling mechanism to combine together general symbols in successions of unlimited variety and extent a uniting link is established between the operations of matter and the abstract mental processes of the most abstract branch of mathematical science  finite single recipe single parity xor single loops address repeat loop turing machines nand-tm programming language loops arrays equivalent turing equivalence turing completeness finite functions unbounded turing machines loops finite unbounded infinite language finite vs infinite computation turing machines computing is normally done by writing certain symbols on paper we may suppose that this paper is divided into squares like a childs arithmetic book the behavior of the human computer at any moment is determined by the symbols which he is observing and of his state of mind at that moment we may suppose that in a simple operation not more than one symbol is altered we compare a man in the process of computing  to a machine which is only capable of a finite number of configurations the machine is supplied with a tape the analogue of paper  divided into sections called squares each capable of bearing a symbol what is the difference between a turing machine and the modern computer its the same as that between hillarys ascent of everest and the establishment of a hilton hotel on its peak turing machine tape alphabet l r s h transition function extended example a turing machine for palindromes palindromes palindrome i ii transition function transition function turing machines a formal definition tape turing machine transition function output turing machine  transition function finite infinite computable functions computable functions computes computable computable functions church turing thesis extended any possible algorithm  functions not programs compute functions  computable the class  r formal language theory formal language membership decision decides decidable recursive functions functions vs languages infinite loops and partial functions some partial function partial function subset computes computable computable partial or total functions does not necessary bot symbol turing machines as programming languages program program programs tape list array head position state local register boolean the nand-tm programming language nand-tm programming language single uniform algorithm arbitrary lengths loops straight-line loops arrays scalar array index  python c javascript ocaml nand-circ  loops  arrays  everything integer valued boolean valued scalars arrays scalar array arrays scalar variables arrays default values boolean four nand-tm program scalar variables array variables nand-tm programs sneak peak nand-tm vs turing machines examples xor in nand-tm increment function increment in nand-tm  equivalence of turing machines and nand-tm programs  turing machines and nand-tm programs are equivalent    every   tape arrays state scalar variables exists every  running time equivalence optional specification vs implementation again function functions programs machines nand-tm syntactic sugar goto and inner loops looping constructs other loops python java javascript invariants our intellectual powers are rather geared to master static relations and  our powers to visualize processes evolving in time are relatively poorly developed we should  do our utmost best to shorten the conceptual gap between the static program and the dynamic process java gotos in programming languages uniformity and nand vs nand-tm discussion collection uniformity uniform nonuniform uniform non uniform non uniform computational models nand-circ programs boolean circuits finite every some infinite sequence single algorithm uniform computational models turing machines nand-tm programs arbitrary length infinite infinite loop not  turing machines nand-tm programs infinite loop  exercises majority explicit nand tm programming computable functions examples two two index nand-tm two tape turing machine two tape turing machines two dimensional two dimensional arrays two-dimensional turing machine two dimensional two dimensional turing machines  oblivious oblivious turing machines challenging  single vs multiple bit countable uncomputability via counting all not explicit not every function is computable bibliographical notes analytical engine programs enigma seven tuple halting states rejecting state accepting state deciding a language input alphabet tape alphabet recognizes recursively enumerable"], ["lec_09_godel.html", "Is every theorem provable?", " is every theorem provable   take any definite unsolved problem such as  the existence of an infinite number of prime numbers of the form n   however unapproachable these problems may seem to us and however helpless we stand before them we have nevertheless the firm conviction that their solution must follow by a finite number of purely logical processes this conviction of the solvability of every mathematical problem is a powerful incentive to the worker we hear within us the perpetual call there is the problem seek its solution you can find it by pure reason for in mathematics there is no ignorabimus the meaning of a statement is its method of verification gdels incompleteness theorem inherently unprovable turing machine configurations hilberts program and gdels incompleteness theorem and what are these vanishing increments they are neither finite quantities nor quantities infinitely small nor yet nothing may we not call them the ghosts of departed quantities hilbert program  true provable gdels incompleteness theorem  informal version defining proof systems axioms inference rules mathematical statements string false the number   is prime programs  proof systems proof effectiveness soundness proof system effectiveness soundness unprovable complete proof systems proof verification algorithm  gdels incompleteness theorem computational variant gdels incompleteness theorem computational variant   not  fixed point true the gdel statement optional quantified integer statements programs natural numbers quantified integer statements  quantified integer statement quantified integer statements syntactic sugar for quantified integer statements v is not sound or v is not complete gdels incompleteness theorem for quantified integer statements  uncomputability of quantified integer statements every  diophantine equations and the mrdp theorem quintic group theory by any means diophantine equations integer no method mrdp theorem code data active code vs static data hardness of quantified integer statements easier solutions uncomputable  quantified mixed statements easier step  quantified mixed statements and computation histories quantified mixed statements string variables quantified mixed statement quantified mixed statements  uncomputability of quantified mixed statements  configuration quantified mixed statement computation history history  configuration configuration i ii iii for every for every  alternative proofs step  reducing mixed statements to integer statements integer integers  constructible prime sequence    exercises gdels theorem from uncomputability of qis halts on every input xv hint proof systems and uncomputability  expression for floor  sound axiomatic proof systems puzzle problem types of puzzle pieces post corrrespondence problem square tiling uncomputability of puzzle quadratic integer equation problem quadratic mrdp exercise faster the busy beaver problem bibliographical notes continuum hypothesis"], ["lec_12_NP.html", "Polynomial time reductions", " polynomial-time reductions  polynomial-time reductions  sat longest path maximum cut quadratic equations search computationally equivalent  np completeness reduction paradigm reduce does not exist inherently intractable formal definitions of problems decision problems boolean sat sat problem true quadratic equations quadratic equations problem longest path longest path problem maximum cut maximum cut problem polynomial-time reductions polynomial-time reduction reduction  f reduces to g equivalent complexity polynomial-time reductions reductions and  p   reduction  min-cut max-flow no polynomial-time algorithm uncomputability polynomial time transitivity of reductions transitivity of polynomial-time reductions  reducing sat to zero one equations zero-one linear equations problem real numbers gaussian elimination  hardness of eq  inequality equality takeaway technique auxiliary variables  completeness soundness completeness soundness  anatomy of a reduction what analysis why algorithm description how algorithm analysis how why analysis efficient correct efficiency completeness completeness soundness quadratic equations quadratic equations quadratic  hardness of quadratic equations  takeaway technique nonlinearity   the independent set problem stable set maximum independent set scheduling problems  hardness of independent set  takeaway technique gadget  conflicting literals triangle conflicting part  completeness true true part  soundness independent set true  python every clique clique is equivalent to independent set complement not clique  reducing independent set to maximum cut maximum cut  hardness of max cut  takeaway technique  part  completeness part  soundness  reducing sat to longest path note shortest path longest path  hardness of longest path    summary of relations equivalent complexity reductions not transitivity  exercises bibliographical notes mapping reduction many to one reduction karp reduction maximal maximum vertex cover maximum maximal sat solvers"], ["lec_26_quantum_computing.html", "Quantum computing", " quantum computing   we always have had secret secret close the doors  a great deal of difficulty in understanding the world view that quantum mechanics represents  it has not yet become obvious to me that theres no real problem  can i learn anything from asking this question about computersabout this may or may not be mystery as to what the world view of quantum mechanics is the only difference between a probabilistic classical world and the equations of the quantum world is that somehow or other it appears as if the probabilities would have to go negative aristotle essence reasons democritus atoms state the double slit experiment metal barrier with a single slit even more dented photons fewer not hit at all when both slits are open destructive fewer measure   quantum amplitudes not measure amplitude negative complex measure constructive destructive amplitudes cancellations  either not hit at all real negative pure mixed complex vs real other simplifications linear algebra quick review linear algebra complex linear inner product norm unit vector orthogonal orthonormal basis standard basis matrix unitary transpose matrix product bells inequality is disagree agree  bells inequality  deterministic randomized distributions averaging principle randomized strategies quantum weirdness interference measurement measured entanglement quantum entanglement quantum computing and computation - an executive summary exponential a b quantum computer physical extended church turing thesis not not grovers algorithm some not quantum computing and  np structured  quantum systems quantum classical logical bit classical local probabilistic distribution negation basis matrices vectors bases norms  quantum amplitudes complex real norm preserving complex hadamard quantum systems an executive summary state quantum system quantum operation unitary matrix transpose measure collapses analysis of bells inequality optional   case  x and y case  x and y case  case  x and y   opposing directions destructive interference quantum vs probabilistic strategies quantum computation basic operations non uniform models of computation uniform models of computation efficient computation quantum computation non uniform quantum circuits quantum circuit out degree measuring reversible three hadamard quantum circuit quantum circuit measure computes quantum circuit of n inputs m-n auxiliary bits and s gates computes quantum circuit   polynomial size quantum circuits   bqppoly probabilistic computation exponential space polynomial space prove known the obviously exponential fallacy qnand-circ programs optional measure uniform computation uniform qnand-tm programming language  the class  bqp      incomparable uniformly restricting attention to circuits physically realizing quantum computation universal sets collapsing coherence time theorems shors algorithm hearing the shape of prime factors no shors algorithm period finding periods periodic musical notes periodic wave length frequency chord every wave shors algorithm a birds eye view step  reduce to period finding  periodic  discrete logarithm step  period finding via the quantum fourier transform measure quantum fourier transform x-th fourier coefficient frequency greatest common divisor shors algorithm sketch input output operations quantum fourier transform period  quantum fourier transform not quantum state quantum fourier transform quantum fourier transform advanced optional quantum fourier transform group group theory finite commutative aka abelian groups group binary operation associative commutative abelian group theory every fourier coefficient of f corresponding to g fourier expansion fourier transform fourier coefficients fourier characters homomorphisms h periodic quantum fourier transform over the boolean cube simons algorithm qft over the boolean cube  hadamard fourier transform   from fourier to period finding simons algorithm advanced optional h periodic linear from simon to shor advanced optional can not not  exponentially faster  exercises quantum and classical complexity class relations generator order discrete logarithm discrete logarithm from order finding bibliographical notes"], ["lec_00_1_math_background.html", "Mathematical Background", " mathematical background  definitions statements proofs  i found that every number which may be expressed from one to ten surpasses the preceding by one unit afterwards the ten is doubled or tripled  until a hundred then the hundred is doubled and tripled in the same manner as the units and the tens  and so forth to the utmost limit of numeration a mathematicians apology computation is there an efficient algorithm to find the prime factors of a given integer phrase definition algorithm efficient nonexistence mathematical proof this chapter a readers manual discrete probability a quick overview of mathematical prerequisites proofs definitions statements proofs sets relations operations tuples and strings alphabet some special sets functions domain codomain one-to-one injective onto surjective partial functions logical operations basic combinatorics graphs big-o notation discrete probability probability theory finite random variables expectation concentration reading mathematical texts precise nature definitions assertions proofs definitions  one to one injective one to one function assertions theorems lemmas claims theorem lemma claim proofs proofs definitions theorems theorem statement proof basic discrete math objects sets set cardinality infinite subset superset empty set strict subset operations on sets union or intersection and set difference not tuples lists strings sequences tuple ordered pair tuples lists string length sequences function cartesian product cartesian product special sets natural numbers integers numbers real positive strings all generalizing the star operation concatenation concatenation functions function domain codomain image range range remainder one-to-one injective injection onto surjective surjection bijective bijection permutation infinite partial functions partial total total basic facts about functions composition a b c infinite b c definition onto at least one-to-one at most      onto  graphs graphs undirected directed  undirected graph vertices neighbors undirected graphs degree path simple path cycle connected connected    transitive    connected vertices have simple paths shortest  finding proofs directed graphs  directed graph ordered pairs out-neighbor in-neighbor directed graphs in-degree out-degree path simple path cycle directed acyclic graphs dags  directed acyclic graph dag directed acyclic graphs      shortest path  labeled graphs labels labelling function labeled graphs logic operators and quantifiers and or negation parameter unbound for every there exists for sufficiently large n quantifiers for summations and products parsing formulas bound and free variables bound free rename equivalent aside mathematical vs programming notation asymptotics and big-o notation     n has been proved to go to infinity but has never been observed to do so scaling behavior fog f og big-o notation much o is not equality inequalities some rules of thumb for big-o notation big o for other applications optional proofs yourself proofs and programs proofs programs program task yourself machine verifiable readability clear logical flow proof writing style proof qed role patterns in proofs if it was so it might be and if it were so it would be but as it isnt it aint thats logic through the looking-glass proofs by contradiction    even  proofs of a universal statement     proofs of an implication     proofs of equivalence proofs by combining intermediate claims proofs by case distinction a exhaustive one b proofs by induction without loss of generality wlog why structured hierarchical proofs hierarchical proofs optional extended example topological sorting topological sorting layering layering  layering layering of a dag  topological sort     cycle   algorithm  mathematical induction proof by induction induction a b a b b a a b b a b b b b  induction and recursion proving the result by induction for every dag gve with n vertices there is a layering of g for every n if qn- is true then qn is true source proof qed lemmas claims claim proof of claim qed claim case  case  case  case  self loop    type   trying  minimality and uniqueness unique minimal minimal minimal layering is unique unique    why  this book notation and conventions not partial total boolean function deciding a language partial functions promise problem variable name conventions variables type some idioms let x be   let x denote   let x   defining property we say that   has the property x if   where x is   quantifiers for all i   there is x   dependencies for every k  there exists n depends for every natural number k there exists a prime number n such that n divides k there exists a prime number n such that for every natural number k n divides k numbered equations theorems definitions ie eg thus therefore we get that indeed the n-vertex graph g has at least n- edges indeed this follows since g is connected constants scales constants there exists a constant c such that for every n    algorithm a runs in at most c   n steps on inputs of length n algorithm a runs in on time  numbers sets tuples strings graphs functions graphs pairs definitions statements proofs  exercises true odd logical expressions quantifiers   set construction notation existence of one to one mappings inclusion exclusion          o-notation     bibliographical notes graph one to one onto"], ["lec_14a_space_complexity.html", "Space bounded computation", " space bounded computation exercises bibliographical notes"], ["lec_08_uncomputability.html", "Universality and uncomputability", " universality and uncomputability  halting problem reductions  a function of a variable quantity is an analytic expression composed in any way whatsoever of the variable quantity and numbers or constant quantities the importance of the universal machine is clear we do not need to have an infinity of different machines doing different jobs  the engineering problem of producing various machines for various jobs is replaced by the office work of programming the universal machine universality larger universal turing machine universal nand-tm program general purpose computer via software code uncomputable functions universal turing machine some reductions universality or a meta-circular evaluator universal turing machine arbitrary arbitrary self reference universal turing machine universal turing machine universal  interpreter  proving the existence of a universal turing machine string representation string representation of turing machine every some take away points of representation python turing machine dictionary  search tree hash table efficiency of the simulation direct construction of universal turing machines implications of universality discussion a i said to him ho ho youre confusing theory with practice this eval is intended for reading not for computing but he went ahead and did it that is he compiled the eval in my paper into ibm  machine code fixing a bug and then advertised this as a lisp interpreter which it certainly was b themselves is every function computable false uncomputable  uncomputable functions  not     can not any   cannot  diagonalization counting undecidable non recursive the halting problem some wants  uncomputability of halting function  reduce  reduction case  case     is the halting problem really hard discussion they church-turing thesis every will general procedure arbitrary a direct proof of the uncomputability of   halt optional  reductions contrapositive if then if then believe know if pigs could whistle then horses could fly reduction reduces analysis algorithm specification what implementation how analysis why proof reductions are algorithms example halting on the zero problem  halting without input   reduction description of the reduction analysis of the reduction not description analysis claim proof of claim   the hardwiring technique rices theorem and the impossibility of general software verification we cannot certify semantic properties of general purpose programs function semantic property uncomputable  computing all zero function  not   uncomputability of verifying parity  rices theorem semantic specification semantic true false function the program p computes a function f mapping integers to integers satisfying that fn   n for every input n not semantic source code functionally equivalent semantic some semantic properties zerofunc is semantic  semantic rices theorem i ii not  anywhere machines functions algorithm b input goal assumption operation a b  not a b code not does a b  only not computable i ii syntactic semantic is not the same as uncomputable halting and rices theorem for other turing-complete models equivalent  nand-tm machine halting   constructive compute reduction    calculus two dimensional automata is software verification doomed discussion general arbitrary prove software verification universal inherently uncomputable any  exercises nand-ram halt step computable timed halting computable space halting challenging necessarily computable computable compositions  computing parity cannot tm equivalence  hint  recursively enumerable countable not recursively enumerable language recognized by m recursively enumerable a b b rices theorem standard form  m-semantic rices theorem for general turing-equivalent models optional bibliographical notes we have seen a mass of bizarre functions which appear to be forced to resemble as little as possible honest functions which serve some purpose  they are invented on purpose to show that our ancestors reasoning was at fault and we shall never get anything more than that out of them incompleteness theorem recursively enumerable"], ["lec_11_running_time.html", "Modeling running time", " modeling running time  time hierarchy theorem can can not non uniform  max newman alan turing  dependence polynomial time exponential time polynomially related efficient time hierarchy theorem non uniform sequence uncomputable formally defining running time running time function of the length x of the input computable in tn single-tape-turing-machine time tm-time for short running time turing machines  functions machines  boolean functions example of time bounds  polynomial and exponential time extended polynomial exponential polynomial time computable in polynomial time polynomial exponential time computable in exponential time exponential  p and  exp not can  differerent definitions of  p degree  boolean non boolean boolean versions of problems modeling running time using ram machines  nand-ram computable efficiency ram machines computable in tn ram time ram-time for short running time ram relating ram and turing machines  nand-ram programs polynomial exponential design analyze negative result  quantum computers  statement  two dimensional array boolean-valued number of repetitions is at most tn take number of steps polynomial in       tn take otn steps takes otn steps takes otn steps  nice time bound function in the number of bits nice time bounds extended church-turing thesis discussion turing machines ram machines  nand-ram programs extended church turing thesis scalable computing device physical extended church-turing thesis quantum computing efficient universal machine a nand-ram interpreter in nand-ram polynomial constant universal nand-ram program not u is a universal nand-ram program u is efficient efficient universality of nand-ram  statement   timed universal turing machine unary  timed universal turing machine timed  the time hierarchy theorem uncomputable can can not yes  time hierarchy theorem  simpler corollary of the time hierarchy theorem time hierarchy theorem distinct   bounded halting claim  claim  proof of claim  proof of claim  not   p vs  exp  known non uniform computation finite restriction non-uniformly computable in at most tn size non uniform computation single different nonuniform computation contains uniform computation loops oblivious  oblivious nand-tm programs oblivious  making nand-tm oblivious   oblivious  unrolling the loop algorithmic transformation of turing machines to circuits algorithmic turing-machine to circuit compiler  oblivious   alternative characterization of  p   ppoly characterization by advice  can uniform algorithms simulate non uniform ones no uncomputable  uncomputable  ppoly contains uncomputable functions   onto constant  uniformity single efficient inefficient computation uniform vsnonuniform computation a recap uniform models turing machines nand-tm programs ram machines nand-ram programs cjavascriptpython non-uniform models boolean circuits straightline programs hardness easiness some  exercises equivalence of different definitions of  p and  exp robust robustness to representation boolean functions  composition composition of polynomial time  non composition of exponential time oblivious length oblivious hint oblivious turing machines planar  evaluate nand circuits hint find hard function conflicts   prove three  bibliographical notes maximum worst case complexity minimum average case complexity cryptography advice string"], ["lec_17_model_rand.html", "Modeling randomized computation", " modeling randomized computation   any one who considers arithmetical methods of producing random digits is of course in a state of sin worst case amplify yes pseudorandom generators modeling randomized computation running in polynomial time the class  bpp not worst case on every possible randomized polynomial time randomized algorithm choosing from a set  an alternative view random coins as an extra input deterministic two inputs  alternative characterization of  bpp    there exists for every definitions of  bpp and  np random tapes success amplification of two-sided error algorithms amplification amplify    incorrect   bpp and  np completeness yes  np hardness and bpp every    every  the power of randomization extended church turing hypothesis not solving  bpp in exponential time exponential  simulating randomized algorithms in exponential time   simulating randomized algorithms by circuits random every  randomness does not help for non uniform computation  single fixed choice all  amplify union every there exists  derandomization single all input lengths guaranteed to fail general always pseudorandom generators single collection eliminate reducing  t -pseudorandom generator pseudorandom generator seed finite deterministic  pseudorandom what reason do we have to believe that pseudorandom generators with non-trivial parameters exist even if they do exist why would such generators be useful to derandomize randomized algorithms prove interesting exponentially larger  statement proof  from existence to constructivity exists non existence hardness vs randomness optimal prg conjecture exponentially secure pseudorandom generator   conjecture prove exponentially strong pseudorandom functions pseudorandom function generator pseudorandomness usefulness of pseudorandom generators  derandomization of bpp  exponential expansion    p np and  bpp vs  p negative positive  sipsergcs theorem statement   claim i claim ii claim i claim ii claim i claim ii probabilistic method existential proof of claim ii exist not claim i  non-constructive existence of pseudorandom generators advanced optional constructivity exponentially larger  existence of inefficient pseudorandom generators  exists proof technique deterministic  claim i at random sample space all exists does not  worst case on every input amplify exponentiall close to   exercises bibliographical notes entropy uniform"], ["lec_13_Cook_Levin.html", "NP, NP completeness, and the Cook-Levin Theorem", " np np completeness and the cook-levin theorem   in this paper we give theorems that suggest but do not imply that these problems as well as many others will remain intractable perpetually sad to say but it will be many more years if ever before we really understand the mystical power of twoness -sat is easy -sat is hard -dimensional matching is easy -dimensional matching is hard why oh why computationally equivalent search solution every verified cook levin theorem every  np complete the class  np search problem efficiently verified np every certificate witness proof solution certificate witness alternative definition of  np  short and efficiently verifiable proof verifier short asymmetric not not does  np not necessaily closed under complement examples of functions in  np sat    np basic facts about  np verifying is no harder than solving  not easy to verify  np does not mean non-polynomial  np is in exponential time  strict certify reductions and  np  from  np to sat the cook-levin theorem solve verify many  cook-levin theorem equivalent every all  np hard  np complete  np-hardness and  np-completeness single efficiently-verifiable  what does this mean the strict permanent the cook-levin theorem proof outline the   nandsat problem and why it is  np hard input output nandsat    np        claim proof of claim  the   nand problem input output     true part i completeness part ii soundness not smallest do  from   nand to   sat        independent set wrapping up some  all unknown nonexistent average-case complexity approximation algorithms  exercises  hint poor mans ladners theorem hint is  np    co-np    np    p without negations  employee recruiting problem  balanced max cut regular expression intersection bibliographical notes"], ["lec_03_computation.html", "Defining Computation", " defining computation  boolean circuits straight-line programs  there is no reason why mental as well as bodily labor should not be economized by the aid of machinery if unwarned by my example any man shall undertake and shall succeed in constructing an engine embodying in itself the whole of the executive department of mathematical analysis upon different principles or by simpler mechanical means i have no fear of leaving my reputation in his charge for he alone will be fully able to appreciate the nature of my efforts and the value of their results to understand a program you must become both the machine and the program popular mechanics python technology independent specifies what implementing how defining computation how to solve an equation of the form  roots and squares are equal to numbers for instance one square  and ten roots of the same amount to thirty-nine dirhems that is to say what must be the square which when increased by ten of its own root amounts to thirty-nine the solution is this you halve the number of the roots which in the present instance yields five this you multiply by itself the product is twenty-five add this to thirty-nine the sum is sixty-four now take the root of this which is eight and subtract from it half the number of roots which is five the remainder is three this is the root of the square which you sought for the square itself is nine programming languages python informal definition of an algorithm algorithm computes  boolean circuits straight line programs elementary operations boolean circuit straight line program computing using and or and not complex simpler composing either and or and or and majority from andor and not some properties of and and or commutativity associativity distributive law for and and or  extended example computing   xor from   and   or and   not    different  python compute xor on three bits of input associativity commutativity    informally defining basic operations and algorithms semi-formal definition of an algorithm algorithm computes    mechanize transistors physically implement boolean circuits boolean circuits gates inputs wires wires or and not or gate and not inputs output gates mathematical model voltage physical realization of boolean circuits boolean circuit gates wires inputs all equal function  all equal boolean circuits a formal definition and or not directed acyclic graph dag vertices edges and or not boolean circuit input gates and or not outputs boolean circuit inputs gates and or not outputs size boolean circuits topologically sorted  output minimal layering topological sorting and computes computing a function via a boolean circuit boolean circuits nitpicks optional equivalence of circuits and straight-line programs and or not boolean circuit and or not straight-line program straight-line program and or not circuit aon-circ program input output output of p on input x computes aon-circ programming language  or and   equivalence of circuits and straight-line programs  and and   or not  physical implementations of computing devices digression computation implementations fluidics quantum mechanical effects transistors transistor source gate sink standard transistor complementary transistor vacuum tubes transistors semiconductors field effect integrated circuits logical gates from transistors biological computing lac cellular automata and the game of life cellular automata cells neighboring cells neural networks brain neural network threshold gates threshold function corresponding to wt neuron cells artificial neural networks a computer made from marbles and pipes mechanical the nand function  nand computes andornot    i ii   compute majority with nand  nand circuits nand circuits nand circuit for xor  nand is a universal operation    equivalent in power  more examples of nand circuits optional incrementing integers add  to the least significant bit and propagate the carry python increment from increment to addition the nand-circ programming language nand-circ programming language our first nand-circ program   computes computing by a nand-circ program  nand circuits and straight-line program equivalence  no finite infinite is the nand-circ programming language turing complete optional note equivalence of all these models equivalence between models of finite computation   circuitsprograms functions specification implementation circuits with other gate sets  f program universal set of operations general straight-line programs  f circuits gate symmetric universality ifzeroone circuits not specification vsimplementation again specification what implementation how specification implementation function specification what program algorithms implementation how functions programs  algorithm nand-circ programming language  exercises compare  bit numbers compare n bit numbers universal ornot is universal monotone not andor is not universal affine or linear modulo two not xor is not universal majnot  is universal hint majnot  is not universal nor is universal lookup is universal  bound on universal basis size challenge hint size and inputs  outputs  threshold threshold using nands nand approximator affine nands from activation functions majority with nands efficiently hint output at last layer biographical notes difference engine analytical engine principia mathematica"], ["lec_03a_computing_every_function.html", "Syntactic sugar, and computing every function", " syntactic sugar and computing every function  quantitatively  in  i had a running compiler and nobody would touch it because they carefully told me computers could only do arithmetic they could not do programs syntactic sugar causes cancer of the semicolon equivalent every every some examples of syntactic sugar straight-line programming language user-defined procedures procedures subroutines functions procedures  procedure definition synctatic sugar non recursive no recursive procedure majority computing majority from nand using syntactic sugar  present counting lines proof by python optional regular expressions parsing function definitions optional conditional statements   multiplexing  conditional statements synctatic sugar extended example addition and multiplication optional loop  addition using nand-circ programs  multiplication using nand-circ programs the lookup function  lookup lookup function  lookup function constructing a nand-circ program for   lookup  lookup recursion   proof of a hreflookup-thmtheorem a from a hreflookup-rec-lemlemma a every computing every function every  universality of nand  universality of boolean circuits every  improved bounds proof of nands universality every every  some result in perspective improving by a factor of n optional  universality of nand circuits improved bound distinct functions   universality of boolean circuits  improved bound computing every function an alternative proof  universality of boolean circuits alternative phrasing   claim proof of claim  the class   sizet every some  size class of functions functions programs category error programs functions computes equal every all    functions programs specifications implementations functions finite vs infinite functions size closed under complement   efficient  exercises pairing computing mux at least two  majority conditional statements half adder full adder half and full adders  addition  multiplication  hint efficient multiplication challenge multibit function simplifying using syntactic sugar power or and or prove   not computable compare if and nand compare xor and nand circuits for majority threshold circuits for threshold bibliographical notes"], ["lec_15_probability.html", "Probability theory 101", " probability theory    god doesnt play dice with the universe einstein was doubly wrong  not only does god definitely play dice but he sometimes confuses us by throwing them where they cant be seen the probability of winning a battle has no place in our theory because it does not belong to any random experiment probability cannot be applied to this problem any more than the physical concept of work can be applied to the work done by an actor reciting his part i am unable to see why objectivity requires us to interpret every probability as a frequency in some random experiment particularly when in most problems probabilities are frequencies only in an imaginary universe invented just for the purpose of allowing a frequency interpretation random coins events random variables sample spaces event probability of a      intersection union and or even and not not   sample space  event some remember the sample space random variables events how much random variable expectation linear  linearity of expectation   expectation of sum     union bound     union bound distributions over strings real number string distributions distribution identical more general sample spaces probability distribution event random variable correlations and independence independence correlations correlation causation independent not independent positively correlated negatively correlated independent  disjointness independence disjoint independent not disjointness vs independence conditional probability conditioned on a more than two events mutually independent not independent random variables       collections of independent random variables mutually independent  expectation of product of independent random variables  functions preserve independence   concentration and tail bounds independent concentrated concentration tail  markovs inequality  tight    the averaging principle averaging principle    chebyshevs inequality concentrated median chebyshevs inequality standard deviation standard deviation variance standard deviation  chebyshevs inequality   independent and identically distributed the chernoff bound normal gaussian bell curve very exponential decay normal distribution exponentially  chernoffhoeffding bound random variables expectation concentration tail bounds  exercises      not    product of expectations  transformations preserve independence  variance of independent random variables  entropy entropy challenge  hint entropy approximation to binomial  chernoff using stirling  hint hint poor mans chernoff    hint simulating distributions using coins sampling   sampling  bibliographical notes"], ["lec_04_code_and_data.html", "Code as Data, Data as Code", " code as data data as code  exponential physical extended church-turing thesis all  the term code script is of course too narrow the chromosomal structures are at the same time instrumental in bringing about the development they foreshadow they are law-code and executive power - or to use another simile they are architects plan and builders craft - in one a mathematician would hardly call a correspondence between the set of  triples of four units and a set of twenty other unitsuniversal while such correspondence is probably the most fundamental general feature of life on earth data inputs program  code data general purpose general count every at most some at least bounded universal circuit loops turing machine count some exponential representing programs as strings adjacency matrix adjacency list every representing programs as strings  counting programs and lower bounds on the size of nand-circ programs  counting programs  double exponential  counting argument lower bound  every cannot  most  more efficient representation advanced optional size hierarchy theorem optional all some not contained  size hierarchy theorem  can cannot  can  cannot    some multiplying prime factorization some can explicit functions the tuples representation number line input output list of tuples representation of p list of tuples representation representing the xor program python from tuples to strings a nand-circ interpreter in nand-circ take-away points arbitrary arbitrary function program specification program implementation self circularity bounded universality of nand-circ programs any other nand-circ program any input bounded universal program universal circuit single program arbitrary loops turing machines every some    universal circuit efficient universal programs exponential polynomial  efficient bounded universality of nand-circ programs exists for every  python a nand-circ interpeter in pseudocode algorithm   bit array a nand interpreter in python python constructing the nand-circ interpreter in nand-circ nand-circ program  you code  can   python universal graph improving to quasilinear overhead advanced optional note a python interpreter in nand-circ discussion every machine language arm architecture can particular particular single different arbitrary in python all universality self reference the physical extended church-turing thesis discussion every church turing thesis physical extended church-turing thesis pectt if a function fn   m can be computed in the physical world using s amount of physical resources then it can be computed by a boolean circuit program of roughly s gates exponentially hard computes exponentially planck length planck time empirically falsify interactive proofs program checking no single explicit function prove advanced note making pectt concrete advanced optional attempts at refuting the pectt spaghetti sort soap bubbles euclidean steiner tree np complete exponentially dna computing continuousreal computers phrase relativity computer and time travel his our closed timelike curves ctcs humans at the moment inherent find quantum computation quantum computing quantum circuits not cryptography a b prove physical extended church-turing thesis and cryptography  process data physical extended church-turing thesis pectt quantum computers  recap of part i finite computation finite computation circuit straight-line program functions functions every at most some at least universal count every every quantum computing sneak preview unbounded inputs exercises   equals function  equal to constant function counting lower bound for multibit functions size hierarchy theorem for multibit functions efficient representation of circuits and a tighter counting upper bound hint tighter counting lower bound  hint random functions are hard  does not exist eval with xor learned hint learning circuits challenge optional assumes more background bibliographical notes universal circuit explicit prove"], ["lec_19_cryptography.html", "Cryptography", " cryptography   human ingenuity cannot concoct a cipher which human ingenuity cannot resolve a good disguise should not reveal the persons height perfect secrecy is defined by requiring of a system that after a cryptogram is intercepted by the enemy the a posteriori probabilities of this cryptogram representing various messages be identically the same as the a priori probabilities of the same messages before the interception it is shown that perfect secrecy is possible but requires if the number of messages is finite the same number of possible keys we stand today on the brink of a revolution in cryptography public key define concrete computational problems classical cryptosystems substitution cipher repeat enigma after enigma not only defining encryption private key encryption public key encryption sender plaintext receiver adversary secret key encrypt ciphertext decrypt valid secure valid private key encryption scheme encryption scheme valid encryption scheme valid lengths of ciphertext and plaintext  larger defining security of encryption security  secure  methods a cryptosystem should be secure even if everything about the system except the key is public knowledge any random there is no secrecy without randomness secrecy randomness  trapdoor randomness in the real world perfect secrecy an encryption scheme is secure if it is not possible to recover the key k from ekx plaintext an encryption scheme is secure if it is not possible to recover the plaintext x from ekx partial information perfect secrecy perfectly secret perfect secrecy  example perfect secrecy in the battlefield eve   bayes rule no additional information constructing perfectly secret encryption perfect secrecy any matching  one time pad vernam  shannon     one time pad  all  necessity of long keys not necessary  perfect secrecy requires long keys  degree  claim i image  computational secrecy exponential in the length of the key computational secrecy computationally secret computational secrecy  arbitrary  yes computational hardness  exponentially stream ciphers or the derandomized one-time pad stream cipher pseudorandom generator cryptographic pseudorandom generator cryptographic pseudorandom generator pseudorandom generator exponential size the crypto prg conjecture  derandomized one-time pad   triangle inequality   stream ciphers block ciphers chosen plaintext man in the middle chosen ciphertext stream ciphers in practice computational secrecy and  np breaking encryption using  np algorithm  averaging principle  false public key cryptography raised exponentially harder compute invert trapdoor without ever having exchanged a secret key integrity secrecy sign key exchange protocol public key encryption key exchange protocol defining public key encryption public key encryption key generation algorithm public encryption private decryption security parameter encryption algorithm decryption algorithm public key encryption computationally secret public key encryption public key encryption randomized necessary only one bit long longer than the key group theoretic constructions integer factoring discrete logarithm latticecoding based constructions closest vector in a lattice bounded distance decoding quantum computers diffie-hellman key exchange discrete logarithm problem inverse binary search modular arithmetic discrete logarithm alice bob alice quantum computer other security notions integrity authentication digital signature schemes active attacks cryptographic hash functions magic zero knowledge proofs zero knowledge proofs rigorously show absolutely no additional information about x negative result positive applications fully homomorphic encryption manipulate without knowing the secret key k immensely ever learning any information existence fully homomorphic encryption scheme multiparty secure computation no commonly trusted party or authority electronic voting protocol second highest bid randomized perfect secrecy anything computational secrecy exponentially bigger public key encryption digital signatures hash functions multiparty secure computation fully homomorphic encryption zero knowledge proofs  exercises bibliographical notes i hope my handwriting etc do not give the impression i am just a crank or circle-squarer the significance of this conjecture that certain encryption schemes are exponentially secure against key recovery attacks  is that it is quite feasible to design ciphers that are effectively unbreakable computational indistinguishability semantic security signature scheme"], ["lec_02_representation.html", "Computation and Representation", " computation and representation  specification implementation mathematical functions algorithmsprograms  the alphabet sic was a great invention which enabled men sic to store and to learn with little effort what others had learned the hard way  that is to learn from books rather than from direct possibly painful contact with the real world the name of the song is called haddocks eyes oh thats the name of the song is it no you dont understand thats what the name is called the name really is the aged aged man then i ought to have said thats what the song is called no you oughtnt thats quite another thing the song is called ways and means but thats only what its called you know well what is the song then i was coming to that the song really is a-sitting on a gate and the tunes my own invention through the looking-glass computation input output computation what specification how implementation what strings of zeroes and ones language compute representation defining representations representation representing representation representation scheme one to one representing natural numbers binary basis number decimal representation number binary representation binary recursively python binary representation in python optional code examples equivalent not programming examples meaning of representations discussion liber abaci representations beyond natural numbers representing potentially negative integers integers onto  type interpretation and context twos complement representation optional signed magnitude representation twos complement representation negative twos complement representation undefined behavior rational numbers and representing pairs of strings pairs of strings pairs of strings pair representing a rational number as a string  lists of lists prefix free encoding representing real numbers real numbers irrational floating point representation floating point representation scheme approximately exactly can we represent reals exactly exactly  reals are uncountable uncountability of the reals no one shall expel us from the paradise which cantor has created for us is is  functions sequences    does  onto diagonal   every subsets power set generalizing beyond strings and reals   binary using decimal expansion optional representing objects beyond numbers representation scheme encoding decoding  representation scheme encoding decoding string representation onto encoding     partial total total decoding functions finite representations finite     prefix-free encoding prefix-free prefix list every lists prefix prefix-free prefix free encoding lists prefix-free implies tuple encoding      lists every prefix freeness of list representation making representations prefix-free fixed output length         proof by python optional constructive lists prefix free prefix-free  python functions  lists representing letters and text code points braille system the braille representation representing objects in c optional representing vectors matrices images vectors matrices representing graphs graph adjacency adjacency list representing lists and nested lists nested notation a is an algorithm that computes the multiplication function on natural numbers a is an algorithm that computes the function f    such that for every pair ab     if x   is a string representing the pair ab then fx will be a string representing their product a  b  defining computational tasks as mathematical functions computational process computational tasks specification implementation computing a function factorization longest partial do  boolean decision problem language deciding a language boolean functions and languages boolean functions languages deciding a language algorithms there is no algorithm good thing algorithm distinguish functions from programs specifications implementations mathematical functions algorithmsprograms functions programs programs mathematical function program algorithm function computes function program computes function program computes  functions programs circuits machines partial promise problems relations relation set of strings interactive boolean computation beyond functions advanced optional  computing a function best  exercises  binary representation no lossless one to one random speed ratio every more compact than ascii representation representing graphs upper bound no representing graphs lower bound multiplying in different representation    prefix-free prefix-free encoding of tuples more efficient prefix-free transformation   krafts inequality  composition of one-to-one functions natural numbers and strings map lists of integers to a number bibliographical notes compression error corrections information theory data structures design gullivers travels definition specification implementation computation approximate spectral graph theory random walks"], ["lec_16_randomized_alg.html", "Probabilistic computation", " probabilistic computation   in   i asked myself what are the chances that a canfield solitaire laid out with  cards will come out successfully after spending a lot of time trying to estimate them by pure combinatorial calculations i wondered whether a more practical method  might not be to lay it our say one hundred times and simple observe and count the salient features of our method are that it is probabilistic  and with a controllable miniscule probability of error out error correct redundancy resource finding approximately good maximum cuts maximum cut problem  approximating max cut  random cut  algorithm random cut input operation   randomized algorithms work in the worst case not random choices of the algorithm for every graph g every possible input  not amplifying the success of randomized algorithms expectation amplify too      success amplification some all repeat   algorithm amplify random cut input operation   two-sided amplification one sided error two sided errors majority value exponentially close two-sided amplification what does this mean worst case input graph internal randomness of the algorithm guaranteed solving sat through randomization algorithm walksat input parameters operation   walksat simple analysis claim i proof of claim i satisfying not claim  proof of claim ii  bipartite matching matching bipartite perfect matching perfect matching permutation  inverted determinant matching polynomial   determinant zero testing if a polynomial is not identically zero then it cant have too many roots to decide if p is identically zero choose a random input x and check if px    schwartzzippel lemma algorithm perfect-matching input operation  amplify  exercises amplification for max cut  deterministic max cut algorithm    hint simulating distributions using coins  better walksat analysis  faster bipartite matching challenge bibliographical notes acknowledgements"], ["lec_02_computational_security.html", "Computational security", " computational security additional reading perfect secrecy anything really this defining  t bits of computational secrecy computational secrecy first attempt impossible  prove   t bits of computational secrecysup idfnrefa hreffn relfootnoteasup computational secrecy concrete  guessing game for computational secrecy     proof by reduction the way you show that if s is secure then s is secure is by giving a transformation from an adversary that breaks s into an adversary that breaks s backwards the asymptotic approach principles asymptotic analysis big oh notation polynomial efficient exponential infeasible exponential subexponential efficient negligible  asymptotic analysis efficient fixed any exponential  computationally secret computational secrecy asymptotic counting number of operations probabilistic our first conjecture the cipher conjecture one way functions conjecture the  breaking crypto if pnp  exponentially  prove intuition every concrete candidates tons minimalism necessary why care about the cipher conjecture give me a place to stand and i shall move the world every prelude computational indistinguishability distinguish computationally indistinguishable  -computationally indistinguishable computationally indistinguishable parameterized computational indistinguishability note  computational indistinguishability phrasing of security distance  triangle inequality for computational indistinguishability    computational indistinguishability is preserved under repetition  averaging principle someone   hybrid argument the hybrid argument the length extension theorem length extension theorem  security of repetition   randomized encryption scheme necessary public key  length extension of ciphers  ephemeral keys is it secure claim random independently proof of claim  appendix the computational model  probabilistic straightline program size complexity probabilistic straightline program non existence interference entanglement quantum computing advanced note non uniform uniform"], ["lec_14_zero_knowledge.html", "Zero Knowledge proofs", " zero knowledge proofs proof why how how zero knowledge proofs any additional knowledge applications for zero knowledge proofs nuclear disarmament deployed stockpiles voting prove more applications identification protocols zero knowledge proof of knowledge digital signatures passive active defining and constructing zero knowledge proofs define proof proof system statement proof euclidean geometry statements proofs zermelo-fraenkel  axiom of choice zfc statement proof hamiltonian efficient interactive probabilistic protocols prove proof of tetrachromacy quadratic residue alice bob common input not accepts was    probabilistic proof for f completeness soundness proof systems  languages functions lanugage functions vs languages argument systems efficient prover  honest should malicious honest but curious notation for strategies defining zero knowledge zero knowledge protocol zk-qr not not a proof system is zero knowledge if the verifier did not learn anything after the interaction that he could not have learned on his own  zero knowledge simulator zero knowledge proofs  not allowed simulation simulation paradigm positive negative the simulation paradigm something  zero knowledge for quadratic residuosity  claim  claim  claim  proof of claim  proof of claim  proof of claim   constant zero knowledge proof for hamiltonicity hamiltonian cycle protocol zk-ham common input alices private input  zero knowledge proof for hamiltonian cycle  completeness soundness zero knowledge completeness soundness i ii i ii zero knowledge simulator hamiltonian claim  claim  claim  identical  why is this interesting parallel repetition and turning zero knowledge proofs to signatures after in parallel random function non-interactive bonus features of zero knowledge"], ["lec_12_lattices.html", "Lattice based cryptography", " lattice based cryptography knapsack noisy linear equations private key worst case public key worst case lattices attack today a world without gaussian elimination structure discrete logarithm column transposing   correct incorrect scheme lwoe-enc key generation encryption decryption   security in the real world is brittle noisy learning with errors lwe inherent conjecture learning with errors regev  learning with error lwe conjecture with respect to q  discrete gaussian lwe conjecture search to decision  search to decision reduction for lwe   an lwe based encryption scheme lwe-based encryption lweenc parameters key generation encrypt decrypt      signs   cpa security of lweenc    i ii   statistically indistinguishable claim not    but what are lattices lattice integer basis shortest vector problem closest vector problem not bounded distance decoding closest vector bounded distance decoding ring based lattices ideal lattices"], ["lec_17_SFE.html", "Multiparty secure computation", " multiparty secure computation i definition and honest-but-curious to malicious complier cryptography is about replacing trust with mathematics multiparty secure computation secure function evaluation ideal vsreal model security trust ideal world secure multiparty computation formally defining secure multiparty computation k-party protocol broadcast channel k party functionality first attempt a slightly too ideal definition  secure protocol for f mpc without aborts allowing for aborts  secure protocol for f mpc with aborts argument   every  fundamental theorem of cryptography some comments fairness guaranteed output delivery guaranteed output delivery fairness network models setup assumptions adversarial power concurrent compositions standalone execution concurrent composition communication efficiency vsgenerality in principle is multiparty secure computation the end of crypto qualitative further reading example second price auction using bitcoin another example distributed and threshold cryptography cryptographic computations key escrow ith share every   use proving the fundamental theorem two parties malicious to honest but curious reduction proves zero knowledge proof deterministic     some the same input for all messages commit  commitment scheme sender receiver hiding senders security binding recievers security commitment scheme open computationally hiding and statistically binding deterministic alice simulating bob proof of knowledge handling probabilistic strategies coin tossing protocol commitment protocol after"], ["lec_01_introduction.html", "Introduction", " introduction additional reading undistinguished cryptography making cryptoanalysis breaking cryptology cryptography alice bob secret eve encode encrypt substitution cipher repeat enigma after not only defining encryptions key encryption function plaintext ciphertext decryption function  valid private key encryption scheme encryption scheme valid encryption scheme a note on notation methods a cryptosystem should be secure even if everything about the system except the key is public knowledge random there is no secrecy without randomness there is no secrecy without randomness generating randomness in actual cryptographic systems unpredictable entropy hash function the trapdoor defining the secrecy requirement mathematically precise definition  n-secure security of encryption first attempt   too strong weak     message  n-secure security of encryption second attempt every every random  n-secure security of encryption third attempt perfect secrecy any additional information  perfectly secret perfect secrecy  two to many theorem  exists    matching  one time pad vernam  shannon      one time pad  all  necessity of long keys necessary not  perfect secrecy requires long keys    claim i image  advanced comment adding probability into the picture randomness probabilistic distribution"], ["lec_05_prf-from-prg.html", "PRFs from PRGs", " pseudorandom functions from pseudorandom generators  the prf theorem  means before first resampled identical   block ciphers prfs in practice securely encrypting many messages - chosen plaintext security encryption  not  single stream ciphers synchronized shared state what ads chooses chosen plaintext attack for every after  secure against chosen plaintext attack cpa secure wins chosen plaintext attack cpa secure encryption wins stronger strictly stronger  deterministic cpa security requires randomization   randomized probabilistic wont high entropy  cpa security from prfs  claim proof of claim  pseudorandom permutations  block ciphers pseudorandom permutations  pseudorandom permutation prp collection key length input length block length pseudorandom permutations  not   prps from prfs block cipher round key scheduling algorithm round key encryption modes electronic code book ecb mode deterministic cipher block chaining mode initialization vector initialization vector output feedback mode ofb counter mode chosen ciphertext security"], ["lec_13_handshake.html", "Secure communication over insecure channels", " establishing secure connections over insecure channels cryptographys obsession with adjectives quantitative qualitative infrastructuresetup assumptions public signature key password know witness encryption adversary access passive active person-in-the-middle graceful recovery forward secrecy some all threshold cryptography interaction security goal win basic key exchange protocol key exchange diffie hellman passive authenticated key exchange not authenticated bleichenbachers attack on rsa pkcs v and ssl v attacks constructions chosen ciphertext security cca chosen ciphertext attack security for public key cryptography public key  chosen ciphertext attack cca secure not wins cca secure public key encryption public key digital signatures   signing key secret verification key public encryption public why cca security matters yes private key secure sealed envelopes cca secure public key encryption in the random oracle model trapdoor permutation cca-rom-enc scheme ingredients key generation encryption decryption  cca security from random oracles  claim proof of claim qed claim not cpa game  defining secure authenticated key exchange secure channel certificate authority ca prove one sided authentication   the compiler approach for authenticated key exchange passive eavesdropping compile password authenticated key exchange   client to client key exchange for secure text messaging - zrtp otr textsecure heartbleed and logjam attacks"], ["lec_07_hash_functions.html", "Hash functions and random oracles", " hash functions and random oracles bitcoin the bitcoin problem centralized decentralized the currency problem currency ownership bitcoin architecture coin owner satoshi ledger computational puzzle np   digital signatures the bitcoin ledger ledger consensus benign proof   not no   even to a party that holds the key theorem not impossible to achieve the random oracle heuristic aka random oracle model bellare-rogaway  description  not insecure any important caveat on the random oracle model from proof of work to consensus on ledger length valid selfish cost to mine mining pools profitable variance the real bitcoin block collision resistance hash functions and creating short unique identifiers bound one to one much     collision resistant  collision resistant hash function crh collection collision resistant hash functions not second preimage attack is  crh vs prf practical constructions of cryptographic hash functions keyed fixed keyless function compression function  merkle-damgard preserves collision resistance  constructive  practical random-ish functions not length extension attack end block cipher tailor made some history secure hash algorithm sha the nsa and hash functions cryptographic vs non-cryptographic hash functions non-cryptographic linear cyclic redundancy codes crc"], ["lec_09_priv_recap.html", "Private key crypto recap", " private key crypto recap private key public key commitment scheme not one way functions one way function theorem permutation attacks on private key cryptosystems linear differential side channel"], ["lec_22_obfuscation_part2.html", "Obfuscation II: applications", " more obfuscation exotic encryptions fine grained access control functional encryption f-restricted decryption key identity based encryption ibe slower weaker less securer leaking deterministic encryption order preserving encryption searchable encryption how to get ibe from pairing based assumptions linear functions in the exponent quadratic pairing based cryptography pairing diffie hellman assumption master key generation key distribution encryption decryption correctness security definition definition wins theorem proof claim proof beyond pairing based cryptography multilinear map noise zero test"], ["lec_12a_CCA_public_key.html", "Chosen-ciphertext secure public key encryption", " chosen ciphertext security for public key encryption"], ["lec_11_concrete_pkc.html", "Public key encryption candidates", " concrete candidates for public key crypto public key cryptography some number theory  digits note on n bits vs a number n  the number m vs the message m primaliy testing  primality testing probabilistic deterministic    not group  all testing find fields field  fundamental theorem of algebra mod p version square roots  finding roots chinese remainder theorem all  chinese remainder theorem crt   if you know ms factorization  square root extraction implies factoring   average case the rsa and rabin functions  rsa function rsa function  rabin function rabin function inverted permutation    order not   plaintextbook rsa abstraction trapdoor permutations trapdoor permutation family  trapdoor permutation family tdp key generation algorithm trapdoor permutation  extended reimann hypothesis proved domain of permutations public key encryption from trapdoor permutations tdp-based public key encryption tdpenc key generation public encryption key secret decryption key encryption decryption  valid   public key encryption from trapdoor permutations  wins claim proof does not     not hard core security without random oracles digital signatures from trapdoor permutations full domain hash signatures fdhsig key generation public verification key secret signing key signing verification  full domain hash security  before input     hash and sign hardcore bits and security without random oracles"], ["lec_02_computational-security.html", "Computational security", " computational security additional reading perfect secrecy anything really this defining  t bits of computational secrecy computational secrecy first attempt impossible  prove   t bits of computational secrecysup idfnrefa hreffn relfootnoteasup computational secrecy concrete  guessing game for computational secrecy     proof by reduction the way you show that if s is secure then s is secure is by giving a transformation from an adversary that breaks s into an adversary that breaks s backwards the asymptotic approach principles asymptotic analysis big oh notation polynomial efficient exponential infeasible exponential subexponential efficient negligible  asymptotic analysis efficient fixed any exponential  computationally secret computational secrecy asymptotic counting number of operations probabilistic our first conjecture the cipher conjecture one way functions conjecture the  breaking crypto if pnp  exponentially  prove intuition every concrete candidates tons minimalism necessary why care about the cipher conjecture give me a place to stand and i shall move the world every prelude computational indistinguishability distinguish computationally indistinguishable  -computationally indistinguishable computationally indistinguishable parameterized computational indistinguishability note  computational indistinguishability phrasing of security distance  triangle inequality for computational indistinguishability    computational indistinguishability is preserved under repetition  averaging principle someone   hybrid argument the hybrid argument the length extension theorem length extension theorem  security of repetition   randomized encryption scheme necessary public key  length extension of ciphers  ephemeral keys is it secure claim random independently proof of claim  appendix the computational model  probabilistic straightline program size complexity probabilistic straightline program non existence interference entanglement quantum computing advanced note non uniform uniform"], ["lec_15_FHE.html", "Fully Homomorphic Encryption", " fully homomorphic encryption introduction and bootstrapping alice bob encrypted fully homomorphic encryption fhe does not know the secret key learning with error lwe easiest to describe efficient ideal structured  verifying computation negative lesson from verifying computation  poor mans fhe via hardware defining fully homomorphic encryption partially homomorphic   f-homomorphic public key encryption scheme partially homomorphic encryption   fully homomomorphic encryption all another application fully homomorphic encryption for verifying computation assumptions preprocessing client query server response client check example an xor homomorphic encryption  qn-decision learning with error qn-dlwe conjecture lwe simplified decision variant lwe conjecture   search to decision a linearly-homomorphic encryption scheme linear functions       abstraction a trapdoor pseudorandom generator trapdoor generator trapdoor generator   statistically indistinguishable     not  trapdoor generator randomized statistically indistinguishable trapdoor generators   aside trapdoor generators in real life could from linear homomorphism to full homomorphism logarithmic depth fully homomorphic any bootstrapping fully homomorphic escape velocity any fully all homomorphically evaluate its own decryption algorithm  bootstrapping theorem gentry  radioactive legos analogy proving the bootstrapping theorem  any leveled not any   "], ["lec_25_course_recap.html", "Course recap", " course recap mathematically define insecure strategy capabilities secrecy randomness conservative reductions private key cryptography collision resistant hash functions random oracle public key encryption learning with errors fully homomorphic encryption fhe functional encryption witness encryption identity based encryption pairing some things we did not cover minimal necessary universal posterior sampler sufficient number field sieve what i hope you learned"], ["lec_19_quantum.html", "Quantum computing", " quantum computing and cryptography i i think i can safely say that nobody understands quantum mechanics the only difference between a probabilistic classical world and the equations of the quantum world is that somehow or other it appears as if the probabilities would have to go negative increase smaller measured fewer negative squaring smaller have complex mixed density matrix interference measurement measured entanglement quantum entanglement quantum computing and computation - an executive summary exponential if a physical system cannot be simulated by a computer in t steps the system can be considered as performing a computation that would take more than t steps a b quantum computer quadratic cant quantum  probabilistic states bit qubit probability distribution quantum state measurement state measure collapses measure operations stochastic unitary elementary operations gates elementary n-lift of m with indices ijk elementary stochastic matrix probabilistic gate quantum gate complexity randomized complexity efficiently classically computable quantum complexity efficiently quantumly computable computing functions efficiently classically computable efficiently quantumly computable quantum and classical computation the obviously exponential fallacy probabilistic computation exponential space polynomial space prove every known physically realizing quantum computation universal sets collapsing coherence time theorems bra-ket notation row outer product bells inequality uncertainty principle claim proof claim proof epr pair quantum vs probabilistic strategies grovers algorithm theorem grover search   proof sketch"], ["lec_18_SFE_part2.html", "MPC II: Construction from FHE", " multiparty secure computation construction using fully homomorphic encryption yaos garbled circuit  two party honest-but-curious mpc  secure protocol for f view two party honest-but-curious secure computation constructing  party honest but curious computation from fully homomorphic encryption deterministic protocol pc assumptions inputs alice-bob bob-alice alices output claim b proof malicious claim a   not not circuit privacy  perfect circuit privacy perfect circuit privacy     secret key zero  statistical circuit privacy statistical circuit privacy achieving circuit privacy in a fully homomorphic encryption deterministic to kill a signal drown it in lots of noise         bottom line a two party honest but curious two party secure computation protocol  two party "], ["lec_24_policy.html", "Ethical, moral and policy considerations", " ethical moral and policy dimensions to cryptography less used meta data reading prior to lecture case studies the snowden revelations fbi vs apple case juniper backdoor case and the opm break-in"], ["lec_16_FHE_part2.html", "FHE II: Construction", " fully homomorphic encryption  construction circular security  fhe from lwe prelude from vectors to matrices multiplications multiply matrices eigenvector  types matrix vector scalar   generate private key public key private key public key private key fhe real world partially homomorphic encryption   noise management via encoding if only there was some way to encode numbers between  and q- using only s and s binary encoding decoding linear putting it all together fheenc key generation encryption decryption nand evaluation   analysis of our scheme correctness cpa security homomorphism shallow decryption circuit correctness     cpa security circular secure leveled homomorphism noise     shallow decryption circuit depth           example application private information retrieval"], ["lec_21_obfuscation.html", "Software obfuscation", " software obfuscation private key encryption message authentication codes any additional information public key encryption digital signatures sharing a prior key hash functions pseudorandom function password based key exchange fully homomorphic encryption zero knowledge proofs why multiparty secure computation functionality yes witness encryption ua-secure encryption witness encryption any deniable encryption deniable  functional encryption functional encryption selectively decrypt  functional encryption scheme wins functional encryption the software patch problem software obfuscation virtual black-box vbb secure software obfuscation indistinguishablity obfuscators compiler  virtual black box vbb secure obfuscator vbb secure obfuscation applications of obfuscation impossibility of obfuscation  impossibility of obfuscation proof of impossibility of vbb obfuscation learnable approximately predicts strong vbb obfuscator      impossiblity of obfuscation from fhe   case  case    indistinguishability obfuscation  indistinguishability obfuscator io indistinguishability obfuscation"], ["lec_06_CCA.html", "Chosen Ciphertext Security", " chosen ciphertext security short recap perfect secrecy pseudorandom generator prg conjecture pseudorandom function prf function collection identification protocols message authentication codes chosen plaintext attack cpa security many messages of eves choice going beyond cpa   example the wired equivalence protocol wep linear chosen ciphertext security active plaintexts ciphertexts  chosen ciphertext attack cca secure mallory wins cca security this definition seems to be too strong decryption box sufficiently conservative this definition seems to be too weak what does cca have to do with wep would    any exactly identical    constructing cca secure encryption not non do integrity confidentiality active to ensure confidentiality you need integrity secrecy encryption authentication nearly all of the symmetric encryption modes you learned about in school textbooks and wikipedia are potentially insecuresup idfnrefa hreffn relfootnoteasup passive how      canonical verification algorithm cca from cpa and mac  case i case ii i ii some not encryption queries decryption decryption box will    simplified gcm encryption almost universal universal hash function padding chopping and their pitfalls the buffer overflow of cryptography fixed size chopping into blocks block cipher modes not extend remove padding padded padding chosen ciphertext attack as implementing metaphors formal verification automatically dolev yao models algebraic"], ["lec_00_1_mathematical-background.html", "Mathematical Background", " mathematical background how not to be wrong a quick overview of mathematical prerequisites proofs definitions statements proofs sets and functions and big oh notation logical operations tuples and strings alphabet graphs basic combinatorics modular arithmetic modular inverse group theory linear algebra discrete probability probability theory finite mathematical proofs the a proof is a piece of writing meant to convince human readers that a particular statement is true yourself detrimental example the existence of infinitely many primes prime number  infinitude of primes gap  existence of prime divisor  existence of co-prime     probability and sample spaces events random variables sample spaces event probability of a  even ones     intersection union and or even and not not   sample space  event some remember the sample space random variables events how much random variable expectation linear  linearity of expectation      union bound     union bound distributions over strings real number string distributions distribution identical more general sample spaces probability distribution event random variable correlations and independence independence correlations correlation causation independent not independent positively correlated negatively correlated independent  disjointness independence disjoint independent not disjointness vs independence conditional probability conditioned on a more than two events mutually independent not independent random variables  independant random variables     collections of independent random variables mutually independent  expectation of product of independent random variables  functions preserve independence   concentration independent concentrated concentration tail  markovs inequality  tight    going beyond markovs inequality chebyshevs inequality standard deviation variance standard deviation  chebyshevs inequality   independent and identically distributed the chernoff bound normal gaussian bell curve very exponential decay normal distribution exponentially  chernoffhoeffding bound exercises not equal every no test"], ["lec_08_hash_functions_part2.html", "Hash functions II: Key derivations, protecting passwords, Merkle trees", " key derivation protecting passwords slow hashes merkle trees collision resistance random oracle heuristic keys from passwords humans entropy knew the entropy of a secret is always measured with respect to the attackers point of view offline online online offline public key cryptography password authenticated key exchange master password encrypt  not  deliberately slow hash key derivation function memory bound public offline never merkle trees and verifying storage certificate  merkle tree security   proofs of retrievability did not proof of retrievability was entropy extraction randomness do from the point of view of the attacker entropy entropy flat shannon entropy chain rule min entropy min-entropy family collision probability conservative flat sources  randomness extractor randomness extractor  random function is an extractor  claim proof of claim   statistically indistinguishable pairwise independence statistical randomness forward and backward secrecy"], ["lec_23_anonymous.html", "Anonymous communication", " anonymous communication anonymous routing steganography steganography symmetric case public key setting pseudorandom ciphertexts anonymous routing low latency communication message at a time protection against timing  traffic analysis tor telex riposte"], ["lec_03_pseudorandom-generators.html", "Pseudorandomness", " pseudorandomness reading order predictions random randomness is a function of the observer if a quantity is hard to compute it might as well be random  pseudorandom generator pseudorandom generator pseudorandom generator       prove conjecture the prg conjecture implies  length extension for prgs  seed  seed  unpredictablity and indistinguishability- an alternative approach for proving the length extension theorem stream ciphers  prg conjecture implies  cipher conjectures equivalent  one time pad claim proof of claim  stream ciphers stream cipher  using pseudorandom generators for coin tossing over the phone what do pseudorandom generators actually look like exist dont prove candidates attempt  the counter generator not   attempt  the linear checksum  linear feedback shift register lfsr checksum linear feedback shift register generator periods linear generator ring of integers modulo q linear congruential generator gaussian elimination algorithm jiuzhang suanshu  the unfortunate theorem for cryptography linearly independent  test entropy non-cryptographic prgs from insecurity to security discrete logarithm problem learning with errors problem block ciphers mixing global s-boxes non-linearity rounds deep large algebraic degree attempt  linear congruential generators with dropped bits lattice algorithms successful examples successful case study  subset sum generator worst case average case   single boolean vector small case study  rc permutation not non-constructive existence of pseudorandom generators constructivity exponentially larger  existence of inefficient pseudorandom generators  exists proof technique deterministic   claim i at random sample space all exists does not "], ["lec_00_0_foreword.html", "Foreword and Syllabus", " foreword and syllabus human ingenuity cannot concoct a cipher which human ingenuity cannot resolve public key unimaginable syllabus fully homomorphic encryption indistinguishability obfuscators ideas implementations how do we define security for encryption mathematically precise definition broken proving secure perfect security and its limitations computational security pseudorandom generators pseudorandom functions permutations block ciphers authentication and active attacks authentication secrecy hash functions and the random oracle model building pseudorandom generators from one-way permutations optional public key cryptography and the obfuscation paradigm imagine constructing public key encryption factoring discrete log and lattice based systems lattice based cryptosystems signature schemes active attacks for encryption fully homomorphic encryption multiparty secure computation zero knowledge proofs why quantum computing and cryptography indistinguishability obfuscation practical protocols cryptocurrencies prerequisites why is cryptography hard all possible attacks mathematical proofs defining knowledge computation intellectual imagine"], ["lec_10_public_key_intro.html", "Public key cryptography", " public key cryptography raised exponentially harder but integrity secrecy sign key exchange protocol diffie-hellman key exchange private key crypto recap public key private key cryptography commitment scheme not one way functions  one way function one way functions  one way functions and private key cryptography permutation  linear differential side channel attacks on private key cryptosystems  digital signatures digital signatures public key encryptions definition pair encryption key decryption key  public key encryption scheme key generation algorithm encryption algorithm decryption algorithm cpa secure wins public key encryption   lock it unlock encrypt decrypt the obfuscation paradigm no matter what program p the adversary gets obfuscation based public key encyption ingredients i ii key generation encryption decryption inherently impossible software obfuscation side effect free black box access impossible some concrete candidates theorem theorem candidates lattice efficiently solvable quantum computers single diffie-hellman encryption aka el-gamal discrete logarithm problem repeated squaring trick discrete logarithm key generation algorithm encryption algorithm decryption algorithm  insecure    diffie-hellman problem decisional diffie-hellman ddh computational diffie-hellman assumption computational diffie-hellman cdh sequence of groups computational diffie-hellman conjecture for mod prime groups    diffie-hellman security in random oracle model  claim proof of claim identical   elliptic curve cryptography  diffie-hellman key exchange elgamal encryption signature scheme deterministic encryption vs key exchange and el gamal sampling random primes efficient testing randomized prime density    least common multiple lcm claim  claim  proof of claim  proof of claim   a little bit of group theory cyclic finite commutative group order subgroups generator cyclic isomorphism generator   digital signatures confidentiality authenticity integrity everyone  digital signature scheme key generation signing key verification wins not digital signatures  strong unforgability strong unforgability the digital signature algorithm dsa identification protocol interactive not dsa signatures key generation not signature verification      random-oracle model security of dsa signatures  case i case ii case iia before case iib case iia twice case iib twice   non-random oracle model security putting everything together - security in practice steganography anonymous routing servers users public new york times times transitive you apple i apple certify that the public key of amazoncom is    a       f e fd     b be e d  d    e b c  bb ab d ff f b  b a f be c d f c b f dc   b  e e b  b  b a ca af cc bf  fb  b b   bc b   b e e  b bd  d    e   e f f  e b a  fd e b a e d da c     e a bd d  c b f a a e e ed   f dc ec e f a e c ae f a e a d ca f  cf    d fa c c e e   a c dc cd a    b ca c e c     c   f     a b d ba e  dc  a   f c  bc      c   a  ec d  a b da  d  ac c e d fe   d ba e dc      e e f e c a aa   af ec   b  f fb f     c b c  a b  ec cd  e    db      certificate spoof verisign certificate authorities encryption ephemeral forward secrecy which example appendix an alternative proof of the density of primes    "], ["lec_20_quantum_part2.html", "Quantum II: Shor", " quantum computing and cryptography ii no  shors theorem  order order finding algorithm from order finding to factoring and discrete log factoring discrete log finding periods of a function simons algorithm period h time frequency fourier transform quantum fourier transform simons algorithm  simons algorithm   from simon to shor  shors algorithm restated quantum fourier transform qft measuring the fourier transform over   fourier transform of f fourier basis orthonormal unitary homomorphism periodic fast fourier transform fast fourier transform quantum quantum fourier transform over   quantum fourier transform  quantum fourier transform bernstein-vazirani initial state shors order-finding algorithm order  order finding algorithm restated continued fractions including analysis the case that rm claim the general case    lemma  lemma  proof of lemma  proof of lemma  rational approximation of real numbers continued fraction infinite closest quantum cryptography"], ["lec_04_pseudorandom-functions.html", "Pseudorandom functions", " pseudorandom functions pseudorandom generators prg conjecture length extension efficient pseudorandom function generator  pseudorandom function prf generator pseudorandom function generator black box oracle pseudorandom function collection  prfs from prgs one time passwords eggoogle authenticator rsa id etc encryption secrecy authentication integrity the login problem alice bob mallory mall identification protocol password encryption   replay replay attack how do pseudorandom functions help in the login problem one time password protocol  nonce why is this secure pseudo actual extremely unlikely no information    login protocol via prf  actual random claim  huge proof of claim  not independent   increasing output length of prfs message authentication codes identity message authentication codes macs identity communication alice bob mallory message learning private key many choose chosen message chosen plaintext  sign verify message authentication code mac not replay message authentication codes mac not not  her any chosen plaintext chosen ciphertext why can mallory choose the messages  has canonical verifier algorithm strong unforgability macs from prfs  mac theorem  not  input length extension for macs and prfs tags aside natural proofs in the truth table size of f"], ["lnotes_book.html", "index", " an intensive introduction to cryptography boaz barak work in progress"]]