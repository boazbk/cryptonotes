[["lec_14_PvsNP.html", "What if P equals NP?", " what if p equals np  search-to-decision  you dont have to believe in god but you should believe in the book no more half measures walter the evidence in favor of  p   np and  its algebraic counterpart  is so overwhelming and the consequences of their failure are so grotesque that their status may perhaps be compared to that of physical laws rather than that of ordinary mathematical conjectures suppose aliens invade the earth and threaten to obliterate it in a years time unless human beings can find the fifth ramsey number we could marshal the worlds best minds and fastest computers and within a year we could probably calculate the value if the aliens demanded the sixth ramsey number however we would have no choice but to launch a preemptive attack what if  p np but the best algorithm for sat takes n time sat is very easy sat is very hard search-to-decision reduction if find  search vs decision     some  optimization optimal longest   yes optimization from  p np    binary search   optimization problems linear programming integer  valued integer programming weighted objective function is need for binary search example supervised learning supervised learning examples labels hypothesis predictor predict occams razor principle parameters example breaking cryptosystems cryptography finding mathematical proofs proof system proof system verifier statement candidate proof sequence axiom inference rule quantifier elimination advanced search optimization yes we can there exists independent set there exists for every smallest there exists for every there exists polynomial hierarchy collapse   negation  quantified boolean formula application self improving algorithm for   sat best possible there exists for every there exists approximating counting problems and posterior sampling advanced optional approximate counting if  p np witnesses posterior sampling and probabilistic programming sampling posterior sampling what does all of this imply how the laws of nature have this amazing feeling of inevitability which is associated with local perfection the classical picture of the world is the top of a local mountain in the space of ideas and you go up to the top and it looks amazing up there and absolutely incredible and you learn that there is a taller mountain out there find it mount quantum theyre not smoothly connected  youve got to make a jump to go from classical to quantum  this also tells you why we have such major challenges in trying to extend our understanding of physics we dont have these knobs and little wheels and twiddles that we can turn we have to learn how to make these jumps and it is a tall order and thats why things are difficult new type of understanding  can  p    np be neither true nor false no failure programs short is  p np in practice worst case not heuristics some proxy measures what if  p    np cannot cannot be broken public key cryptography electronic cash secure multiparty computation randomness positive proving restricted forms general exist  exercises bibliographical notes"], ["lec_24_proofs.html", "Proofs and algorithms", " proofs and algorithms lets not try to define knowledge but try to define zero-knowledge proofs elements exercises bibliographical notes"], ["lec_07_other_models.html", "Equivalent models of computation", " equivalent models of computation   all problems in computer science can be solved by another level of indirection because we shall later compute with expressions for functions we need a distinction between functions and forms and a notation for expressing this distinction this distinction and a notation for describing it from which we deviate trivially is given by church turing completeness turing equivalence church-turing thesis every ram machines random access memory ram turing equivalence cellular automata configurations gdels incompleteness theorem   calculus infinite finite ram machines and nand-ram random access memory ram pointer ram machine word ram model word word size registers ram machine data movement computation control flow nand-ram programming language integer valued indexed access false true  turing machines aka nand-tm programs and ram machines aka nand-ram programs are equivalent indexed access a indexed access b boolean valued integer valued indexed access of bit arrays a two dimensional bit arrays two dimensional arrays two indices two dimensional arrays arrays of integers integers bits  primary memory    ram machines  nand-ram and assembly language optional the gory details optional is you indexed access in nand-tm indexed access while two dimensional arrays in nand-tm one to one all the rest recursion stack machine languages recursion in nand-ram advanced turing equivalence discussion turing equivalent turing complete the best of both worlds paradigm prove a theorem can not can be computed cant can have our cake and eat it too cant can  lets talk about abstractions the talk level of abstraction implementation level pseudocode formal low level implementation pseudocode representation low level specification intermediate implementation level defining algorithms algorithm turing completeness and equivalence a formal definition optional computational model program function computational model turing complete turing equivalent computational model  m-computes turing complete turing equivalent turing completeness and equivalence optional cellular automata cellular automata two dimensional cellular automaton state one dimensional cellular automaton two dimensional cellular automaton one dimensional cellular automaton one dimensional cellular automation transition rule configuration one dimensional cellular automata finite configuration finite one dimensional cellular automata are turing complete one dimensional automata are turing complete configurations configuration configurations of turing machines and the next-step function configurations configuration configuration of m configuration of turing machines you  snapshot   completing the proof of a hrefonedimcathmtheorem a one dimensional automata are turing complete formal statement  nand-tm program configurations of nand-tm programs lambda calculus and functional programming languages the  operator python javascript scheme dropping parenthesis applying functions to functions    obtaining multi-argument functions via currying formal description of the  calculus  expression application abstraction  expression recursive definition arithmetic expression free and bound variables free bound precedence and parenthesis equivalence of  expressions equivalent form equivalence equivalent evaluation aka   reduction variable renaming aka   conversion equivalence of  expressions call by name lazy evaluation call by value eager evaluation pure simplification evaluation    reduction renaming    conversion canonical simplification equivalent simplification of  expressions equivalence of  expressions  infinite loops in the  calculus the enhanced  calculus enhanced  calculus boolean constants and if function pairs pairing lists and strings empty list lists string list operations list-processing functions recursion recursive functions anonymous compute nand using  calculus  compute xor using  calculus  link pointer reference computing a function in the enhanced  calculus enhanced  expression application abstraction exp computes f computing a function via  calculus enhanced  calculus is turing-complete  lambda calculus and nand-tm      every initial configuration  from enhanced to pure  calculus all   enhanced  calculus equivalent to pure  calculus natural numbers church numerals optional list processing the y combinator or recursion without recursion python itself non recursive two inputs  two from python to the   calculus fixed point operators fixed point fixed point the y combinator the church-turing thesis discussion in  church had been speculating and finally definitely proposed that the -definable functions are all the effectively calculable functions  when church proposed this thesis i sat down to disprove it  but quickly realizing that my approach failed i became overnight a supporter of the thesis the thesis is not so much a definition or to an axiom but  a natural law computable church-turing thesis efficient extended efficiently different models of computation computational problems type of model examples memory bounded finite automata finite state machines regular languages   exercises key value alternative proof for tmram equivalence nand-tm lookup pairing shortest path longest simple path efficient longest path shortest path  expression next-step function is local  hint  calculus requires at most three variables evaluation order example in  calculus list of n pairs zip function without using   recurse next-step function without recurse  calculus to nand-tm compiler challenging at least two at least two in   calculus locality of the next step function not configuration locality of next-step function bibliographical notes haskell types"], ["lec_01_introduction.html", "Introduction", " introduction  algorithm tools ways of thinking and understanding  computer science is no more about computers than astronomy is about telescopes hackers need to understand the theory of computation about as much as painters need to understand paint chemistry the subject of my talk is perhaps most directly indicated by simply asking two questions first is it harder to multiply than to add and second whyi would like to show that there is no algorithm for multiplication computationally as simple as that for addition and this proves something of a stumbling block place-value number system position unspeakable integer multiplication an example of an algorithm data structure algorithm algorithm inherent independent specification what implementation how specification implementations analysis why proof correct efficient specification implementation and analysis of algorithms extended example a faster way to multiply optional quadruple analysis of algorithms two-digit four doubling quadrupling three double triple precise specification analysis analysis         fast fourier transform fourier transform matrix multiply eight matrix doubles seven matrix multiplication advanced note algorithms beyond arithmetic graph algorithms maximum flow pagerank akamai consistent hashing backpropagation algorithm compressed sensing ask on the importance of negative results dont laws of nature perpetual motion machine law of conservation of energy group theory non-euclidean geometries apply  most efficient prove impossible  roadmap to the rest of this book exist     models of computation impossibility results can not be solved reductions cryptography dependencies between chapters preliminaries part i finite computation boolean circuits part ii uniform computation turing machines part iii efficient computation part iv randomized computation part v advanced topics finite functions quantitative unbounded input lengths qualitative quantitative exercises   non existence non existence non existence usefulness of algorithmic non-existence hint analysis of karatsubas algorithm   matrix multiplication optional advanced bibliographical notes fast fourier transform matrix backpropagation pagerank hits akamai consistent hashing compressed sensing"], ["lec_10_efficient_alg.html", "Efficient computation", " efficient computation   the problem of distinguishing prime numbers from composite and of resolving the latter into their prime factors is  one of the most important and useful in arithmetic  nevertheless we must confess that all methods  are either restricted to very special cases or are so laborious  they try the patience of even the practiced calculator  and do not apply at all to larger numbers for practical purposes the difference between algebraic and exponential order is often more crucial than the difference between finite and non-finite what is the most efficient way to sort a million -bit integers i think the bubble sort would be the wrong way to go  computable time function of their input length best best known number function  exponential polynomial exponential insensitive polynomial not-too-large exponent exponential np completeness part i quantitative study finite functions part ii qualitative study infinite functions unbounded input length qualitative question part iii quantitative study infinite functions scale polynomially relations between parts of this book problems on graphs graphs vertices edges directed undirected adjacency list adjacency matrix finding the shortest path in a graph shortest path problem exponential queue queue weighted degree data structures lists arrays queues stacks heaps search trees hash tables some on data structures finding the longest path in a graph longest path problem longest maximally long longest path problem knights tour finding the minimum cut in a graph cut st cut minimum st cut problem cut cut bottlenecks polynomial min-cut max-flow and linear programming flow maximum st flow at most at least maximum flow flow linear programming global global minimum cut reduction  finding the maximum cut in a graph maximum cut maximizes maximum cut a note on convexity convex local minimum global minimum non convex convex convex local minimum global minimum maximizing concave linear discrete maximum empirical risk minimization training examples classifier errors loss function square loss linear function linear regression non convex beyond graphs sat propositional formula conjunctive normal form literal satisfiability problem satisfying assignment true sat sat problem satisfies literals implication sat solving linear equations inequalities integer exponential bit complexity of numbers solving quadratic equations linear quadratic more advanced examples determinant of a matrix nonsingular orthogonal inversions triangular triangular permanent of a matrix permanent permanent modulo  boolean permanent modulo  finding a zero-sum equilibrium zero sum game distribution finding a nash equilibrium equilibrium primality testing exponential probabilistic integer factoring find non existence our current knowledge factoring inherently require exponential gap  exercises  hint exponential time algorithm for longest path  sat algorithm bipartite cliques reductions for showing algorithms bibliographical notes further explorations"], ["lec_00_0_preface.html", "Preface", " preface we make ourselves no promises but we cherish the hope that the unobstructed pursuit of useless knowledge will prove to have consequences in the future as in the past an institution which sets free successive generations of human souls is amply justified whether or not this graduate or that makes a so-called useful contribution to human knowledge a poem a symphony a painting a mathematical truth a new scientific fact all bear in themselves all the justification that universities colleges and institutes of research need or require i suggest that you take the hardest courses that you can because you learn the most when you challenge yourself cs  i found pretty hard tool lens universality code data proofs reduction inherently intractable notion python c lisp to the student actively before definitions theorems theorem statement proof precise is the effort worth it different way of thinking energy matter computation information to potential instructors finite automata boolean circuits every code data universality restricted computational model liveness safety tractable semantic questions after time complexity functions languages decides a language computes a function specification function implementation program proofs programs acknowledgements"], ["lec_08a_restricted_models.html", "Restricted computational models", " restricted computational models  regular expressions context-free grammars semantic properties  happy families are all alike every unhappy family is unhappy in its own way turing equivalent uncomputable restricted computational models a b restricted computational models semantic questions  can not turing completeness as a bug the dao is borne from immutable unstoppable and irrefutable computer code the dao hack regular expressions searching search problem matched function program python not restricted computational models rich enough restricted regular expression or regular expression regular expression matches  matches regular function notation languages regular matching a regular expression   a regular function binary case generative models regular expression always halt  computing  smaller case  case  case   deterministic finite automata and efficient matching of regular expressions optional linear matching regular expressions in linear time  restriction input goal operation regular expression matching in linear time running time claim proof of claim i ii i ii   matching regular expressions using constant memory single pass if and only if  dfa for regular expression matching   input goals operation copy the variables  ve  to temporary variables update the variables  ve  based on the i-th bit of x constant memory regular expression matching  deterministic finite automata deterministic finite automaton dfa finite state machine dfa for xor transition function accepting states computes deterministic finite automaton   dfa and regular expression equivalency   with all intermediate states being in the set t  t- base case inductive step  regular functions are closed under complement  regular expressions closed under complement  limitations of regular expressions  matching parenthesis pumping lemma pumping lemma   if a string matching a regular expression is long enough one of its substrings must be matched using the  operator  somewhere base case inductive step a b c a b c   recursively defined induction recursive definitions and inductive proofs  not not there exists for every there exists for every there exists for every palindrome palindromes is not regular  other semantic properties of regular expressions tokens semantic questions equivalent  emptiness of regular languages is computable     equivalence of regular expressions is computable    context free grammars syntax error infinite loop syntax do not restricted context free grammars digit number operation expression number sub-expression operation sub-expression sub-expression recursive rules recursive context free grammar cfg over   variables initial variable rules can be derived context free grammar context free grammar for arithmetic expressions context-free grammars as a computational model can be derived in one step can be derived matched function computed by context free language function context free deriving a string from a grammar  context-free grammars always halt chomsky normal form  deciding tree root leaves parse tree parser parse trees the power of context free grammars  context free grammars and regular expressions case  case  case  recursion  context free grammar for palindromes  not non palindromes not  limitations of context-free grammars optional not  context-free pumping lemma if a long enough string is matched by a grammar there must be a variable that is repeated in the derivation  recursion  equality is not context-free  semantic properties of context free languages  emptiness for cfgs is decidable  non empty   uncomputability of context-free grammar equivalence optional uncomputable  fullness of cfgs is uncomputable not configurations configuration not every  configurations configuration initial halting configuration computation history reversed claim not at least one is not  summary of semantic properties for regular expressions and context-free grammars expressiveness amenability to analysis not  semantic regular expressions context free grammars  exercises closure properties of regular functions  non regularity closure properties of context-free functions  variables statement program syntax for programming languages bibliographical notes non deterministic finite automata always context general aka type  grammars recursively enumerable context sensitive grammars"], ["lec_20_alg_society.html", "Algorithms and society", " algorithms and society exercises bibliographical notes"], ["lec_06_loops.html", "Loops and infinity", " loops and infinity  turing machines arbitrary input lengths loops arrays  an algorithm is a finite answer to an infinite number of questions the bounds of arithmetic were however outstepped the moment the idea of applying the punched cards had occurred and the analytical engine does not occupy common ground with merecalculating machines  in enabling mechanism to combine together general symbols in successions of unlimited variety and extent a uniting link is established between the operations of matter and the abstract mental processes of the most abstract branch of mathematical science  finite single recipe single parity xor single loops address repeat loop turing machines nand-tm programming language loops arrays equivalent turing equivalence turing completeness finite functions unbounded turing machines loops finite unbounded infinite language finite vs infinite computation turing machines computing is normally done by writing certain symbols on paper we may suppose that this paper is divided into squares like a childs arithmetic book the behavior of the human computer at any moment is determined by the symbols which he is observing and of his state of mind at that moment we may suppose that in a simple operation not more than one symbol is altered we compare a man in the process of computing  to a machine which is only capable of a finite number of configurations the machine is supplied with a tape the analogue of paper  divided into sections called squares each capable of bearing a symbol what is the difference between a turing machine and the modern computer its the same as that between hillarys ascent of everest and the establishment of a hilton hotel on its peak turing machine tape alphabet l r s h transition function extended example a turing machine for palindromes palindromes palindrome i ii transition function transition function turing machines a formal definition tape turing machine transition function output turing machine  transition function finite infinite computable functions computable functions computes computable computable functions church turing thesis extended any possible algorithm  functions not programs compute functions  computable the class  r formal language theory formal language membership decision decides decidable recursive functions functions vs languages infinite loops and partial functions some partial function partial function subset computes computable computable partial or total functions does not necessary bot symbol turing machines as programming languages program program programs tape list array head position state local register boolean the nand-tm programming language nand-tm programming language single uniform algorithm arbitrary lengths loops straight-line loops arrays scalar array index  python c javascript ocaml nand-circ  loops  arrays  everything integer valued boolean valued scalars arrays scalar array arrays scalar variables arrays default values boolean four nand-tm program scalar variables array variables nand-tm programs sneak peak nand-tm vs turing machines examples xor in nand-tm increment function increment in nand-tm  equivalence of turing machines and nand-tm programs  turing machines and nand-tm programs are equivalent    every   tape arrays state scalar variables exists every  running time equivalence optional specification vs implementation again function functions programs machines nand-tm syntactic sugar goto and inner loops looping constructs other loops python java javascript invariants our intellectual powers are rather geared to master static relations and  our powers to visualize processes evolving in time are relatively poorly developed we should  do our utmost best to shorten the conceptual gap between the static program and the dynamic process java gotos in programming languages uniformity and nand vs nand-tm discussion collection uniformity uniform nonuniform uniform non uniform non uniform computational models nand-circ programs boolean circuits finite every some infinite sequence single algorithm uniform computational models turing machines nand-tm programs arbitrary length infinite infinite loop not  turing machines nand-tm programs infinite loop  exercises majority explicit nand tm programming computable functions examples two two index nand-tm two tape turing machine two tape turing machines two dimensional two dimensional arrays two-dimensional turing machine two dimensional two dimensional turing machines  oblivious oblivious turing machines challenging  single vs multiple bit countable uncomputability via counting all not explicit not every function is computable bibliographical notes analytical engine programs enigma seven tuple halting states rejecting state accepting state deciding a language input alphabet tape alphabet recognizes recursively enumerable"], ["lec_09_godel.html", "Is every theorem provable?", " is every theorem provable   take any definite unsolved problem such as  the existence of an infinite number of prime numbers of the form n   however unapproachable these problems may seem to us and however helpless we stand before them we have nevertheless the firm conviction that their solution must follow by a finite number of purely logical processes this conviction of the solvability of every mathematical problem is a powerful incentive to the worker we hear within us the perpetual call there is the problem seek its solution you can find it by pure reason for in mathematics there is no ignorabimus the meaning of a statement is its method of verification gdels incompleteness theorem inherently unprovable turing machine configurations hilberts program and gdels incompleteness theorem and what are these vanishing increments they are neither finite quantities nor quantities infinitely small nor yet nothing may we not call them the ghosts of departed quantities hilbert program  true provable gdels incompleteness theorem  informal version defining proof systems axioms inference rules mathematical statements string false the number   is prime programs  proof systems proof effectiveness soundness proof system effectiveness soundness unprovable complete proof systems proof verification algorithm  gdels incompleteness theorem computational variant gdels incompleteness theorem computational variant   not  fixed point true the gdel statement optional quantified integer statements programs natural numbers quantified integer statements  quantified integer statement quantified integer statements syntactic sugar for quantified integer statements v is not sound or v is not complete gdels incompleteness theorem for quantified integer statements  uncomputability of quantified integer statements every  diophantine equations and the mrdp theorem quintic group theory by any means diophantine equations integer no method mrdp theorem code data active code vs static data hardness of quantified integer statements easier solutions uncomputable  quantified mixed statements easier step  quantified mixed statements and computation histories quantified mixed statements string variables quantified mixed statement quantified mixed statements  uncomputability of quantified mixed statements  configuration quantified mixed statement computation history history  configuration configuration i ii iii for every for every  alternative proofs step  reducing mixed statements to integer statements integer integers  constructible prime sequence    exercises gdels theorem from uncomputability of qis halts on every input xv hint proof systems and uncomputability  expression for floor  sound axiomatic proof systems puzzle problem types of puzzle pieces post corrrespondence problem square tiling uncomputability of puzzle quadratic integer equation problem quadratic mrdp exercise faster the busy beaver problem bibliographical notes continuum hypothesis"], ["lec_12_NP.html", "Polynomial time reductions", " polynomial-time reductions  polynomial-time reductions  sat longest path maximum cut quadratic equations search computationally equivalent  np completeness reduction paradigm reduce does not exist inherently intractable formal definitions of problems decision problems boolean sat sat problem true quadratic equations quadratic equations problem longest path longest path problem maximum cut maximum cut problem polynomial-time reductions polynomial-time reduction reduction  f reduces to g equivalent complexity polynomial-time reductions reductions and  p   reduction  min-cut max-flow no polynomial-time algorithm uncomputability polynomial time transitivity of reductions transitivity of polynomial-time reductions  reducing sat to zero one equations zero-one linear equations problem real numbers gaussian elimination  hardness of eq  inequality equality takeaway technique auxiliary variables  completeness soundness completeness soundness  anatomy of a reduction what analysis why algorithm description how algorithm analysis how why analysis efficient correct efficiency completeness completeness soundness quadratic equations quadratic equations quadratic  hardness of quadratic equations  takeaway technique nonlinearity   the independent set problem stable set maximum independent set scheduling problems  hardness of independent set  takeaway technique gadget  conflicting literals triangle conflicting part  completeness true true part  soundness independent set true  python every clique clique is equivalent to independent set complement not clique  reducing independent set to maximum cut maximum cut  hardness of max cut  takeaway technique  part  completeness part  soundness  reducing sat to longest path note shortest path longest path  hardness of longest path    summary of relations equivalent complexity reductions not transitivity  exercises bibliographical notes mapping reduction many to one reduction karp reduction maximal maximum vertex cover maximum maximal sat solvers"], ["lec_26_quantum_computing.html", "Quantum computing", " quantum computing   we always have had secret secret close the doors  a great deal of difficulty in understanding the world view that quantum mechanics represents  it has not yet become obvious to me that theres no real problem  can i learn anything from asking this question about computersabout this may or may not be mystery as to what the world view of quantum mechanics is the only difference between a probabilistic classical world and the equations of the quantum world is that somehow or other it appears as if the probabilities would have to go negative aristotle essence reasons democritus atoms state the double slit experiment metal barrier with a single slit even more dented photons fewer not hit at all when both slits are open destructive fewer measure   quantum amplitudes not measure amplitude negative complex measure constructive destructive amplitudes cancellations  either not hit at all real negative pure mixed complex vs real other simplifications linear algebra quick review linear algebra complex linear inner product norm unit vector orthogonal orthonormal basis standard basis matrix unitary transpose matrix product bells inequality is disagree agree  bells inequality  deterministic randomized distributions averaging principle randomized strategies quantum weirdness interference measurement measured entanglement quantum entanglement quantum computing and computation - an executive summary exponential a b quantum computer physical extended church turing thesis not not grovers algorithm some not quantum computing and  np structured  quantum systems quantum classical logical bit classical local probabilistic distribution negation basis matrices vectors bases norms  quantum amplitudes complex real norm preserving complex hadamard quantum systems an executive summary state quantum system quantum operation unitary matrix transpose measure collapses analysis of bells inequality optional   case  x and y case  x and y case  case  x and y   opposing directions destructive interference quantum vs probabilistic strategies quantum computation basic operations non uniform models of computation uniform models of computation efficient computation quantum computation non uniform quantum circuits quantum circuit out degree measuring reversible three hadamard quantum circuit quantum circuit measure computes quantum circuit of n inputs m-n auxiliary bits and s gates computes quantum circuit   polynomial size quantum circuits   bqppoly probabilistic computation exponential space polynomial space prove known the obviously exponential fallacy qnand-circ programs optional measure uniform computation uniform qnand-tm programming language  the class  bqp      incomparable uniformly restricting attention to circuits physically realizing quantum computation universal sets collapsing coherence time theorems shors algorithm hearing the shape of prime factors no shors algorithm period finding periods periodic musical notes periodic wave length frequency chord every wave shors algorithm a birds eye view step  reduce to period finding  periodic  discrete logarithm step  period finding via the quantum fourier transform measure quantum fourier transform x-th fourier coefficient frequency greatest common divisor shors algorithm sketch input output operations quantum fourier transform period  quantum fourier transform not quantum state quantum fourier transform quantum fourier transform advanced optional quantum fourier transform group group theory finite commutative aka abelian groups group binary operation associative commutative abelian group theory every fourier coefficient of f corresponding to g fourier expansion fourier transform fourier coefficients fourier characters homomorphisms h periodic quantum fourier transform over the boolean cube simons algorithm qft over the boolean cube  hadamard fourier transform   from fourier to period finding simons algorithm advanced optional h periodic linear from simon to shor advanced optional can not not  exponentially faster  exercises quantum and classical complexity class relations generator order discrete logarithm discrete logarithm from order finding bibliographical notes"], ["lec_00_1_math_background.html", "Mathematical Background", " mathematical background  definitions statements proofs  i found that every number which may be expressed from one to ten surpasses the preceding by one unit afterwards the ten is doubled or tripled  until a hundred then the hundred is doubled and tripled in the same manner as the units and the tens  and so forth to the utmost limit of numeration a mathematicians apology computation is there an efficient algorithm to find the prime factors of a given integer phrase definition algorithm efficient nonexistence mathematical proof this chapter a readers manual discrete probability a quick overview of mathematical prerequisites proofs definitions statements proofs sets relations operations tuples and strings alphabet some special sets functions domain codomain one-to-one injective onto surjective partial functions logical operations basic combinatorics graphs big-o notation discrete probability probability theory finite random variables expectation concentration reading mathematical texts precise nature definitions assertions proofs definitions  one to one injective one to one function assertions theorems lemmas claims theorem lemma claim proofs proofs definitions theorems theorem statement proof basic discrete math objects sets set cardinality infinite subset superset empty set strict subset operations on sets union or intersection and set difference not tuples lists strings sequences tuple ordered pair tuples lists string length sequences function cartesian product cartesian product special sets natural numbers integers numbers real positive strings all generalizing the star operation concatenation concatenation functions function domain codomain image range range remainder one-to-one injective injection onto surjective surjection bijective bijection permutation infinite partial functions partial total total basic facts about functions composition a b c infinite b c definition onto at least one-to-one at most      onto  graphs graphs undirected directed  undirected graph vertices neighbors undirected graphs degree path simple path cycle connected connected    transitive    connected vertices have simple paths shortest  finding proofs directed graphs  directed graph ordered pairs out-neighbor in-neighbor directed graphs in-degree out-degree path simple path cycle directed acyclic graphs dags  directed acyclic graph dag directed acyclic graphs      shortest path  labeled graphs labels labelling function labeled graphs logic operators and quantifiers and or negation parameter unbound for every there exists for sufficiently large n quantifiers for summations and products parsing formulas bound and free variables bound free rename equivalent aside mathematical vs programming notation asymptotics and big-o notation     n has been proved to go to infinity but has never been observed to do so scaling behavior fog f og big-o notation much o is not equality inequalities some rules of thumb for big-o notation big o for other applications optional proofs yourself proofs and programs proofs programs program task yourself machine verifiable readability clear logical flow proof writing style proof qed role patterns in proofs if it was so it might be and if it were so it would be but as it isnt it aint thats logic through the looking-glass proofs by contradiction    even  proofs of a universal statement     proofs of an implication     proofs of equivalence proofs by combining intermediate claims proofs by case distinction a exhaustive one b proofs by induction without loss of generality wlog why structured hierarchical proofs hierarchical proofs optional extended example topological sorting topological sorting layering layering  layering layering of a dag  topological sort     cycle   algorithm  mathematical induction proof by induction induction a b a b b a a b b a b b b b  induction and recursion proving the result by induction for every dag gve with n vertices there is a layering of g for every n if qn- is true then qn is true source proof qed lemmas claims claim proof of claim qed claim case  case  case  case  self loop    type   trying  minimality and uniqueness unique minimal minimal minimal layering is unique unique    why  this book notation and conventions not partial total boolean function deciding a language partial functions promise problem variable name conventions variables type some idioms let x be   let x denote   let x   defining property we say that   has the property x if   where x is   quantifiers for all i   there is x   dependencies for every k  there exists n depends for every natural number k there exists a prime number n such that n divides k there exists a prime number n such that for every natural number k n divides k numbered equations theorems definitions ie eg thus therefore we get that indeed the n-vertex graph g has at least n- edges indeed this follows since g is connected constants scales constants there exists a constant c such that for every n    algorithm a runs in at most c   n steps on inputs of length n algorithm a runs in on time  numbers sets tuples strings graphs functions graphs pairs definitions statements proofs  exercises true odd logical expressions quantifiers   set construction notation existence of one to one mappings inclusion exclusion          o-notation     bibliographical notes graph one to one onto"], ["lec_14a_space_complexity.html", "Space bounded computation", " space bounded computation exercises bibliographical notes"], ["lec_08_uncomputability.html", "Universality and uncomputability", " universality and uncomputability  halting problem reductions  a function of a variable quantity is an analytic expression composed in any way whatsoever of the variable quantity and numbers or constant quantities the importance of the universal machine is clear we do not need to have an infinity of different machines doing different jobs  the engineering problem of producing various machines for various jobs is replaced by the office work of programming the universal machine universality larger universal turing machine universal nand-tm program general purpose computer via software code uncomputable functions universal turing machine some reductions universality or a meta-circular evaluator universal turing machine arbitrary arbitrary self reference universal turing machine universal turing machine universal  interpreter  proving the existence of a universal turing machine string representation string representation of turing machine every some take away points of representation python turing machine dictionary  search tree hash table efficiency of the simulation direct construction of universal turing machines implications of universality discussion a i said to him ho ho youre confusing theory with practice this eval is intended for reading not for computing but he went ahead and did it that is he compiled the eval in my paper into ibm  machine code fixing a bug and then advertised this as a lisp interpreter which it certainly was b themselves is every function computable false uncomputable  uncomputable functions  not     can not any   cannot  diagonalization counting undecidable non recursive the halting problem some wants  uncomputability of halting function  reduce  reduction case  case     is the halting problem really hard discussion they church-turing thesis every will general procedure arbitrary a direct proof of the uncomputability of   halt optional  reductions contrapositive if then if then believe know if pigs could whistle then horses could fly reduction reduces analysis algorithm specification what implementation how analysis why proof reductions are algorithms example halting on the zero problem  halting without input   reduction description of the reduction analysis of the reduction not description analysis claim proof of claim   the hardwiring technique rices theorem and the impossibility of general software verification we cannot certify semantic properties of general purpose programs function semantic property uncomputable  computing all zero function  not   uncomputability of verifying parity  rices theorem semantic specification semantic true false function the program p computes a function f mapping integers to integers satisfying that fn   n for every input n not semantic source code functionally equivalent semantic some semantic properties zerofunc is semantic  semantic rices theorem i ii not  anywhere machines functions algorithm b input goal assumption operation a b  not a b code not does a b  only not computable i ii syntactic semantic is not the same as uncomputable halting and rices theorem for other turing-complete models equivalent  nand-tm machine halting   constructive compute reduction    calculus two dimensional automata is software verification doomed discussion general arbitrary prove software verification universal inherently uncomputable any  exercises nand-ram halt step computable timed halting computable space halting challenging necessarily computable computable compositions  computing parity cannot tm equivalence  hint  recursively enumerable countable not recursively enumerable language recognized by m recursively enumerable a b b rices theorem standard form  m-semantic rices theorem for general turing-equivalent models optional bibliographical notes we have seen a mass of bizarre functions which appear to be forced to resemble as little as possible honest functions which serve some purpose  they are invented on purpose to show that our ancestors reasoning was at fault and we shall never get anything more than that out of them incompleteness theorem recursively enumerable"], ["lec_11_running_time.html", "Modeling running time", " modeling running time  time hierarchy theorem can can not non uniform  max newman alan turing  dependence polynomial time exponential time polynomially related efficient time hierarchy theorem non uniform sequence uncomputable formally defining running time running time function of the length x of the input computable in tn single-tape-turing-machine time tm-time for short running time turing machines  functions machines  boolean functions example of time bounds  polynomial and exponential time extended polynomial exponential polynomial time computable in polynomial time polynomial exponential time computable in exponential time exponential  p and  exp not can  differerent definitions of  p degree  boolean non boolean boolean versions of problems modeling running time using ram machines  nand-ram computable efficiency ram machines computable in tn ram time ram-time for short running time ram relating ram and turing machines  nand-ram programs polynomial exponential design analyze negative result  quantum computers  statement  two dimensional array boolean-valued number of repetitions is at most tn take number of steps polynomial in       tn take otn steps takes otn steps takes otn steps  nice time bound function in the number of bits nice time bounds extended church-turing thesis discussion turing machines ram machines  nand-ram programs extended church turing thesis scalable computing device physical extended church-turing thesis quantum computing efficient universal machine a nand-ram interpreter in nand-ram polynomial constant universal nand-ram program not u is a universal nand-ram program u is efficient efficient universality of nand-ram  statement   timed universal turing machine unary  timed universal turing machine timed  the time hierarchy theorem uncomputable can can not yes  time hierarchy theorem  simpler corollary of the time hierarchy theorem time hierarchy theorem distinct   bounded halting claim  claim  proof of claim  proof of claim  not   p vs  exp  known non uniform computation finite restriction non-uniformly computable in at most tn size non uniform computation single different nonuniform computation contains uniform computation loops oblivious  oblivious nand-tm programs oblivious  making nand-tm oblivious   oblivious  unrolling the loop algorithmic transformation of turing machines to circuits algorithmic turing-machine to circuit compiler  oblivious   alternative characterization of  p   ppoly characterization by advice  can uniform algorithms simulate non uniform ones no uncomputable  uncomputable  ppoly contains uncomputable functions   onto constant  uniformity single efficient inefficient computation uniform vsnonuniform computation a recap uniform models turing machines nand-tm programs ram machines nand-ram programs cjavascriptpython non-uniform models boolean circuits straightline programs hardness easiness some  exercises equivalence of different definitions of  p and  exp robust robustness to representation boolean functions  composition composition of polynomial time  non composition of exponential time oblivious length oblivious hint oblivious turing machines planar  evaluate nand circuits hint find hard function conflicts   prove three  bibliographical notes maximum worst case complexity minimum average case complexity cryptography advice string"], ["lec_17_model_rand.html", "Modeling randomized computation", " modeling randomized computation   any one who considers arithmetical methods of producing random digits is of course in a state of sin worst case amplify yes pseudorandom generators modeling randomized computation running in polynomial time the class  bpp not worst case on every possible randomized polynomial time randomized algorithm choosing from a set  an alternative view random coins as an extra input deterministic two inputs  alternative characterization of  bpp    there exists for every definitions of  bpp and  np random tapes success amplification of two-sided error algorithms amplification amplify    incorrect   bpp and  np completeness yes  np hardness and bpp every    every  the power of randomization extended church turing hypothesis not solving  bpp in exponential time exponential  simulating randomized algorithms in exponential time   simulating randomized algorithms by circuits random every  randomness does not help for non uniform computation  single fixed choice all  amplify union every there exists  derandomization single all input lengths guaranteed to fail general always pseudorandom generators single collection eliminate reducing  t -pseudorandom generator pseudorandom generator seed finite deterministic  pseudorandom what reason do we have to believe that pseudorandom generators with non-trivial parameters exist even if they do exist why would such generators be useful to derandomize randomized algorithms prove interesting exponentially larger  statement proof  from existence to constructivity exists non existence hardness vs randomness optimal prg conjecture exponentially secure pseudorandom generator   conjecture prove exponentially strong pseudorandom functions pseudorandom function generator pseudorandomness usefulness of pseudorandom generators  derandomization of bpp  exponential expansion    p np and  bpp vs  p negative positive  sipsergcs theorem statement   claim i claim ii claim i claim ii claim i claim ii probabilistic method existential proof of claim ii exist not claim i  non-constructive existence of pseudorandom generators advanced optional constructivity exponentially larger  existence of inefficient pseudorandom generators  exists proof technique deterministic  claim i at random sample space all exists does not  worst case on every input amplify exponentiall close to   exercises bibliographical notes entropy uniform"], ["lec_13_Cook_Levin.html", "NP, NP completeness, and the Cook-Levin Theorem", " np np completeness and the cook-levin theorem   in this paper we give theorems that suggest but do not imply that these problems as well as many others will remain intractable perpetually sad to say but it will be many more years if ever before we really understand the mystical power of twoness -sat is easy -sat is hard -dimensional matching is easy -dimensional matching is hard why oh why computationally equivalent search solution every verified cook levin theorem every  np complete the class  np search problem efficiently verified np every certificate witness proof solution certificate witness alternative definition of  np  short and efficiently verifiable proof verifier short asymmetric not not does  np not necessaily closed under complement examples of functions in  np sat    np basic facts about  np verifying is no harder than solving  not easy to verify  np does not mean non-polynomial  np is in exponential time  strict certify reductions and  np  from  np to sat the cook-levin theorem solve verify many  cook-levin theorem equivalent every all  np hard  np complete  np-hardness and  np-completeness single efficiently-verifiable  what does this mean the strict permanent the cook-levin theorem proof outline the   nandsat problem and why it is  np hard input output nandsat    np        claim proof of claim  the   nand problem input output     true part i completeness part ii soundness not smallest do  from   nand to   sat        independent set wrapping up some  all unknown nonexistent average-case complexity approximation algorithms  exercises  hint poor mans ladners theorem hint is  np    co-np    np    p without negations  employee recruiting problem  balanced max cut regular expression intersection bibliographical notes"], ["lec_03_computation.html", "Defining Computation", " defining computation  boolean circuits straight-line programs  there is no reason why mental as well as bodily labor should not be economized by the aid of machinery if unwarned by my example any man shall undertake and shall succeed in constructing an engine embodying in itself the whole of the executive department of mathematical analysis upon different principles or by simpler mechanical means i have no fear of leaving my reputation in his charge for he alone will be fully able to appreciate the nature of my efforts and the value of their results to understand a program you must become both the machine and the program popular mechanics python technology independent specifies what implementing how defining computation how to solve an equation of the form  roots and squares are equal to numbers for instance one square  and ten roots of the same amount to thirty-nine dirhems that is to say what must be the square which when increased by ten of its own root amounts to thirty-nine the solution is this you halve the number of the roots which in the present instance yields five this you multiply by itself the product is twenty-five add this to thirty-nine the sum is sixty-four now take the root of this which is eight and subtract from it half the number of roots which is five the remainder is three this is the root of the square which you sought for the square itself is nine programming languages python informal definition of an algorithm algorithm computes  boolean circuits straight line programs elementary operations boolean circuit straight line program computing using and or and not complex simpler composing either and or and or and majority from andor and not some properties of and and or commutativity associativity distributive law for and and or  extended example computing   xor from   and   or and   not    different  python compute xor on three bits of input associativity commutativity    informally defining basic operations and algorithms semi-formal definition of an algorithm algorithm computes    mechanize transistors physically implement boolean circuits boolean circuits gates inputs wires wires or and not or gate and not inputs output gates mathematical model voltage physical realization of boolean circuits boolean circuit gates wires inputs all equal function  all equal boolean circuits a formal definition and or not directed acyclic graph dag vertices edges and or not boolean circuit input gates and or not outputs boolean circuit inputs gates and or not outputs size boolean circuits topologically sorted  output minimal layering topological sorting and computes computing a function via a boolean circuit boolean circuits nitpicks optional equivalence of circuits and straight-line programs and or not boolean circuit and or not straight-line program straight-line program and or not circuit aon-circ program input output output of p on input x computes aon-circ programming language  or and   equivalence of circuits and straight-line programs  and and   or not  physical implementations of computing devices digression computation implementations fluidics quantum mechanical effects transistors transistor source gate sink standard transistor complementary transistor vacuum tubes transistors semiconductors field effect integrated circuits logical gates from transistors biological computing lac cellular automata and the game of life cellular automata cells neighboring cells neural networks brain neural network threshold gates threshold function corresponding to wt neuron cells artificial neural networks a computer made from marbles and pipes mechanical the nand function  nand computes andornot    i ii   compute majority with nand  nand circuits nand circuits nand circuit for xor  nand is a universal operation    equivalent in power  more examples of nand circuits optional incrementing integers add  to the least significant bit and propagate the carry python increment from increment to addition the nand-circ programming language nand-circ programming language our first nand-circ program   computes computing by a nand-circ program  nand circuits and straight-line program equivalence  no finite infinite is the nand-circ programming language turing complete optional note equivalence of all these models equivalence between models of finite computation   circuitsprograms functions specification implementation circuits with other gate sets  f program universal set of operations general straight-line programs  f circuits gate symmetric universality ifzeroone circuits not specification vsimplementation again specification what implementation how specification implementation function specification what program algorithms implementation how functions programs  algorithm nand-circ programming language  exercises compare  bit numbers compare n bit numbers universal ornot is universal monotone not andor is not universal affine or linear modulo two not xor is not universal majnot  is universal hint majnot  is not universal nor is universal lookup is universal  bound on universal basis size challenge hint size and inputs  outputs  threshold threshold using nands nand approximator affine nands from activation functions majority with nands efficiently hint output at last layer biographical notes difference engine analytical engine principia mathematica"], ["lec_03a_computing_every_function.html", "Syntactic sugar, and computing every function", " syntactic sugar and computing every function  quantitatively  in  i had a running compiler and nobody would touch it because they carefully told me computers could only do arithmetic they could not do programs syntactic sugar causes cancer of the semicolon equivalent every every some examples of syntactic sugar straight-line programming language user-defined procedures procedures subroutines functions procedures  procedure definition synctatic sugar non recursive no recursive procedure majority computing majority from nand using syntactic sugar  present counting lines proof by python optional regular expressions parsing function definitions optional conditional statements   multiplexing  conditional statements synctatic sugar extended example addition and multiplication optional loop  addition using nand-circ programs  multiplication using nand-circ programs the lookup function  lookup lookup function  lookup function constructing a nand-circ program for   lookup  lookup recursion   proof of a hreflookup-thmtheorem a from a hreflookup-rec-lemlemma a every computing every function every  universality of nand  universality of boolean circuits every  improved bounds proof of nands universality every every  some result in perspective improving by a factor of n optional  universality of nand circuits improved bound distinct functions   universality of boolean circuits  improved bound computing every function an alternative proof  universality of boolean circuits alternative phrasing   claim proof of claim  the class   sizet every some  size class of functions functions programs category error programs functions computes equal every all    functions programs specifications implementations functions finite vs infinite functions size closed under complement   efficient  exercises pairing computing mux at least two  majority conditional statements half adder full adder half and full adders  addition  multiplication  hint efficient multiplication challenge multibit function simplifying using syntactic sugar power or and or prove   not computable compare if and nand compare xor and nand circuits for majority threshold circuits for threshold bibliographical notes"], ["lec_15_probability.html", "Probability theory 101", " probability theory    god doesnt play dice with the universe einstein was doubly wrong  not only does god definitely play dice but he sometimes confuses us by throwing them where they cant be seen the probability of winning a battle has no place in our theory because it does not belong to any random experiment probability cannot be applied to this problem any more than the physical concept of work can be applied to the work done by an actor reciting his part i am unable to see why objectivity requires us to interpret every probability as a frequency in some random experiment particularly when in most problems probabilities are frequencies only in an imaginary universe invented just for the purpose of allowing a frequency interpretation random coins events random variables sample spaces event probability of a      intersection union and or even and not not   sample space  event some remember the sample space random variables events how much random variable expectation linear  linearity of expectation   expectation of sum     union bound     union bound distributions over strings real number string distributions distribution identical more general sample spaces probability distribution event random variable correlations and independence independence correlations correlation causation independent not independent positively correlated negatively correlated independent  disjointness independence disjoint independent not disjointness vs independence conditional probability conditioned on a more than two events mutually independent not independent random variables       collections of independent random variables mutually independent  expectation of product of independent random variables  functions preserve independence   concentration and tail bounds independent concentrated concentration tail  markovs inequality  tight    the averaging principle averaging principle    chebyshevs inequality concentrated median chebyshevs inequality standard deviation standard deviation variance standard deviation  chebyshevs inequality   independent and identically distributed the chernoff bound normal gaussian bell curve very exponential decay normal distribution exponentially  chernoffhoeffding bound random variables expectation concentration tail bounds  exercises      not    product of expectations  transformations preserve independence  variance of independent random variables  entropy entropy challenge  hint entropy approximation to binomial  chernoff using stirling  hint hint poor mans chernoff    hint simulating distributions using coins sampling   sampling  bibliographical notes"], ["lec_04_code_and_data.html", "Code as Data, Data as Code", " code as data data as code  exponential physical extended church-turing thesis all  the term code script is of course too narrow the chromosomal structures are at the same time instrumental in bringing about the development they foreshadow they are law-code and executive power - or to use another simile they are architects plan and builders craft - in one a mathematician would hardly call a correspondence between the set of  triples of four units and a set of twenty other unitsuniversal while such correspondence is probably the most fundamental general feature of life on earth data inputs program  code data general purpose general count every at most some at least bounded universal circuit loops turing machine count some exponential representing programs as strings adjacency matrix adjacency list every representing programs as strings  counting programs and lower bounds on the size of nand-circ programs  counting programs  double exponential  counting argument lower bound  every cannot  most  more efficient representation advanced optional size hierarchy theorem optional all some not contained  size hierarchy theorem  can cannot  can  cannot    some multiplying prime factorization some can explicit functions the tuples representation number line input output list of tuples representation of p list of tuples representation representing the xor program python from tuples to strings a nand-circ interpreter in nand-circ take-away points arbitrary arbitrary function program specification program implementation self circularity bounded universality of nand-circ programs any other nand-circ program any input bounded universal program universal circuit single program arbitrary loops turing machines every some    universal circuit efficient universal programs exponential polynomial  efficient bounded universality of nand-circ programs exists for every  python a nand-circ interpeter in pseudocode algorithm   bit array a nand interpreter in python python constructing the nand-circ interpreter in nand-circ nand-circ program  you code  can   python universal graph improving to quasilinear overhead advanced optional note a python interpreter in nand-circ discussion every machine language arm architecture can particular particular single different arbitrary in python all universality self reference the physical extended church-turing thesis discussion every church turing thesis physical extended church-turing thesis pectt if a function fn   m can be computed in the physical world using s amount of physical resources then it can be computed by a boolean circuit program of roughly s gates exponentially hard computes exponentially planck length planck time empirically falsify interactive proofs program checking no single explicit function prove advanced note making pectt concrete advanced optional attempts at refuting the pectt spaghetti sort soap bubbles euclidean steiner tree np complete exponentially dna computing continuousreal computers phrase relativity computer and time travel his our closed timelike curves ctcs humans at the moment inherent find quantum computation quantum computing quantum circuits not cryptography a b prove physical extended church-turing thesis and cryptography  process data physical extended church-turing thesis pectt quantum computers  recap of part i finite computation finite computation circuit straight-line program functions functions every at most some at least universal count every every quantum computing sneak preview unbounded inputs exercises   equals function  equal to constant function counting lower bound for multibit functions size hierarchy theorem for multibit functions efficient representation of circuits and a tighter counting upper bound hint tighter counting lower bound  hint random functions are hard  does not exist eval with xor learned hint learning circuits challenge optional assumes more background bibliographical notes universal circuit explicit prove"], ["lec_19_cryptography.html", "Cryptography", " cryptography   human ingenuity cannot concoct a cipher which human ingenuity cannot resolve a good disguise should not reveal the persons height perfect secrecy is defined by requiring of a system that after a cryptogram is intercepted by the enemy the a posteriori probabilities of this cryptogram representing various messages be identically the same as the a priori probabilities of the same messages before the interception it is shown that perfect secrecy is possible but requires if the number of messages is finite the same number of possible keys we stand today on the brink of a revolution in cryptography public key define concrete computational problems classical cryptosystems substitution cipher repeat enigma after enigma not only defining encryption private key encryption public key encryption sender plaintext receiver adversary secret key encrypt ciphertext decrypt valid secure valid private key encryption scheme encryption scheme valid encryption scheme valid lengths of ciphertext and plaintext  larger defining security of encryption security  secure  methods a cryptosystem should be secure even if everything about the system except the key is public knowledge any random there is no secrecy without randomness secrecy randomness  trapdoor randomness in the real world perfect secrecy an encryption scheme is secure if it is not possible to recover the key k from ekx plaintext an encryption scheme is secure if it is not possible to recover the plaintext x from ekx partial information perfect secrecy perfectly secret perfect secrecy  example perfect secrecy in the battlefield eve   bayes rule no additional information constructing perfectly secret encryption perfect secrecy any matching  one time pad vernam  shannon     one time pad  all  necessity of long keys not necessary  perfect secrecy requires long keys  degree  claim i image  computational secrecy exponential in the length of the key computational secrecy computationally secret computational secrecy  arbitrary  yes computational hardness  exponentially stream ciphers or the derandomized one-time pad stream cipher pseudorandom generator cryptographic pseudorandom generator cryptographic pseudorandom generator pseudorandom generator exponential size the crypto prg conjecture  derandomized one-time pad   triangle inequality   stream ciphers block ciphers chosen plaintext man in the middle chosen ciphertext stream ciphers in practice computational secrecy and  np breaking encryption using  np algorithm  averaging principle  false public key cryptography raised exponentially harder compute invert trapdoor without ever having exchanged a secret key integrity secrecy sign key exchange protocol public key encryption key exchange protocol defining public key encryption public key encryption key generation algorithm public encryption private decryption security parameter encryption algorithm decryption algorithm public key encryption computationally secret public key encryption public key encryption randomized necessary only one bit long longer than the key group theoretic constructions integer factoring discrete logarithm latticecoding based constructions closest vector in a lattice bounded distance decoding quantum computers diffie-hellman key exchange discrete logarithm problem inverse binary search modular arithmetic discrete logarithm alice bob alice quantum computer other security notions integrity authentication digital signature schemes active attacks cryptographic hash functions magic zero knowledge proofs zero knowledge proofs rigorously show absolutely no additional information about x negative result positive applications fully homomorphic encryption manipulate without knowing the secret key k immensely ever learning any information existence fully homomorphic encryption scheme multiparty secure computation no commonly trusted party or authority electronic voting protocol second highest bid randomized perfect secrecy anything computational secrecy exponentially bigger public key encryption digital signatures hash functions multiparty secure computation fully homomorphic encryption zero knowledge proofs  exercises bibliographical notes i hope my handwriting etc do not give the impression i am just a crank or circle-squarer the significance of this conjecture that certain encryption schemes are exponentially secure against key recovery attacks  is that it is quite feasible to design ciphers that are effectively unbreakable computational indistinguishability semantic security signature scheme"], ["lec_02_representation.html", "Computation and Representation", " computation and representation  specification implementation mathematical functions algorithmsprograms  the alphabet sic was a great invention which enabled men sic to store and to learn with little effort what others had learned the hard way  that is to learn from books rather than from direct possibly painful contact with the real world the name of the song is called haddocks eyes oh thats the name of the song is it no you dont understand thats what the name is called the name really is the aged aged man then i ought to have said thats what the song is called no you oughtnt thats quite another thing the song is called ways and means but thats only what its called you know well what is the song then i was coming to that the song really is a-sitting on a gate and the tunes my own invention through the looking-glass computation input output computation what specification how implementation what strings of zeroes and ones language compute representation defining representations representation representing representation representation scheme one to one representing natural numbers binary basis number decimal representation number binary representation binary recursively python binary representation in python optional code examples equivalent not programming examples meaning of representations discussion liber abaci representations beyond natural numbers representing potentially negative integers integers onto  type interpretation and context twos complement representation optional signed magnitude representation twos complement representation negative twos complement representation undefined behavior rational numbers and representing pairs of strings pairs of strings pairs of strings pair representing a rational number as a string  lists of lists prefix free encoding representing real numbers real numbers irrational floating point representation floating point representation scheme approximately exactly can we represent reals exactly exactly  reals are uncountable uncountability of the reals no one shall expel us from the paradise which cantor has created for us is is  functions sequences    does  onto diagonal   every subsets power set generalizing beyond strings and reals   binary using decimal expansion optional representing objects beyond numbers representation scheme encoding decoding  representation scheme encoding decoding string representation onto encoding     partial total total decoding functions finite representations finite     prefix-free encoding prefix-free prefix list every lists prefix prefix-free prefix free encoding lists prefix-free implies tuple encoding      lists every prefix freeness of list representation making representations prefix-free fixed output length         proof by python optional constructive lists prefix free prefix-free  python functions  lists representing letters and text code points braille system the braille representation representing objects in c optional representing vectors matrices images vectors matrices representing graphs graph adjacency adjacency list representing lists and nested lists nested notation a is an algorithm that computes the multiplication function on natural numbers a is an algorithm that computes the function f    such that for every pair ab     if x   is a string representing the pair ab then fx will be a string representing their product a  b  defining computational tasks as mathematical functions computational process computational tasks specification implementation computing a function factorization longest partial do  boolean decision problem language deciding a language boolean functions and languages boolean functions languages deciding a language algorithms there is no algorithm good thing algorithm distinguish functions from programs specifications implementations mathematical functions algorithmsprograms functions programs programs mathematical function program algorithm function computes function program computes function program computes  functions programs circuits machines partial promise problems relations relation set of strings interactive boolean computation beyond functions advanced optional  computing a function best  exercises  binary representation no lossless one to one random speed ratio every more compact than ascii representation representing graphs upper bound no representing graphs lower bound multiplying in different representation    prefix-free prefix-free encoding of tuples more efficient prefix-free transformation   krafts inequality  composition of one-to-one functions natural numbers and strings map lists of integers to a number bibliographical notes compression error corrections information theory data structures design gullivers travels definition specification implementation computation approximate spectral graph theory random walks"], ["lec_16_randomized_alg.html", "Probabilistic computation", " probabilistic computation   in   i asked myself what are the chances that a canfield solitaire laid out with  cards will come out successfully after spending a lot of time trying to estimate them by pure combinatorial calculations i wondered whether a more practical method  might not be to lay it our say one hundred times and simple observe and count the salient features of our method are that it is probabilistic  and with a controllable miniscule probability of error out error correct redundancy resource finding approximately good maximum cuts maximum cut problem  approximating max cut  random cut  algorithm random cut input operation   randomized algorithms work in the worst case not random choices of the algorithm for every graph g every possible input  not amplifying the success of randomized algorithms expectation amplify too      success amplification some all repeat   algorithm amplify random cut input operation   two-sided amplification one sided error two sided errors majority value exponentially close two-sided amplification what does this mean worst case input graph internal randomness of the algorithm guaranteed solving sat through randomization algorithm walksat input parameters operation   walksat simple analysis claim i proof of claim i satisfying not claim  proof of claim ii  bipartite matching matching bipartite perfect matching perfect matching permutation  inverted determinant matching polynomial   determinant zero testing if a polynomial is not identically zero then it cant have too many roots to decide if p is identically zero choose a random input x and check if px    schwartzzippel lemma algorithm perfect-matching input operation  amplify  exercises amplification for max cut  deterministic max cut algorithm    hint simulating distributions using coins  better walksat analysis  faster bipartite matching challenge bibliographical notes acknowledgements"], ["lnotes_book.html", "index", " introduction to theoretical computer science boaz barak work in progress comments suggestions typo fixes issue pull request github repository boazbktcs"]]