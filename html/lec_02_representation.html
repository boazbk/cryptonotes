<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: Computation and Representation</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: Computation and Representation" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->



<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.1</b> Exercises</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Computation and Representation</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_02_representation.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="chaprepres" data-number="2">Computation and Representation</h1>
<div id="section" class="objectives" name="Objectives">
<ul>
<li>Distinguish between <em>specification</em> and <em>implementation</em>, or equivalently between <em>mathematical functions</em> and <em>algorithms/programs</em>.</li>
<li>Representing an object as a string (often of zeroes and ones).</li>
<li>Examples of representations for common objects such as numbers, vectors, lists, graphs.</li>
<li>Prefix-free representations.</li>
<li>Cantor’s Theorem: The real numbers cannot be represented exactly as finite strings.</li>
</ul>
</div>
<blockquote>
<p><em>“The alphabet (sic) was a great invention, which enabled men (sic) to store and to learn with little effort what others had learned the hard way – that is, to learn from books rather than from direct, possibly painful, contact with the real world.”</em>, B.F. Skinner</p>
</blockquote>
<blockquote>
<p><em>“The name of the song is called `HADDOCK’S EYES.’”</em> [said the Knight]</p>
<p><em>“Oh, that’s the name of the song, is it?”</em> Alice said, trying to feel interested.</p>
<p><em>“No, you don’t understand,”</em> the Knight said, looking a little vexed. <em>“That’s what the name is CALLED. The name really is `THE AGED AGED MAN.’”</em></p>
<p><em>“Then I ought to have said `That’s what the SONG is called’?”</em> Alice corrected herself.</p>
<p><em>“No, you oughtn’t: that’s quite another thing! The SONG is called `WAYS AND MEANS’: but that’s only what it’s CALLED, you know!”</em></p>
<p><em>“Well, what IS the song, then?”</em> said Alice, who was by this time completely bewildered.</p>
<p><em>“I was coming to that,”</em> the Knight said. <em>“The song really IS `A-SITTING ON A GATE’: and the tune’s my own invention.”</em></p>
<p>Lewis Carroll, <em>Through the Looking-Glass</em></p>
</blockquote>
<p>To a first approximation, <em>computation</em> is a process that maps an <em>input</em> to an <em>output</em>.</p>
<figure>
<img src="../figure/input_output.png" alt="2.1: Our basic notion of computation is some process that maps an input to an output" id="computationinputtooutputfig" class="margin" /><figcaption>2.1: Our basic notion of <em>computation</em> is some process that maps an input to an output</figcaption>
</figure>
<p>When discussing computation, it is essential to separate the question of <strong>what</strong> is the task we need to perform (i.e., the <em>specification</em>) from the question of <strong>how</strong> we achieve this task (i.e., the <em>implementation</em>). For example, as we’ve seen, there is more than one way to achieve the computational task of computing the product of two integers.</p>
<p>In this chapter we focus on the <strong>what</strong> part, namely defining computational tasks. For starters, we need to define the inputs and outputs. Capturing all the potential inputs and outputs that we might ever want to compute on seems challenging, since computation today is applied to a wide variety of objects. We do not compute merely on numbers, but also on texts, images, videos, connection graphs of social networks, MRI scans, gene data, and even other programs. We will represent all these objects as <strong>strings of zeroes and ones</strong>, that is objects such as <span><span class="math inline">\(0011101\)</span></span> or <span><span class="math inline">\(1011\)</span></span> or any other finite list of <span><span class="math inline">\(1\)</span></span>’s and <span><span class="math inline">\(0\)</span></span>’s. (This choice is for convenience: there is nothing “holy” about zeroes and ones, and we could have used any other finite collection of symbols.)</p>
<figure>
<img src="../figure/zeroes-ones.jpg" alt="2.2: We represent numbers, texts, images, networks and many other objects using strings of zeroes and ones. Writing the zeroes and ones themselves in green font over a black background is optional." id="zerosandonesgreenfig" class="margin" /><figcaption>2.2: We represent numbers, texts, images, networks and many other objects using strings of zeroes and ones. Writing the zeroes and ones themselves in green font over a black background is optional.</figcaption>
</figure>
<p>Today, we are so used to the notion of digital representation that we are not surprised by the existence of such an encoding. But it is actually a deep insight with significant implications. Many animals can convey a particular fear or desire, but what is unique about humans is <em>language</em>: we use a finite collection of basic symbols to describe a potentially unlimited range of experiences. Language allows transmission of information over both time and space and enables societies that span a great many people and accumulate a body of shared knowledge over time.</p>
<p>Over the last several decades, we have seen a revolution in what we can represent and convey in digital form. We can capture experiences with almost perfect fidelity, and disseminate it essentially instantaneously to an unlimited audience. Moreover, once information is in digital form, we can <em>compute</em> over it, and gain insights from data that were not accessible in prior times. At the heart of this revolution is the simple but profound observation that we can represent an unbounded variety of objects using a finite set of symbols (and in fact using only the two symbols <code>0</code> and <code>1</code>).</p>
<p>In later chapters, we will typically take such representations for granted, and hence use expressions such as “program <span><span class="math inline">\(P\)</span></span> takes <span><span class="math inline">\(x\)</span></span> as input” when <span><span class="math inline">\(x\)</span></span> might be a number, a vector, a graph, or any other object, when we really mean that <span><span class="math inline">\(P\)</span></span> takes as input the <em>representation</em> of <span><span class="math inline">\(x\)</span></span> as a binary string. However, in this chapter we will dwell a bit more on how we can construct such representations.</p>
<h2 id="defining-representations" data-number="2.1">Defining representations</h2>
<p>Every time we store numbers, images, sounds, databases, or other objects on a computer, what we actually store in the computer’s memory is the <em>representation</em> of these objects. Moreover, the idea of representation is not restricted to digital computers. When we write down text or make a drawing we are <em>representing</em> ideas or experiences as sequences of symbols (which might as well be strings of zeroes and ones). Even our brain does not store the actual sensory inputs we experience, but rather only a <em>representation</em> of them.</p>
<p>To use objects such as numbers, images, graphs, or others as inputs for computation, we need to define precisely how to represent these objects as binary strings. A <em>representation scheme</em> is a way to map an object <span><span class="math inline">\(x\)</span></span> to a binary string <span><span class="math inline">\(E(x) \in \{0,1\}^*\)</span></span>. For example, a representation scheme for natural numbers is a function <span><span class="math inline">\(E:\N \rightarrow \{0,1\}^*\)</span></span>. Of course, we cannot merely represent all numbers as the string “<span><span class="math inline">\(0011\)</span></span>” (for example). A minimal requirement is that if two numbers <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(x&#39;\)</span></span> are different then they would be represented by different strings. Another way to say this is that we require the encoding function <span><span class="math inline">\(E\)</span></span> to be <em>one to one</em>.</p>
<h3 id="representing-natural-numbers" data-number="2.1.1">Representing natural numbers</h3>
<p>We now show how we can represent natural numbers as binary strings. Over the years people have represented numbers in a variety of ways, including Roman numerals, tally marks, our own Hindu-Arabic decimal system, and many others. We can use any one of those as well as many others to represent a number as a string (see <a href='#bitmapdigitsfig'>Figure 2.3</a>). However, for the sake of concreteness, we use the <em>binary basis</em> as our default representation of natural numbers as strings. For example, we represent the number six as the string <span><span class="math inline">\(110\)</span></span> since <span><span class="math inline">\(1\cdot 2^{2} + 1 \cdot 2^1 + 0 \cdot 2^0 = 6\)</span></span>, and similarly we represent the number thirty-five as the string <span><span class="math inline">\(y = 100011\)</span></span> which satisfies <span><span class="math inline">\(\sum_{i=0}^5 y_i \cdot 2^{|y|-i-1} = 35\)</span></span>. Some more examples are given in the table below.</p>
<figure>
<img src="../figure/digitsbitmap.png" alt="2.3: Representing each one the digits 0,1,2,\ldots,9 as a 12\times 8 bitmap image, which can be thought of as a string in \{0,1\}^{96}. Using this scheme we can represent a natural number x of n decimal digits as a string in \{0,1\}^{96n}. Image taken from blog post of A. C. Andersen." id="bitmapdigitsfig" class="margin" /><figcaption>2.3: Representing each one the digits <span><span class="math inline">\(0,1,2,\ldots,9\)</span></span> as a <span><span class="math inline">\(12\times 8\)</span></span> bitmap image, which can be thought of as a string in <span><span class="math inline">\(\{0,1\}^{96}\)</span></span>. Using this scheme we can represent a natural number <span><span class="math inline">\(x\)</span></span> of <span><span class="math inline">\(n\)</span></span> decimal digits as a string in <span><span class="math inline">\(\{0,1\}^{96n}\)</span></span>. Image taken from <a href="http://blog.andersen.im/2010/12/autonomous-neural-development-and-pruning/">blog post of A. C. Andersen</a>.</figcaption>
</figure>
<table>
<caption>Representing numbers in the binary basis. The lefthand column contains representations of natural numbers in the decimal basis, while the righthand column contains representations of the same numbers in the binary basis.</caption>
<thead>
<tr class="header">
<th><strong>Number (decimal representation)</strong></th>
<th><strong>Number (binary representation)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>10</td>
</tr>
<tr class="even">
<td>5</td>
<td>101</td>
</tr>
<tr class="odd">
<td>16</td>
<td>10000</td>
</tr>
<tr class="even">
<td>40</td>
<td>101000</td>
</tr>
<tr class="odd">
<td>53</td>
<td>110101</td>
</tr>
<tr class="even">
<td>389</td>
<td>110000101</td>
</tr>
<tr class="odd">
<td>3750</td>
<td>111010100110</td>
</tr>
</tbody>
</table>
<p>If <span><span class="math inline">\(n\)</span></span> is even, then the least significant digit of <span><span class="math inline">\(n\)</span></span>’s binary representation is <span><span class="math inline">\(0\)</span></span>, while if <span><span class="math inline">\(n\)</span></span> is odd then this digit equals <span><span class="math inline">\(1\)</span></span>. Just like the number <span><span class="math inline">\(\floor{n/10}\)</span></span> corresponds to “chopping off” the least significant decimal digit (e.g., <span><span class="math inline">\(\floor{457/10}=\floor{45.7}=45\)</span></span>), the number <span><span class="math inline">\(\floor{n/2}\)</span></span> corresponds to the “chopping off” the least significant <em>binary</em> digit. Hence the binary representation can be formally defined as the following function <span><span class="math inline">\(NtS:\N \rightarrow \{0,1\}^*\)</span></span> (<span><span class="math inline">\(NtS\)</span></span> stands for “natural numbers to strings”):</p>
<p><span>
<div class='myequationbox'><span class="math display">\[NtS(n) = \begin{cases}
            0    &amp;  n=0 \\
            1    &amp;  n=1 \\
            NtS(\floor{n/2}) parity(n) &amp; n&gt;1
\end{cases} \;\;(2.1)\]</span><a id='ntseq'></a></div></span> where <span><span class="math inline">\(parity:\N \rightarrow \{0,1\}\)</span></span> is the function defined as <span><span class="math inline">\(parity(n)=0\)</span></span> if <span><span class="math inline">\(n\)</span></span> is even and <span><span class="math inline">\(parity(n)=1\)</span></span> if <span><span class="math inline">\(n\)</span></span> is odd, and as usual, for strings <span><span class="math inline">\(x,y \in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(xy\)</span></span> denotes the concatenation of <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span>. The function <span><span class="math inline">\(NtS\)</span></span> is defined <em>recursively</em>: for every <span><span class="math inline">\(n&gt;0\)</span></span> we define <span><span class="math inline">\(rep(n)\)</span></span> in terms of the representation of the smaller number <span><span class="math inline">\(\floor{n/2}\)</span></span>. It is also possible to define <span><span class="math inline">\(NtS\)</span></span> non-recursively, see <a href='#binaryrepex'>Exercise 2.2</a>.</p>
<p>Throughout most of this book, the particular choices of representation of numbers as binary strings would not matter much: we just need to know that such a representation exists. In fact, for many of our purposes we can even use the simpler representation of mapping a natural number <span><span class="math inline">\(n\)</span></span> to the length-<span><span class="math inline">\(n\)</span></span> all-zero string <span><span class="math inline">\(0^n\)</span></span>.</p>
<div id="pythonbinary" class="remark" title="Binary representation in python (optional)" name="Remark 2.1 (Binary representation in python (optional)) ">
<p>We can implement the binary representation in <em>Python</em> as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> NtS(n):<span class="co"># natural numbers to strings</span></a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">if</span> n <span class="op">&gt;</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-3" title="3">        <span class="cf">return</span> NtS(n <span class="op">//</span> <span class="dv">2</span>) <span class="op">+</span> <span class="bu">str</span>(n <span class="op">%</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="cf">return</span> <span class="bu">str</span>(n <span class="op">%</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="bu">print</span>(NtS(<span class="dv">236</span>))</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co"># 11101100</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="bu">print</span>(NtS(<span class="dv">19</span>))</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co"># 10011</span></a></code></pre></div>
<p>We can also use Python to implement the inverse transformation, mapping a string back to the natural number it represents.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> StN(x):<span class="co"># String to number</span></a>
<a class="sourceLine" id="cb2-2" title="2">    k <span class="op">=</span> <span class="bu">len</span>(x)<span class="op">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="cf">return</span> <span class="bu">sum</span>(<span class="bu">int</span>(x[i])<span class="op">*</span>(<span class="dv">2</span><span class="op">**</span>(k<span class="op">-</span>i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k<span class="op">+</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="bu">print</span>(StN(NtS(<span class="dv">236</span>)))</a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co"># 236</span></a></code></pre></div>
</div>
<div id="programmingrem" class="remark" title="Programming examples" name="Remark 2.2 (Programming examples) ">
<p>In this book, we sometimes use <em>code examples</em> as in <a href='#pythonbinary'>Remark 2.1</a>. The point is always to emphasize that certain computations can be achieved concretely, rather than illustrating the features of Python or any other programming language. Indeed, one of the messages of this book is that all programming languages are in a certain precise sense <em>equivalent</em> to one another, and hence we could have just as well used JavaScript, C, COBOL, Visual Basic or even <a href="https://goo.gl/LKKNFK">BrainF*ck</a>. This book is <em>not</em> about programming, and it is absolutely OK if you are not familiar with Python or do not follow code examples such as those in <a href='#pythonbinary'>Remark 2.1</a>.</p>
</div>
<h3 id="meaning-of-representations-discussion" data-number="2.1.2">Meaning of representations (discussion)</h3>
<p>It is natural for us to think of <span><span class="math inline">\(236\)</span></span> as the “actual” number, and of <span><span class="math inline">\(11101100\)</span></span> as “merely” its representation. However, for most Europeans in the middle ages <code>CCXXXVI</code> would be the “actual” number and <span><span class="math inline">\(236\)</span></span> (if they have even heard about it) would be the weird Hindu-Arabic positional representation.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> When our AI robot overlords materialize, they will probably think of <span><span class="math inline">\(11101100\)</span></span> as the “actual” number and of <span><span class="math inline">\(236\)</span></span> as “merely” a representation that they need to use when they give commands to humans.</p>
<p>So what is the “actual” number? This is a question that philosophers of mathematics have pondered over throughout history. Plato argued that mathematical objects exist in some ideal sphere of existence (that to a certain extent is more “real” than the world we perceive via our senses, as this latter world is merely the shadow of this ideal sphere). In Plato’s vision, the symbols <span><span class="math inline">\(236\)</span></span> are merely notation for some ideal object, that, in homage to the <a href="https://goo.gl/b93h83">late musician</a>, we can refer to as “the number commonly represented by <span><span class="math inline">\(236\)</span></span>”.</p>
<p>The Austrian philosopher Ludwig Wittgenstein, on the other hand, argued that mathematical objects do not exist at all, and the only things that exist are the actual marks on paper that make up <span><span class="math inline">\(236\)</span></span>, <span><span class="math inline">\(11101100\)</span></span> or <code>CCXXXVI</code>. In Wittgenstein’s view, mathematics is merely about formal manipulation of symbols that do not have any inherent meaning. You can think of the “actual” number as (somewhat recursively) “that thing which is common to <span><span class="math inline">\(236\)</span></span>, <span><span class="math inline">\(11101100\)</span></span> and <code>CCXXXVI</code> and all other past and future representations that are meant to capture the same object”.</p>
<p>While reading this book, you are free to choose your own philosophy of mathematics, as long as you maintain the distinction between the mathematical objects themselves and the various particular choices of representing them, whether as splotches of ink, pixels on a screen, zeroes and one, or any other form.</p>
<h2 id="representations-beyond-natural-numbers" data-number="2.2">Representations beyond natural numbers</h2>
<p>We have seen that natural numbers can be represented as binary strings. We now show that the same is true for other types of objects, including (potentially negative) integers, rational numbers, vectors, lists, graphs and many others. In many instances, choosing the “right” string representation for a piece of data is highly nontrivial, and finding the “best” one (e.g., most compact, best fidelity, most efficiently manipulable, robust to errors, most informative features, etc.) is the object of intense research. But for now, we focus on presenting some simple representations for various objects that we would like to use as inputs and outputs for computation.</p>
<h3 id="repnegativeintegerssec" data-number="2.2.1">Representing (potentially negative) integers</h3>
<p>Since we can represent natural numbers as strings, we can represent the full set of <em>integers</em> (i.e., members of the set <span><span class="math inline">\(\Z=\{ \ldots, -3 , -2 , -1 , 0 , +1, +2, +3,\ldots \}\)</span></span> ) by adding one more bit that represents the sign. To represent a (potentially negative) number <span><span class="math inline">\(m\)</span></span>, we prepend to the representation of the natural number <span><span class="math inline">\(|m|\)</span></span> a bit <span><span class="math inline">\(\sigma\)</span></span> that equals <span><span class="math inline">\(0\)</span></span> if <span><span class="math inline">\(m \geq 0\)</span></span> and equals <span><span class="math inline">\(1\)</span></span> if <span><span class="math inline">\(m&lt;0\)</span></span>. Formally, we define the function <span><span class="math inline">\(ZtS:\Z \rightarrow \{0,1\}^*\)</span></span> as follows <span>
<div class='myequationbox'><span class="math display">\[ZtS(m) = \begin{cases}
0\;NtS(m) &amp; m \geq 0  \\
1\;NtS(-m) &amp; m &lt; 0
\end{cases}\]</span></div></span> where <span><span class="math inline">\(NtS\)</span></span> is defined as in <a href='#ntseq'>Equation 2.1</a>.</p>
<p>While the encoding function of a representation needs to be one to one, it does not have to be <em>onto</em>. For example, in the representation above there is no number that is represented by the empty string but it is still a fine representation, since every integer is represented uniquely by some string.</p>
<div id="contextreprem" class="remark" title="Interpretation and context" name="Remark 2.3 (Interpretation and context) ">
<p>Given a string <span><span class="math inline">\(y\in \{0,1\}^*\)</span></span>, how do we know if it’s “supposed” to represent a (nonnegative) natural number or a (potentially negative) integer? For that matter, even if we know <span><span class="math inline">\(y\)</span></span> is “supposed” to be an integer, how do we know what representation scheme it uses? The short answer is that we do not necessarily know this information, unless it is supplied from the context. (In programming languages, the compiler or interpreter determines the representation of the sequence of bits corresponding to a variable based on the variable’s <em>type</em>.) We can treat the same string <span><span class="math inline">\(y\)</span></span> as representing a natural number, an integer, a piece of text, an image, or a green gremlin. Whenever we say a sentence such as “let <span><span class="math inline">\(n\)</span></span> be the number represented by the string <span><span class="math inline">\(y\)</span></span>,” we will assume that we are fixing some canonical representation scheme such as the ones above. The choice of the particular representation scheme will rarely matter, except that we want to make sure to stick with the same one for consistency.</p>
</div>
<h3 id="twoscomplement" data-number="2.2.2">Two’s complement representation (optional)</h3>
<p><a href='#repnegativeintegerssec'>Subsection 2.2.1</a>’s approach of representing an integer using a specific “sign bit” is known as the <em>Signed Magnitude Representation</em> and was used in some early computers. However, the <a href="https://en.wikipedia.org/wiki/Two%27s%5Fcomplement">two’s complement representation</a> is much more common in practice. The <em>two’s complement representation</em> of an integer <span><span class="math inline">\(k\)</span></span> in the set <span><span class="math inline">\(\{ -2^n , -2^n+1, \ldots, 2^n-1 \}\)</span></span> is the string <span><span class="math inline">\(ZtS_n(k)\)</span></span> of length <span><span class="math inline">\(n+1\)</span></span> defined as follows: <span>
<div class='myequationbox'><span class="math display">\[
ZtS_n(k) = \begin{cases} NtS_{n+1}(k) &amp; 0 \leq k \leq 2^n-1 \\
                     NtS_{n+1}(2^{n+1}+k) &amp; -2^n \leq k \leq -1 \end{cases} \;,
\]</span></div></span> where <span><span class="math inline">\(NtS_\ell(m)\)</span></span> demotes the standard binary representation of a number <span><span class="math inline">\(m \in \{0,\ldots, 2^{\ell}\}\)</span></span> as string of length <span><span class="math inline">\(\ell\)</span></span>, padded with leading zeros as needed. For example, if <span><span class="math inline">\(n=3\)</span></span> then <span><span class="math inline">\(ZtS_3(1)=NtS_4(1)=0001\)</span></span>, <span><span class="math inline">\(ZtS_3(2)=NtS_4(2)=0010\)</span></span>, <span><span class="math inline">\(ZtS_3(-1)=NtS_4(16-1)=1111\)</span></span>, and <span><span class="math inline">\(ZtS_3(-8)=NtS_4(16-8)=1000\)</span></span>. If <span><span class="math inline">\(k\)</span></span> is a negative number larger than or equal to <span><span class="math inline">\(-2^n\)</span></span> then <span><span class="math inline">\(2^{n+1}+k\)</span></span> is a number between <span><span class="math inline">\(2^n\)</span></span> and <span><span class="math inline">\(2^{n+1}-1\)</span></span>. Hence the two’s complement representation of such a number <span><span class="math inline">\(k\)</span></span> is a string of length <span><span class="math inline">\(n+1\)</span></span> with its first digit equal to <span><span class="math inline">\(1\)</span></span>.</p>
<p>Another way to say this is that we represent a potentially negative number <span><span class="math inline">\(k \in \{ -2^n,\ldots, 2^n-1 \}\)</span></span> as the non-negative number <span><span class="math inline">\(k \mod 2^{n+1}\)</span></span> (see also <a href='#twoscomplementfig'>Figure 2.4</a>). This means that if two (potentially negative) numbers <span><span class="math inline">\(k\)</span></span> and <span><span class="math inline">\(k&#39;\)</span></span> are not too large (i.e., <span><span class="math inline">\(|k|+|k&#39;|&lt;2^{n+1}\)</span></span>), then we can compute the representation of <span><span class="math inline">\(k+k&#39;\)</span></span> by adding modulo <span><span class="math inline">\(2^{n+1}\)</span></span> the representations of <span><span class="math inline">\(k\)</span></span> and <span><span class="math inline">\(k&#39;\)</span></span> as if they were non-negative integers. This property of the two’s complement representation is its main attraction since, depending on their architectures, microprocessors can often perform arithmetic operations modulo <span><span class="math inline">\(2^w\)</span></span> very efficiently (for certain values of <span><span class="math inline">\(w\)</span></span> such as <span><span class="math inline">\(32\)</span></span> and <span><span class="math inline">\(64\)</span></span>). Many systems leave it to the programmer to check that values are not too large and will carry out this modular arithmetic regardless of the size of the numbers involved. For this reason, in some systems adding two large positive numbers can result in a <em>negative</em> number (e.g., adding <span><span class="math inline">\(2^n-100\)</span></span> and <span><span class="math inline">\(2^n-200\)</span></span> might result in <span><span class="math inline">\(-300\)</span></span> since <span><span class="math inline">\((2^{n+1}-300) \mod 2^{n+1} = -300\)</span></span>, see also <a href='#twoscomplementfig'>Figure 2.4</a>).</p>
<figure>
<img src="../figure/twoscomplement.png" alt="2.4: In the two’s complement representation we represent a potentially negative integer k \in \{ -2^n ,\ldots, 2^n-1 \} as an n+1 length string using the binary representation of the integer k \mod 2^{n+1}. On the lefthand side: this representation for n=3 (the red integers are the numbers being represented by the blue binary strings). If a microprocessor does not check for overflows, adding the two positive numbers 6 and 5 might result in the negative number -5 (since -5 \mod 16 = 11. The righthand side is a C program that will on some 32 bit architecture print a negative number after adding two positive numbers. (Integer overflow in C is considered undefined behavior which means the result of this program, including whether it runs or crashes, could differ depending on the architecture, compiler, and even compiler options and version.)" id="twoscomplementfig" class="margin" /><figcaption>2.4: In the <em>two’s complement representation</em> we represent a potentially negative integer <span><span class="math inline">\(k \in \{ -2^n ,\ldots, 2^n-1 \}\)</span></span> as an <span><span class="math inline">\(n+1\)</span></span> length string using the binary representation of the integer <span><span class="math inline">\(k \mod 2^{n+1}\)</span></span>. On the lefthand side: this representation for <span><span class="math inline">\(n=3\)</span></span> (the red integers are the numbers being represented by the blue binary strings). If a microprocessor does not check for overflows, adding the two positive numbers <span><span class="math inline">\(6\)</span></span> and <span><span class="math inline">\(5\)</span></span> might result in the negative number <span><span class="math inline">\(-5\)</span></span> (since <span><span class="math inline">\(-5 \mod 16 = 11\)</span></span>. The righthand side is a <code>C</code> program that will on some <span><span class="math inline">\(32\)</span></span> bit architecture print a negative number after adding two positive numbers. (Integer overflow in <code>C</code> is considered <em>undefined behavior</em> which means the result of this program, including whether it runs or crashes, could differ depending on the architecture, compiler, and even compiler options and version.)</figcaption>
</figure>
<h3 id="rational-numbers-and-representing-pairs-of-strings" data-number="2.2.3">Rational numbers, and representing pairs of strings</h3>
<p>We can represent a rational number of the form <span><span class="math inline">\(a/b\)</span></span> by representing the two numbers <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(b\)</span></span>. However, merely concatenating the representations of <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(b\)</span></span> will not work. For example, the binary representation of <span><span class="math inline">\(4\)</span></span> is <span><span class="math inline">\(100\)</span></span> and the binary representation of <span><span class="math inline">\(43\)</span></span> is <span><span class="math inline">\(101011\)</span></span>, but the concatenation <span><span class="math inline">\(100101011\)</span></span> of these strings is also the concatenation of the representation <span><span class="math inline">\(10010\)</span></span> of <span><span class="math inline">\(18\)</span></span> and the representation <span><span class="math inline">\(1011\)</span></span> of <span><span class="math inline">\(11\)</span></span>. Hence, if we used such simple concatenation then we would not be able to tell if the string <span><span class="math inline">\(100101011\)</span></span> is supposed to represent <span><span class="math inline">\(4/43\)</span></span> or <span><span class="math inline">\(18/11\)</span></span>.</p>
<p>We tackle this by giving a general representation for <em>pairs of strings</em>. If we were using a pen and paper, we would just use a separator symbol such as <span><span class="math inline">\(\|\)</span></span> to represent, for example, the pair consisting of the numbers represented by <span><span class="math inline">\(10\)</span></span> and <span><span class="math inline">\(110001\)</span></span> as the length-<span><span class="math inline">\(9\)</span></span> string “<span><span class="math inline">\(01\|110001\)</span></span>”. In other words, there is a one to one map <span><span class="math inline">\(F\)</span></span> from <em>pairs of strings</em> <span><span class="math inline">\(x,y \in \{0,1\}^*\)</span></span> into a single string <span><span class="math inline">\(z\)</span></span> over the alphabet <span><span class="math inline">\(\Sigma = \{0,1,\| \}\)</span></span> (in other words, <span><span class="math inline">\(z\in \Sigma^*\)</span></span>). Using such separators is similar to the way we use spaces and punctuation to separate words in English. By adding a little redundancy, we achieve the same effect in the digital domain. We can map the three-element set <span><span class="math inline">\(\Sigma\)</span></span> to the three-element set <span><span class="math inline">\(\{00,11,01 \} \subset \{0,1\}^2\)</span></span> in a one-to-one fashion, and hence encode a length <span><span class="math inline">\(n\)</span></span> string <span><span class="math inline">\(z\in \Sigma^*\)</span></span> as a length <span><span class="math inline">\(2n\)</span></span> string <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span>.</p>
<p>Our final representation for rational numbers is obtained by composing the following steps:</p>
<ol type="1">
<li><p>Representing a non-negative rational number as a pair of natural numbers.</p></li>
<li><p>Representing a natural number by a string via the binary representation.</p></li>
<li><p>Combining 1 and 2 to obtain a representation of a rational number as a pair of strings.</p></li>
<li><p>Representing a pair of strings over <span><span class="math inline">\(\{0,1\}\)</span></span> as a single string over <span><span class="math inline">\(\Sigma = \{0,1,\|\}\)</span></span>.</p></li>
<li><p>Representing a string over <span><span class="math inline">\(\Sigma\)</span></span> as a longer string over <span><span class="math inline">\(\{0,1\}\)</span></span>.</p></li>
</ol>
<div id="represnumberbypairs" class="example" title="Representing a rational number as a string" name="Example 2.4 (Representing a rational number as a string) ">
<p>Consider the rational number <span><span class="math inline">\(r=-5/8\)</span></span>. We represent <span><span class="math inline">\(-5\)</span></span> as <span><span class="math inline">\(1101\)</span></span> and <span><span class="math inline">\(+8\)</span></span> as <span><span class="math inline">\(01000\)</span></span>, and so we can represent <span><span class="math inline">\(r\)</span></span> as the <em>pair</em> of strings <span><span class="math inline">\((1101,01000)\)</span></span> and represent this pair as the length <span><span class="math inline">\(10\)</span></span> string <span><span class="math inline">\(1101\|01000\)</span></span> over the alphabet <span><span class="math inline">\(\{0,1,\|\}\)</span></span>. Now, applying the map <span><span class="math inline">\(0 \mapsto 00\)</span></span>, <span><span class="math inline">\(1\mapsto 11\)</span></span>, <span><span class="math inline">\(\| \mapsto 01\)</span></span>, we can represent the latter string as the length <span><span class="math inline">\(20\)</span></span> string <span><span class="math inline">\(s=11110011010011000000\)</span></span> over the alphabet <span><span class="math inline">\(\{0,1\}\)</span></span>.</p>
</div>
<p>The same idea can be used to represent triples of strings, quadruples, and so on as a string. Indeed, this is one instance of a very general principle that we use time and again in both the theory and practice of computer science (for example, in Object Oriented programming):</p>
<div id="representtuplesidea" class="bigidea" name="Bigidea 1">
<p>If we can represent objects of type <span><span class="math inline">\(T\)</span></span> as strings, then we can represent tuples of objects of type <span><span class="math inline">\(T\)</span></span> as strings as well.</p>
</div>
<p>Repeating the same idea, once we can represent objects of type <span><span class="math inline">\(T\)</span></span>, we can also represent <em>lists of lists</em> of such objects, and even lists of lists of lists and so on and so forth. We will come back to this point when we discuss <em>prefix free encoding</em> in <a href='#prefixfreesec'>Subsection 2.4.2</a>.</p>
<h2 id="representing-real-numbers" data-number="2.3">Representing real numbers</h2>
<p>The set of <em>real numbers</em> <span><span class="math inline">\(\R\)</span></span> contains all numbers including positive, negative, and fractional, as well as <em>irrational</em> numbers such as <span><span class="math inline">\(\pi\)</span></span> or <span><span class="math inline">\(e\)</span></span>. Every real number can be approximated by a rational number, and thus we can represent every real number <span><span class="math inline">\(x\)</span></span> by a rational number <span><span class="math inline">\(a/b\)</span></span> that is very close to <span><span class="math inline">\(x\)</span></span>. For example, we can represent <span><span class="math inline">\(\pi\)</span></span> by <span><span class="math inline">\(22/7\)</span></span> within an error of about <span><span class="math inline">\(10^{-3}\)</span></span>. If we want a smaller error (e.g., about <span><span class="math inline">\(10^{-4}\)</span></span>) then we can use <span><span class="math inline">\(311/99\)</span></span>, and so on and so forth.</p>
<figure>
<img src="../figure/floatingpoint.png" alt="2.5: The floating point representation of a real number x\in \R is its approximation as a number of the form \sigma b \cdot 2^e where \sigma \in \{\pm 1 \}, e is an (potentially negative) integer, and b is a rational number between 1 and 2 expressed as a binary fraction 1.b_0b_1b_2\ldots b_{k} for some b_1,\ldots,b_k \in \{0,1\} (that is b = 1 + b_1/2 + b_2/4 + \ldots + b_k/2^k). Commonly-used floating point representations fix the numbers \ell and k of bits to represent e and b respectively. In the example above, assuming we use two’s complement representation for e, the number represented is -1 \times 2^{5} \times ( 1 + 1/2 + 1/4 + 1/64 + 1/512) = -56.5625." id="floatingpointfig" /><figcaption>2.5: The <em>floating point representation</em> of a real number <span><span class="math inline">\(x\in \R\)</span></span> is its approximation as a number of the form <span><span class="math inline">\(\sigma b \cdot 2^e\)</span></span> where <span><span class="math inline">\(\sigma \in \{\pm 1 \}\)</span></span>, <span><span class="math inline">\(e\)</span></span> is an (potentially negative) integer, and <span><span class="math inline">\(b\)</span></span> is a rational number between <span><span class="math inline">\(1\)</span></span> and <span><span class="math inline">\(2\)</span></span> expressed as a binary fraction <span><span class="math inline">\(1.b_0b_1b_2\ldots b_{k}\)</span></span> for some <span><span class="math inline">\(b_1,\ldots,b_k \in \{0,1\}\)</span></span> (that is <span><span class="math inline">\(b = 1 + b_1/2 + b_2/4 + \ldots + b_k/2^k\)</span></span>). Commonly-used floating point representations fix the numbers <span><span class="math inline">\(\ell\)</span></span> and <span><span class="math inline">\(k\)</span></span> of bits to represent <span><span class="math inline">\(e\)</span></span> and <span><span class="math inline">\(b\)</span></span> respectively. In the example above, assuming we use two’s complement representation for <span><span class="math inline">\(e\)</span></span>, the number represented is <span><span class="math inline">\(-1 \times 2^{5} \times ( 1 + 1/2 + 1/4 + 1/64 + 1/512) = -56.5625\)</span></span>.</figcaption>
</figure>
<p>The above representation of real numbers via rational numbers that approximate them is a fine choice for a representation scheme. However, typically in computing applications, it is more common to use the <em>floating point representation scheme</em> (see <a href='#floatingpointfig'>Figure 2.5</a>) to represent real numbers. In the floating point representation scheme we represent <span><span class="math inline">\(x\in \R\)</span></span> by the pair <span><span class="math inline">\((b,e)\)</span></span> of (positive or negative) integers of some prescribed sizes (determined by the desired accuracy) such that <span><span class="math inline">\(b \times 2^{e}\)</span></span> is closest to <span><span class="math inline">\(x\)</span></span>. Floating point representation is the base-two version of <a href="https://goo.gl/MUJnVE">scientific notation</a>, where one represents a number <span><span class="math inline">\(y\in R\)</span></span> as its approximation of the form <span><span class="math inline">\(b \times 10^e\)</span></span> for <span><span class="math inline">\(b,e\)</span></span>. It is called “floating point” because we can think of the number <span><span class="math inline">\(b\)</span></span> as specifying a sequence of binary digits, and <span><span class="math inline">\(e\)</span></span> as describing the location of the “binary point” within this sequence. The use of floating representation is the reason why in many programming systems, printing the expression <code>0.1+0.2</code> will result in <code>0.30000000000000004</code> and not <code>0.3</code>, see <a href="http://floating-point-gui.de/">here</a>, <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">here</a> and <a href="https://randomascii.wordpress.com/2012/04/05/floating-point-complexities/">here</a> for more.</p>
<figure>
<img src="../figure/e_to_the_pi_minus_pi.png" alt="2.6: XKCD cartoon on floating-point arithmetic." id="xkcdfloatingfig" class="margin" /><figcaption>2.6: XKCD cartoon on floating-point arithmetic.</figcaption>
</figure>
<p>The reader might be (rightly) worried about the fact that the floating point representation (or the rational number one) can only <em>approximately</em> represent real numbers. In many (though not all) computational applications, one can make the accuracy tight enough so that this does not affect the final result, though sometimes we do need to be careful. Indeed, floating-point bugs can sometimes be no joking matter. For example, floating point rounding errors have been implicated in the <a href="http://embeddedgurus.com/barr-code/2014/03/lethal-software-defects-patriot-missile-failure/">failure</a> of a U.S. Patriot missile to intercept an Iraqi Scud missile, costing 28 lives, as well as a 100 million pound error in computing <a href="https://catless.ncl.ac.uk/Risks/5/74">payouts to British pensioners</a>.</p>
<h3 id="cantorsec" data-number="2.3.1">Can we represent reals <em>exactly</em>?</h3>
<p>Given the issues with floating point approximations for real numbers, a natural question is whether it is possible to represent real numbers <em>exactly</em> as strings. Unfortunately, the following theorem shows that this cannot be done:</p>
<div id="cantorthm" class="theorem" title="Reals are uncountable" name="Theorem 2.5 (Reals are uncountable) ">
<p>There does not exist a one-to-one function <span><span class="math inline">\(RtS:\R \rightarrow \{0,1\}^*\)</span></span>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
</div>
<p><a href='#cantorthm'>Theorem 2.5</a> was proven by <a href="https://en.wikipedia.org/wiki/Georg_Cantor">Georg Cantor</a> in 1874. (Cantor used the set <span><span class="math inline">\(\N\)</span></span> rather than <span><span class="math inline">\(\{0,1\}^*\)</span></span>, but one can show that these two results are equivalent using the one-to-one mappings between those two sets, see <a href='#naturalsstringsmapex'>Exercise 2.13</a>.) The non-existence of such a map is equivalent to saying that there is no way to “count” all the real numbers as some sequence <span><span class="math inline">\(x_0,x_1,x_2,\ldots\)</span></span>. For this reason <a href='#cantorthm'>Theorem 2.5</a> is known as the <em>uncountability of the reals</em>.</p>
<p>This result (and the theory around it) was quite shocking to mathematicians at the time. By showing that there is no one-to-one map from <span><span class="math inline">\(\R\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span> (or <span><span class="math inline">\(\N\)</span></span>), Cantor showed that these two infinite sets have “different forms of infinity” and that the set of real numbers <span><span class="math inline">\(\R\)</span></span> is in some sense “bigger” than the infinite set <span><span class="math inline">\(\{0,1\}^*\)</span></span>. The notion that there are “shades of infinity” was deeply disturbing to mathematicians and philosophers at the time. The philosopher Ludwig Wittgenstein (whom we mentioned before) called Cantor’s results “utter nonsense” and “laughable.” Others thought they were even worse than that. Leopold Kronecker called Cantor a “corrupter of youth,” while Henri Poincaré said that Cantor’s ideas “should be banished from mathematics once and for all.” The tide eventually turned, and these days Cantor’s work is universally accepted as the cornerstone of set theory and the foundations of mathematics. As David Hilbert said in 1925, <em>“No one shall expel us from the paradise which Cantor has created for us.”</em> As we will see later in this book, Cantor’s ideas also play a huge role in the theory of computation.</p>
<p>Now that we have discussed <a href='#cantorthm'>Theorem 2.5</a>’s importance, let us see the proof. It is achieved in two steps:</p>
<ol type="1">
<li><p>Define some infinite set <span><span class="math inline">\(\mathcal{X}\)</span></span> for which it is easier for us to prove that <span><span class="math inline">\(\mathcal{X}\)</span></span> is not countable (namely, it’s easier for us to prove that there is no one-to-one function from <span><span class="math inline">\(\mathcal{X}\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span>).</p></li>
<li><p>Prove that there <em>is</em> a one-to-one function <span><span class="math inline">\(G\)</span></span> mapping <span><span class="math inline">\(\mathcal{X}\)</span></span> to <span><span class="math inline">\(\mathbb{R}\)</span></span>.</p></li>
</ol>
<p>We can use a proof by contradiction to show that these two facts together imply <a href='#cantorthm'>Theorem 2.5</a>. Specifically, if we assume (towards the sake of contradiction) that there exists some one-to-one <span><span class="math inline">\(F\)</span></span> mapping <span><span class="math inline">\(\mathbb{R}\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span> then the function <span><span class="math inline">\(x \mapsto F(G(x))\)</span></span> obtained by composing <span><span class="math inline">\(F\)</span></span> with the function <span><span class="math inline">\(G\)</span></span> from Step 2 above would be a one-to-one function from <span><span class="math inline">\(\mathcal{X}\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span>, which contradicts what we proved in Step 1!</p>
<p>To turn this idea into a full proof of <a href='#cantorthm'>Theorem 2.5</a> we need to:</p>
<ul>
<li><p>Define the set <span><span class="math inline">\(\mathcal{X}\)</span></span>.</p></li>
<li><p>Prove that there is no one-to-one function from <span><span class="math inline">\(\mathcal{X}\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span></p></li>
<li><p>Prove that there <em>is</em> a one-to-one function from <span><span class="math inline">\(\mathcal{X}\)</span></span> to <span><span class="math inline">\(\R\)</span></span>.</p></li>
</ul>
<p>We now proceed to do precisely that. That is, we will define the set <span><span class="math inline">\(\{0,1\}^\infty\)</span></span>, which will play the role of <span><span class="math inline">\(\mathcal{X}\)</span></span>, and then state and prove two lemmas that show that this set satisfies our two desired properties.</p>
<div id="bitsinfdef" class="definition" name="Definition 2.6">
<p>We denote by <span><span class="math inline">\(\{0,1\}^\infty\)</span></span> the set <span><span class="math inline">\(\{ f \;|\; f:\N \rightarrow \{0,1\} \}\)</span></span>.</p>
</div>
<p>That is, <span><span class="math inline">\(\{0,1\}^\infty\)</span></span> is a set of <em>functions</em>, and a function <span><span class="math inline">\(f\)</span></span> is in <span><span class="math inline">\(\{0,1\}^\infty\)</span></span> iff its domain is <span><span class="math inline">\(\N\)</span></span> and its codomain is <span><span class="math inline">\(\{0,1\}\)</span></span>. We can also think of <span><span class="math inline">\(\{0,1\}^\infty\)</span></span> as the set of all infinite <em>sequences</em> of bits, since a function <span><span class="math inline">\(f:\N \rightarrow \{0,1\}\)</span></span> can be identified with the sequence <span><span class="math inline">\((f(0),f(1),f(2),\ldots )\)</span></span>. The following two lemmas show that <span><span class="math inline">\(\{0,1\}^\infty\)</span></span> can play the role of <span><span class="math inline">\(\mathcal{X}\)</span></span> to establish <a href='#cantorthm'>Theorem 2.5</a>.</p>
<div id="sequencestostrings" class="lemma" name="Lemma 2.7">
<p>There does not exist a one-to-one map <span><span class="math inline">\(FtS:\{0,1\}^\infty \rightarrow \{0,1\}^*\)</span></span>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
</div>
<div id="sequencestoreals" class="lemma" name="Lemma 2.8">
<p>There <em>does</em> exist a one-to-one map <span><span class="math inline">\(FtR:\{0,1\}^\infty \rightarrow \R\)</span></span>.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
</div>
<p>As we’ve seen above, <a href='#sequencestostrings'>Lemma 2.7</a> and <a href='#sequencestoreals'>Lemma 2.8</a> together imply <a href='#cantorthm'>Theorem 2.5</a>. To repeat the argument more formally, suppose, for the sake of contradiction, that there did exist a one-to-one function <span><span class="math inline">\(RtS:\R \rightarrow \{0,1\}^*\)</span></span>. By <a href='#sequencestoreals'>Lemma 2.8</a>, there exists a one-to-one function <span><span class="math inline">\(FtR:\{0,1\}^\infty \rightarrow \R\)</span></span>. Thus, under this assumption, since the composition of two one-to-one functions is one-to-one (see <a href='#onetoonecompex'>Exercise 2.12</a>), the function <span><span class="math inline">\(FtS:\{0,1\}^\infty \rightarrow \{0,1\}^*\)</span></span> defined as <span><span class="math inline">\(FtS(f)=RtS(FtR(f))\)</span></span> will be one to one, contradicting <a href='#sequencestostrings'>Lemma 2.7</a>. See <a href='#proofofcantorfig'>Figure 2.7</a> for a graphical illustration of this argument.</p>
<figure>
<img src="../figure/proofofcantor.png" alt="2.7: We prove  by combining  and . , which uses standard calculus tools, shows the existence of a one-to-one map FtR from the set \{0,1\}^\infty to the real numbers. So, if a hypothetical one-to-one map RtS:\R \rightarrow \{0,1\}^* existed, then we could compose them to get a one-to-one map FtS:\{0,1\}^\infty \rightarrow \{0,1\}^*. Yet this contradicts - the heart of the proof- which rules out the existence of such a map." id="proofofcantorfig" /><figcaption>2.7: We prove <a href='#cantorthm'>Theorem 2.5</a> by combining <a href='#sequencestostrings'>Lemma 2.7</a> and <a href='#sequencestoreals'>Lemma 2.8</a>. <a href='#sequencestoreals'>Lemma 2.8</a>, which uses standard calculus tools, shows the existence of a one-to-one map <span><span class="math inline">\(FtR\)</span></span> from the set <span><span class="math inline">\(\{0,1\}^\infty\)</span></span> to the real numbers. So, if a hypothetical one-to-one map <span><span class="math inline">\(RtS:\R \rightarrow \{0,1\}^*\)</span></span> existed, then we could compose them to get a one-to-one map <span><span class="math inline">\(FtS:\{0,1\}^\infty \rightarrow \{0,1\}^*\)</span></span>. Yet this contradicts <a href='#sequencestostrings'>Lemma 2.7</a>- the heart of the proof- which rules out the existence of such a map.</figcaption>
</figure>
<p>Now all that is left is to prove these two lemmas. We start by proving <a href='#sequencestostrings'>Lemma 2.7</a> which is really the heart of <a href='#cantorthm'>Theorem 2.5</a>.</p>
<figure>
<img src="../figure/diagreals2.png" alt="2.8: We construct a function \overline{d} such that \overline{d} \neq StF(x) for every x\in \{0,1\}^* by ensuring that \overline{d}(n(x)) \neq StF(x)(n(x)) for every x\in \{0,1\}^* with lexicographic order n(x). We can think of this as building a table where the columns correspond to numbers m\in \N and the rows correspond to x\in \{0,1\}^* (sorted according to n(x)). If the entry in the x-th row and the m-th column corresponds to g(m)) where g=StF(x) then \overline{d} is obtained by going over the “diagonal” elements in this table (the entries corresponding to the x-th row and n(x)-th column) and ensuring that \overline{d}(x)(n(x)) \neq StF(x)(n(x))." id="diagrealsfig" /><figcaption>2.8: We construct a function <span><span class="math inline">\(\overline{d}\)</span></span> such that <span><span class="math inline">\(\overline{d} \neq StF(x)\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> by ensuring that <span><span class="math inline">\(\overline{d}(n(x)) \neq StF(x)(n(x))\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> with lexicographic order <span><span class="math inline">\(n(x)\)</span></span>. We can think of this as building a table where the columns correspond to numbers <span><span class="math inline">\(m\in \N\)</span></span> and the rows correspond to <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> (sorted according to <span><span class="math inline">\(n(x)\)</span></span>). If the entry in the <span><span class="math inline">\(x\)</span></span>-th row and the <span><span class="math inline">\(m\)</span></span>-th column corresponds to <span><span class="math inline">\(g(m))\)</span></span> where <span><span class="math inline">\(g=StF(x)\)</span></span> then <span><span class="math inline">\(\overline{d}\)</span></span> is obtained by going over the “diagonal” elements in this table (the entries corresponding to the <span><span class="math inline">\(x\)</span></span>-th row and <span><span class="math inline">\(n(x)\)</span></span>-th column) and ensuring that <span><span class="math inline">\(\overline{d}(x)(n(x)) \neq StF(x)(n(x))\)</span></span>.</figcaption>
</figure>
<div class="proof" data-ref="sequencestostrings" name="Proof 2.3.1">
<p>We will prove that there does not exist an <em>onto</em> function <span><span class="math inline">\(StF:\{0,1\}^* \rightarrow \{0,1\}^\infty\)</span></span>. This implies the lemma since for every two sets <span><span class="math inline">\(A\)</span></span> and <span><span class="math inline">\(B\)</span></span>, there exists an onto function from <span><span class="math inline">\(A\)</span></span> to <span><span class="math inline">\(B\)</span></span> if and only if there exists a one-to-one function from <span><span class="math inline">\(B\)</span></span> to <span><span class="math inline">\(A\)</span></span> (see <a href='lec_00_1_math_background.html#onetooneimpliesonto'>Lemma 1.2</a>).</p>
<p>The technique of this proof is known as the “diagonal argument” and is illustrated in <a href='#diagrealsfig'>Figure 2.8</a>. We assume, towards a contradiction, that there exists such a function <span><span class="math inline">\(StF:\{0,1\}^* \rightarrow \{0,1\}^\infty\)</span></span>. We will show that <span><span class="math inline">\(StF\)</span></span> is not onto by demonstrating a function <span><span class="math inline">\(\overline{d}\in \{0,1\}^\infty\)</span></span> such that <span><span class="math inline">\(\overline{d} \neq StF(x)\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. Consider the lexicographic ordering of binary strings (i.e., <span><span class="math inline">\(\ensuremath{\text{\texttt{&quot;&quot;}}}\)</span></span>,<span><span class="math inline">\(0\)</span></span>,<span><span class="math inline">\(1\)</span></span>,<span><span class="math inline">\(00\)</span></span>,<span><span class="math inline">\(01\)</span></span>,<span><span class="math inline">\(\ldots\)</span></span>). For every <span><span class="math inline">\(n\in \N\)</span></span>, we let <span><span class="math inline">\(x_n\)</span></span> be the <span><span class="math inline">\(n\)</span></span>-th string in this order. That is <span><span class="math inline">\(x_0 =\ensuremath{\text{\texttt{&quot;&quot;}}}\)</span></span>, <span><span class="math inline">\(x_1 = 0\)</span></span>, <span><span class="math inline">\(x_2= 1\)</span></span> and so on and so forth. We define the function <span><span class="math inline">\(\overline{d} \in \{0,1\}^\infty\)</span></span> as follows: <span>
<div class='myequationbox'><span class="math display">\[\overline{d}(n) = 1 - StF(x_n)(n)\]</span></div></span> for every <span><span class="math inline">\(n\in \N\)</span></span>. That is, to compute <span><span class="math inline">\(\overline{d}\)</span></span> on input <span><span class="math inline">\(n\in\N\)</span></span>, we first compute <span><span class="math inline">\(g= StF(x_n)\)</span></span>, where <span><span class="math inline">\(x_n \in \{0,1\}^*\)</span></span> is the <span><span class="math inline">\(n\)</span></span>-th string in the lexicographical ordering. Since <span><span class="math inline">\(g \in \{0,1\}^\infty\)</span></span>, it is a function mapping <span><span class="math inline">\(\N\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>. The value <span><span class="math inline">\(\overline{d}(n)\)</span></span> is defined to be the negation of <span><span class="math inline">\(g(n)\)</span></span>.</p>
<p>The definition of the function <span><span class="math inline">\(\overline{d}\)</span></span> is a bit subtle. One way to think about it is to imagine the function <span><span class="math inline">\(StF\)</span></span> as being specified by an infinitely long table, in which every row corresponds to a string <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> (with strings sorted in lexicographic order), and contains the sequence <span><span class="math inline">\(StF(x)(0), StF(x)(1), StF(x)(2),\ldots\)</span></span>. The <em>diagonal</em> elements in this table are the values</p>
<p><span>
<div class='myequationbox'><span class="math display">\[StF(\ensuremath{\text{\texttt{&quot;&quot;}}})(0),StF(0)(1),StF(1)(2),StF(00)(3), StF(01)(4),\ldots\]</span></div></span></p>
<p>which correspond to the elements <span><span class="math inline">\(StF(x_n)(n)\)</span></span> in the <span><span class="math inline">\(n\)</span></span>-th row and <span><span class="math inline">\(n\)</span></span>-th column of this table for <span><span class="math inline">\(n=0,1,2,\ldots\)</span></span>. The function <span><span class="math inline">\(\overline{d}\)</span></span> we defined above maps every <span><span class="math inline">\(n\in \N\)</span></span> to the negation of the <span><span class="math inline">\(n\)</span></span>-th diagonal value.</p>
<p>To complete the proof that <span><span class="math inline">\(StF\)</span></span> is not onto we need to show that <span><span class="math inline">\(\overline{d} \neq StF(x)\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. Indeed, let <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> be some string and let <span><span class="math inline">\(g = StF(x)\)</span></span>. If <span><span class="math inline">\(n\)</span></span> is the position of <span><span class="math inline">\(x\)</span></span> in the lexicographical order then by construction <span><span class="math inline">\(\overline{d}(n) = 1-g(n) \neq g(n)\)</span></span> which means that <span><span class="math inline">\(g \neq \overline{d}\)</span></span> which is what we wanted to prove.</p>
</div>
<div class="pause" name="Pause">
<p>The proof of <a href='#sequencestostrings'>Lemma 2.7</a> is rather subtle, and worth re-reading a second or third time. We will use the “diagonal argument” again several times later on in this book.</p>
</div>
<div id="generalizepowerset" class="remark" title="Generalizing beyond strings and reals" name="Remark 2.9 (Generalizing beyond strings and reals) ">
<p><a href='#sequencestostrings'>Lemma 2.7</a> doesn’t really have much to do with the natural numbers or the strings. An examination of the proof shows that it really shows that for <em>every</em> set <span><span class="math inline">\(S\)</span></span>, there is no one-to-one map <span><span class="math inline">\(F:\{0,1\}^S \rightarrow S\)</span></span> where <span><span class="math inline">\(\{0,1\}^S\)</span></span> denotes the set <span><span class="math inline">\(\{ f \;|\; f:S \rightarrow \{0,1\} \}\)</span></span> of all Boolean functions with domain <span><span class="math inline">\(S\)</span></span>. Since we can identify a subset <span><span class="math inline">\(V \subseteq S\)</span></span> with its characteristic function <span><span class="math inline">\(f=1_V\)</span></span> (i.e., <span><span class="math inline">\(1_V(x)=1\)</span></span> iff <span><span class="math inline">\(x\in V\)</span></span>), we can think of <span><span class="math inline">\(\{0,1\}^S\)</span></span> also as the set of all <em>subsets</em> of <span><span class="math inline">\(S\)</span></span>. This subset is sometimes called the <em>power set</em> of <span><span class="math inline">\(S\)</span></span>.</p>
<p>The proof of <a href='#sequencestostrings'>Lemma 2.7</a> can be generalized to show that there is no one-to-one map between a set and its power set. In particular, it means that the set <span><span class="math inline">\(\{0,1\}^\R\)</span></span> is “even bigger” than <span><span class="math inline">\(\R\)</span></span>. Cantor used these ideas to construct an infinite hierarchy of shades of infinity. The number of such shades turns out to be much larger than <span><span class="math inline">\(|\N|\)</span></span> or even <span><span class="math inline">\(|\R|\)</span></span>. He denoted the cardinality of <span><span class="math inline">\(\N\)</span></span> by <span><span class="math inline">\(\aleph_0\)</span></span> and denoted the next largest infinite number by <span><span class="math inline">\(\aleph_1\)</span></span>. (<span><span class="math inline">\(\aleph\)</span></span> is the first letter in the Hebrew alphabet.) Cantor also made the <a href="https://en.wikipedia.org/wiki/Continuum_hypothesis">continuum hypothesis</a> that <span><span class="math inline">\(|\R|=\aleph_1\)</span></span>. We will come back to the fascinating story of this hypothesis later on in this book. <a href="https://www.scottaaronson.com/democritus/lec2.html">This lecture of Aaronson</a> mentions some of these issues (see also <a href="http://www.eecs70.org/static/notes/n10.pdf">this Berkeley CS 70 lecture</a>).</p>
</div>
<p>To complete the proof of <a href='#cantorthm'>Theorem 2.5</a>, we need to show <a href='#sequencestoreals'>Lemma 2.8</a>. This requires some calculus background but is otherwise straightforward. If you have not had much experience with limits of a real series before, then the formal proof below might be a little hard to follow. This part is not the core of Cantor’s argument, nor are such limits important to the remainder of this book, so you can feel free to take <a href='#sequencestoreals'>Lemma 2.8</a> on faith and skip the proof.</p>
<div class="proofidea" data-ref="sequencestoreals" name="Proofidea 2.3.1">
<p>We define <span><span class="math inline">\(FtR(f)\)</span></span> to be the number between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(2\)</span></span> whose decimal expansion is <span><span class="math inline">\(f(0).f(1) f(2) \ldots\)</span></span>, or in other words <span><span class="math inline">\(FtR(f) = \sum_{i=0}^{\infty} f(i) \cdot 10^{-i}\)</span></span>. To prove that <span><span class="math inline">\(FtR\)</span></span> is one to one, we need to show that if <span><span class="math inline">\(f \neq g\)</span></span> then <span><span class="math inline">\(FtR(f) \neq FtR(g)\)</span></span>. To do that we let <span><span class="math inline">\(k\in \N\)</span></span> be the first input on which <span><span class="math inline">\(f\)</span></span> and <span><span class="math inline">\(g\)</span></span> disagree. The numbers <span><span class="math inline">\(FtR(f)\)</span></span> and <span><span class="math inline">\(FtR(g)\)</span></span> agree in the first <span><span class="math inline">\(k-1\)</span></span> digits following the decimal point and disagree in the <span><span class="math inline">\(k\)</span></span>-th digit. One can then calculate and verify that this means that <span><span class="math inline">\(|FtR(f)-FtR(g)| &gt; 0.5 \cdot 10^{-k}\)</span></span> which in particular means that these two numbers are distinct from one another. (You might wonder why we can’t immediately deduce that two numbers that differ in a digit are not the same. The issue is that we have to be a little more careful when talking about infinite expansions. For example, the number one half has two decimal expansions <span><span class="math inline">\(0.5\)</span></span> and <span><span class="math inline">\(0.49999\cdots\)</span></span>. However, this issue does not come up if (as in our case) we restrict attention only to numbers with decimal expansions that do not involve the digit <span><span class="math inline">\(9\)</span></span>.)</p>
</div>
<div class="proof" data-ref="sequencestoreals" name="Proof 2.3.1">
<p>For every <span><span class="math inline">\(f \in \{0,1\}^\infty\)</span></span>, we define <span><span class="math inline">\(FtR(f)\)</span></span> to be the number whose decimal expansion is <span><span class="math inline">\(f(0).f(1)f(2)f(3)\ldots\)</span></span>.</p>
<p>Formally we define <span>
<div class='myequationbox'><span class="math display">\[
FtR(f) = \sum_{i=0}^\infty f(i) \cdot 10^{-i} \;\;(2.7)
\]</span><a id='eqcantordecimalexpansion'></a></div></span> It is a known result in calculus (whose proof we will not repeat here) that the series on the righthand side of <a href='#eqcantordecimalexpansion'>Equation 2.7</a> converges to a definite limit in <span><span class="math inline">\(\mathbb{R}\)</span></span>.</p>
<p>We now prove that <span><span class="math inline">\(FtR\)</span></span> is one to one. Let <span><span class="math inline">\(f,g\)</span></span> be two distinct functions in <span><span class="math inline">\(\{0,1\}^\infty\)</span></span>. Since <span><span class="math inline">\(f\)</span></span> and <span><span class="math inline">\(g\)</span></span> are distinct, there must be some input on which they differ, and we define <span><span class="math inline">\(k\)</span></span> to be the smallest such input and assume without loss of generality that <span><span class="math inline">\(f(k)=0\)</span></span> and <span><span class="math inline">\(g(k)=1\)</span></span>. (Otherwise, if <span><span class="math inline">\(f(k)=1\)</span></span> and <span><span class="math inline">\(g(k)=0\)</span></span>, then we can simply switch the roles of <span><span class="math inline">\(f\)</span></span> and <span><span class="math inline">\(g\)</span></span>.) The numbers <span><span class="math inline">\(FtR(f)\)</span></span> and <span><span class="math inline">\(FtR(g)\)</span></span> agree with each other up to the <span><span class="math inline">\(k-1\)</span></span>-th digit up after the decimal point. Since this digit equals <span><span class="math inline">\(0\)</span></span> for <span><span class="math inline">\(FtR(f)\)</span></span> and equals <span><span class="math inline">\(1\)</span></span> for <span><span class="math inline">\(FtR(g)\)</span></span>, we claim that <span><span class="math inline">\(FtR(g)\)</span></span> is bigger than <span><span class="math inline">\(FtR(f)\)</span></span> by at least <span><span class="math inline">\(0.5 \cdot 10^{-k}\)</span></span>. To see this note that the difference <span><span class="math inline">\(FtR(g)-FtR(f)\)</span></span> will be minimized if <span><span class="math inline">\(g(\ell)=0\)</span></span> for every <span><span class="math inline">\(\ell&gt;k\)</span></span> and <span><span class="math inline">\(f(\ell)=1\)</span></span> for every <span><span class="math inline">\(\ell&gt;k\)</span></span>, in which case (since <span><span class="math inline">\(f\)</span></span> and <span><span class="math inline">\(g\)</span></span> agree up to the <span><span class="math inline">\(k-1\)</span></span>-th digit)</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
FtR(g)-FtR(f) = 10^{-k} - 10^{-k-1} - 10^{-k-2} - 10^{-k-3} - \cdots \;\;(2.7)
\]</span><a id='eqcantordecimalexpansion'></a></div></span></p>
<p>Since the infinite series <span><span class="math inline">\(\sum_{j=0}^{\infty} 10^{-i}\)</span></span> converges to <span><span class="math inline">\(10/9\)</span></span>, it follows that for every such <span><span class="math inline">\(f\)</span></span> and <span><span class="math inline">\(g\)</span></span>, <span><span class="math inline">\(FtR(g) - FtR(f) \geq 10^{-k} - 10^{-k-1}\cdot (10/9) &gt; 0\)</span></span>. In particular we see that for every distinct <span><span class="math inline">\(f,g \in \{0,1\}^\infty\)</span></span>, <span><span class="math inline">\(FtR(f) \neq FtR(g)\)</span></span>, implying that the function <span><span class="math inline">\(FtR\)</span></span> is one to one.</p>
</div>
<div id="decimal" class="remark" title="Using decimal expansion (optional)" name="Remark 2.10 (Using decimal expansion (optional)) ">
<p>In the proof above we used the fact that <span><span class="math inline">\(1 + 1/10 + 1/100 + \cdots\)</span></span> converges to <span><span class="math inline">\(10/9\)</span></span>, which plugging into <a href='#eqcantordecimalexpansion'>Equation 2.7</a> yields that the difference between <span><span class="math inline">\(FtR(g)\)</span></span> and <span><span class="math inline">\(FtR(h)\)</span></span> is at least <span><span class="math inline">\(10^{-k} - 10^{-k-1}\cdot (10/9) &gt; 0\)</span></span>. While the choice of the decimal representation for <span><span class="math inline">\(FtR\)</span></span> was arbitrary, we could not have used the binary representation in its place. Had we used the <em>binary</em> expansion instead of decimal, the corresponding sequence <span><span class="math inline">\(1 + 1/2 + 1/4 + \cdots\)</span></span> converges to <span><span class="math inline">\(2/1=2\)</span></span>, and since <span><span class="math inline">\(2^{-k} = 2^{-k-1} \cdot 2\)</span></span>, we could not have deduced that <span><span class="math inline">\(FtR\)</span></span> is one to one. Indeed there do exist pairs of distinct sequences <span><span class="math inline">\(f,g\in \{0,1\}^\infty\)</span></span> such that <span><span class="math inline">\(\sum_{i=0}^\infty f(i)2^{-i} = \sum_{i=0}^\infty g(i)2^{-i}\)</span></span>. (For example, the sequence <span><span class="math inline">\(1,0,0,0,\ldots\)</span></span> and the sequence <span><span class="math inline">\(0,1,1,1,\ldots\)</span></span> have this property.)</p>
</div>
<h2 id="representing-objects-beyond-numbers" data-number="2.4">Representing objects beyond numbers</h2>
<p>Numbers are of course by no means the only objects that we can represent as binary strings. A <em>representation scheme</em> for representing objects from some set <span><span class="math inline">\(\mathcal{O}\)</span></span> consists of an <em>encoding</em> function that maps an object in <span><span class="math inline">\(\mathcal{O}\)</span></span> to a string, and a <em>decoding</em> function that decodes a string back to an object in <span><span class="math inline">\(\mathcal{O}\)</span></span>. Formally, we make the following definition:</p>
<div id="binaryrepdef" class="definition" title="String representation" name="Definition 2.11 (String representation) ">
<p>Let <span><span class="math inline">\(\mathcal{O}\)</span></span> be any set. A <em>representation scheme</em> for <span><span class="math inline">\(\mathcal{O}\)</span></span> is a pair of functions <span><span class="math inline">\(E,D\)</span></span> where <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span> is a total one-to-one function, <span><span class="math inline">\(D:\{0,1\}^* \rightarrow_p \mathcal{O}\)</span></span> is a (possibly partial) function, and such that <span><span class="math inline">\(D\)</span></span> and <span><span class="math inline">\(E\)</span></span> satisfy that <span><span class="math inline">\(D(E(o))=o\)</span></span> for every <span><span class="math inline">\(o\in \mathcal{O}\)</span></span>. <span><span class="math inline">\(E\)</span></span> is known as the <em>encoding</em> function and <span><span class="math inline">\(D\)</span></span> is known as the <em>decoding</em> function.</p>
</div>
<p>Note that the condition <span><span class="math inline">\(D(E(o))=o\)</span></span> for every <span><span class="math inline">\(o\in\mathcal{O}\)</span></span> implies that <span><span class="math inline">\(D\)</span></span> is <em>onto</em> (can you see why?). It turns out that to construct a representation scheme we only need to find an <em>encoding</em> function. That is, every one-to-one encoding function has a corresponding decoding function, as shown in the following lemma:</p>
<div id="decodelem" class="lemma" name="Lemma 2.12">
<p>Suppose that <span><span class="math inline">\(E: \mathcal{O} \rightarrow \{0,1\}^*\)</span></span> is one-to-one. Then there exists a function <span><span class="math inline">\(D:\{0,1\}^* \rightarrow \mathcal{O}\)</span></span> such that <span><span class="math inline">\(D(E(o))=o\)</span></span> for every <span><span class="math inline">\(o\in \mathcal{O}\)</span></span>.</p>
</div>
<div id="section-1" class="proof" data-ref="decodelem" name="Proof">
<p>Let <span><span class="math inline">\(o_0\)</span></span> be some arbitrary element of <span><span class="math inline">\(\mathcal{O}\)</span></span>. For every <span><span class="math inline">\(x \in \{0,1\}^*\)</span></span>, there exists either zero or a single <span><span class="math inline">\(o\in \mathcal{O}\)</span></span> such that <span><span class="math inline">\(E(o)=x\)</span></span> (otherwise <span><span class="math inline">\(E\)</span></span> would not be one-to-one). We will define <span><span class="math inline">\(D(x)\)</span></span> to equal <span><span class="math inline">\(o_0\)</span></span> in the first case and this single object <span><span class="math inline">\(o\)</span></span> in the second case. By definition <span><span class="math inline">\(D(E(o))=o\)</span></span> for every <span><span class="math inline">\(o\in \mathcal{O}\)</span></span>.</p>
</div>
<div id="totaldecoding" class="remark" title="Total decoding functions" name="Remark 2.13 (Total decoding functions) ">
<p>While the decoding function of a representation scheme can in general be a <em>partial</em> function, the proof of <a href='#decodelem'>Lemma 2.12</a> implies that every representation scheme has a <em>total</em> decoding function. This observation can sometimes be useful.</p>
</div>
<h3 id="finite-representations" data-number="2.4.1">Finite representations</h3>
<p>If <span><span class="math inline">\(\mathcal{O}\)</span></span> is <em>finite</em>, then we can represent every object in <span><span class="math inline">\(\mathcal{O}\)</span></span> as a string of length at most some number <span><span class="math inline">\(n\)</span></span>. What is the value of <span><span class="math inline">\(n\)</span></span>? Let us denote by <span><span class="math inline">\(\{0,1\}^{\leq n}\)</span></span> the set <span><span class="math inline">\(\{ x\in \{0,1\}^* : |x| \leq n \}\)</span></span> of strings of length at most <span><span class="math inline">\(n\)</span></span>. The size of <span><span class="math inline">\(\{0,1\}^{\leq n}\)</span></span> is equal to <span>
<div class='myequationbox'><span class="math display">\[
|\{0,1\}^0| + |\{0,1\}^1| + |\{0,1\}^2| + \cdots + |\{0,1\}^n| = \sum_{i=0}^n 2^i = 2^{n+1}-1
\]</span></div></span> using the standard formula for summing a <a href="https://en.wikipedia.org/wiki/Geometric_progression">geometric progression</a>.</p>
<p>To obtain a representation of objects in <span><span class="math inline">\(\mathcal{O}\)</span></span> as strings of length at most <span><span class="math inline">\(n\)</span></span> we need to come up with a one-to-one function from <span><span class="math inline">\(\mathcal{O}\)</span></span> to <span><span class="math inline">\(\{0,1\}^{\leq n}\)</span></span>. We can do so, if and only if <span><span class="math inline">\(|\mathcal{O}| \leq 2^{n+1}-1\)</span></span> as is implied by the following lemma:</p>
<div id="onetoone" class="lemma" name="Lemma 2.14">
<p>For every two finite sets <span><span class="math inline">\(S,T\)</span></span>, there exists a one-to-one <span><span class="math inline">\(E:S \rightarrow T\)</span></span> if and only if <span><span class="math inline">\(|S| \leq |T|\)</span></span>.</p>
</div>
<div id="section-2" class="proof" data-ref="onetoone" name="Proof">
<p>Let <span><span class="math inline">\(k=|S|\)</span></span> and <span><span class="math inline">\(m=|T|\)</span></span> and so write the elements of <span><span class="math inline">\(S\)</span></span> and <span><span class="math inline">\(T\)</span></span> as <span><span class="math inline">\(S = \{ s_0 , s_1, \ldots, s_{k-1} \}\)</span></span> and <span><span class="math inline">\(T= \{ t_0 , t_1, \ldots, t_{m-1} \}\)</span></span>. We need to show that there is a one-to-one function <span><span class="math inline">\(E: S \rightarrow T\)</span></span> iff <span><span class="math inline">\(k \leq m\)</span></span>. For the “if” direction, if <span><span class="math inline">\(k \leq m\)</span></span> we can simply define <span><span class="math inline">\(E(s_i)=t_i\)</span></span> for every <span><span class="math inline">\(i\in [k]\)</span></span>. Clearly for <span><span class="math inline">\(i \neq j\)</span></span>, <span><span class="math inline">\(t_i = E(s_i) \neq E(s_j) = t_j\)</span></span>, and hence this function is one-to-one. In the other direction, suppose that <span><span class="math inline">\(k&gt;m\)</span></span> and <span><span class="math inline">\(E: S \rightarrow T\)</span></span> is some function. Then <span><span class="math inline">\(E\)</span></span> cannot be one-to-one. Indeed, for <span><span class="math inline">\(i=0,1,\ldots,m-1\)</span></span> let us “mark” the element <span><span class="math inline">\(t_j=E(s_i)\)</span></span> in <span><span class="math inline">\(T\)</span></span>. If <span><span class="math inline">\(t_j\)</span></span> was marked before, then we have found two objects in <span><span class="math inline">\(S\)</span></span> mapping to the same element <span><span class="math inline">\(t_j\)</span></span>. Otherwise, since <span><span class="math inline">\(T\)</span></span> has <span><span class="math inline">\(m\)</span></span> elements, when we get to <span><span class="math inline">\(i=m-1\)</span></span> we mark all the objects in <span><span class="math inline">\(T\)</span></span>. Hence, in this case, <span><span class="math inline">\(E(s_m)\)</span></span> must map to an element that was already marked before. (This observation is sometimes known as the “Pigeon Hole Principle”: the principle that if you have a pigeon coop with <span><span class="math inline">\(m\)</span></span> holes, and <span><span class="math inline">\(k&gt;m\)</span></span> pigeons, then there must be two pigeons in the same hole. )</p>
</div>
<h3 id="prefixfreesec" data-number="2.4.2">Prefix-free encoding</h3>
<p>When showing a representation scheme for rational numbers, we used the “hack” of encoding the alphabet <span><span class="math inline">\(\{ 0,1, \|\}\)</span></span> to represent tuples of strings as a single string. This is a special case of the general paradigm of <em>prefix-free</em> encoding. The idea is the following: if our representation has the property that no string <span><span class="math inline">\(x\)</span></span> representing an object <span><span class="math inline">\(o\)</span></span> is a <em>prefix</em> (i.e., an initial substring) of a string <span><span class="math inline">\(y\)</span></span> representing a different object <span><span class="math inline">\(o&#39;\)</span></span>, then we can represent a <em>list</em> of objects by merely concatenating the representations of all the list members. For example, because in English every sentence ends with a punctuation mark such as a period, exclamation, or question mark, no sentence can be a prefix of another and so we can represent a list of sentences by merely concatenating the sentences one after the other. (English has some complications such as periods used for abbreviations (e.g., “e.g.”) or sentence quotes containing punctuation, but the high level point of a prefix-free representation for sentences still holds.)</p>
<p>It turns out that we can transform <em>every</em> representation to a prefix-free form. This justifies <a href='#representtuplesidea'>Bigidea 1</a>, and allows us to transform a representation scheme for objects of a type <span><span class="math inline">\(T\)</span></span> to a representation scheme of <em>lists</em> of objects of the type <span><span class="math inline">\(T\)</span></span>. By repeating the same technique, we can also represent lists of lists of objects of type <span><span class="math inline">\(T\)</span></span>, and so on and so forth. But first let us formally define prefix-freeness:</p>
<div id="prefixfreedef" class="definition" title="Prefix free encoding" name="Definition 2.15 (Prefix free encoding) ">
<p>For two strings <span><span class="math inline">\(y,y&#39;\)</span></span>, we say that <span><span class="math inline">\(y\)</span></span> is a <em>prefix</em> of <span><span class="math inline">\(y&#39;\)</span></span> if <span><span class="math inline">\(|y| \leq |y&#39;|\)</span></span> and for every <span><span class="math inline">\(i&lt;|y|\)</span></span>, <span><span class="math inline">\(y&#39;_i = y_i\)</span></span>.</p>
<p>Let <span><span class="math inline">\(\mathcal{O}\)</span></span> be a non-empty set and <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span> be a function. We say that <span><span class="math inline">\(E\)</span></span> is <em>prefix-free</em> if <span><span class="math inline">\(E(o)\)</span></span> is non-empty for every <span><span class="math inline">\(o\in\mathcal{O}\)</span></span> and there does not exist a distinct pair of objects <span><span class="math inline">\(o, o&#39; \in \mathcal{O}\)</span></span> such that <span><span class="math inline">\(E(o)\)</span></span> is a prefix of <span><span class="math inline">\(E(o&#39;)\)</span></span>.</p>
</div>
<p>Recall that for every set <span><span class="math inline">\(\mathcal{O}\)</span></span>, the set <span><span class="math inline">\(\mathcal{O}^*\)</span></span> consists of all finite length tuples (i.e., <em>lists</em>) of elements in <span><span class="math inline">\(\mathcal{O}\)</span></span>. The following theorem shows that if <span><span class="math inline">\(E\)</span></span> is a prefix-free encoding of <span><span class="math inline">\(\mathcal{O}\)</span></span> then by concatenating encodings we can obtain a valid (i.e., one-to-one) representation of <span><span class="math inline">\(\mathcal{O}^*\)</span></span>:</p>
<div id="prefixfreethm" class="theorem" title="Prefix-free implies tuple encoding" name="Theorem 2.16 (Prefix-free implies tuple encoding) ">
<p>Suppose that <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span> is prefix-free. Then the following map <span><span class="math inline">\(\overline{E}:\mathcal{O}^* \rightarrow \{0,1\}^*\)</span></span> is one to one, for every <span><span class="math inline">\(o_0,\ldots,o_{k-1} \in \mathcal{O}^*\)</span></span>, we define <span>
<div class='myequationbox'><span class="math display">\[
\overline{E}(o_0,\ldots,o_{k-1}) = E(o_0)E(o_1) \cdots E(o_{k-1}) \;.
\]</span></div></span></p>
</div>
<div id="section-3" class="pause" name="Pause">
<p><a href='#prefixfreethm'>Theorem 2.16</a> is an example of a theorem that is a little hard to parse, but in fact is fairly straightforward to prove once you understand what it means. Therefore, I highly recommend that you pause here to make sure you understand the statement of this theorem. You should also try to prove it on your own before proceeding further.</p>
</div>
<figure>
<img src="../figure/repres_list.png" alt="2.9: If we have a prefix-free representation of each object then we can concatenate the representations of k objects to obtain a representation for the tuple (o_0,\ldots,o_{k-1})." id="prefixfreerepconcat" class="margin" /><figcaption>2.9: If we have a prefix-free representation of each object then we can concatenate the representations of <span><span class="math inline">\(k\)</span></span> objects to obtain a representation for the tuple <span><span class="math inline">\((o_0,\ldots,o_{k-1})\)</span></span>.</figcaption>
</figure>
<div id="section-4" class="proofidea" data-ref="prefixfreethm" name="Proofidea">
<p>The idea behind the proof is simple. Suppose that for example we want to decode a triple <span><span class="math inline">\((o_0,o_1,o_2)\)</span></span> from its representation <span><span class="math inline">\(x= \overline{E}(o_0,o_1,o_2)=E(o_0)E(o_1)E(o_2)\)</span></span>. We will do so by first finding the first prefix <span><span class="math inline">\(x_0\)</span></span> of <span><span class="math inline">\(x\)</span></span> such is a representation of some object. Then we will decode this object, remove <span><span class="math inline">\(x_0\)</span></span> from <span><span class="math inline">\(x\)</span></span> to obtain a new string <span><span class="math inline">\(x&#39;\)</span></span>, and continue onwards to find the first prefix <span><span class="math inline">\(x_1\)</span></span> of <span><span class="math inline">\(x&#39;\)</span></span> and so on and so forth (see <a href='#prefix-free-tuples-ex'>Exercise 2.9</a>). The prefix-freeness property of <span><span class="math inline">\(E\)</span></span> will ensure that <span><span class="math inline">\(x_0\)</span></span> will in fact be <span><span class="math inline">\(E(o_0)\)</span></span>, <span><span class="math inline">\(x_1\)</span></span> will be <span><span class="math inline">\(E(o_1)\)</span></span>, etc.</p>
</div>
<div class="proof" data-ref="prefixfreethm" name="Proof 2.4.2">
<p>We now show the formal proof. Suppose, towards the sake of contradiction, that there exist two distinct tuples <span><span class="math inline">\((o_0,\ldots,o_{k-1})\)</span></span> and <span><span class="math inline">\((o&#39;_0,\ldots,o&#39;_{k&#39;-1})\)</span></span> such that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\overline{E}(o_0,\ldots,o_{k-1})= \overline{E}(o&#39;_0,\ldots,o&#39;_{k&#39;-1}) \;. \;\;(2.10)
\]</span><a id='prefixfreeassump'></a></div></span> We will denote the string <span><span class="math inline">\(\overline{E}(o_0,\ldots,o_{k-1})\)</span></span> by <span><span class="math inline">\(\overline{x}\)</span></span>.</p>
<p>Let <span><span class="math inline">\(i\)</span></span> be the first index such that <span><span class="math inline">\(o_i \neq o&#39;_i\)</span></span>. (If <span><span class="math inline">\(o_i=o&#39;_i\)</span></span> for all <span><span class="math inline">\(i\)</span></span> then, since we assume the two tuples are distinct, one of them must be larger than the other. In this case we assume without loss of generality that <span><span class="math inline">\(k&#39;&gt;k\)</span></span> and let <span><span class="math inline">\(i=k\)</span></span>.) In the case that <span><span class="math inline">\(i&lt;k\)</span></span>, we see that the string <span><span class="math inline">\(\overline{x}\)</span></span> can be written in two different ways:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\overline{x} = \overline{E}(o_0,\ldots,o_{k-1}) = x_0\cdots x_{i-1} E(o_i) E(o_{i+1}) \cdots E(o_{k-1})
\]</span></div></span></p>
<p>and</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\overline{x} = \overline{E}(o&#39;_0,\ldots,o&#39;_{k&#39;-1}) = x_0\cdots x_{i-1} E(o&#39;_i) E(o&#39;_{i+1}) \cdots E(o&#39;_{k-1})
\]</span></div></span></p>
<p>where <span><span class="math inline">\(x_j = E(o_j) = E(o&#39;_j)\)</span></span> for all <span><span class="math inline">\(j&lt;i\)</span></span>. Let <span><span class="math inline">\(\overline{y}\)</span></span> be the string obtained after removing the prefix <span><span class="math inline">\(x_0 \cdots x_{i-i}\)</span></span> from <span><span class="math inline">\(\overline{x}\)</span></span>. We see that <span><span class="math inline">\(\overline{y}\)</span></span> can be written as both <span><span class="math inline">\(\overline{y}= E(o_i)s\)</span></span> for some string <span><span class="math inline">\(s\in \{0,1\}^*\)</span></span> and as <span><span class="math inline">\(\overline{y} = E(o&#39;_i)s&#39;\)</span></span> for some <span><span class="math inline">\(s&#39;\in \{0,1\}^*\)</span></span>. But this means that one of <span><span class="math inline">\(E(o_i)\)</span></span> and <span><span class="math inline">\(E(o&#39;_i)\)</span></span> must be a prefix of the other, contradicting the prefix-freeness of <span><span class="math inline">\(E\)</span></span>.</p>
<p>In the case that <span><span class="math inline">\(i=k\)</span></span> and <span><span class="math inline">\(k&#39;&gt;k\)</span></span>, we get a contradiction in the following way. In this case</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\overline{x} = E(o_0)\cdots E(o_{k-1}) = E(o_0) \cdots E(o_{k-1}) E(o&#39;_k) \cdots E(o&#39;_{k&#39;-1})\]</span></div></span></p>
<p>which means that <span><span class="math inline">\(E(o&#39;_k) \cdots E(o&#39;_{k&#39;-1})\)</span></span> must correspond to the empty string <span><span class="math inline">\(\text{\ensuremath{\text{\texttt{&quot;&quot;}}}}\)</span></span>. But in such a case <span><span class="math inline">\(E(o&#39;_k)\)</span></span> must be the empty string, which in particular is the prefix of any other string, contradicting the prefix-freeness of <span><span class="math inline">\(E\)</span></span>.</p>
</div>
<div id="prefixfreelistsrem" class="remark" title="Prefix freeness of list representation" name="Remark 2.17 (Prefix freeness of list representation) ">
<p>Even if the representation <span><span class="math inline">\(E\)</span></span> of objects in <span><span class="math inline">\(\mathcal{O}\)</span></span> is prefix free, this does not mean that our representation <span><span class="math inline">\(\overline{E}\)</span></span> of <em>lists</em> of such objects will be prefix free as well. In fact, it won’t be: for every three objects <span><span class="math inline">\(o,o&#39;,o&#39;&#39;\)</span></span> the representation of the list <span><span class="math inline">\((o,o&#39;)\)</span></span> will be a prefix of the representation of the list <span><span class="math inline">\((o,o&#39;,o&#39;&#39;)\)</span></span>. However, as we see in <a href='#prefixfreetransformationlem'>Lemma 2.18</a> below, we can transform <em>every</em> representation into prefix-free form, and so will be able to use that transformation if needed to represent lists of lists, lists of lists of lists, and so on and so forth.</p>
</div>
<h3 id="making-representations-prefix-free" data-number="2.4.3">Making representations prefix-free</h3>
<p>Some natural representations are prefix-free. For example, every <em>fixed output length</em> representation (i.e., one-to-one function <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^n\)</span></span>) is automatically prefix-free, since a string <span><span class="math inline">\(x\)</span></span> can only be a prefix of an equal-length <span><span class="math inline">\(x&#39;\)</span></span> if <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(x&#39;\)</span></span> are identical. Moreover, the approach we used for representing rational numbers can be used to show the following:</p>
<div id="prefixfreetransformationlem" class="lemma" name="Lemma 2.18">
<p>Let <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span> be a one-to-one function. Then there is a one-to-one prefix-free encoding <span><span class="math inline">\(\overline{E}\)</span></span> such that <span><span class="math inline">\(|\overline{E}(o)| \leq 2|E(o)|+2\)</span></span> for every <span><span class="math inline">\(o\in \mathcal{O}\)</span></span>.</p>
</div>
<div id="section-5" class="pause" name="Pause">
<p>For the sake of completeness, we will include the proof below, but it is a good idea for you to pause here and try to prove it on your own, using the same technique we used for representing rational numbers.</p>
</div>
<div class="proof" data-ref="prefixfreetransformationlem" name="Proofidea 22.11.1">
<p>The idea behind the proof is to use the map <span><span class="math inline">\(0 \mapsto 00\)</span></span>, <span><span class="math inline">\(1 \mapsto 11\)</span></span> to “double” every bit in the string <span><span class="math inline">\(x\)</span></span> and then mark the end of the string by concatenating to it the pair <span><span class="math inline">\(01\)</span></span>. If we encode a string <span><span class="math inline">\(x\)</span></span> in this way, it ensures that the encoding of <span><span class="math inline">\(x\)</span></span> is never a prefix of the encoding of a distinct string <span><span class="math inline">\(x&#39;\)</span></span>. Formally, we define the function <span><span class="math inline">\(\ensuremath{\mathit{PF}}:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> as follows: <span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{PF}}(x)=x_0 x_0 x_1 x_1 \ldots x_{n-1}x_{n-1}01\]</span></div></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. If <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span> is the (potentially not prefix-free) representation for <span><span class="math inline">\(\mathcal{O}\)</span></span>, then we transform it into a prefix-free representation <span><span class="math inline">\(\overline{E}:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span> by defining <span><span class="math inline">\(\overline{E}(o)=\ensuremath{\mathit{PF}}(E(o))\)</span></span>.</p>
<p>To prove the lemma we need to show that <strong>(1)</strong> <span><span class="math inline">\(\overline{E}\)</span></span> is one-to-one and <strong>(2)</strong> <span><span class="math inline">\(\overline{E}\)</span></span> is prefix-free. In fact, prefix freeness is a stronger condition than one-to-one (if two strings are equal then in particular one of them is a prefix of the other) and hence it suffices to prove <strong>(2)</strong>, which we now do.</p>
<p>Let <span><span class="math inline">\(o \neq o&#39;\)</span></span> in <span><span class="math inline">\(\mathcal{O}\)</span></span> be two distinct objects. We will prove that <span><span class="math inline">\(\overline{E}(o)\)</span></span> is a not a prefix of <span><span class="math inline">\(\overline{E}(o&#39;)\)</span></span>. Define <span><span class="math inline">\(x = E(o)\)</span></span> and <span><span class="math inline">\(x&#39;=E(o&#39;)\)</span></span>. Since <span><span class="math inline">\(E\)</span></span> is one-to-one, <span><span class="math inline">\(x \neq x&#39;\)</span></span>. Under our assumption, <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)\)</span></span> is a prefix of <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)\)</span></span>. If <span><span class="math inline">\(|x|&lt;|x&#39;|\)</span></span> then the two bits in positions <span><span class="math inline">\(2|x|,2|x|+1\)</span></span> in <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)\)</span></span> have the value <span><span class="math inline">\(01\)</span></span> but the corresponding bits in <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)\)</span></span> will equal either <span><span class="math inline">\(00\)</span></span> or <span><span class="math inline">\(11\)</span></span> (depending on the <span><span class="math inline">\(|x|\)</span></span>-th bit of <span><span class="math inline">\(x&#39;\)</span></span>) and hence <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)\)</span></span> cannot be a prefix of <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)\)</span></span>. If <span><span class="math inline">\(|x|=|x&#39;|\)</span></span> then, since <span><span class="math inline">\(x \neq x&#39;\)</span></span>, there must be a coordinate <span><span class="math inline">\(i\)</span></span> in which they differ, meaning that the strings <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)\)</span></span> differ in the coordinates <span><span class="math inline">\(2i,2i+1\)</span></span>, which again means that <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)\)</span></span> cannot be a prefix of <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)\)</span></span>. If <span><span class="math inline">\(|x|&gt;|x&#39;|\)</span></span> then <span><span class="math inline">\(|\ensuremath{\mathit{PF}}(x)|=2|x|+2&gt;|\ensuremath{\mathit{PF}}(x&#39;)|=2|x&#39;|+2\)</span></span> and hence <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)\)</span></span> is longer than (and cannot be a prefix of) <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)\)</span></span>. In all cases we see that <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x)=\overline{E}(o)\)</span></span> is not a prefix of <span><span class="math inline">\(\ensuremath{\mathit{PF}}(x&#39;)=\overline{E}(o&#39;)\)</span></span>, hence completing the proof.</p>
</div>
<p>The proof of <a href='#prefixfreetransformationlem'>Lemma 2.18</a> is not the only or even the best way to transform an arbitrary representation into prefix-free form. <a href='#prefix-free-ex'>Exercise 2.10</a> asks you to construct a more efficient prefix-free transformation satisfying <span><span class="math inline">\(|\overline{E}(o)| \leq |E(o)| + O(\log |E(o)|)\)</span></span>.</p>
<h3 id="proof-by-python-optional" data-number="2.4.4">“Proof by Python” (optional)</h3>
<p>The proofs of <a href='#prefixfreethm'>Theorem 2.16</a> and <a href='#prefixfreetransformationlem'>Lemma 2.18</a> are <em>constructive</em> in the sense that they give us:</p>
<ul>
<li><p>A way to transform the encoding and decoding functions of any representation of an object <span><span class="math inline">\(O\)</span></span> to encoding and decoding functions that are prefix-free, and</p></li>
<li><p>A way to extend prefix-free encoding and decoding of single objects to encoding and decoding of <em>lists</em> of objects by concatenation.</p></li>
</ul>
<p>Specifically, we could transform any pair of Python functions <code>encode</code> and <code>decode</code> to functions <code>pfencode</code> and <code>pfdecode</code> that correspond to a prefix-free encoding and decoding. Similarly, given <code>pfencode</code> and <code>pfdecode</code> for single objects, we can extend them to encoding of lists. Let us show how this works for the case of the <code>NtS</code> and <code>StN</code> functions we defined above.</p>
<p>We start with the “Python proof” of <a href='#prefixfreetransformationlem'>Lemma 2.18</a>: a way to transform an arbitrary representation into one that is <em>prefix free</em>. The function <code>prefixfree</code> below takes as input a pair of encoding and decoding functions, and returns a triple of functions containing <em>prefix-free</em> encoding and decoding functions, as well as a function that checks whether a string is a valid encoding of an object.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="co"># takes functions encode and decode mapping</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co"># objects to lists of bits and vice versa,</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co"># and returns functions pfencode and pfdecode that</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co"># maps objects to lists of bits and vice versa</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co"># in a prefix-free way.</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co"># Also returns a function pfvalid that says</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co"># whether a list is a valid encoding</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="kw">def</span> prefixfree(encode, decode):</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="kw">def</span> pfencode(o):</a>
<a class="sourceLine" id="cb3-10" title="10">        L <span class="op">=</span> encode(o)</a>
<a class="sourceLine" id="cb3-11" title="11">        <span class="cf">return</span> [L[i<span class="op">//</span><span class="dv">2</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span><span class="op">*</span><span class="bu">len</span>(L))]<span class="op">+</span>[<span class="dv">0</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="kw">def</span> pfdecode(L):</a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="cf">return</span> decode([L[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(L)<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)])</a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="kw">def</span> pfvalid(L):</a>
<a class="sourceLine" id="cb3-15" title="15">        <span class="cf">return</span> (<span class="bu">len</span>(L) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> ) <span class="kw">and</span> <span class="bu">all</span>(L[<span class="dv">2</span><span class="op">*</span>i]<span class="op">==</span>L[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>((<span class="bu">len</span>(L)<span class="op">-</span><span class="dv">2</span>)<span class="op">//</span><span class="dv">2</span>)) <span class="kw">and</span> L[<span class="op">-</span><span class="dv">2</span>:]<span class="op">==</span>[<span class="dv">0</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb3-16" title="16"></a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="cf">return</span> pfencode, pfdecode, pfvalid</a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19">pfNtS, pfStN , pfvalidN <span class="op">=</span> prefixfree(NtS,StN)</a>
<a class="sourceLine" id="cb3-20" title="20"></a>
<a class="sourceLine" id="cb3-21" title="21">NtS(<span class="dv">234</span>)</a>
<a class="sourceLine" id="cb3-22" title="22"><span class="co"># 11101010</span></a>
<a class="sourceLine" id="cb3-23" title="23">pfNtS(<span class="dv">234</span>)</a>
<a class="sourceLine" id="cb3-24" title="24"><span class="co"># 111111001100110001</span></a>
<a class="sourceLine" id="cb3-25" title="25">pfStN(pfNtS(<span class="dv">234</span>))</a>
<a class="sourceLine" id="cb3-26" title="26"><span class="co"># 234</span></a>
<a class="sourceLine" id="cb3-27" title="27">pfvalidM(pfNtS(<span class="dv">234</span>))</a>
<a class="sourceLine" id="cb3-28" title="28"><span class="co"># true</span></a></code></pre></div>
<div id="section-6" class="pause" name="Pause">
<p>Note that the Python function <code>prefixfree</code> above takes two <em>Python functions</em> as input and outputs three Python functions as output. (When it’s not too awkward, we use the term “Python function” or “subroutine” to distinguish between such snippets of Python programs and mathematical functions.) You don’t have to know Python in this course, but you do need to get comfortable with the idea of functions as mathematical objects in their own right, that can be used as inputs and outputs of other functions.</p>
</div>
<p>We now show a “Python proof” of <a href='#prefixfreethm'>Theorem 2.16</a>. Namely, we show a function <code>represlists</code> that takes as input a prefix-free representation scheme (implemented via encoding, decoding, and validity testing functions) and outputs a representation scheme for <em>lists</em> of such objects. If we want to make this representation prefix-free then we could fit it into the function <code>prefixfree</code> above.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> represlists(pfencode,pfdecode,pfvalid):</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">    Takes functions pfencode, pfdecode and pfvalid,</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">    and returns functions encodelists, decodelists</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">    that can encode and decode lists of the objects</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">    respectively.</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">def</span> encodelist(L):</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="co">&quot;&quot;&quot;Gets list of objects, encodes it as list of bits&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join([pfencode(obj) <span class="cf">for</span> obj <span class="kw">in</span> L])</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">def</span> decodelist(S):</a>
<a class="sourceLine" id="cb4-14" title="14">        <span class="co">&quot;&quot;&quot;Gets lists of bits, returns lists of objects&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-15" title="15">        i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">=</span><span class="dv">1</span> <span class="op">;</span> res <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-16" title="16">        <span class="cf">while</span> j<span class="op">&lt;=</span><span class="bu">len</span>(S):</a>
<a class="sourceLine" id="cb4-17" title="17">            <span class="cf">if</span> pfvalid(S[i:j]):</a>
<a class="sourceLine" id="cb4-18" title="18">                res <span class="op">+=</span> [pfdecode(S[i:j])]</a>
<a class="sourceLine" id="cb4-19" title="19">                i<span class="op">=</span>j</a>
<a class="sourceLine" id="cb4-20" title="20">            j<span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-21" title="21">        <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb4-22" title="22"></a>
<a class="sourceLine" id="cb4-23" title="23">    <span class="cf">return</span> encodelist,decodelist</a>
<a class="sourceLine" id="cb4-24" title="24"></a>
<a class="sourceLine" id="cb4-25" title="25"></a>
<a class="sourceLine" id="cb4-26" title="26">LtS , StL <span class="op">=</span> represlists(pfNtS,pfStN,pfvalidN)</a>
<a class="sourceLine" id="cb4-27" title="27"></a>
<a class="sourceLine" id="cb4-28" title="28">LtS([<span class="dv">234</span>,<span class="dv">12</span>,<span class="dv">5</span>])</a>
<a class="sourceLine" id="cb4-29" title="29"><span class="co"># 111111001100110001111100000111001101</span></a>
<a class="sourceLine" id="cb4-30" title="30">StL(LtS([<span class="dv">234</span>,<span class="dv">12</span>,<span class="dv">5</span>]))</a>
<a class="sourceLine" id="cb4-31" title="31"><span class="co"># [234, 12, 5]</span></a></code></pre></div>
<h3 id="representing-letters-and-text" data-number="2.4.5">Representing letters and text</h3>
<p>We can represent a letter or symbol by a string, and then if this representation is prefix-free, we can represent a sequence of symbols by merely concatenating the representation of each symbol. One such representation is the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> that represents <span><span class="math inline">\(128\)</span></span> letters and symbols as strings of <span><span class="math inline">\(7\)</span></span> bits. Since the ASCII representation is fixed-length, it is automatically prefix-free (can you see why?). <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> is representation of (at the time of this writing) about 128,000 symbols as numbers (known as <em>code points</em>) between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1,114,111\)</span></span>. There are several types of prefix-free representations of the code points, a popular one being <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> that encodes every codepoint into a string of length between <span><span class="math inline">\(8\)</span></span> and <span><span class="math inline">\(32\)</span></span>. <!-- (For example, the UTF-8 encoding for the "confused face" emoji 😕 is `11110000100111111001100010010101`) --></p>
<figure>
<img src="../figure/braille.png" alt="2.10: The word “Binary” in “Grade 1” or “uncontracted” Unified English Braille. This word is encoded using seven symbols since the first one is a modifier indicating that the first letter is capitalized." id="braillefig" class="class margin" /><figcaption>2.10: The word “Binary” in “Grade 1” or “uncontracted” Unified English Braille. This word is encoded using seven symbols since the first one is a modifier indicating that the first letter is capitalized.</figcaption>
</figure>
<div id="braille" class="example" title="The Braille representation" name="Example 2.19 (The Braille representation) ">
<p>The <em>Braille system</em> is another way to encode letters and other symbols as binary strings. Specifically, in Braille, every letter is encoded as a string in <span><span class="math inline">\(\{0,1\}^6\)</span></span>, which is written using indented dots arranged in two columns and three rows, see <a href='#braillefig'>Figure 2.10</a>. (Some symbols require more than one six-bit string to encode, and so Braille uses a more general prefix-free encoding.)</p>
<p>The Braille system was invented in 1821 by <a href="https://goo.gl/Y2BkEe">Louis Braille</a> when he was just 12 years old (though he continued working on it and improving it throughout his life). Braille was a French boy who lost his eyesight at the age of 5 as the result of an accident.</p>
</div>
<div id="Crepresentation" class="example" title="Representing objects in C (optional)" name="Example 2.20 (Representing objects in C (optional)) ">
<p>We can use programming languages to probe how our computing environment represents various values. This is easiest to do in “unsafe” programming languages such as <code>C</code> that allow direct access to the memory.</p>
<p>Using a <a href="https://goo.gl/L8oMzn">simple <code>C</code> program</a> we have produced the following representations of various values. One can see that for integers, multiplying by 2 corresponds to a “left shift” inside each byte. In contrast, for floating point numbers, multiplying by two corresponds to adding one to the exponent part of the representation. In the architecture we used, a negative number is represented using the <a href="https://goo.gl/wov5fa">two’s complement</a> approach. <code>C</code> represents strings in a prefix-free form by ensuring that a zero byte is at their end.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span>      <span class="dv">2</span>    : <span class="bn">00000010</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="dt">int</span>      <span class="dv">4</span>    : <span class="bn">00000100</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="dt">int</span>      <span class="dv">513</span>  : <span class="bn">00000001</span> <span class="bn">00000010</span> <span class="bn">00000000</span> <span class="bn">00000000</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="dt">long</span>     <span class="dv">513</span>  : <span class="bn">00000001</span> <span class="bn">00000010</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="dt">int</span>      -<span class="dv">1</span>   : <span class="dv">11111111</span> <span class="dv">11111111</span> <span class="dv">11111111</span> <span class="dv">11111111</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="dt">int</span>      -<span class="dv">2</span>   : <span class="dv">11111110</span> <span class="dv">11111111</span> <span class="dv">11111111</span> <span class="dv">11111111</span></a>
<a class="sourceLine" id="cb5-7" title="7">string   Hello: <span class="bn">01001000</span> <span class="bn">01100101</span> <span class="bn">01101100</span> <span class="bn">01101100</span> <span class="bn">01101111</span> <span class="bn">00000000</span></a>
<a class="sourceLine" id="cb5-8" title="8">string   abcd : <span class="bn">01100001</span> <span class="bn">01100010</span> <span class="bn">01100011</span> <span class="bn">01100100</span> <span class="bn">00000000</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dt">float</span>    <span class="fl">33.0</span> : <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000100</span> <span class="bn">01000010</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="dt">float</span>    <span class="fl">66.0</span> : <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="dv">10000100</span> <span class="bn">01000010</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="dt">float</span>    <span class="fl">132.0</span>: <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000100</span> <span class="bn">01000011</span></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="dt">double</span>   <span class="fl">132.0</span>: <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="bn">00000000</span> <span class="dv">10000000</span> <span class="bn">01100000</span> <span class="bn">01000000</span></a></code></pre></div>
</div>
<h3 id="representing-vectors-matrices-images" data-number="2.4.6">Representing vectors, matrices, images</h3>
<p>Once we can represent numbers and lists of numbers, then we can also represent <em>vectors</em> (which are just lists of numbers). Similarly, we can represent lists of lists, and thus, in particular, can represent <em>matrices</em>. To represent an image, we can represent the color at each pixel by a list of three numbers corresponding to the intensity of Red, Green and Blue. (We can restrict to three primary colors since <a href="https://en.wikipedia.org/wiki/Tetrachromacy">most</a> humans only have three types of cones in their retinas; we would have needed 16 primary colors to represent colors visible to the <a href="https://goo.gl/t7JBfC">Mantis Shrimp</a>.) Thus an image of <span><span class="math inline">\(n\)</span></span> pixels would be represented by a list of <span><span class="math inline">\(n\)</span></span> such length-three lists. A video can be represented as a list of images. Of course these representations are rather wasteful and <a href="https://en.wikipedia.org/wiki/JPEG">much</a> <a href="https://goo.gl/Vs8UhU">more</a> compact representations are typically used for images and videos, though this will not be our concern in this book.</p>
<h3 id="representing-graphs" data-number="2.4.7">Representing graphs</h3>
<p>A <em>graph</em> on <span><span class="math inline">\(n\)</span></span> vertices can be represented as an <span><span class="math inline">\(n\times n\)</span></span> <em>adjacency</em> matrix whose <span><span class="math inline">\((i,j)^{th}\)</span></span> entry is equal to <span><span class="math inline">\(1\)</span></span> if the edge <span><span class="math inline">\((i,j)\)</span></span> is present and is equal to <span><span class="math inline">\(0\)</span></span> otherwise. That is, we can represent an <span><span class="math inline">\(n\)</span></span> vertex directed graph <span><span class="math inline">\(G=(V,E)\)</span></span> as a string <span><span class="math inline">\(A\in \{0,1\}^{n^2}\)</span></span> such that <span><span class="math inline">\(A_{i,j}=1\)</span></span> iff the edge <span><span class="math inline">\(\overrightarrow{i\;j}\in E\)</span></span>. We can transform an undirected graph to a directed graph by replacing every edge <span><span class="math inline">\(\{i,j\}\)</span></span> with both edges <span><span class="math inline">\(\overrightarrow{i\; j}\)</span></span> and <span><span class="math inline">\(\overleftarrow{i\;j}\)</span></span></p>
<p>Another representation for graphs is the <em>adjacency list</em> representation. That is, we identify the vertex set <span><span class="math inline">\(V\)</span></span> of a graph with the set <span><span class="math inline">\([n]\)</span></span> where <span><span class="math inline">\(n=|V|\)</span></span>, and represent the graph <span><span class="math inline">\(G=(V,E)\)</span></span> as a list of <span><span class="math inline">\(n\)</span></span> lists, where the <span><span class="math inline">\(i\)</span></span>-th list consists of the out-neighbors of vertex <span><span class="math inline">\(i\)</span></span>. The difference between these representations can be significant for some applications, though for us would typically be immaterial.</p>
<figure>
<img src="../figure/representing_graphs.png" alt="2.11: Representing the graph G=(\{0,1,2,3,4\},\{ (1,0),(4,0),(1,4),(4,1),(2,1),(3,2),(4,3) \}) in the adjacency matrix and adjacency list representations." id="representinggraphsfig" class="margin" /><figcaption>2.11: Representing the graph <span><span class="math inline">\(G=(\{0,1,2,3,4\},\{ (1,0),(4,0),(1,4),(4,1),(2,1),(3,2),(4,3) \})\)</span></span> in the adjacency matrix and adjacency list representations.</figcaption>
</figure>
<h3 id="representing-lists-and-nested-lists" data-number="2.4.8">Representing lists and nested lists</h3>
<p>If we have a way of representing objects from a set <span><span class="math inline">\(\mathcal{O}\)</span></span> as binary strings, then we can represent lists of these objects by applying a prefix-free transformation. Moreover, we can use a trick similar to the above to handle <em>nested</em> lists. The idea is that if we have some representation <span><span class="math inline">\(E:\mathcal{O} \rightarrow \{0,1\}^*\)</span></span>, then we can represent nested lists of items from <span><span class="math inline">\(\mathcal{O}\)</span></span> using strings over the five element alphabet <span><span class="math inline">\(\Sigma = \{\)</span></span> <code>0</code>,<code>1</code>,<code>[</code> , <code>]</code> , <code>,</code> <span><span class="math inline">\(\}\)</span></span>. For example, if <span><span class="math inline">\(o_1\)</span></span> is represented by <code>0011</code>, <span><span class="math inline">\(o_2\)</span></span> is represented by <code>10011</code>, and <span><span class="math inline">\(o_3\)</span></span> is represented by <code>00111</code>, then we can represent the nested list <span><span class="math inline">\((o_1,(o_2,o_3))\)</span></span> as the string <code>"[0011,[10011,00111]]"</code> over the alphabet <span><span class="math inline">\(\Sigma\)</span></span>. By encoding every element of <span><span class="math inline">\(\Sigma\)</span></span> itself as a three-bit string, we can transform any representation for objects <span><span class="math inline">\(\mathcal{O}\)</span></span> into a representation that enables representing (potentially nested) lists of these objects.</p>
<h3 id="notation" data-number="2.4.9">Notation</h3>
<p>We will typically identify an object with its representation as a string. For example, if <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> is some function that maps strings to strings and <span><span class="math inline">\(n\)</span></span> is an integer, we might make statements such as “<span><span class="math inline">\(F(n)+1\)</span></span> is prime” to mean that if we represent <span><span class="math inline">\(n\)</span></span> as a string <span><span class="math inline">\(x\)</span></span>, then the integer <span><span class="math inline">\(m\)</span></span> represented by the string <span><span class="math inline">\(F(x)\)</span></span> satisfies that <span><span class="math inline">\(m+1\)</span></span> is prime. (You can see how this convention of identifying objects with their representation can save us a lot of cumbersome formalism.) Similarly, if <span><span class="math inline">\(x,y\)</span></span> are some objects and <span><span class="math inline">\(F\)</span></span> is a function that takes strings as inputs, then by <span><span class="math inline">\(F(x,y)\)</span></span> we will mean the result of applying <span><span class="math inline">\(F\)</span></span> to the representation of the ordered pair <span><span class="math inline">\((x,y)\)</span></span>. We use the same notation to invoke functions on <span><span class="math inline">\(k\)</span></span>-tuples of objects for every <span><span class="math inline">\(k\)</span></span>.</p>
<p>This convention of identifying an object with its representation as a string is one that we humans follow all the time. For example, when people say a statement such as “<span><span class="math inline">\(17\)</span></span> is a prime number”, what they really mean is that the integer whose decimal representation is the string “<code>17</code>”, is prime.</p>
<blockquote>
<div class="quote" name="Quote 2.4.9">
<p>When we say</p>
<p><em><span><span class="math inline">\(A\)</span></span> is an algorithm that computes the multiplication function on natural numbers.</em></p>
<p>what we really mean is that</p>
<p><em><span><span class="math inline">\(A\)</span></span> is an algorithm that computes the function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> such that for every pair <span><span class="math inline">\(a,b \in \N\)</span></span>, if <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> is a string representing the pair <span><span class="math inline">\((a,b)\)</span></span> then <span><span class="math inline">\(F(x)\)</span></span> will be a string representing their product <span><span class="math inline">\(a\cdot b\)</span></span>.</em></p>
</div>
</blockquote>
<h2 id="defining-computational-tasks-as-mathematical-functions" data-number="2.5">Defining computational tasks as mathematical functions</h2>
<p>Abstractly, a <em>computational process</em> is some process that takes an input which is a string of bits and produces an output which is a string of bits. This transformation of input to output can be done using a modern computer, a person following instructions, the evolution of some natural system, or any other means.</p>
<p>In future chapters, we will turn to mathematically defining computational processes, but, as we discussed above, at the moment we focus on <em>computational tasks</em>. That is, we focus on the <strong>specification</strong> and not the <strong>implementation</strong>. Again, at an abstract level, a computational task can specify any relation that the output needs to have with the input. However, for most of this book, we will focus on the simplest and most common task of <em>computing a function</em>. Here are some examples:</p>
<ul>
<li><p>Given (a representation of) two integers <span><span class="math inline">\(x,y\)</span></span>, compute the product <span><span class="math inline">\(x\times y\)</span></span>. Using our representation above, this corresponds to computing a function from <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span>. We have seen that there is more than one way to solve this computational task, and in fact, we still do not know the best algorithm for this problem.</p></li>
<li><p>Given (a representation of) an integer <span><span class="math inline">\(z&gt;1\)</span></span>, compute its <em>factorization</em>; i.e., the list of primes <span><span class="math inline">\(p_1 \leq \cdots \leq p_k\)</span></span> such that <span><span class="math inline">\(z = p_1\cdots p_k\)</span></span>. This again corresponds to computing a function from <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span>. The gaps in our knowledge of the complexity of this problem are even larger.</p></li>
<li><p>Given (a representation of) a graph <span><span class="math inline">\(G\)</span></span> and two vertices <span><span class="math inline">\(s\)</span></span> and <span><span class="math inline">\(t\)</span></span>, compute the length of the shortest path in <span><span class="math inline">\(G\)</span></span> between <span><span class="math inline">\(s\)</span></span> and <span><span class="math inline">\(t\)</span></span>, or do the same for the <em>longest</em> path (with no repeated vertices) between <span><span class="math inline">\(s\)</span></span> and <span><span class="math inline">\(t\)</span></span>. Both these tasks correspond to computing a function from <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span>, though it turns out that there is a vast difference in their computational difficulty.</p></li>
<li><p>Given the code of a Python program, determine whether there is an input that would force it into an infinite loop. This task corresponds to computing a <em>partial</em> function from <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span> since not every string corresponds to a syntactically valid Python program. We will see that we <em>do</em> understand the computational status of this problem, but the answer is quite surprising.</p></li>
<li><p>Given (a representation of) an image <span><span class="math inline">\(I\)</span></span>, decide if <span><span class="math inline">\(I\)</span></span> is a photo of a cat or a dog. This corresponds to computing some (partial) function from <span><span class="math inline">\(\{0,1\}^*\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>.</p></li>
</ul>
<div id="booleanrem" class="remark" title="Boolean functions and languages" name="Remark 2.21 (Boolean functions and languages) ">
<p>An important special case of computational tasks corresponds to computing <em>Boolean</em> functions, whose output is a single bit <span><span class="math inline">\(\{0,1\}\)</span></span>. Computing such functions corresponds to answering a YES/NO question, and hence this task is also known as a <em>decision problem</em>. Given any function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> and <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, the task of computing <span><span class="math inline">\(F(x)\)</span></span> corresponds to the task of deciding whether or not <span><span class="math inline">\(x\in L\)</span></span> where <span><span class="math inline">\(L = \{ x : F(x)=1 \}\)</span></span> is known as the <em>language</em> that corresponds to the function <span><span class="math inline">\(F\)</span></span>. (The language terminology is due to historical connections between the theory of computation and formal linguistics as developed by Noam Chomsky.) Hence many texts refer to such a computational task as <em>deciding a language</em>.</p>
</div>
<figure>
<img src="../figure/booleanfunc.png" alt="??: A subset L \subseteq \{0,1\}^* can be identified with the function F:\{0,1\}^* \rightarrow \{0,1\} such that F(x)=1 if x\in L and F(x)=0 if x\not\in L. Functions with a single bit of output are called Boolean functions, while subsets of strings are called languages. The above shows that the two are essentially the same object, and we can identify the task of deciding membership in L (known as deciding a language in the literature) with the task of computing the function F." id="booleanlangfig" class="margin" /><figcaption>??: A subset <span><span class="math inline">\(L \subseteq \{0,1\}^*\)</span></span> can be identified with the function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(F(x)=1\)</span></span> if <span><span class="math inline">\(x\in L\)</span></span> and <span><span class="math inline">\(F(x)=0\)</span></span> if <span><span class="math inline">\(x\not\in L\)</span></span>. Functions with a single bit of output are called <em>Boolean functions</em>, while subsets of strings are called <em>languages</em>. The above shows that the two are essentially the same object, and we can identify the task of deciding membership in <span><span class="math inline">\(L\)</span></span> (known as <em>deciding a language</em> in the literature) with the task of computing the function <span><span class="math inline">\(F\)</span></span>.</figcaption>
</figure>
<p>For every particular function <span><span class="math inline">\(F\)</span></span>, there can be several possible <em>algorithms</em> to compute <span><span class="math inline">\(F\)</span></span>. We will be interested in questions such as:</p>
<ul>
<li><p>For a given function <span><span class="math inline">\(F\)</span></span>, can it be the case that <em>there is no algorithm</em> to compute <span><span class="math inline">\(F\)</span></span>?</p></li>
<li><p>If there is an algorithm, what is the best one? Could it be that <span><span class="math inline">\(F\)</span></span> is “effectively uncomputable” in the sense that every algorithm for computing <span><span class="math inline">\(F\)</span></span> requires a prohibitively large amount of resources?</p></li>
<li><p>If we cannot answer this question, can we show equivalence between different functions <span><span class="math inline">\(F\)</span></span> and <span><span class="math inline">\(F&#39;\)</span></span> in the sense that either they are both easy (i.e., have fast algorithms) or they are both hard?</p></li>
<li><p>Can a function being hard to compute ever be a <em>good thing</em>? Can we use it for applications in areas such as cryptography?</p></li>
</ul>
<p>In order to do that, we will need to mathematically define the notion of an <em>algorithm</em>, which is what we will do in <a href='lec_03_computation.html#compchap'>Chapter 3</a>.</p>
<h3 id="secimplvsspec" data-number="2.5.1">Distinguish functions from programs!</h3>
<p>You should always watch out for potential confusions between <strong>specifications</strong> and <strong>implementations</strong> or equivalently between <strong>mathematical functions</strong> and <strong>algorithms/programs</strong>. It does not help that programming languages (Python included) use the term <em>“functions”</em> to denote (parts of) <em>programs</em>. This confusion also stems from thousands of years of mathematical history, where people typically defined functions by means of a way to compute them.</p>
<p>For example, consider the multiplication function on natural numbers. This is the function <span><span class="math inline">\(\ensuremath{\mathit{MULT}}:\N\times \N \rightarrow \N\)</span></span> that maps a pair <span><span class="math inline">\((x,y)\)</span></span> of natural numbers to the number <span><span class="math inline">\(x \cdot y\)</span></span>. As we mentioned, it can be implemented in more than one way:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">def</span> mult1(x,y):</a>
<a class="sourceLine" id="cb6-2" title="2">    res <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="cf">while</span> y<span class="op">&gt;</span><span class="dv">0</span>:</a>
<a class="sourceLine" id="cb6-4" title="4">        res <span class="op">+=</span> x</a>
<a class="sourceLine" id="cb6-5" title="5">        y   <span class="op">-=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">def</span> mult2(x,y):</a>
<a class="sourceLine" id="cb6-9" title="9">    a <span class="op">=</span> <span class="bu">str</span>(x) <span class="co"># represent x as string in decimal notation</span></a>
<a class="sourceLine" id="cb6-10" title="10">    b <span class="op">=</span> <span class="bu">str</span>(y) <span class="co"># represent y as string in decimal notation</span></a>
<a class="sourceLine" id="cb6-11" title="11">    res <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a)):</a>
<a class="sourceLine" id="cb6-13" title="13">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(b)):</a>
<a class="sourceLine" id="cb6-14" title="14">            res <span class="op">+=</span> <span class="bu">int</span>(a[<span class="bu">len</span>(a)<span class="op">-</span>i])<span class="op">*</span><span class="bu">int</span>(b[<span class="bu">len</span>(b)<span class="op">-</span>j])<span class="op">*</span>(<span class="dv">10</span><span class="op">**</span>(i<span class="op">+</span>j))</a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb6-16" title="16"></a>
<a class="sourceLine" id="cb6-17" title="17"><span class="bu">print</span>(mult1(<span class="dv">12</span>,<span class="dv">7</span>))</a>
<a class="sourceLine" id="cb6-18" title="18"><span class="co"># 84</span></a>
<a class="sourceLine" id="cb6-19" title="19"><span class="bu">print</span>(mult2(<span class="dv">12</span>,<span class="dv">7</span>))</a>
<a class="sourceLine" id="cb6-20" title="20"><span class="co"># 84</span></a></code></pre></div>
<p>Both <code>mult1</code> and <code>mult2</code> produce the same output given the same pair of natural number inputs. (Though <code>mult1</code> will take far longer to do so when the numbers become large.) Hence, even though these are two different <em>programs</em>, they compute the same <em>mathematical function</em>. This distinction between a <em>program</em> or <em>algorithm</em> <span><span class="math inline">\(A\)</span></span>, and the <em>function</em> <span><span class="math inline">\(F\)</span></span> that <span><span class="math inline">\(A\)</span></span> <em>computes</em> will be absolutely crucial for us in this course (see also <a href='#functionornotfig'>Figure 2.13</a>).</p>
<figure>
<img src="../figure/functionornot.png" alt="2.13: A function is a mapping of inputs to outputs. A program is a set of instructions on how to obtain an output given an input. A program computes a function, but it is not the same as a function, popular programming language terminology notwithstanding." id="functionornotfig" class="margin" /><figcaption>2.13: A <em>function</em> is a mapping of inputs to outputs. A <em>program</em> is a set of instructions on how to obtain an output given an input. A program <em>computes</em> a function, but it is not the same as a function, popular programming language terminology notwithstanding.</figcaption>
</figure>
<div id="functionprogramidea" class="bigidea" name="Bigidea 2">
<p>A <em>function</em> is not the same as a <em>program</em>. A program <em>computes</em> a function.</p>
</div>
<p>Distinguishing <em>functions</em> from <em>programs</em> (or other ways for computing, including <em>circuits</em> and <em>machines</em>) is a crucial theme for this course. For this reason, this is often a running theme in questions that I (and many other instructors) assign in homework and exams (hint, hint).</p>
<div id="beyonfdunc" class="remark" title="Computation beyond functions (advanced, optional)" name="Remark 2.22 (Computation beyond functions (advanced, optional)) ">
<p>Functions capture quite a lot of computational tasks, but one can consider more general settings as well. For starters, we can and will talk about <em>partial</em> functions, that are not defined on all inputs. When computing a partial function, we only need to worry about the inputs on which the function is defined. Another way to say it is that we can design an algorithm for a partial function <span><span class="math inline">\(F\)</span></span> under the assumption that someone “promised” us that all inputs <span><span class="math inline">\(x\)</span></span> would be such that <span><span class="math inline">\(F(x)\)</span></span> is defined (as otherwise, we do not care about the result). Hence such tasks are also known as <em>promise problems</em>.</p>
<p>Another generalization is to consider <em>relations</em> that may have more than one possible admissible output. For example, consider the task of finding any solution for a given set of equations. A <em>relation</em> <span><span class="math inline">\(R\)</span></span> maps a string <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> into a <em>set of strings</em> <span><span class="math inline">\(R(x)\)</span></span> (for example, <span><span class="math inline">\(x\)</span></span> might describe a set of equations, in which case <span><span class="math inline">\(R(x)\)</span></span> would correspond to the set of all solutions to <span><span class="math inline">\(x\)</span></span>). We can also identify a relation <span><span class="math inline">\(R\)</span></span> with the set of pairs of strings <span><span class="math inline">\((x,y)\)</span></span> where <span><span class="math inline">\(y\in R(x)\)</span></span>. A computational process solves a relation if for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, it outputs some string <span><span class="math inline">\(y\in R(x)\)</span></span>.</p>
<p>Later in this book, we will consider even more general tasks, including <em>interactive</em> tasks, such as finding a good strategy in a game, tasks defined using probabilistic notions, and others. However, for much of this book, we will focus on the task of computing a function, and often even a <em>Boolean</em> function, that has only a single bit of output. It turns out that a great deal of the theory of computation can be studied in the context of this task, and the insights learned are applicable in the more general settings.</p>
</div>
<div id="section-7" class="recap" name="Recap">
<ul>
<li>We can represent objects we want to compute on using binary strings.</li>
<li>A representation scheme for a set of objects <span><span class="math inline">\(\mathcal{O}\)</span></span> is a one-to-one map from <span><span class="math inline">\(\mathcal{O}\)</span></span> to <span><span class="math inline">\(\{0,1\}^*\)</span></span>.</li>
<li>We can use prefix-free encoding to “boost” a representation for a set <span><span class="math inline">\(\mathcal{O}\)</span></span> into representations of lists of elements in <span><span class="math inline">\(\mathcal{O}\)</span></span>.</li>
<li>A basic computational task is the task of <em>computing a function</em> <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span>. This task encompasses not just arithmetical computations such as multiplication, factoring, etc. but a great many other tasks arising in areas as diverse as scientific computing, artificial intelligence, image processing, data mining and many many more.</li>
<li>We will study the question of finding (or at least giving bounds on) what the <em>best</em> algorithm for computing <span><span class="math inline">\(F\)</span></span> for various interesting functions <span><span class="math inline">\(F\)</span></span> is.</li>
</ul>
</div>
<h2 id="exercises" data-number="2.6">Exercises</h2>
<div class="exercise" name="Exercise 2.1">
<p>Which one of these objects can be represented by a binary string?</p>
<ol type="a">
<li><p>An integer <span><span class="math inline">\(x\)</span></span></p></li>
<li><p>An undirected graph <span><span class="math inline">\(G\)</span></span>.</p></li>
<li><p>A directed graph <span><span class="math inline">\(H\)</span></span></p></li>
<li><p>All of the above.</p></li>
</ol>
</div>
<div id="binaryrepex" class="exercise" title="Binary representation" name="Exercise 2.2 (Binary representation) ">
<ol type="a">
<li><p>Prove that the function <span><span class="math inline">\(NtS:\N \rightarrow \{0,1\}^*\)</span></span> of the binary representation defined in <a href='#ntseq'>Equation 2.1</a> satisfies that for every <span><span class="math inline">\(n\in \N\)</span></span>, if <span><span class="math inline">\(x = NtS(n)\)</span></span> then <span><span class="math inline">\(|x| =1+\max(0,\floor{\log_2 n})\)</span></span> and <span><span class="math inline">\(x_i = \floor{x/2^{\floor{\log_2 n}-i}} \mod 2\)</span></span>.</p></li>
<li><p>Prove that <span><span class="math inline">\(NtS\)</span></span> is a one to one function by coming up with a function <span><span class="math inline">\(StN:\{0,1\}^* \rightarrow \N\)</span></span> such that <span><span class="math inline">\(StN(NtS(n))=n\)</span></span> for every <span><span class="math inline">\(n\in \N\)</span></span>.</p></li>
</ol>
</div>
<div id="compactrepletters" class="exercise" title="More compact than ASCII representation" name="Exercise 2.3 (More compact than ASCII representation) ">
<p>The ASCII encoding can be used to encode a string of <span><span class="math inline">\(n\)</span></span> English letters as a <span><span class="math inline">\(7n\)</span></span> bit binary string, but in this exercise, we ask about finding a more compact representation for strings of English lowercase letters.</p>
<ol type="1">
<li><p>Prove that there exists a representation scheme <span><span class="math inline">\((E,D)\)</span></span> for strings over the 26-letter alphabet <span><span class="math inline">\(\{ a, b,c,\ldots,z \}\)</span></span> as binary strings such that for every <span><span class="math inline">\(n&gt;0\)</span></span> and length-<span><span class="math inline">\(n\)</span></span> string <span><span class="math inline">\(x \in \{ a,b,\ldots,z \}^n\)</span></span>, the representation <span><span class="math inline">\(E(x)\)</span></span> is a binary string of length at most <span><span class="math inline">\(4.8n+1000\)</span></span>. In other words, prove that for every <span><span class="math inline">\(n\)</span></span>, there exists a one-to-one function <span><span class="math inline">\(E:\{a,b,\ldots, z\}^n \rightarrow \{0,1\}^{\lfloor 4.8n +1000 \rfloor}\)</span></span>.</p></li>
<li><p>Prove that there exists <em>no</em> representation scheme for strings over the alphabet <span><span class="math inline">\(\{ a, b,\ldots,z \}\)</span></span> as binary strings such that for every length-<span><span class="math inline">\(n\)</span></span> string <span><span class="math inline">\(x \in \{ a,b,\ldots, z\}^n\)</span></span>, the representation <span><span class="math inline">\(E(x)\)</span></span> is a binary string of length <span><span class="math inline">\(\lfloor 4.6n+1000 \rfloor\)</span></span>. In other words, prove that there exists some <span><span class="math inline">\(n&gt;0\)</span></span> such that there is no one-to-one function <span><span class="math inline">\(E:\{a,b,\ldots,z \}^n \rightarrow \{0,1\}^{\lfloor 4.6n + 1000 \rfloor}\)</span></span></p></li>
<li><p>Python’s <code>bz2.compress</code> function is a mapping from strings to strings, which uses the <em>lossless</em> (and hence <em>one to one</em>) <a href="https://en.wikipedia.org/wiki/Bzip2">bzip2</a> algorithm for compression. After converting to lowercase, and truncating spaces and numbers, the text of Tolstoy’s “War and Peace” contains <span><span class="math inline">\(n=2,517,262\)</span></span>. Yet, if we run <code>bz2.compress</code> on the string of the text of “War and Peace” we get a string of length <span><span class="math inline">\(k=6,274,768\)</span></span> bits, which is only <span><span class="math inline">\(2.49n\)</span></span> (and in particular much smaller than <span><span class="math inline">\(4.6n\)</span></span>). Explain why this does not contradict your answer to the previous question.</p></li>
<li><p>Interestingly, if we try to apply <code>bz2.compress</code> on a <em>random</em> string, we get much worse performance. In my experiments, I got a ratio of about <span><span class="math inline">\(4.78\)</span></span> between the number of bits in the output and the number of characters in the input. However, one could imagine that one could do better and that there exists a company called “Pied Piper” with an algorithm that can losslessly compress a string of <span><span class="math inline">\(n\)</span></span> random lowercase letters to fewer than <span><span class="math inline">\(4.6n\)</span></span> bits.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> Show that this is not the case by proving that for <em>every</em> <span><span class="math inline">\(n&gt;100\)</span></span> and one to one function <span><span class="math inline">\(Encode:\{a,\ldots,z\}^{n} \rightarrow \{0,1\}^*\)</span></span>, if we let <span><span class="math inline">\(Z\)</span></span> be the random variable <span><span class="math inline">\(|Encode(x)|\)</span></span> (i.e., the length of <span><span class="math inline">\(Encode(x)\)</span></span>) for <span><span class="math inline">\(x\)</span></span> chosen uniformly at random from the set <span><span class="math inline">\(\{a,\ldots,z\}^n\)</span></span>, then the expected value of <span><span class="math inline">\(Z\)</span></span> is at least <span><span class="math inline">\(4.6n\)</span></span>.</p></li>
</ol>
</div>
<div id="representinggraphsex" class="exercise" title="Representing graphs: upper bound" name="Exercise 2.4 (Representing graphs: upper bound) ">
<p>Show that there is a string representation of directed graphs with vertex set <span><span class="math inline">\([n]\)</span></span> and degree at most <span><span class="math inline">\(10\)</span></span> that uses at most <span><span class="math inline">\(1000 n\log n\)</span></span> bits. More formally, show the following: Suppose we define for every <span><span class="math inline">\(n\in\mathbb{N}\)</span></span>, the set <span><span class="math inline">\(G_n\)</span></span> as the set containing all directed graphs (with no self loops) over the vertex set <span><span class="math inline">\([n]\)</span></span> where every vertex has degree at most <span><span class="math inline">\(10\)</span></span>. Then, prove that for every sufficiently large <span><span class="math inline">\(n\)</span></span>, there exists a one-to-one function <span><span class="math inline">\(E:G_n \rightarrow \{0,1\}^{\lfloor 1000 n \log n \rfloor}\)</span></span>.</p>
</div>
<div id="represgraphlbex" class="exercise" title="Representing graphs: lower bound" name="Exercise 2.5 (Representing graphs: lower bound) ">
<ol type="1">
<li><p>Define <span><span class="math inline">\(S_n\)</span></span> to be the set of one-to-one and onto functions mapping <span><span class="math inline">\([n]\)</span></span> to <span><span class="math inline">\([n]\)</span></span>. Prove that there is a one-to-one mapping from <span><span class="math inline">\(S_n\)</span></span> to <span><span class="math inline">\(G_{2n}\)</span></span>, where <span><span class="math inline">\(G_{2n}\)</span></span> is the set defined in <a href='#representinggraphsex'>Exercise 2.4</a> above.</p></li>
<li><p>In this question you will show that one cannot improve the representation of <a href='#representinggraphsex'>Exercise 2.4</a> to length <span><span class="math inline">\(o(n \log n)\)</span></span>. Specifically, prove for every sufficiently large <span><span class="math inline">\(n\in \mathbb{N}\)</span></span> there is <em>no</em> one-to-one function <span><span class="math inline">\(E:G_n \rightarrow \{0,1\}^{\lfloor 0.001 n \log n \rfloor +1000}\)</span></span>.</p></li>
</ol>
</div>
<div id="multrepres" class="exercise" title="Multiplying in different representation" name="Exercise 2.6 (Multiplying in different representation) ">
<p>Recall that the grade-school algorithm for multiplying two numbers requires <span><span class="math inline">\(O(n^2)\)</span></span> operations. Suppose that instead of using decimal representation, we use one of the following representations <span><span class="math inline">\(R(x)\)</span></span> to represent a number <span><span class="math inline">\(x\)</span></span> between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(10^n-1\)</span></span>. For which one of these representations you can still multiply the numbers in <span><span class="math inline">\(O(n^2)\)</span></span> operations?</p>
<ol type="a">
<li><p>The standard binary representation: <span><span class="math inline">\(B(x)=(x_0,\ldots,x_{k})\)</span></span> where <span><span class="math inline">\(x = \sum_{i=0}^{k} x_i 2^i\)</span></span> and <span><span class="math inline">\(k\)</span></span> is the largest number s.t. <span><span class="math inline">\(x \geq 2^k\)</span></span>.</p></li>
<li><p>The reverse binary representation: <span><span class="math inline">\(B(x) = (x_{k},\ldots,x_0)\)</span></span> where <span><span class="math inline">\(x_i\)</span></span> is defined as above for <span><span class="math inline">\(i=0,\ldots,k-1\)</span></span>.<br />
</p></li>
<li><p>Binary coded decimal representation: <span><span class="math inline">\(B(x)=(y_0,\ldots,y_{n-1})\)</span></span> where <span><span class="math inline">\(y_i \in \{0,1\}^4\)</span></span> represents the <span><span class="math inline">\(i^{th}\)</span></span> decimal digit of <span><span class="math inline">\(x\)</span></span> mapping <span><span class="math inline">\(0\)</span></span> to <span><span class="math inline">\(0000\)</span></span>, <span><span class="math inline">\(1\)</span></span> to <span><span class="math inline">\(0001\)</span></span>, <span><span class="math inline">\(2\)</span></span> to <span><span class="math inline">\(0010\)</span></span>, etc. (i.e. <span><span class="math inline">\(9\)</span></span> maps to <span><span class="math inline">\(1001\)</span></span>)</p></li>
<li><p>All of the above.</p></li>
</ol>
</div>
<div id="section-8" class="exercise" name="Exercise">
<p>Suppose that <span><span class="math inline">\(R:\N \rightarrow \{0,1\}^*\)</span></span> corresponds to representing a number <span><span class="math inline">\(x\)</span></span> as a string of <span><span class="math inline">\(x\)</span></span> <span><span class="math inline">\(1\)</span></span>’s, (e.g., <span><span class="math inline">\(R(4)=1111\)</span></span>, <span><span class="math inline">\(R(7)=1111111\)</span></span>, etc.). If <span><span class="math inline">\(x,y\)</span></span> are numbers between <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(10^n -1\)</span></span>, can we still multiply <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span> using <span><span class="math inline">\(O(n^2)\)</span></span> operations if we are given them in the representation <span><span class="math inline">\(R(\cdot)\)</span></span>?</p>
</div>
<div class="exercise" name="Exercise 2.8">
<p>Recall that if <span><span class="math inline">\(F\)</span></span> is a one-to-one and onto function mapping elements of a finite set <span><span class="math inline">\(U\)</span></span> into a finite set <span><span class="math inline">\(V\)</span></span> then the sizes of <span><span class="math inline">\(U\)</span></span> and <span><span class="math inline">\(V\)</span></span> are the same. Let <span><span class="math inline">\(B:\N\rightarrow\{0,1\}^*\)</span></span> be the function such that for every <span><span class="math inline">\(x\in\N\)</span></span>, <span><span class="math inline">\(B(x)\)</span></span> is the binary representation of <span><span class="math inline">\(x\)</span></span>.</p>
<ol type="1">
<li><p>Prove that <span><span class="math inline">\(x &lt; 2^k\)</span></span> if and only if <span><span class="math inline">\(|B(x)| \leq k\)</span></span>.</p></li>
<li><p>Use 1. to compute the size of the set <span><span class="math inline">\(\{ y \in \{0,1\}^* : |y| \leq k \}\)</span></span> where <span><span class="math inline">\(|y|\)</span></span> denotes the length of the string <span><span class="math inline">\(y\)</span></span>.</p></li>
<li><p>Use 1. and 2. to prove that <span><span class="math inline">\(2^k-1 = 1 + 2 + 4+ \cdots + 2^{k-1}\)</span></span>.</p></li>
</ol>
</div>
<div id="prefix-free-tuples-ex" class="exercise" title="Prefix-free encoding of tuples" name="Exercise 2.9 (Prefix-free encoding of tuples) ">
<p>Suppose that <span><span class="math inline">\(F:\N\rightarrow\{0,1\}^*\)</span></span> is a one-to-one function that is <em>prefix-free</em> in the sense that there is no <span><span class="math inline">\(a\neq b\)</span></span> s.t. <span><span class="math inline">\(F(a)\)</span></span> is a prefix of <span><span class="math inline">\(F(b)\)</span></span>.</p>
<ol type="a">
<li><p>Prove that <span><span class="math inline">\(F_2:\N\times \N \rightarrow \{0,1\}^*\)</span></span>, defined as <span><span class="math inline">\(F_2(a,b) = F(a)F(b)\)</span></span> (i.e., the concatenation of <span><span class="math inline">\(F(a)\)</span></span> and <span><span class="math inline">\(F(b)\)</span></span>) is a one-to-one function.</p></li>
<li><p>Prove that <span><span class="math inline">\(F_*:\N^*\rightarrow\{0,1\}^*\)</span></span> defined as <span><span class="math inline">\(F_*(a_1,\ldots,a_k) = F(a_1)\cdots F(a_k)\)</span></span> is a one-to-one function, where <span><span class="math inline">\(\N^*\)</span></span> denotes the set of all finite-length lists of natural numbers.</p></li>
</ol>
</div>
<div id="prefix-free-ex" class="exercise" title="More efficient prefix-free transformation" name="Exercise 2.10 (More efficient prefix-free transformation) ">
<p>Suppose that <span><span class="math inline">\(F:O\rightarrow\{0,1\}^*\)</span></span> is some (not necessarily prefix-free) representation of the objects in the set <span><span class="math inline">\(O\)</span></span>, and <span><span class="math inline">\(G:\N\rightarrow\{0,1\}^*\)</span></span> is a prefix-free representation of the natural numbers. Define <span><span class="math inline">\(F&#39;(o)=G(|F(o)|)F(o)\)</span></span> (i.e., the concatenation of the representation of the length <span><span class="math inline">\(F(o)\)</span></span> and <span><span class="math inline">\(F(o)\)</span></span>).</p>
<ol type="a">
<li><p>Prove that <span><span class="math inline">\(F&#39;\)</span></span> is a prefix-free representation of <span><span class="math inline">\(O\)</span></span>.</p></li>
<li><p>Show that we can transform any representation to a prefix-free one by a modification that takes a <span><span class="math inline">\(k\)</span></span> bit string into a string of length at most <span><span class="math inline">\(k+O(\log k)\)</span></span>.</p></li>
<li><p>Show that we can transform any representation to a prefix-free one by a modification that takes a <span><span class="math inline">\(k\)</span></span> bit string into a string of length at most <span><span class="math inline">\(k+ \log k + O(\log\log k)\)</span></span>.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p></li>
</ol>
</div>
<div id="prefix-free-lb" class="exercise" title="Kraft&#39;s Inequality" name="Exercise 2.11 (Kraft&#39;s Inequality) ">
<p>Suppose that <span><span class="math inline">\(S \subseteq \{0,1\}^n\)</span></span> is some finite prefix-free set.</p>
<ol type="a">
<li><p>For every <span><span class="math inline">\(k \leq n\)</span></span> and length-<span><span class="math inline">\(k\)</span></span> string <span><span class="math inline">\(x\in S\)</span></span>, let <span><span class="math inline">\(L(x) \subseteq \{0,1\}^n\)</span></span> denote all the length-<span><span class="math inline">\(n\)</span></span> strings whose first <span><span class="math inline">\(k\)</span></span> bits are <span><span class="math inline">\(x_0,\ldots,x_{k-1}\)</span></span>. Prove that <strong>(1)</strong> <span><span class="math inline">\(|L(x)|=2^{n-|x|}\)</span></span> and <strong>(2)</strong> If <span><span class="math inline">\(x \neq x&#39;\)</span></span> then <span><span class="math inline">\(L(x)\)</span></span> is disjoint from <span><span class="math inline">\(L(x&#39;)\)</span></span>.</p></li>
<li><p>Prove that <span><span class="math inline">\(\sum_{x\in S}2^{-|x|} \leq 1\)</span></span>.</p></li>
<li><p>Prove that there is no prefix-free encoding of strings with less than logarithmic overhead. That is, prove that there is no function <span><span class="math inline">\(\ensuremath{\mathit{PF}}:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> s.t. <span><span class="math inline">\(|\ensuremath{\mathit{PF}}(x)| \leq |x|+0.9\log |x|\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> and such that the set <span><span class="math inline">\(\{ \ensuremath{\mathit{PF}}(x) : x\in \{0,1\}^* \}\)</span></span> is prefix-free. The factor <span><span class="math inline">\(0.9\)</span></span> is arbitrary; all that matters is that it is less than <span><span class="math inline">\(1\)</span></span>.</p></li>
</ol>
</div>
<div id="onetoonecompex" class="exercise" title="Composition of one-to-one functions" name="Exercise 2.12 (Composition of one-to-one functions) ">
<p>Prove that for every two one-to-one functions <span><span class="math inline">\(F:S \rightarrow T\)</span></span> and <span><span class="math inline">\(G:T \rightarrow U\)</span></span>, the function <span><span class="math inline">\(H:S \rightarrow U\)</span></span> defined as <span><span class="math inline">\(H(x)=G(F(x))\)</span></span> is one to one.</p>
</div>
<div id="naturalsstringsmapex" class="exercise" title="Natural numbers and strings" name="Exercise 2.13 (Natural numbers and strings) ">
<ol type="1">
<li><p>We have shown that the natural numbers can be represented as strings. Prove that the other direction holds as well: that there is a one-to-one map <span><span class="math inline">\(StN:\{0,1\}^* \rightarrow \N\)</span></span>. (<span><span class="math inline">\(StN\)</span></span> stands for “strings to numbers.”)</p></li>
<li><p>Recall that Cantor proved that there is no one-to-one map <span><span class="math inline">\(RtN:\R \rightarrow \N\)</span></span>. Show that Cantor’s result implies <a href='#cantorthm'>Theorem 2.5</a>.</p></li>
</ol>
</div>
<div id="listsinttonumex" class="exercise" title="Map lists of integers to a number" name="Exercise 2.14 (Map lists of integers to a number) ">
<p>Recall that for every set <span><span class="math inline">\(S\)</span></span>, the set <span><span class="math inline">\(S^*\)</span></span> is defined as the set of all finite sequences of members of <span><span class="math inline">\(S\)</span></span> (i.e., <span><span class="math inline">\(S^* = \{ (x_0,\ldots,x_{n-1}) \;|\; n\in\mathbb{N} \;,\; \forall_{i\in [n]} x_i \in S \}\)</span></span> ). Prove that there is a one-one-map from <span><span class="math inline">\(\mathbb{Z}^*\)</span></span> to <span><span class="math inline">\(\mathbb{N}\)</span></span> where <span><span class="math inline">\(\mathbb{Z}\)</span></span> is the set of <span><span class="math inline">\(\{ \ldots, -3 , -2 , -1,0,+1,+2,+3,\ldots \}\)</span></span> of all integers.</p>
</div>
<h2 id="bibnotesrepres" data-number="2.7">Bibliographical notes</h2>
<p>The study of representing data as strings, including issues such as <em>compression</em> and <em>error corrections</em> falls under the purview of <em>information theory</em>, as covered in the classic textbook of Cover and Thomas  (<a href="https://scholar.google.com/scholar?hl=en&q=Cover,+Thomas+Elements+of+information+theory+2nd+edition" target="_blank">Cover, Thomas, 2006</a>) . Representations are also studied in the field of <em>data structures design</em>, as covered in texts such as  (<a href="https://scholar.google.com/scholar?hl=en&q=Cormen,+Leiserson,+Rivest,+Stein+Introduction+to+algorithms" target="_blank">Cormen, Leiserson, Rivest, Stein, 2009</a>) .</p>
<p>The question of whether to represent integers with the most significant digit first or last is known as <a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">Big Endian vs. Little Endian</a> representation. This terminology comes from Cohen’s  (<a href="https://scholar.google.com/scholar?hl=en&q=Cohen+On+holy+wars+and+a+plea+for+peace" target="_blank">Cohen, 1981</a>)  entertaining and informative paper about the conflict between adherents of both schools which he compared to the warring tribes in Jonathan Swift’s <em>“Gulliver’s Travels”</em>. The two’s complement representation of signed integers was suggested in von Neumann’s classic report  (<a href="https://scholar.google.com/scholar?hl=en&q=von+Neumann+First+Draft+of+a+Report+on+the+EDVAC" target="_blank">von Neumann, 1945</a>)  that detailed the design approaches for a stored-program computer, though similar representations have been used even earlier in abacus and other mechanical computation devices.</p>
<p>The idea that we should separate the <em>definition</em> or <em>specification</em> of a function from its <em>implementation</em> or <em>computation</em> might seem “obvious,” but it took quite a lot of time for mathematicians to arrive at this viewpoint. Historically, a function <span><span class="math inline">\(F\)</span></span> was identified by rules or formulas showing how to derive the output from the input. As we discuss in greater depth in <a href='lec_08_uncomputability.html#chapcomputable'>Chapter 8</a>, in the 1800s this somewhat informal notion of a function started “breaking at the seams,” and eventually mathematicians arrived at the more rigorous definition of a function as an arbitrary assignment of input to outputs. While many functions may be described (or computed) by one or more formulas, today we do not consider that to be an essential property of functions, and also allow functions that do not correspond to any “nice” formula.</p>
<p>We have mentioned that all representations of the real numbers are inherently <em>approximate</em>. Thus an important endeavor is to understand what guarantees we can offer on the approximation quality of the output of an algorithm, as a function of the approximation quality of the inputs. This question is known as the question of determining the <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> of given equations. The <a href="https://floating-point-gui.de/">Floating Points Guide website</a> contains an extensive description of the floating point representation, as well the many ways in which it could subtly fail, see also the website <a href="http://0.30000000000000004.com/">0.30000000000000004.com</a>.</p>
<p>Dauben  (<a href="https://scholar.google.com/scholar?hl=en&q=Dauben+Georg+Cantor:+His+mathematics+and+philosophy+of+the+infinite" target="_blank">Dauben, 1990</a>)  gives a biography of Cantor with emphasis on the development of his mathematical ideas.  (<a href="https://scholar.google.com/scholar?hl=en&q=Halmos+Naive+set+theory" target="_blank">Halmos, 1960</a>)  is a classic textbook on set theory, including also Cantor’s theorem. Cantor’s Theorem is also covered in many texts on discrete mathematics, including  (<a href="https://scholar.google.com/scholar?hl=en&q=Lehman,+Leighton,+Meyer+Mathematics+for+Computer+Science" target="_blank">Lehman, Leighton, Meyer, 2018</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=Lewis,+Zax+Essential+Discrete+Mathematics+for+Computer+Science" target="_blank">Lewis, Zax, 2019</a>) .</p>
<p>The adjacency matrix representation of graphs is not merely a convenient way to map a graph into a binary string, but it turns out that many natural notions and operations on matrices are useful for graphs as well. (For example, Google’s PageRank algorithm relies on this viewpoint.) The notes of <a href="http://www.cs.yale.edu/homes/spielman/561/">Spielman’s course</a> are an excellent source for this area, known as <em>spectral graph theory</em>. We will return to this view much later in this book when we talk about <em>random walks</em>.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>While the Babylonians already invented a positional system much earlier, the decimal positional system we use today was invented by Indian mathematicians around the third century. Arab mathematicians took it up in the 8th century. It first received significant attention in Europe with the publication of the 1202 book <em>“Liber Abaci”</em> by Leonardo of Pisa, also known as Fibonacci, but it did not displace Roman numerals in common usage until the 15th century.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p><span><span class="math inline">\(RtS\)</span></span> stands for “real numbers to strings”.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p><span><span class="math inline">\(FtS\)</span></span> stands for “functions to strings”.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p><span><span class="math inline">\(FtR\)</span></span> stands for “functions to reals.”</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>Actually that particular fictional company uses a metric that focuses more on compression <em>speed</em> then <em>ratio</em>, see <a href="https://blogs.dropbox.com/tech/2016/06/lossless-compression-with-brotli/">here</a> and <a href="https://www.jefftk.com/p/weissman-scores-useful">here</a>.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>Hint: Think recursively how to represent the length of the string.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:39:54</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_02_representation.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
