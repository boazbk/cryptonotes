<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Pseudorandomness</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Pseudorandomness" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->



<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#countoperation"><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational-security.html"><a href="lec_02_computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash functions and random oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "bitcoin" problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The currency problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The bitcoin ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From proof of work to consensus on ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision resistance hash functions and creating short "unique" identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical constructions of cryptographic hash functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical random-ish functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some history</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions."><i class="fa fa-check"></i><b>7.4.3</b> The NSA and hash functions.</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs non-cryptographic hash functions:</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_09_priv_recap.html"><a href="lec_09_priv_recap.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li><li class="chapter" data-level="10.6" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a><ul><li class="chapter" data-level="10.6.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li></ul></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li><ul><li class="chapter" data-level="12.0.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li></ul></li><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#an-lwe-based-encryption-scheme"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Pseudorandomness</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_03_pseudorandom-generators.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="pseudorandomness" data-number="3">Pseudorandomness</h1>
<p><strong>Reading:</strong> Katz-Lindell Section 3.3, Boneh-Shoup Chapter 3</p>
<p>The nature of randomness has troubled philosophers, scientists, statisticians and laypeople for many years.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> Over the years people have given different answers to the question of what does it mean for data to be random, and what is the nature of probability. The movements of the planets initially looked random and arbitrary, but then the early astronomers managed to find <em>order</em> and make some <em>predictions</em> on them. Similarly we have made great advances in predicting the weather, and probably will continue to do so. So, while these days it seems as if the event of whether or not it will rain a week from today is <em>random</em>, we could imagine that in with time we will be able to predict the weather further into the future. Even the canonical notion of a random experiment -tossing a coin - turns out that it <a href="http://statweb.stanford.edu/~susan/papers/headswithJ.pdf">might not be as random as you’d think</a>, with about a 51% chance that the second toss will have the same result as the first one. (Though <a href="https://www.stat.berkeley.edu/~aldous/Real-World/coin_tosses.html">see also this experiment</a>.) It is conceivable that at some point someone would discover some function <span><span class="math inline">\(F\)</span></span> that given the first 100 coin tosses by any given person can predict the value of the 101<span><span class="math inline">\(^{th}\)</span></span>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> In all these examples, the physics underlying the event, whether it’s the planets’ movement, the weather, or coin tosses, did not change but only our powers to predict them. So to a large extent, <em>randomness is a function of the observer</em>, or in other words</p>
<blockquote>
<p><em>If a quantity is hard to compute, it might as well be random.</em></p>
</blockquote>
<p>Much of cryptography is about trying to make this intuition more formal, and harnessing it to build secure systems. The basic object we want is the following:</p>
<div id="prgdefconcrete" class="definition" title="Pseudorandom generator (concrete)" name="Definition 3.1 (Pseudorandom generator (concrete)) ">
<p>A function <span><span class="math inline">\(G:{\{0,1\}}^n\rightarrow{\{0,1\}}^\ell\)</span></span> is a <span><span class="math inline">\((T,\epsilon)\)</span></span> <em>pseudorandom generator</em> if <span><span class="math inline">\(G(U_n) \approx_{T,\epsilon} U_\ell\)</span></span> where <span><span class="math inline">\(U_t\)</span></span> denotes the uniform distribution on <span><span class="math inline">\({\{0,1\}}^t\)</span></span>.</p>
</div>
<p>That is, <span><span class="math inline">\(G\)</span></span> is a <span><span class="math inline">\((T,\epsilon)\)</span></span> pseudorandom generators if no circuit of at most <span><span class="math inline">\(T\)</span></span> gates can distinguish with bias better than <span><span class="math inline">\(\epsilon\)</span></span> between the output of <span><span class="math inline">\(G\)</span></span> (on a random input) and a uniformly random string of the same length.</p>
<p>As we did for the case of encryption, we will typically use <em>asymptotic terms</em> to describe cryptographic pseudorandom generator. We say that <span><span class="math inline">\(G\)</span></span> is simply a pseudorandom generator if it is <span><span class="math inline">\((p(n),1/p(n))\)</span></span>-pseudorandom generator for every polynomial <span><span class="math inline">\(p(\cdot)\)</span></span>. In other words, we define pseudorandom generators as follows</p>
<div id="prgdef" class="definition" title="Pseudorandom generator" name="Definition 3.2 (Pseudorandom generator) ">
<p>Let <span><span class="math inline">\(G:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> be some function computable in polynomial time. We say that <span><span class="math inline">\(G\)</span></span> is a <em>pseudorandom generator</em> with length function <span><span class="math inline">\(\ell:\N \rightarrow \N\)</span></span> (where <span><span class="math inline">\(\ell(n)&gt;n\)</span></span>)if</p>
<ul>
<li><p>For every <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(|G(x)| = \ell(|x|)\)</span></span>.</p></li>
<li><p>For every polynomial <span><span class="math inline">\(p(\cdot)\)</span></span> and sufficiently large <span><span class="math inline">\(n\)</span></span>, the function <span><span class="math inline">\(G_n\)</span></span> (the restriction of <span><span class="math inline">\(G\)</span></span> to inputs of length <span><span class="math inline">\(n\)</span></span>) is a <span><span class="math inline">\((p(n),\tfrac{1}{p(n)})\)</span></span> pseudorandom generator.</p></li>
</ul>
</div>
<p>Equivalently, <span><span class="math inline">\(G\)</span></span> as above is a pseudorandom generator if the two distributions <span><span class="math inline">\(G(U_n)\)</span></span> and <span><span class="math inline">\(U_{\ell(n)}\)</span></span> are <em>computationally indistinguishable</em>.</p>
<div id="section" class="pause" data-number="3" name="Pause">
<p>This definition (as is often the case in cryptography) is a bit long, so you want to take your time parsing it. In particular you should verify that you understand why the condition <a href='#prgdefeq'>Equation 3.1</a> is the same as saying that for every polynomial <span><span class="math inline">\(p:\N \rightarrow \N\)</span></span>, if <span><span class="math inline">\(n\)</span></span> is sufficiently large, then for every circuit <span><span class="math inline">\(D\)</span></span> of at most <span><span class="math inline">\(T\)</span></span> gates (or equivalently, for every straightline program <span><span class="math inline">\(D\)</span></span> of at most <span><span class="math inline">\(T\)</span></span> lines): <span>
<div class='myequationbox'><span class="math display">\[\left| \Pr[D(G(U_n))=1] - \Pr[ D(U_\ell)=1] \right| &lt; \tfrac{1}{p(n)} \;\;(3.1)\]</span><a id='prgdefeq'></a></div></span></p>
</div>
<p>Note that the requirement that <span><span class="math inline">\(\ell&gt;n\)</span></span> is crucial to make this notion non-trivial, as for <span><span class="math inline">\(\ell=n\)</span></span> the function <span><span class="math inline">\(G(x)=x\)</span></span> clearly satisfies that <span><span class="math inline">\(G(U_n)\)</span></span> is identical to (and hence in particular indistinguishable from) the distribution <span><span class="math inline">\(U_n\)</span></span>. (Make sure that you understand this last statement!) However, for <span><span class="math inline">\(\ell&gt;n\)</span></span> this is no longer trivial at all, and in particular if we didn’t restrict the running time of <span><span class="math inline">\(Eve\)</span></span> then no such pseudo-random generator would exist:</p>
<div id="breakprglem" class="lemma" data-number="3" name="Lemma 3.3">
<p>Suppose that <span><span class="math inline">\(G:{\{0,1\}}^n\rightarrow{\{0,1\}}^{n+1}\)</span></span>. Then there exists an (inefficient) algorithm <span><span class="math inline">\(Eve:{\{0,1\}}^{n+1}\rightarrow{\{0,1\}}\)</span></span> such that <span><span class="math inline">\({\mathbb{E}}[ Eve(G(U_n)) ]=1\)</span></span> but <span><span class="math inline">\({\mathbb{E}}[ Eve(U_{n+1})] \leq 1/2\)</span></span>.</p>
</div>
<div id="section-1" class="proof" data-ref="breakprglem" data-number="3" name="Proof">
<p>On input <span><span class="math inline">\(y\in{\{0,1\}}^{n+1}\)</span></span>, consider the algorithm <span><span class="math inline">\(Eve\)</span></span> that goes over all possible <span><span class="math inline">\(x\in{\{0,1\}}^n\)</span></span> and will output <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(y=G(x)\)</span></span> for some <span><span class="math inline">\(x\)</span></span>. Clearly <span><span class="math inline">\({\mathbb{E}}[ Eve(G(U_n)) ] =1\)</span></span>. However, the set <span><span class="math inline">\(S =\{ G(x) : x\in {\{0,1\}}^n \}\)</span></span> on which Eve outputs <span><span class="math inline">\(1\)</span></span> has size at most <span><span class="math inline">\(2^n\)</span></span>, and hence a random <span><span class="math inline">\(y{\leftarrow_{\tiny R}} U_{n+1}\)</span></span> will fall in <span><span class="math inline">\(S\)</span></span> with probability at most <span><span class="math inline">\(1/2\)</span></span>.</p>
</div>
<p>It is not hard to show that if <span><span class="math inline">\(P=\ensuremath{\mathit{NP}}\)</span></span> then the above algorithm Eve can be made efficient. In particular, at the moment we do not know how to <em>prove</em> the existence of pseudorandom generators. Nevertheless they are widely believed to exist and hence we make the following conjecture:</p>
<blockquote>
<p><strong>Conjecture (The PRG conjecture):</strong> For every <span><span class="math inline">\(n\)</span></span>, there exists a pseudorandom generator <span><span class="math inline">\(G\)</span></span> mapping <span><span class="math inline">\(n\)</span></span> bits to <span><span class="math inline">\(n+1\)</span></span> bits.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
</blockquote>
<p>As was the case for the cipher conjecture, and any other conjecture, there are two natural questions regarding the PRG conjecture: why should we believe it and why should we care. Fortunately, the answer to the first question is simple: it is known that the cipher conjecture <em>implies</em> the PRG conjecture, and hence if we believe the former we should believe the latter. (The proof is highly non-trivial and we may not get to see it in this course.) As for the second question, we will see that the PRG conjecture implies a great number of useful cryptographic tools, including the cipher conjecture (i.e., the two conjectures are in fact equivalent). We start by showing that once we can get to an output that is one bit longer than the input, we can in fact obtain any number of bits.</p>
<div id="lengthextendprgthm" class="theorem" title="Length Extension for PRG&#39;s" data-number="3" name="Theorem 3.4 (Length Extension for PRG&#39;s) ">
<p>Suppose that the PRG conjecture is true. Then for every polynomial <span><span class="math inline">\(t(n)\)</span></span>, there exists a pseudorandom generator mapping <span><span class="math inline">\(n\)</span></span> bits to <span><span class="math inline">\(t(n)\)</span></span> bits.</p>
</div>
<figure>
<img src="../figure/length-extension-prg.jpg" alt="3.1: Length extension for pseudorandom generators" id="lengthextendprgfig" /><figcaption>3.1: Length extension for pseudorandom generators</figcaption>
</figure>
<div id="section-2" class="proof" data-ref="lengthextendprgthm" data-number="3" name="Proof">
<p>The proof of this theorem is very similar to the length extension theorem for ciphers, and in fact this theorem can be used to give an alternative proof for the former theorem.</p>
<p>The construction is illustrated in <a href='#lengthextendprgfig'>Figure 3.1</a>. We are given a pseudorandom generator <span><span class="math inline">\(G&#39;\)</span></span> mapping <span><span class="math inline">\(n\)</span></span> bits into <span><span class="math inline">\(n+1\)</span></span> bits and need to construct a pseudorandom generator <span><span class="math inline">\(G\)</span></span> mapping <span><span class="math inline">\(n\)</span></span> bits to <span><span class="math inline">\(t=t(n)\)</span></span> bits for some polynomial <span><span class="math inline">\(t(\cdot)\)</span></span>. The idea is that we maintain a state of <span><span class="math inline">\(n\)</span></span> bits, which are originally our input seed<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> <span><span class="math inline">\(s_0\)</span></span>, and at the <span><span class="math inline">\(i^{th}\)</span></span> step we use <span><span class="math inline">\(G&#39;\)</span></span> to map <span><span class="math inline">\(s_{i-1}\)</span></span> to the <span><span class="math inline">\(n+1\)</span></span>-long bit string <span><span class="math inline">\((s_i,y_i)\)</span></span>, output <span><span class="math inline">\(y_i\)</span></span> and keep <span><span class="math inline">\(s_i\)</span></span> as our new state. To prove the security of this construction we need to show that the distribution <span><span class="math inline">\(G(U_n) = (y_1,\ldots,y_t)\)</span></span> is computationally indistinguishable from the uniform distribution <span><span class="math inline">\(U_t\)</span></span>. As usual, we will use the hybrid argument. For <span><span class="math inline">\(i\in\{0,\ldots,t\}\)</span></span> we define <span><span class="math inline">\(H_i\)</span></span> to be the distribution where the first <span><span class="math inline">\(i\)</span></span> bits chosen at uniform, whereas the last <span><span class="math inline">\(t-i\)</span></span> bits are computed as above. Namely, we choose <span><span class="math inline">\(s_i\)</span></span> at random in <span><span class="math inline">\(\{0,1\}^n\)</span></span> and continue the computation of <span><span class="math inline">\(y_{i+1},\ldots,y_t\)</span></span> from the state <span><span class="math inline">\(s_i\)</span></span>. Clearly <span><span class="math inline">\(H_0=G(U_n)\)</span></span> and <span><span class="math inline">\(H_t=U_t\)</span></span> and hence by the triangle inequality it suffices to prove that <span><span class="math inline">\(H_i \approx H_{i+1}\)</span></span> for all <span><span class="math inline">\(i\in\{0,\ldots,t-1\}\)</span></span>. We illustrate these two hybrids in <a href='#lengthextendhybridfig'>Figure 3.2</a>.</p>
<figure>
<img src="../figure/length-extension-prg-hybrid.jpg" alt="3.2: Hybrids H_i and H_{i+1}— dotted boxes refer to values that are chosen independently and uniformly at random" id="lengthextendhybridfig" /><figcaption>3.2: Hybrids <span><span class="math inline">\(H_i\)</span></span> and <span><span class="math inline">\(H_{i+1}\)</span></span>— dotted boxes refer to values that are chosen independently and uniformly at random</figcaption>
</figure>
<p>Now suppose otherwise, that there exists some adversary <span><span class="math inline">\(Eve\)</span></span> such that <span><span class="math inline">\(\left| \E[Eve(H_i)] - \E[Eve(H_{i+1})] \right| \geq \epsilon\)</span></span> for some non-negligible <span><span class="math inline">\(\epsilon\)</span></span>. We will build from <span><span class="math inline">\(Eve\)</span></span> an adversary <span><span class="math inline">\(Eve&#39;\)</span></span> breaking the security of the pseudorandom generator <span><span class="math inline">\(G&#39;\)</span></span> (see <a href='#reductionlengthextendfig'>Figure 3.3</a>).</p>
<figure>
<img src="../figure/length-extension-prg-adversary.jpg" alt="3.3: Building an adversary Eve&#39; for G&#39; from an adversary Eve distinguishing H_i and H_{i+1}. The boxes marked with questions marks are those that are random or pseudorandom depending on whether we are in H_i or H_{i+1}. Everything inside the dashed red lines is simulated by Eve&#39; that gets as input the n+1-bit string (s_{i+1},y_{i+1})." id="reductionlengthextendfig" /><figcaption>3.3: Building an adversary <span><span class="math inline">\(Eve&#39;\)</span></span> for <span><span class="math inline">\(G&#39;\)</span></span> from an adversary <span><span class="math inline">\(Eve\)</span></span> distinguishing <span><span class="math inline">\(H_i\)</span></span> and <span><span class="math inline">\(H_{i+1}\)</span></span>. The boxes marked with questions marks are those that are random or pseudorandom depending on whether we are in <span><span class="math inline">\(H_i\)</span></span> or <span><span class="math inline">\(H_{i+1}\)</span></span>. Everything inside the dashed red lines is simulated by <span><span class="math inline">\(Eve&#39;\)</span></span> that gets as input the <span><span class="math inline">\(n+1\)</span></span>-bit string <span><span class="math inline">\((s_{i+1},y_{i+1})\)</span></span>.</figcaption>
</figure>
<p>On input of string <span><span class="math inline">\(y\)</span></span> of length <span><span class="math inline">\(n+1\)</span></span>, <span><span class="math inline">\(Eve&#39;\)</span></span> will interpret <span><span class="math inline">\(y\)</span></span> as <span><span class="math inline">\((s_{i+1},y_{i+1})\)</span></span>, choose <span><span class="math inline">\(y_1,\ldots,y_i\)</span></span> randomly and compute <span><span class="math inline">\(y_{i+2},\ldots,y_t\)</span></span> as in our pseudorandom generator’s construction. <span><span class="math inline">\(Eve&#39;\)</span></span> will then feed <span><span class="math inline">\((y_1,\ldots,y_t)\)</span></span> to <span><span class="math inline">\(Eve\)</span></span> and output whatever <span><span class="math inline">\(Eve\)</span></span> does. Clearly, <span><span class="math inline">\(Eve&#39;\)</span></span> is efficient if <span><span class="math inline">\(Eve\)</span></span> is. Moreover, one can see that if <span><span class="math inline">\(y\)</span></span> was random then <span><span class="math inline">\(Eve&#39;\)</span></span> is feeding <span><span class="math inline">\(Eve\)</span></span> with an input distributed according to <span><span class="math inline">\(H_{i+1}\)</span></span> while if <span><span class="math inline">\(y\)</span></span> was of the form <span><span class="math inline">\(G(s)\)</span></span> for a random <span><span class="math inline">\(s\)</span></span> then <span><span class="math inline">\(Eve&#39;\)</span></span> will feed <span><span class="math inline">\(Eve\)</span></span> with an input distributed according to <span><span class="math inline">\(H_i\)</span></span>. Hence we get that <span><span class="math inline">\(| \E[ Eve&#39;(G&#39;(U_n))] - \E[Eve&#39;(U_{n+1})] | \geq \epsilon\)</span></span> contradicting the security of <span><span class="math inline">\(G&#39;\)</span></span>.</p>
</div>
<p>The proof of <a href='#lengthextendprgthm'>Theorem 3.4</a> is indicative of many practical constructions of pseudorandom generators. Many operating systems keep track of an initial <em>seed</em> of randomness, and supply a system call <code>rand</code> such that every call to <code>rand</code> applies a pseudorandom generator <span><span class="math inline">\(G&#39;\)</span></span> to the current seed, uses part of the output to update the seed, and returns the remainder to the caller.</p>
<div id="alternativelengthextendrem" class="remark" title="Unpredictablity and indistinguishability- an alternative approach for proving the length extension theorem" data-number="3" name="Remark 3.5 (Unpredictablity and indistinguishability- an alternative approach for proving the length extension theorem) ">
<p>The notion that being random is the same as being “unpredictable” can be formalized as follows. One can show that a random variable <span><span class="math inline">\(X\)</span></span> over <span><span class="math inline">\(\{0,1\}^n\)</span></span> is pseudorandom if and only if every efficient algorithm <span><span class="math inline">\(A\)</span></span> succeeds in the following experiment with probability at most <span><span class="math inline">\(1/2+negl(n)\)</span></span>: <span><span class="math inline">\(A\)</span></span> is given <span><span class="math inline">\(i\)</span></span> chosen at random in <span><span class="math inline">\(\{0,\ldots,n-1\}\)</span></span> and <span><span class="math inline">\(x_1,\ldots,x_i\)</span></span> where <span><span class="math inline">\((x_1,\ldots,x_n)\)</span></span> is drawn from <span><span class="math inline">\(X\)</span></span> and wins if it outputs <span><span class="math inline">\(x_{i+1}\)</span></span>. It is a good optional exercise to prove this, and to use that to give an alternative proof of the length extension theorem.</p>
</div>
<h2 id="stream-ciphers" data-number="3.1">Stream ciphers</h2>
<p>We now show a connection between our two notions:</p>
<div id="PRGandcipherthm" class="theorem" title="PRG conjecture implies  Cipher conjectures" data-number="3.1" name="Theorem 3.6 (PRG conjecture implies  Cipher conjectures) ">
<p>If the PRG conjecture is true then so is the cipher conjecture.</p>
</div>
<p>It turns out that the converse direction is also true, and hence these two conjectures are <em>equivalent</em>, though we will probably not show the (quite non-trivial) proof of this fact in this course. (We might show some weaker version of this harder direction.)</p>
<div id="section-3" class="proof" data-ref="PRGandcipherthm" data-number="3.1" name="Proof">
<p>The construction is actually quite simple, recall that the <em>one time pad</em> is a perfectly secure cipher but its only problem was that to encrypt an <span><span class="math inline">\(n+1\)</span></span> long message it needed an <span><span class="math inline">\(n+1\)</span></span> long bit key. Now using a pseudorandom generator, we can map an <span><span class="math inline">\(n\)</span></span>-bit long key into an <span><span class="math inline">\(n+1\)</span></span>-bit long string that looks random enough that we could use it as a key for the one-time pad. That is, our cipher will look as follows:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
E_k(m) = G(k) \oplus m
\]</span></div></span></p>
<p>and</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
D_k(c) = G(k) \oplus c
\]</span></div></span></p>
<p>Just like in the one time pad, <span><span class="math inline">\(D_k(E_k(m)) = G(k) \oplus G(k) \oplus m = m\)</span></span>. Moreover, the encryption and decryption algorithms are clearly efficient and so the only thing that’s left is to prove security or that for every pair <span><span class="math inline">\(m,m&#39;\)</span></span> of plaintexts, <span><span class="math inline">\(E_{U_n}(m) \approx E_{U_n}(m&#39;)\)</span></span>. We show this by proving the following claim:</p>
<p><strong>Claim:</strong> For every <span><span class="math inline">\(m\in{\{0,1\}}^{n+1}\)</span></span>, <span><span class="math inline">\(E_{U_n}(m) \approx U_{n+1} \oplus m\)</span></span>.</p>
<p>The claim implies the security of the scheme, since it means that <span><span class="math inline">\(E_{U_n}(m)\)</span></span> is indistinguishable from the one-time-pad encryption of <span><span class="math inline">\(m\)</span></span>, which is identically distributed to the one-time pad encryption of <span><span class="math inline">\(m&#39;\)</span></span> which (by another application of the claim) is indistinguishable from <span><span class="math inline">\(E_{U_n}(m&#39;)\)</span></span> and so the theorem follows from the triangle inequality. Thus all that’s left is to prove the claim:</p>
<p><strong>Proof of claim:</strong> Suppose that there was an efficient adversary <span><span class="math inline">\(Eve&#39;\)</span></span> such that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\left| {\mathbb{E}}[ Eve&#39;(G(U_n)\oplus m)] - {\mathbb{E}}[ Eve&#39;(U_{n+1}\oplus m) ] \right| \geq \epsilon
\]</span></div></span></p>
<p>for some non-negligible <span><span class="math inline">\(\epsilon=\epsilon(n)&gt;0\)</span></span>. Then the adversary <span><span class="math inline">\(Eve\)</span></span> defined as <span><span class="math inline">\(Eve(y) = Eve&#39;(y\oplus m)\)</span></span> would be also efficient and would break the security of the PRG with non-negligible success. This concludes the proof of the claim and hence the theorem.</p>
</div>
<p>If the PRG outputs <span><span class="math inline">\(t(n)\)</span></span> bits instead of <span><span class="math inline">\(n+1\)</span></span> then we automatically get an encryption scheme with <span><span class="math inline">\(t(n)\)</span></span> long message length. In fact, in practice if we use the length extension for PRG’s, we don’t need to decide on the length of messages in advance. Every time we need to encrypt another bit (or another block) <span><span class="math inline">\(m_i\)</span></span> of the message, we run the basic PRG to update our state and obtain some new randomness <span><span class="math inline">\(y_i\)</span></span> that we can XOR with the message and output. Such constructions are known as <em>stream ciphers</em> in the literature. In much of the practical literature the name <em>stream cipher</em> is used both for the pseudorandom generator itself, as well as for the encryption scheme that is obtained by combining it with the one-time pad.</p>
<div id="cointossingphonerm" class="remark" title="Using pseudorandom generators for coin tossing over the phone" data-number="3.1" name="Remark 3.7 (Using pseudorandom generators for coin tossing over the phone) ">
<p>The following is a cute application of pseudorandom generators. Alice and Bob want to toss a fair coin over the phone. They use a pseudorandom generator <span><span class="math inline">\(G:\{0,1\}^b\rightarrow\{0,1\}^{3n}\)</span></span>.</p>
<ul>
<li>Alice will send <span><span class="math inline">\(z\leftarrow_R\{0,1\}^{3n}\)</span></span> to Bob<br />
</li>
<li>Bob picks <span><span class="math inline">\(s\leftarrow_R\{0,1\}^n\)</span></span> and with probability <span><span class="math inline">\(1/2\)</span></span> sends <span><span class="math inline">\(G(s)\)</span></span> (case I) and with probability <span><span class="math inline">\(1/2\)</span></span> sends <span><span class="math inline">\(G(s)\oplus z\)</span></span> (case II).<br />
</li>
<li>Alice then picks a random <span><span class="math inline">\(b\leftarrow_R\{0,1\}\)</span></span> and sends it to Bob.<br />
</li>
<li>Bob reveals what he sent in the previous stage and if it was case I, their output is <span><span class="math inline">\(b\)</span></span>, and if it was case II, their output is <span><span class="math inline">\(1-b\)</span></span>.</li>
</ul>
<p>It can be shown that (assuming the protocol is completed) the output is a random coin, which neither Alice or Bob can control or predict with more than negligible advantage over half. (Trying to formalize this and prove it is an excellent exercise.)</p>
</div>
<h2 id="what-do-pseudorandom-generators-actually-look-like" data-number="3.2">What do pseudorandom generators actually look like?</h2>
<p>So far we have made the conjectures that objects such as ciphers and pseudorandom generators <em>exist</em>, without giving any hint as to how they would actually look like. (Though we have examples such as the Caesar cipher, Vignere, and Enigma of what secure ciphers <em>don’t</em> look like.) As mentioned above, we do not know how to <em>prove</em> that any particular function is a pseudorandom generator. However, there are quite simple <em>candidates</em> (i.e., functions that are conjectured to be secure pseudorandom generators), though care must be taken in constructing them. We now consider candidates for functions that maps <span><span class="math inline">\(n\)</span></span> bits to <span><span class="math inline">\(n+1\)</span></span> bits (or more generally <span><span class="math inline">\(n+c\)</span></span> for some constant <span><span class="math inline">\(c\)</span></span> ) and look at least somewhat “randomish”. As these constructions are typically used as a basic component for obtaining a longer length PRG via the length extension theorem (<a href='#lengthextendprgthm'>Theorem 3.4</a>), we will think of these pseudorandom generators as mapping a string <span><span class="math inline">\(s\in\{0,1\}^n\)</span></span> representing the current state into a string <span><span class="math inline">\(s’\in\{0,1\}^n\)</span></span> representing the new state as well as a string <span><span class="math inline">\(b\in\{0,1\}^c\)</span></span> representing the current output. See also Section 6.1 in Katz-Lindell and (for greater depth) Sections 3.6-3.9 in the Boneh-Shoup book.</p>
<h3 id="attempt-0-the-counter-generator" data-number="3.2.1">Attempt 0: The counter generator</h3>
<p>Just to get started, let’s show an example of an obviously bogus pseudorandom generator. We define the “counter pseudorandom generator” <span><span class="math inline">\(G:\{0,1\}^n \rightarrow \{0,1\}^{n+1}\)</span></span> as follows. <span><span class="math inline">\(G(s)=(s&#39;,b)\)</span></span> where <span><span class="math inline">\(s&#39; = s + 1 \mod 2^n\)</span></span> (treating <span><span class="math inline">\(s\)</span></span> and <span><span class="math inline">\(s&#39;\)</span></span> as numbers in <span><span class="math inline">\(\{0,\ldots,2^n-1\}\)</span></span>) and <span><span class="math inline">\(b\)</span></span> is the least significant digit of <span><span class="math inline">\(s&#39;\)</span></span>. It’s a great exercise to work out why this is <em>not</em> a secure pseudorandom generator.</p>
<div id="section-4" class="pause" data-number="3.2.1" name="Pause">
<p>You should really pause here and make sure you see why the “counter pseudorandom generator” is not a secure pseudorandom generator. Show that this is true even if we replace the least significant digit by the <span><span class="math inline">\(k\)</span></span>-th digit for every <span><span class="math inline">\(0 \leq k &lt; n\)</span></span>.</p>
</div>
<h3 id="attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr" data-number="3.2.2">Attempt 1: The linear checksum / linear feedback shift register (LFSR)</h3>
<p>LFSR can be thought of as the “mother” (or maybe more like the sick great-uncle) of all psuedorandom generators. One of the simplest ways to generate a “randomish” extra digit given an <span><span class="math inline">\(n\)</span></span> digit number is to use a <em>checksum</em> - some linear combination of the digits, with a canonical example being the <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">cyclic redundancy check</a> or CRC.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> This motivates the notion of a <em>linear feedback shift register generator</em> (LFSR): if the current state is <span><span class="math inline">\(s\in\{0,1\}^n\)</span></span> then the output is <span><span class="math inline">\(f(s)\)</span></span> where <span><span class="math inline">\(f\)</span></span> is a linear function (modulo 2) and the new state is obtained by right shifting the previous state and putting <span><span class="math inline">\(f(s)\)</span></span> at the leftmost location. That is, <span><span class="math inline">\(s&#39;_1 = f(s)\)</span></span> and <span><span class="math inline">\(s&#39;_i = s_{i-1}\)</span></span> for <span><span class="math inline">\(i\in\{2,\ldots,n\}\)</span></span>.</p>
<p>LFSR’s have several good properties- if the function <span><span class="math inline">\(f(\cdot)\)</span></span> is chosen properly then they can have very long <em>periods</em> (i.e., it can take an exponential number of steps until the state repeats itself), though that also holds for the simple “counter” generator we saw above. They also have the property that every individual bit is equal to <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span> with probability exactly half (the counter generator also shares this property).</p>
<p>A more interesting property is that (if the function is selected properly) every two coordinates are independent from one another. That is, there is some super-polynomial function <span><span class="math inline">\(t(n)\)</span></span> (in fact <span><span class="math inline">\(t(n)\)</span></span> can be exponential in <span><span class="math inline">\(n\)</span></span>) such that if <span><span class="math inline">\(\ell \neq \ell&#39; \in \{0,\ldots, t(n) \}\)</span></span>, then if we look at the two random variables corresponding to the <span><span class="math inline">\(\ell\)</span></span>-th and <span><span class="math inline">\(\ell&#39;\)</span></span>-th output of the generator (where randomness is the initial state) then they are distributed like two independent random coins. (This is non-trivial to show, and depends on the choice of <span><span class="math inline">\(f\)</span></span> - it is a challenging but useful exercise to work this out.) The counter generator fails badly at this condition: the least significant bits between two consecutive states always flip.</p>
<p>There is a more general notion of a <em>linear generator</em> where the new state can be any invertible linear transformation of the previous state. That is, we interpret the state <span><span class="math inline">\(s\)</span></span> as an element of <span><span class="math inline">\(\Z_q^t\)</span></span> for some integers <span><span class="math inline">\(q,t\)</span></span>,<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> and let <span><span class="math inline">\(s’=F(s)\)</span></span> and the output <span><span class="math inline">\(b=G(s)\)</span></span> where <span><span class="math inline">\(F:\Z_q^t\rightarrow\Z_q^t\)</span></span> and <span><span class="math inline">\(G:\Z_q^t\rightarrow\Z_q\)</span></span> are invertible linear transformations (modulo <span><span class="math inline">\(q\)</span></span>). This includes as a special case the <em>linear congruential generator</em> where <span><span class="math inline">\(t=1\)</span></span> and the map <span><span class="math inline">\(F(s)\)</span></span> corresponds to taking <span><span class="math inline">\(as \pmod{q}\)</span></span> where <span><span class="math inline">\(a\)</span></span> is number co-prime to <span><span class="math inline">\(q\)</span></span>.</p>
<p>All these generators are unfortunately insecure due to the great bane of cryptography- the <em>Gaussian elimination algorithm</em> which students typically encounter in any linear algebra class.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p>
<div id="gaussianelimthm" class="theorem" title="The unfortunate theorem for cryptography" data-number="3.2.2" name="Theorem 3.8 (The unfortunate theorem for cryptography) ">
<p>There is a polynomial time algorithm to solve <span><span class="math inline">\(m\)</span></span> linear equations in <span><span class="math inline">\(n\)</span></span> variables (or to certify no solution exists) over any ring.</p>
</div>
<p>Despite its seeming simplicity and ubiquity, Gaussian elimination (and some generalizations and related algorithms such as Euclid’s extended g.c.d algorithm and the LLL lattice reduction algorithm) has been used time and again to break candidate cryptographic constructions. In particular, if we look at the first <span><span class="math inline">\(n\)</span></span> outputs of a linear generator <span><span class="math inline">\(b_1,\ldots,b_n\)</span></span> then we can write linear equations in the unknown initial state of the form <span><span class="math inline">\(f_1(s)=b_1,\ldots,f_n(s)=b_n\)</span></span> where the <span><span class="math inline">\(f_i\)</span></span>’s are known linear functions. Either those functions are <em>linearly independent</em>, in which case we can solve the equations to get the unique solution for the original state <span><span class="math inline">\(s\)</span></span> and from which point we can predict all outputs of the generator, or they are dependent, which means that we can predict some of the outputs even without recovering the original state. Either way the generator is <span><span class="math inline">\(*\sharp !\)</span></span>’ed (where <span><span class="math inline">\(* \sharp !\)</span></span> refers to whatever verb you prefer to use when your system is broken). See also this <a href="http://alumni.cs.ucr.edu/~jsun/random-number.pdf">1977 paper</a> of James Reed.</p>
<div id="nocryptoprgs" class="remark" title="Non-cryptographic PRGs" data-number="3.2.2" name="Remark 3.9 (Non-cryptographic PRGs) ">
<p>The above means that it is a bad idea to use a linear checksum as a pseudorandom generator in a cryptographic application, and in fact in any adversarial setting (e.g., one shouldn’t hope that an attacker would not be able to reverse engineer the algorithm<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> that computes the control digit of a credit card number). However, that does not mean that there are no legitimate cases where linear generators can be used . In a setting where the application is not adversarial and you have an ability to <em>test</em> if the generator is actually successful, it might be reasonable to use such insecure non-cryptographic generators. They tend to be more efficient (though often not by much) and hence are often the default option in many programming environments such as the <code>C rand()</code> command. (In fact, the real bottleneck in using cryptographic pseudorandom generators is often the generation of <em>entropy</em> for their seed, as discussed in the previous lecture, and not their actual running time.)</p>
</div>
<h3 id="from-insecurity-to-security" data-number="3.2.3">From insecurity to security</h3>
<p>It is often the case that we want to “fix” a broken cryptographic primitive, such as a pseudorandom generator, to make it secure. At the moment this is still more of an art than a science, but there are some principles that cryptographers have used to try to make this more principled. The main intuition is that there are certain properties of computational problems that make them more amenable to algorithms (i.e., “easier”) and when we want to make the problems useful for cryptography (i.e., “hard”) we often seek variants that don’t possess these properties. The following table illustrates some examples of such properties. (These are not formal statements, but rather is intended to give some intuition )</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Easy</th>
<th style="text-align: left;">Hard</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Continuous</td>
<td style="text-align: left;">Discrete</td>
</tr>
<tr class="even">
<td style="text-align: left;">Convex</td>
<td style="text-align: left;">Non-convex</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Linear</td>
<td style="text-align: left;">Non-linear (degree <span><span class="math inline">\(\geq 2\)</span></span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Noiseless</td>
<td style="text-align: left;">Noisy</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Local</td>
<td style="text-align: left;">Global</td>
</tr>
<tr class="even">
<td style="text-align: left;">Shallow</td>
<td style="text-align: left;">Deep</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Low degree</td>
<td style="text-align: left;">High degree</td>
</tr>
</tbody>
</table>
<p>Many cryptographic constructions can be thought of as trying to transform an easy problem into a hard one by moving from the left to the right column of this table.</p>
<p>The <strong>discrete logarithm problem</strong> is the discrete version of the continuous real logarithm problem. The <strong>learning with errors problem</strong> can be thought of as the noisy version of the linear equations problem (or the discrete version of least squares minimization). When constructing <strong>block ciphers</strong> we often have <em>mixing</em> transformation to ensure that the dependency structure between different bits is <em>global</em>, <em>S-boxes</em> to ensure <em>non-linearity</em>, and many <em>rounds</em> to ensure <em>deep</em> structure and <em>large algebraic degree</em>.</p>
<p>This also works in the other direction. Many algorithmic and machine learning advances work by embedding a discrete problem in a continuous convex one. Some attacks on cryptographic objects can be thought of as trying to recover some of the structure (e.g., by embedding modular arithmetic in the real line or “linearizing” non linear equations).</p>
<h3 id="attempt-2-linear-congruential-generators-with-dropped-bits" data-number="3.2.4">Attempt 2: Linear Congruential Generators with dropped bits</h3>
<p>One approach that is widely used in implementations of pseudorandom generators is to take a linear generator such as the linear congruential generators described above, and use for the output a “chopped” version of the linear function and drop some of the least significant bits. The operation of dropping these bits is non-linear and hence the attack above does not immediately apply. Nevertheless, it turns out this attack can be generalized to handle this case, and hence even with dropped bits Linear Congruential Generators are completely insecure and should be used (if at all) only in applications such as simulations where there is no adversary. Section 3.7.1 in the Boneh-Shoup book describes one attack against such generators that uses the notion of <em>lattice algorithms</em> that we will encounter later in this course in very different contexts.</p>
<h2 id="successful-examples" data-number="3.3">Successful examples</h2>
<p>Let’s now describe some <em>successful</em> (at least per current knowledge) pseudorandom generators:</p>
<h3 id="case-study-1-subset-sum-generator" data-number="3.3.1">Case Study 1: Subset Sum Generator</h3>
<p>Here is an extremely simple generator that is yet still secure<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup> as far as we know.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># seed is a list of 40 zero/one  values</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"># output is a 48 bit integer</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">def</span> subset_sum_gen(seed):</a>
<a class="sourceLine" id="cb1-4" title="4">  modulo <span class="op">=</span> <span class="bn">0x1000000</span></a>
<a class="sourceLine" id="cb1-5" title="5">  constants <span class="op">=</span> [  </a>
<a class="sourceLine" id="cb1-6" title="6">     <span class="bn">0x3D6EA1</span>, <span class="bn">0x1E2795</span>, <span class="bn">0xC802C6</span>, <span class="bn">0xBF742A</span>, <span class="bn">0x45FF31</span>,  </a>
<a class="sourceLine" id="cb1-7" title="7">     <span class="bn">0x53A9D4</span>, <span class="bn">0x927F9F</span>, <span class="bn">0x70E09D</span>, <span class="bn">0x56F00A</span>, <span class="bn">0x78B494</span>,  </a>
<a class="sourceLine" id="cb1-8" title="8">     <span class="bn">0x9122E7</span>, <span class="bn">0xAFB10C</span>, <span class="bn">0x18C2C8</span>, <span class="bn">0x8FF050</span>, <span class="bn">0x0239A3</span>,  </a>
<a class="sourceLine" id="cb1-9" title="9">     <span class="bn">0x02E4E0</span>, <span class="bn">0x779B76</span>, <span class="bn">0x1C4FC2</span>, <span class="bn">0x7C5150</span>, <span class="bn">0x81E05E</span>,  </a>
<a class="sourceLine" id="cb1-10" title="10">     <span class="bn">0x154647</span>, <span class="bn">0xB80E68</span>, <span class="bn">0xA042E5</span>, <span class="bn">0xE20269</span>, <span class="bn">0xD3B7F3</span>,  </a>
<a class="sourceLine" id="cb1-11" title="11">     <span class="bn">0xCC5FB9</span>, <span class="bn">0x0BFC55</span>, <span class="bn">0x847AE0</span>, <span class="bn">0x8CFDF8</span>, <span class="bn">0xE304B7</span>,</a>
<a class="sourceLine" id="cb1-12" title="12">     <span class="bn">0x869ACE</span>, <span class="bn">0xB4CDAB</span>, <span class="bn">0xC8E31F</span>, <span class="bn">0x00EDC7</span>, <span class="bn">0xC50541</span>,  </a>
<a class="sourceLine" id="cb1-13" title="13">     <span class="bn">0x0D6DDD</span>, <span class="bn">0x695A2F</span>, <span class="bn">0xA81062</span>, <span class="bn">0x0123CA</span>, <span class="bn">0xC6C5C3</span> ]</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="co"># return the modular sum of the constants</span></a>
<a class="sourceLine" id="cb1-16" title="16">  <span class="co"># corresponding to ones in the seed</span></a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="cf">return</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> x,y: (x<span class="op">+</span>y) <span class="op">%</span> modulo,</a>
<a class="sourceLine" id="cb1-18" title="18">                <span class="bu">map</span>(<span class="kw">lambda</span> a,b: a<span class="op">*</span>b, constants,seed))</a></code></pre></div>
<p>The seed to this generator is an array <code>seed</code> of 40 bits, with 40 hardwired constants each 48 bits long (these constants were generated at random, but are fixed once and for all, and are not kept secret and hence are not considered part of the secret random seed). The output is simply <span>
<div class='myequationbox'><span class="math display">\[\sum_{i=1}^{40} \texttt{seed}[i]\texttt{constants}[i] \pmod{2^{48}}\]</span></div></span> and hence expands the <span><span class="math inline">\(40\)</span></span> bit input into a <span><span class="math inline">\(48\)</span></span> bit output.</p>
<p>This generator is loosely motivated by the “subset sum” computational problem, which is NP hard. However, since NP hardness is a <em>worst case</em> notion of complexity, it does not imply security for pseudorandom generators, which requires hardness of an <em>average case</em> variant. To get some intuition for its security, we can work out why (given that it seems to be linear) we cannot break it by simply using Gaussian elimination.</p>
<div id="section-5" class="pause" data-number="3.3.1" name="Pause">
<p>This is an excellent point for you to stop and try to answer this question on your own.</p>
</div>
<p>Given the known constants and known output, figuring out the set of potential seeds can be thought of as solving a <em>single</em> equation in 40 variables. However, this equation is clearly overdetermined, and will have a solution regardless of whether the observed value is indeed an output of the generator, or it is chosen uniformly at random.</p>
<p>More concretely, we can use linear-equation solving to compute (given the known constants <span><span class="math inline">\(c_1,\ldots,c_{40} \in \Z_{2^{48}}\)</span></span> and the output <span><span class="math inline">\(y \in \Z_{2^{48}}\)</span></span>) the linear subspace <span><span class="math inline">\(V\)</span></span> of all vectors <span><span class="math inline">\((s_1,\ldots,s_{40}) \in (\Z_{2^{48}})^{40}\)</span></span> such that <span><span class="math inline">\(\sum s_i c_i = y \pmod{2^{48}}\)</span></span>. But, regardless of whether <span><span class="math inline">\(y\)</span></span> was generated at random from <span><span class="math inline">\(\Z_{2^{48}}\)</span></span>, or <span><span class="math inline">\(y\)</span></span> was generated as an output of the generator, the subspace <span><span class="math inline">\(V\)</span></span> will always have the same dimension (specifically, since it is formed by a single linear equation over <span><span class="math inline">\(40\)</span></span> variables, the dimension will be <span><span class="math inline">\(39\)</span></span>.) To break the generator we seem to need to be able to decide whether this linear subspace <span><span class="math inline">\(V \subseteq (\Z_{2^{48}})^{40}\)</span></span> contains a <em>Boolean vector</em> (i.e., a vector <span><span class="math inline">\(s\in \{0,1\}^n\)</span></span>). Since the condition that a vector is Boolean is not defined by linear equations, we cannot use Gaussian elimination to break the generator. Generally, the task of finding a vector with <em>small</em> coefficients inside a discrete linear subspace is closely related to a classical problem known as finding the <a href="https://goo.gl/WRNT9S">shortest vector in a lattice</a>. (See also the <a href="https://goo.gl/KwZWhV">short integer solution (SIS) problem</a>.)</p>
<h3 id="case-study-2-rc4" data-number="3.3.2">Case Study 2: RC4</h3>
<p>The following is another example of an extremely simple generator known as RC4 (this stands for Rivest Cipher 4, as Ron Rivest invented this in 1987) and is still fairly widely used today.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> RC4(P,i,j):</a>
<a class="sourceLine" id="cb2-2" title="2">    i <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">256</span></a>
<a class="sourceLine" id="cb2-3" title="3">    j <span class="op">=</span> (j <span class="op">+</span> P[i]) <span class="op">%</span> <span class="dv">256</span></a>
<a class="sourceLine" id="cb2-4" title="4">    P[i], P[j] <span class="op">=</span> P[j], P[i]</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="cf">return</span> (P,i,j,P[(P[i]<span class="op">+</span>P[j]) <span class="op">%</span> <span class="dv">256</span>])</a></code></pre></div>
<p>The function <code>RC4</code> takes as input the current state <code>P,i,j</code> of the generator and returns the new state together with a single output byte. The state of the generator consists of an array <code>P</code> of 256 bytes, which can be thought of as a <em>permutation</em> of the numbers <span><span class="math inline">\(0,\ldots,255\)</span></span> in the sense that we maintain the invariant that <span><span class="math inline">\(\texttt{P}[i]\neq\texttt{P}[j]\)</span></span> for every <span><span class="math inline">\(i\neq j\)</span></span>, and two indices <span><span class="math inline">\(i,j \in \{0,\ldots,255\}\)</span></span>. We can consider the initial state as the case where <code>P</code> is a completely random permutation and <span><span class="math inline">\(i\)</span></span> and <span><span class="math inline">\(j\)</span></span> are initialized to zero, although to save on initial seed size, typically RC4 uses some “pseudorandom” way to generate <code>P</code> from a shorter seed as well.</p>
<p>RC4 has extremely efficient software implementations and hence has been widely implemented. However, it has several issues with its security. In particular it was shown by Mantin<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> and Shamir that the second bit of RC4 is <em>not</em> random, even if the initialization vector was random. This and other issues led to a practical attack on the 802.11b WiFi protocol, see Section 9.9 in Boneh-Shoup. The initial response to those attacks was to suggest to drop the first 1024 bytes of the output, but by now the attacks have been sufficiently extended that RC4 is simply not considered a secure cipher anymore. The ciphers Salsa and ChaCha, designed by Dan Bernstein, have a similar design to RC4, and are considered secure and deployed in several standard protocols such as TLS, SSH and QUIC, see Section 3.6 in Boneh-Shoup.</p>
<h2 id="non-constructive-existence-of-pseudorandom-generators" data-number="3.4">Non-constructive existence of pseudorandom generators</h2>
<p>We now show that, if we don’t insist on <em>constructivity</em> of pseudorandom generators, then we can show that there exists pseudorandom generators with output that <em>exponentially larger</em> in the input length.</p>
<div id="prgexist" class="lemma" title="Existence of inefficient pseudorandom generators" data-number="3.4" name="Lemma 3.10 (Existence of inefficient pseudorandom generators) ">
<p>There is some absolute constant <span><span class="math inline">\(C\)</span></span> such that for every <span><span class="math inline">\(\epsilon,T\)</span></span>, if <span><span class="math inline">\(\ell &gt; C (\log T + \log (1/\epsilon))\)</span></span> and <span><span class="math inline">\(m \leq T\)</span></span>, then there is an <span><span class="math inline">\((T,\epsilon)\)</span></span> pseudorandom generator <span><span class="math inline">\(G: \{0,1\}^\ell \rightarrow \{0,1\}^m\)</span></span>.</p>
</div>
<div id="section-6" class="proofidea" data-ref="prgexist" data-number="3.4" name="Proofidea">
<p>The proof uses an extremely useful technique known as the “probabilistic method” which is not too hard mathematically but can be confusing at first.<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> The idea is to give a “non constructive” proof of existence of the pseudorandom generator <span><span class="math inline">\(G\)</span></span> by showing that if <span><span class="math inline">\(G\)</span></span> was chosen at random, then the probability that it would be a valid <span><span class="math inline">\((T,\epsilon)\)</span></span> pseudorandom generator is positive. In particular this means that there <em>exists</em> a single <span><span class="math inline">\(G\)</span></span> that is a valid <span><span class="math inline">\((T,\epsilon)\)</span></span> pseudorandom generator. The probabilistic method is just a <em>proof technique</em> to demonstrate the existence of such a function. Ultimately, our goal is to show the existence of a <em>deterministic</em> function <span><span class="math inline">\(G\)</span></span> that satisfies the conditions of a <span><span class="math inline">\((T, \epsilon)\)</span></span> PRG.</p>
</div>
<p>The above discussion might be rather abstract at this point, but would become clearer after seeing the proof.</p>
<div id="section-7" class="proof" data-ref="prgexist" data-number="3.4" name="Proof">
<p>Let <span><span class="math inline">\(\epsilon,T,\ell,m\)</span></span> be as in the lemma’s statement. We need to show that there exists a function <span><span class="math inline">\(G:\{0,1\}^\ell \rightarrow \{0,1\}^m\)</span></span> that “fools” every <span><span class="math inline">\(T\)</span></span> line program <span><span class="math inline">\(P\)</span></span> in the sense of <a href='#prgdefeq'>Equation 3.1</a>. We will show that this follows from the following claim:</p>
<p><strong>Claim I:</strong> For every fixed NAND program / Boolean circuit <span><span class="math inline">\(P\)</span></span>, if we pick <span><span class="math inline">\(G:\{0,1\}^\ell \rightarrow \{0,1\}^m\)</span></span> <em>at random</em> then the probability that <a href='#prgdefeq'>Equation 3.1</a> is violated is at most <span><span class="math inline">\(2^{-T^2}\)</span></span>.</p>
<p>Before proving Claim I, let us see why it implies <a href='#prgexist'>Lemma 3.10</a>. We can identify a function <span><span class="math inline">\(G:\{0,1\}^\ell \rightarrow \{0,1\}^m\)</span></span> with its “truth table” or simply the list of evaluations on all its possible <span><span class="math inline">\(2^\ell\)</span></span> inputs. Since each output is an <span><span class="math inline">\(m\)</span></span> bit string, we can also think of <span><span class="math inline">\(G\)</span></span> as a string in <span><span class="math inline">\(\{0,1\}^{m\cdot 2^\ell}\)</span></span>. We define <span><span class="math inline">\(\mathcal{G}^m_\ell\)</span></span> to be the set of all functions from <span><span class="math inline">\(\{0,1\}^\ell\)</span></span> to <span><span class="math inline">\(\{0,1\}^\ell\)</span></span>. As discussed above we can identify <span><span class="math inline">\(\mathcal{F}_\ell^m\)</span></span> with <span><span class="math inline">\(\{0,1\}^{m\cdot 2^\ell}\)</span></span> and choosing a random function <span><span class="math inline">\(G \sim \mathcal{F}_\ell^m\)</span></span> corresponds to choosing a random <span><span class="math inline">\(m\cdot 2^\ell\)</span></span>-long bit string.</p>
<p>For every NAND program / Boolean circuit <span><span class="math inline">\(P\)</span></span> let <span><span class="math inline">\(B_P\)</span></span> be the event that, if we choose <span><span class="math inline">\(G\)</span></span> at random from <span><span class="math inline">\(\mathcal{F}_\ell^m\)</span></span> then <a href='#prgdefeq'>Equation 3.1</a> is violated with respect to the program <span><span class="math inline">\(P\)</span></span>. It is important to understand what is the sample space that the event <span><span class="math inline">\(B_P\)</span></span> is defined over, namely this event depends on the choice of <span><span class="math inline">\(G\)</span></span> and so <span><span class="math inline">\(B_P\)</span></span> is a subset of <span><span class="math inline">\(\mathcal{F}_\ell^m\)</span></span>. An equivalent way to define the event <span><span class="math inline">\(B_P\)</span></span> is that it is the subset of all functions mapping <span><span class="math inline">\(\{0,1\}^\ell\)</span></span> to <span><span class="math inline">\(\{0,1\}^m\)</span></span> that violate <a href='#prgdefeq'>Equation 3.1</a>, or in other words: <span>
<div class='myequationbox'><span class="math display">\[
B_P = \left\{ G \in \mathcal{F}_\ell^m  \; \big| \; \left| \tfrac{1}{2^\ell}\sum_{s\in \{0,1\}^\ell} P(G(s)) - \tfrac{1}{2^m}\sum_{r \in \{0,1\}^m}P(r)  \right| &gt; \epsilon  \right\} \;\;. \;\;(3.6)
\]</span><a id='eq:eventdefine'></a></div></span> (We’ve replaced here the probability statements in <a href='#prgdefeq'>Equation 3.1</a> with the equivalent sums so as to reduce confusion as to what is the sample space that <span><span class="math inline">\(B_P\)</span></span> is defined over.)</p>
<p>To understand this proof it is crucial that you pause here and see how the definition of <span><span class="math inline">\(B_P\)</span></span> above corresponds to <a href='#eq:eventdefine'>Equation 3.6</a>. This may well take re-reading the above text once or twice, but it is a good exercise at parsing probabilistic statements and learning how to identify the <em>sample space</em> that these statements correspond to.</p>
<p>Now, the number of programs of size <span><span class="math inline">\(T\)</span></span> (or circuits of size <span><span class="math inline">\(T\)</span></span>) is at most <span><span class="math inline">\(2^{O(T\log T)}\)</span></span>. Since <span><span class="math inline">\(T\log T = o(T^2\)</span></span>) this means that if Claim I is true, then by the union bound it holds that the probability of the union of <span><span class="math inline">\(B_P\)</span></span> over <em>all</em> NAND programs of at most <span><span class="math inline">\(T\)</span></span> lines is at most <span><span class="math inline">\(2^{O(T\log T)}2^{-T^2} &lt; 0.1\)</span></span> for sufficiently large <span><span class="math inline">\(T\)</span></span>. What is important for us about the number <span><span class="math inline">\(0.1\)</span></span> is that it is smaller than <span><span class="math inline">\(1\)</span></span>. In particular this means that there <em>exists</em> a single <span><span class="math inline">\(G^* \in \mathcal{F}_\ell^m\)</span></span> such that <span><span class="math inline">\(G^*\)</span></span> <em>does not</em> violate <a href='#prgdefeq'>Equation 3.1</a> with respect to any NAND program of at most <span><span class="math inline">\(T\)</span></span> lines, but that precisely means that <span><span class="math inline">\(G^*\)</span></span> is a <span><span class="math inline">\((T,\epsilon)\)</span></span> pseudorandom generator.</p>
<p>Hence conclude the proof of <a href='#prgexist'>Lemma 3.10</a>, it suffices to prove Claim I. Choosing a random <span><span class="math inline">\(G: \{0,1\}^\ell \rightarrow \{0,1\}^m\)</span></span> amounts to choosing <span><span class="math inline">\(L=2^\ell\)</span></span> random strings <span><span class="math inline">\(y_0,\ldots,y_{L-1} \in \{0,1\}^m\)</span></span> and letting <span><span class="math inline">\(G(x)=y_x\)</span></span> (identifying <span><span class="math inline">\(\{0,1\}^\ell\)</span></span> and <span><span class="math inline">\([L]\)</span></span> via the binary representation). Hence the claim amounts to showing that for every fixed function <span><span class="math inline">\(P:\{0,1\}^m \rightarrow \{0,1\}\)</span></span>, if <span><span class="math inline">\(L &gt; 2^{C (\log T + \log \epsilon)}\)</span></span> (which by setting <span><span class="math inline">\(C&gt;4\)</span></span>, we can ensure is larger than <span><span class="math inline">\(10 T^2/\epsilon^2\)</span></span>) then the probability that <span>
<div class='myequationbox'><span class="math display">\[
\left| \tfrac{1}{L}\sum_{i=0}^{L-1} P(y_s)  -  \Pr_{s \sim \{0,1\}^m}[P(s)=1] \right| &gt; \epsilon \;\;(3.7)
\]</span><a id='prgdefeqchernoff'></a></div></span> is at most <span><span class="math inline">\(2^{-T^2}\)</span></span>. <a href='#{prgdefeqchernoff}'>?? ??</a> follows directly from the Chernoff bound. If we let for every <span><span class="math inline">\(i\in [L]\)</span></span> the random variable <span><span class="math inline">\(X_i\)</span></span> denote <span><span class="math inline">\(P(y_i)\)</span></span>, then since <span><span class="math inline">\(y_0,\ldots,y_{L-1}\)</span></span> is chosen independently at random, these are independently and identically distributed random variables with mean <span><span class="math inline">\(\E_{y \sim \{0,1\}^m}[P(y)]= \Pr_{y\sim \{0,1\}^m}[ P(y)=1]\)</span></span> and hence the probability that they deviate from their expectation by <span><span class="math inline">\(\epsilon\)</span></span> is at most <span><span class="math inline">\(2\cdot 2^{-\epsilon^2 L/2}\)</span></span>.</p>
</div>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>Even lawyers grapple with this question, with a recent example being the debate of whether fantasy football is a game of chance or of skill.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>In fact such a function must exist in some sense since in the entire history of the world, presumably no sequence of <span><span class="math inline">\(100\)</span></span> fair coin tosses has ever repeated.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>The name “The PRG conjecture” is non-standard. In the literature this is known as the conjecture of existence of pseudorandom generators. This is a weaker form of “The Optimal PRG Conjecture” presented in my <a href="https://goo.gl/G7bU4M">intro to theoretical CS lecture notes</a> since the PRG conjecture only posits the existence of pseudorandom generators with arbitrary polynomial blowup, as opposed to an exponential blowup posited in the optimal PRF conjecture.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>Because we use a small input to grow a large pseudorandom string, the input to a pseudorandom generator is often known as its <em>seed</em>.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>CRC are often used to generate a “control digit” to detect mistypes of credit card or social security card number. This has very different goals than its use for pseudorandom generators, though there are some common intuitions behind the two usages.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>A ring is a set of elements where addition and multiplication are defined and obey the natural rules of associativity and commutativity (though without necessarily having a multiplicative inverse for every element). For every integer <span><span class="math inline">\(q\)</span></span> we define <span><span class="math inline">\(\Z_q\)</span></span> (known as the <em>ring of integers modulo <span><span class="math inline">\(q\)</span></span></em>) to be the set <span><span class="math inline">\(\{0,\ldots,q-1\}\)</span></span> where addition and multiplication is done modulo <span><span class="math inline">\(q\)</span></span>.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:7"><p>
<div>
<p>Despite the name, the algorithm goes at least as far back as the Chinese <em>Jiuzhang Suanshu</em> manuscript, circa 150 B.C.</p>
</div>
<a href="#fnref:7" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:8"><p>
<div>
<p>That number is obtained by applying an algorithm of <a href="https://goo.gl/SL8ahM">Hans Peter Luhn</a> which applies a simple map to each digit of the card and then sums them up modulo 10.</p>
</div>
<a href="#fnref:8" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:9"><p>
<div>
<p>Actually modern computers will be able to break this generator via brute force, but if the length and number of the constants were doubled (or perhaps quadrupled) this should be sufficiently secure, though longer to write down.</p>
</div>
<a href="#fnref:9" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:10"><p>
<div>
<p>I typically do not include references in these lecture notes, and leave them to the texts, but I make here an exception because Itsik Mantin was a close friend of mine in grad school.</p>
</div>
<a href="#fnref:10" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:11"><p>
<div>
<p>There is a whole (highly recommended) <a href="https://www.amazon.com/Probabilistic-Method-Discrete-Mathematics-Optimization/dp/1119061954/ref=dp_ob_title_bk">book by Alon and Spencer</a> devoted to this method.</p>
</div>
<a href="#fnref:11" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Pseudorandomness+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 02/29/2020 11:01:12</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_03_pseudorandom-generators.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
