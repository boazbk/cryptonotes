<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: Defining Computation</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: Defining Computation" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->



<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.1</b> Exercises</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Defining Computation</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_03_computation.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="compchap" data-number="3">Defining computation</h1>
<div id="section" class="objectives" data-number="3" name="Objectives">
<ul>
<li>See that computation can be precisely modeled.<br />
</li>
<li>Learn the computational model of <em>Boolean circuits</em> / <em>straight-line programs</em>.</li>
<li>Equivalence of circuits and straight-line programs.</li>
<li>Equivalence of AND/OR/NOT and NAND.</li>
<li>Examples of computing in the physical world.<br />
</li>
</ul>
</div>
<blockquote>
<p><em>“there is no reason why mental as well as bodily labor should not be economized by the aid of machinery”</em>, Charles Babbage, 1852</p>
</blockquote>
<blockquote>
<p><em>“If, unwarned by my example, any man shall undertake and shall succeed in constructing an engine embodying in itself the whole of the executive department of mathematical analysis upon different principles or by simpler mechanical means, I have no fear of leaving my reputation in his charge, for he alone will be fully able to appreciate the nature of my efforts and the value of their results.”</em>, Charles Babbage, 1864</p>
</blockquote>
<blockquote>
<p><em>“To understand a program you must become both the machine and the program.”</em>, Alan Perlis, 1982</p>
</blockquote>
<figure>
<img src="../figure/wheels_babbage.png" alt="3.1: Calculating wheels by Charles Babbage. Image taken from the Mark I ‘operating manual’" id="babbagewheels" class="margin" /><figcaption>3.1: Calculating wheels by Charles Babbage. Image taken from the Mark I ‘operating manual’</figcaption>
</figure>
<figure>
<img src="../figure/PopularMechanics1944smaller.jpg" alt="3.2: A 1944 Popular Mechanics article on the Harvard Mark I computer." id="markIcomp" class="margin" /><figcaption>3.2: A 1944 <em>Popular Mechanics</em> article on the <a href="http://sites.harvard.edu/~chsi/markone/about.html">Harvard Mark I computer</a>.</figcaption>
</figure>
<p>People have been computing for thousands of years, with aids that include not just pen and paper, but also abacus, slide rules, various mechanical devices, and modern electronic computers. A priori, the notion of computation seems to be tied to the particular mechanism that you use. You might think that the “best” algorithm for multiplying numbers will differ if you implement it in <em>Python</em> on a modern laptop than if you use pen and paper. However, as we saw in the introduction (<a href='lec_01_introduction.html#chapintro'>Chapter 0</a>), an algorithm that is asymptotically better would eventually beat a worse one regardless of the underlying technology. This gives us hope for a <em>technology independent</em> way of defining computation. This is what we do in this chapter. We will define the notion of computing an output from an input by applying a sequence of basic operations (see <a href='#compchapwhatvshowfig'>Figure 3.3</a>). Using this, we will be able to precisely define statements such as “function <span><span class="math inline">\(f\)</span></span> can be computed by model <span><span class="math inline">\(X\)</span></span>” or “function <span><span class="math inline">\(f\)</span></span> can be computed by model <span><span class="math inline">\(X\)</span></span> using <span><span class="math inline">\(s\)</span></span> operations”.</p>
<figure>
<img src="../figure/compchapterwhatvshow.png" alt="3.3: A function mapping strings to strings specifies a computational task, i.e., describes what the desired relation between the input and the output is. In this chapter we define models for implementing computational processes that achieve the desired relation, i.e., describe how to compute the output from the input. We will see several examples of such models using both Boolean circuits and straight-line programming languages." id="compchapwhatvshowfig" /><figcaption>3.3: A function mapping strings to strings <em>specifies</em> a computational task, i.e., describes <em>what</em> the desired relation between the input and the output is. In this chapter we define models for <em>implementing</em> computational processes that achieve the desired relation, i.e., describe <em>how</em> to compute the output from the input. We will see several examples of such models using both Boolean circuits and straight-line programming languages.</figcaption>
</figure>
<h2 id="defining-computation" data-number="3.1">Defining computation</h2>
<p>The name “algorithm” is derived from the Latin transliteration of Muhammad ibn Musa al-Khwarizmi’s name. Al-Khwarizmi was a Persian scholar during the 9th century whose books introduced the western world to the decimal positional numeral system, as well as to the solutions of linear and quadratic equations (see <a href='#alKhwarizmi'>Figure 3.4</a>). However Al-Khwarizmi’s descriptions of algorithms were rather informal by today’s standards. Rather than use “variables” such as <span><span class="math inline">\(x,y\)</span></span>, he used concrete numbers such as 10 and 39, and trusted the reader to be able to extrapolate from these examples, much as algorithms are still taught to children today.</p>
<p>Here is how Al-Khwarizmi described the algorithm for solving an equation of the form <span><span class="math inline">\(x^2 +bx = c\)</span></span>:</p>
<blockquote>
<p><em>[How to solve an equation of the form ] “roots and squares are equal to numbers”: For instance “one square , and ten roots of the same, amount to thirty-nine dirhems” that is to say, what must be the square which, when increased by ten of its own root, amounts to thirty-nine? The solution is this: you halve the number of the roots, which in the present instance yields five. This you multiply by itself; the product is twenty-five. Add this to thirty-nine’ the sum is sixty-four. Now take the root of this, which is eight, and subtract from it half the number of roots, which is five; the remainder is three. This is the root of the square which you sought for; the square itself is nine.</em></p>
</blockquote>
<figure>
<img src="../figure/alKhwarizmi.jpg" alt="3.4: Text pages from Algebra manuscript with geometrical solutions to two quadratic equations. Shelfmark: MS. Huntington 214 fol. 004v-005r" id="alKhwarizmi" class="margin" /><figcaption>3.4: Text pages from Algebra manuscript with geometrical solutions to two quadratic equations. Shelfmark: MS. Huntington 214 fol. 004v-005r</figcaption>
</figure>
<figure>
<img src="../figure/addition_regrouping.jpg" alt="3.5: An explanation for children of the two digit addition algorithm" id="childrenalg" class="margin" /><figcaption>3.5: An explanation for children of the two digit addition algorithm</figcaption>
</figure>
<p>For the purposes of this book, we will need a much more precise way to describe algorithms. Fortunately (or is it unfortunately?), at least at the moment, computers lag far behind school-age children in learning from examples. Hence in the 20th century, people came up with exact formalisms for describing algorithms, namely <em>programming languages</em>. Here is al-Khwarizmi’s quadratic equation solving algorithm described in the <em>Python</em> programming language:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">from</span> math <span class="im">import</span> sqrt</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">#Pythonspeak to enable use of the sqrt function to compute square roots.</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">def</span> solve_eq(b,c):</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="co"># return solution of x^2 + bx = c following Al Khwarizmi&#39;s instructions</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="co"># Al Kwarizmi demonstrates this for the case b=10 and c= 39</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">    val1 <span class="op">=</span> b <span class="op">/</span> <span class="fl">2.0</span> <span class="co"># &quot;halve the number of the roots&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9">    val2 <span class="op">=</span> val1 <span class="op">*</span> val1 <span class="co"># &quot;this you multiply by itself&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10">    val3 <span class="op">=</span> val2 <span class="op">+</span> c <span class="co"># &quot;Add this to thirty-nine&quot;</span></a>
<a class="sourceLine" id="cb1-11" title="11">    val4 <span class="op">=</span> sqrt(val3) <span class="co"># &quot;take the root of this&quot;</span></a>
<a class="sourceLine" id="cb1-12" title="12">    val5 <span class="op">=</span> val4 <span class="op">-</span> val1 <span class="co"># &quot;subtract from it half the number of roots&quot;</span></a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="cf">return</span> val5  <span class="co"># &quot;This is the root of the square which you sought for&quot;</span></a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co"># Test: solve x^2 + 10*x = 39</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="bu">print</span>(solve_eq(<span class="dv">10</span>,<span class="dv">39</span>))</a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co"># 3.0</span></a></code></pre></div>
<p>We can define algorithms informally as follows:</p>
<blockquote>
<div class="quote" name="Quote 3.1">
<p><strong>Informal definition of an algorithm:</strong> An <em>algorithm</em> is a set of instructions for how to compute an output from an input by following a sequence of “elementary steps”.</p>
<p>An algorithm <span><span class="math inline">\(A\)</span></span> <em>computes</em> a function <span><span class="math inline">\(F\)</span></span> if for every input <span><span class="math inline">\(x\)</span></span>, if we follow the instructions of <span><span class="math inline">\(A\)</span></span> on the input <span><span class="math inline">\(x\)</span></span>, we obtain the output <span><span class="math inline">\(F(x)\)</span></span>.</p>
</div>
</blockquote>
<p>In this chapter we will make this informal definition precise using the model of <strong>Boolean Circuits</strong>. We will show that Boolean Circuits are equivalent in power to <strong>straight line programs</strong> that are written in “ultra simple” programming languages that do not even have loops. We will also see that the particular choice of <strong>elementary operations</strong> is immaterial and many different choices yield models with equivalent power (see <a href='#compchapoverviewfig'>Figure 3.6</a>). However, it will take us some time to get there. We will start by discussing what are “elementary operations” and how we map a description of an algorithm into an actual physical process that produces an output from an input in the real world.</p>
<figure>
<img src="../figure/compcharoverview.png" alt="3.6: An overview of the computational models defined in this chapter. We will show several equivalent ways to represent a recipe for performing a finite computation. Specifically we will show that we can model such a computation using either a Boolean circuit or a straight line program, and these two representations are equivalent to one another. We will also show that we can choose as our basic operations either the set \{ \ensuremath{\mathit{AND}} , \ensuremath{\mathit{OR}} , \ensuremath{\mathit{NOT}} \} or the set \{ \ensuremath{\mathit{NAND}} \} and these two choices are equivalent in power. By making the choice of whether to use circuits or programs, and whether to use \{ \ensuremath{\mathit{AND}} , \ensuremath{\mathit{OR}} , \ensuremath{\mathit{NOT}} \} or \{ \ensuremath{\mathit{NAND}} \} we obtain four equivalent ways of modeling finite computation. Moreover, there are many other choices of sets of basic operations that are equivalent in power." id="compchapoverviewfig" /><figcaption>3.6: An overview of the computational models defined in this chapter. We will show several equivalent ways to represent a recipe for performing a finite computation. Specifically we will show that we can model such a computation using either a <em>Boolean circuit</em> or a <em>straight line program</em>, and these two representations are equivalent to one another. We will also show that we can choose as our basic operations either the set <span><span class="math inline">\(\{ \ensuremath{\mathit{AND}} , \ensuremath{\mathit{OR}} , \ensuremath{\mathit{NOT}} \}\)</span></span> or the set <span><span class="math inline">\(\{ \ensuremath{\mathit{NAND}} \}\)</span></span> and these two choices are equivalent in power. By making the choice of whether to use circuits or programs, and whether to use <span><span class="math inline">\(\{ \ensuremath{\mathit{AND}} , \ensuremath{\mathit{OR}} , \ensuremath{\mathit{NOT}} \}\)</span></span> or <span><span class="math inline">\(\{ \ensuremath{\mathit{NAND}} \}\)</span></span> we obtain four equivalent ways of modeling finite computation. Moreover, there are many other choices of sets of basic operations that are equivalent in power.</figcaption>
</figure>
<h2 id="computing-using-and-or-and-not." data-number="3.2">Computing using AND, OR, and NOT.</h2>
<p>An algorithm breaks down a <em>complex</em> calculation into a series of <em>simpler</em> steps. These steps can be executed in a variety of different ways, including:</p>
<ul>
<li><p>Writing down symbols on a piece of paper.</p></li>
<li><p>Modifying the current flowing on electrical wires.</p></li>
<li><p>Binding a protein to a strand of DNA.</p></li>
<li><p>Responding to a stimulus by a member of a collection (e.g., a bee in a colony, a trader in a market).</p></li>
</ul>
<p>To formally define algorithms, let us try to “err on the side of simplicity” and model our “basic steps” as truly minimal. For example, here are some very simple functions:</p>
<ul>
<li><span><span class="math inline">\(\ensuremath{\mathit{OR}}:\{0,1\}^2 \rightarrow \{0,1\}\)</span></span> defined as</li>
</ul>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{OR}}(a,b) = \begin{cases} 0 &amp; a=b=0 \\ 1 &amp; \text{otherwise} \end{cases}\]</span></div></span></p>
<ul>
<li><span><span class="math inline">\(\ensuremath{\mathit{AND}}:\{0,1\}^2 \rightarrow \{0,1\}\)</span></span> defined as</li>
</ul>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{AND}}(a,b) = \begin{cases} 1 &amp; a=b=1 \\ 0 &amp; \text{otherwise} \end{cases}\]</span></div></span></p>
<ul>
<li><span><span class="math inline">\(\ensuremath{\mathit{NOT}}:\{0,1\} \rightarrow \{0,1\}\)</span></span> defined as</li>
</ul>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{NOT}}(a) = \begin{cases} 0 &amp; a = 1 \\ 1 &amp; a = 0 \end{cases}\]</span></div></span></p>
<p>The functions <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>, are the basic logical operators used in logic and many computer systems. In the context of logic, it is common to use the notation <span><span class="math inline">\(a \wedge b\)</span></span> for <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,b)\)</span></span>, <span><span class="math inline">\(a \vee b\)</span></span> for <span><span class="math inline">\(\ensuremath{\mathit{OR}}(a,b)\)</span></span> and <span><span class="math inline">\(\overline{a}\)</span></span> and <span><span class="math inline">\(\neg a\)</span></span> for <span><span class="math inline">\(\ensuremath{\mathit{NOT}}(a)\)</span></span>, and we will use this notation as well.</p>
<p>Each one of the functions <span><span class="math inline">\(\ensuremath{\mathit{AND}},\ensuremath{\mathit{OR}},\ensuremath{\mathit{NOT}}\)</span></span> takes either one or two single bits as input, and produces a single bit as output. Clearly, it cannot get much more basic than that. However, the power of computation comes from <em>composing</em> such simple building blocks together.</p>
<div id="majorityfunctionex" class="example" title="Majority from $AND$,$OR$ and $NOT$" name="Example 3.1 (Majority from $AND$,$OR$ and $NOT$) ">
<p>Consider the function <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> that is defined as follows:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{MAJ}}(x) = \begin{cases}1 &amp; x_0 + x_1 + x_2 \geq 2 \\ 0 &amp; \text{otherwise}\end{cases} \;.\]</span></div></span></p>
<p>That is, for every <span><span class="math inline">\(x\in \{0,1\}^3\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(x)=1\)</span></span> if and only if the majority (i.e., at least two out of the three) of <span><span class="math inline">\(x\)</span></span>’s elements are equal to <span><span class="math inline">\(1\)</span></span>. Can you come up with a formula involving <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> to compute <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span>? (It would be useful for you to pause at this point and work out the formula for yourself. As a hint, although the <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> operator is needed to compute some functions, you will not need to use it to compute <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span>.)</p>
<p>Let us first try to rephrase <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(x)\)</span></span> in words: “<span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(x)=1\)</span></span> if and only if there exists some pair of distinct elements <span><span class="math inline">\(i,j\)</span></span> such that both <span><span class="math inline">\(x_i\)</span></span> and <span><span class="math inline">\(x_j\)</span></span> are equal to <span><span class="math inline">\(1\)</span></span>.” In other words it means that <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(x)=1\)</span></span> iff <em>either</em> both <span><span class="math inline">\(x_0=1\)</span></span> <em>and</em> <span><span class="math inline">\(x_1=1\)</span></span>, <em>or</em> both <span><span class="math inline">\(x_1=1\)</span></span> <em>and</em> <span><span class="math inline">\(x_2=1\)</span></span>, <em>or</em> both <span><span class="math inline">\(x_0=1\)</span></span> <em>and</em> <span><span class="math inline">\(x_2=1\)</span></span>. Since the <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> of three conditions <span><span class="math inline">\(c_0,c_1,c_2\)</span></span> can be written as <span><span class="math inline">\(\ensuremath{\mathit{OR}}(c_0,\ensuremath{\mathit{OR}}(c_1,c_2))\)</span></span>, we can now translate this into a formula as follows:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{MAJ}}(x_0,x_1,x_2) = \ensuremath{\mathit{OR}}\left(\, \ensuremath{\mathit{AND}}(x_0,x_1)\;,\; \ensuremath{\mathit{OR}} \bigl( \ensuremath{\mathit{AND}}(x_1,x_2) \;,\; \ensuremath{\mathit{AND}}(x_0,x_2) \bigr) \, \right) \;. \;\;(3.5)
\]</span><a id='eqmajandornot'></a></div></span></p>
<p>Recall that we can also write <span><span class="math inline">\(a \vee b\)</span></span> for <span><span class="math inline">\(\ensuremath{\mathit{OR}}(a,b)\)</span></span> and <span><span class="math inline">\(a \wedge b\)</span></span> for <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,b)\)</span></span>. With this notation, <a href='#eqmajandornot'>Equation 3.5</a> can also be written as</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{MAJ}}(x_0,x_1,x_2) = ((x_0 \wedge x_1) \vee (x_1 \wedge x_2)) \vee (x_0 \wedge x_2)\;.\]</span></div></span></p>
<p>We can also write <a href='#eqmajandornot'>Equation 3.5</a> in a “programming language” format, expressing it as a set of instructions for computing <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span> given the basic operations <span><span class="math inline">\(\ensuremath{\mathit{AND}},\ensuremath{\mathit{OR}},\ensuremath{\mathit{NOT}}\)</span></span>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> MAJ(X[<span class="dv">0</span>],X[<span class="dv">1</span>],X[<span class="dv">2</span>]):</a>
<a class="sourceLine" id="cb2-2" title="2">    firstpair  <span class="op">=</span> AND(X[<span class="dv">0</span>],X[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb2-3" title="3">    secondpair <span class="op">=</span> AND(X[<span class="dv">1</span>],X[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb2-4" title="4">    thirdpair  <span class="op">=</span> AND(X[<span class="dv">0</span>],X[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb2-5" title="5">    temp       <span class="op">=</span> OR(secondpair,thirdpair)</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="cf">return</span> OR(firstpair,temp)</a></code></pre></div>
</div>
<h3 id="some-properties-of-and-and-or" data-number="3.2.1">Some properties of AND and OR</h3>
<p>Like standard addition and multiplication, the functions <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> satisfy the properties of <em>commutativity</em>: <span><span class="math inline">\(a \vee b = b \vee a\)</span></span> and <span><span class="math inline">\(a \wedge b = b \wedge a\)</span></span> and <em>associativity</em>: <span><span class="math inline">\((a \vee b) \vee c = a \vee (b \vee c)\)</span></span> and <span><span class="math inline">\((a \wedge b) \wedge c = a \wedge (b \wedge c)\)</span></span>. As in the case of addition and multiplication, we often drop the parenthesis and write <span><span class="math inline">\(a \vee b \vee c \vee d\)</span></span> for <span><span class="math inline">\(((a \vee b) \vee c) \vee d\)</span></span>, and similarly OR’s and AND’s of more terms. They also satisfy a variant of the distributive law:</p>
<div id="distributivelaw" class="solvedexercise" title="Distributive law for AND and OR" name="Solvedexercise 3.1 (Distributive law for AND and OR) ">
<p>Prove that for every <span><span class="math inline">\(a,b,c \in \{0,1\}\)</span></span>, <span><span class="math inline">\(a \wedge (b \vee c) = (a \wedge b) \vee (a \wedge c)\)</span></span>.</p>
</div>
<div class="solution" data-ref="distributivelaw" name="Solution 3.2.1">
<p>We can prove this by enumerating over all the <span><span class="math inline">\(8\)</span></span> possible values for <span><span class="math inline">\(a,b,c \in \{0,1\}\)</span></span> but it also follows from the standard distributive law. Suppose that we identify any positive integer with “true” and the value zero with “false”. Then for every numbers <span><span class="math inline">\(u,v \in \N\)</span></span>, <span><span class="math inline">\(u+v\)</span></span> is positive if and only if <span><span class="math inline">\(u \vee v\)</span></span> is true and <span><span class="math inline">\(u \cdot v\)</span></span> is positive if and only if <span><span class="math inline">\(u \wedge v\)</span></span> is true. This means that for every <span><span class="math inline">\(a,b,c \in \{0,1\}\)</span></span>, the expression <span><span class="math inline">\(a \wedge (b \vee c)\)</span></span> is true if and only if <span><span class="math inline">\(a \cdot(b+c)\)</span></span> is positive, and the expression <span><span class="math inline">\((a \wedge b) \vee (a \wedge c)\)</span></span> is true if and only if <span><span class="math inline">\(a \cdot b + a \cdot c\)</span></span> is positive, But by the standard distributive law <span><span class="math inline">\(a\cdot (b+c) = a\cdot b + a \cdot c\)</span></span> and hence the former expression is true if and only if the latter one is.</p>
</div>
<h3 id="xoraonexample" data-number="3.2.2">Extended example: Computing <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> from <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span></h3>
<p>Let us see how we can obtain a different function from the same building blocks. Define <span><span class="math inline">\(\ensuremath{\mathit{XOR}}:\{0,1\}^2 \rightarrow \{0,1\}\)</span></span> to be the function <span><span class="math inline">\(\ensuremath{\mathit{XOR}}(a,b)= a + b \mod 2\)</span></span>. That is, <span><span class="math inline">\(\ensuremath{\mathit{XOR}}(0,0)=\ensuremath{\mathit{XOR}}(1,1)=0\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{XOR}}(1,0)=\ensuremath{\mathit{XOR}}(0,1)=1\)</span></span>. We claim that we can construct <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> using only <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>.</p>
<div class="pause" name="Pause 3.2.2">
<p>As usual, it is a good exercise to try to work out the algorithm for <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> using <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> on your own before reading further.</p>
</div>
<p>The following algorithm computes <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> using <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>:</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = XORfromAONalg>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 2 </span>$XOR$ from $AND$/$OR$/$NOT$</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  \(a,b \in \{0,1\}\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>  \(XOR(a,b)\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> \(w1 \leftarrow AND(a,b)\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> \(w2 \leftarrow NOT(w1)\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> \(w3 \leftarrow OR(a,b)\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">return</span> \(AND(w2,w3)\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<div id="alganalaysis" class="lemma" name="Lemma 3.3">
<p>For every <span><span class="math inline">\(a,b\in \{0,1\}\)</span></span>, on input <span><span class="math inline">\(a,b\)</span></span>, <a href='#XORfromAONalg'>Algorithm 3.2</a> outputs <span><span class="math inline">\(a+b \mod 2\)</span></span>.</p>
</div>
<div class="proof" data-ref="alganalaysis" name="Proof 3.2.2">
<p>For every <span><span class="math inline">\(a,b\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{XOR}}(a,b)=1\)</span></span> if and only if <span><span class="math inline">\(a\)</span></span> is <em>different</em> from <span><span class="math inline">\(b\)</span></span>. On input <span><span class="math inline">\(a,b\in \{0,1\}\)</span></span>, <a href='#XORfromAONalg'>Algorithm 3.2</a> outputs <span><span class="math inline">\(\ensuremath{\mathit{AND}}(w2,w3)\)</span></span> where <span><span class="math inline">\(w2=\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{AND}}(a,b))\)</span></span> and <span><span class="math inline">\(w3=\ensuremath{\mathit{OR}}(a,b)\)</span></span>.</p>
<ul>
<li><p>If <span><span class="math inline">\(a=b=0\)</span></span> then <span><span class="math inline">\(w3=\ensuremath{\mathit{OR}}(a,b)=0\)</span></span> and so the output will be <span><span class="math inline">\(0\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(a=b=1\)</span></span> then <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,b)=1\)</span></span> and so <span><span class="math inline">\(w2=\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{AND}}(a,b))=0\)</span></span> and the output will be <span><span class="math inline">\(0\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(a=1\)</span></span> and <span><span class="math inline">\(b=0\)</span></span> (or vice versa) then both <span><span class="math inline">\(w3=\ensuremath{\mathit{OR}}(a,b)=1\)</span></span> and <span><span class="math inline">\(w1=\ensuremath{\mathit{AND}}(a,b)=0\)</span></span>, in which case the algorithm will output <span><span class="math inline">\(\ensuremath{\mathit{OR}}(\ensuremath{\mathit{NOT}}(w1),w3)=1\)</span></span>.</p></li>
</ul>
</div>
<p>We can also express <a href='#XORfromAONalg'>Algorithm 3.2</a> using a programming language. Specifically, the following is a <em>Python</em> program that computes the <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> AND(a,b): <span class="cf">return</span> a<span class="op">*</span>b</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">def</span> OR(a,b):  <span class="cf">return</span> <span class="dv">1</span><span class="op">-</span>(<span class="dv">1</span><span class="op">-</span>a)<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>b)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">def</span> NOT(a):   <span class="cf">return</span> <span class="dv">1</span><span class="op">-</span>a</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">def</span> XOR(a,b):</a>
<a class="sourceLine" id="cb3-6" title="6">    w1 <span class="op">=</span> AND(a,b)</a>
<a class="sourceLine" id="cb3-7" title="7">    w2 <span class="op">=</span> NOT(w1)</a>
<a class="sourceLine" id="cb3-8" title="8">    w3 <span class="op">=</span> OR(a,b)</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="cf">return</span> AND(w2,w3)</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="co"># Test out the code</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="bu">print</span>([<span class="ss">f&quot;XOR(</span><span class="sc">{a}</span><span class="ss">,</span><span class="sc">{b}</span><span class="ss">)=</span><span class="sc">{</span>XOR(a,b)<span class="sc">}</span><span class="ss">&quot;</span> <span class="cf">for</span> a <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>] <span class="cf">for</span> b <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb3-13" title="13"><span class="co"># [&#39;XOR(0,0)=0&#39;, &#39;XOR(0,1)=1&#39;, &#39;XOR(1,0)=1&#39;, &#39;XOR(1,1)=0&#39;]</span></a></code></pre></div>
<div id="xorthreebits" class="solvedexercise" title="Compute $XOR$ on three bits of input" name="Solvedexercise 3.2 (Compute $XOR$ on three bits of input) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_3:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> be the function defined as <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_3(a,b,c) = a + b +c \mod 2\)</span></span>. That is, <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_3(a,b,c)=1\)</span></span> if <span><span class="math inline">\(a+b+c\)</span></span> is odd, and <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_3(a,b,c)=0\)</span></span> otherwise. Show that you can compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_3\)</span></span> using AND, OR, and NOT. You can express it as a formula, use a programming language such as Python, or use a Boolean circuit.</p>
</div>
<div class="solution" data-ref="xorthreebits" name="Solution 3.2.2">
<p>Addition modulo two satisfies the same properties of <em>associativity</em> (<span><span class="math inline">\((a+b)+c=a+(b+c)\)</span></span>) and <em>commutativity</em> (<span><span class="math inline">\(a+b=b+a\)</span></span>) as standard addition. This means that, if we define <span><span class="math inline">\(a \oplus b\)</span></span> to equal <span><span class="math inline">\(a + b \mod 2\)</span></span>, then <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{XOR}}_3(a,b,c) = (a \oplus b) \oplus c
\]</span></div></span> or in other words <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{XOR}}_3(a,b,c) = \ensuremath{\mathit{XOR}}(\ensuremath{\mathit{XOR}}(a,b),c) \;.
\]</span></div></span></p>
<p>Since we know how to compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> using AND, OR, and NOT, we can compose this to compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_3\)</span></span> using the same building blocks. In Python this corresponds to the following program:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> XOR3(a,b,c):</a>
<a class="sourceLine" id="cb4-2" title="2">    w1 <span class="op">=</span> AND(a,b)</a>
<a class="sourceLine" id="cb4-3" title="3">    w2 <span class="op">=</span> NOT(w1)</a>
<a class="sourceLine" id="cb4-4" title="4">    w3 <span class="op">=</span> OR(a,b)</a>
<a class="sourceLine" id="cb4-5" title="5">    w4 <span class="op">=</span> AND(w2,w3)</a>
<a class="sourceLine" id="cb4-6" title="6">    w5 <span class="op">=</span> AND(w4,c)</a>
<a class="sourceLine" id="cb4-7" title="7">    w6 <span class="op">=</span> NOT(w5)</a>
<a class="sourceLine" id="cb4-8" title="8">    w7 <span class="op">=</span> OR(w4,c)</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="cf">return</span> AND(w6,w7)</a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co"># Let&#39;s test this out</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="bu">print</span>([<span class="ss">f&quot;XOR3(</span><span class="sc">{a}</span><span class="ss">,</span><span class="sc">{b}</span><span class="ss">,</span><span class="sc">{c}</span><span class="ss">)=</span><span class="sc">{</span>XOR3(a,b,c)<span class="sc">}</span><span class="ss">&quot;</span> <span class="cf">for</span> a <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>] <span class="cf">for</span> b <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>] <span class="cf">for</span> c <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co"># [&#39;XOR3(0,0,0)=0&#39;, &#39;XOR3(0,0,1)=1&#39;, &#39;XOR3(0,1,0)=1&#39;, &#39;XOR3(0,1,1)=0&#39;, &#39;XOR3(1,0,0)=1&#39;, &#39;XOR3(1,0,1)=0&#39;, &#39;XOR3(1,1,0)=0&#39;, &#39;XOR3(1,1,1)=1&#39;]</span></a></code></pre></div>
</div>
<div id="section-1" class="pause" name="Pause">
<p>Try to generalize the above examples to obtain a way to compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}_n:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> for every <span><span class="math inline">\(n\)</span></span> using at most <span><span class="math inline">\(4n\)</span></span> basic steps involving applications of a function in <span><span class="math inline">\(\{ \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}} , \ensuremath{\mathit{NOT}} \}\)</span></span> to outputs or previously computed values.</p>
</div>
<h3 id="informally-defining-basic-operations-and-algorithms" data-number="3.2.3">Informally defining “basic operations” and “algorithms”</h3>
<p>We have seen that we can obtain at least some examples of interesting functions by composing together applications of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>. This suggests that we can use <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> as our “basic operations”, hence obtaining the following definition of an “algorithm”:</p>
<blockquote>
<div class="quote" name="Quote 3.2.3">
<p><strong>Semi-formal definition of an algorithm:</strong> An <em>algorithm</em> consists of a sequence of steps of the form “compute a new value by applying <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, or <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> to previously computed values”.</p>
<p>An algorithm <span><span class="math inline">\(A\)</span></span> <em>computes</em> a function <span><span class="math inline">\(F\)</span></span> if for every input <span><span class="math inline">\(x\)</span></span> to <span><span class="math inline">\(F\)</span></span>, if we feed <span><span class="math inline">\(x\)</span></span> as input to the algorithm, the value computed in its last step is <span><span class="math inline">\(F(x)\)</span></span>.</p>
</div>
</blockquote>
<p>There are several concerns that are raised by this definition:</p>
<ol type="1">
<li><p>First and foremost, this definition is indeed too informal. We do not specify exactly what each step does, nor what it means to “feed <span><span class="math inline">\(x\)</span></span> as input”.</p></li>
<li><p>Second, the choice of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> or <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> seems rather arbitrary. Why not <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span>? Why not allow operations like addition and multiplication? What about any other logical constructions such <code>if</code>/<code>then</code> or <code>while</code>?</p></li>
<li><p>Third, do we even know that this definition has anything to do with actual computing? If someone gave us a description of such an algorithm, could we use it to actually compute the function in the real world?</p></li>
</ol>
<div id="section-2" class="pause" name="Pause">
<p>These concerns will to a large extent guide us in the upcoming chapters. Thus you would be well advised to re-read the above informal definition and see what you think about these issues.</p>
</div>
<p>A large part of this book will be devoted to addressing the above issues. We will see that:</p>
<ol type="1">
<li><p>We can make the definition of an algorithm fully formal, and so give a precise mathematical meaning to statements such as “Algorithm <span><span class="math inline">\(A\)</span></span> computes function <span><span class="math inline">\(f\)</span></span>”.</p></li>
<li><p>While the choice of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> is arbitrary, and we could just as well have chosen other functions, we will also see this choice does not matter much. We will see that we would obtain the same computational power if we instead used addition and multiplication, and essentially every other operation that could be reasonably thought of as a basic step.</p></li>
<li><p>It turns out that we can and do compute such “<span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> based algorithms” in the real world. First of all, such an algorithm is clearly well specified, and so can be executed by a human with a pen and paper. Second, there are a variety of ways to <em>mechanize</em> this computation. We’ve already seen that we can write Python code that corresponds to following such a list of instructions. But in fact we can directly implement operations such as <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> via electronic signals using components known as <em>transistors</em>. This is how modern electronic computers operate.</p></li>
</ol>
<p>In the remainder of this chapter, and the rest of this book, we will begin to answer some of these questions. We will see more examples of the power of simple operations to compute more complex operations including addition, multiplication, sorting and more. We will also discuss how to <em>physically implement</em> simple operations such as <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> using a variety of technologies.</p>
<h2 id="booleancircuitfig" data-number="3.3">Boolean Circuits</h2>
<figure>
<img src="../figure/logicgates.png" alt="3.7: Standard symbols for the logical operations or “gates” of \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, \ensuremath{\mathit{NOT}}, as well as the operation \ensuremath{\mathit{NAND}} discussed in ." id="logicgatesfig" class="margin" /><figcaption>3.7: Standard symbols for the logical operations or “gates” of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>, as well as the operation <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> discussed in <a href='#nandsec'>Section 3.5</a>.</figcaption>
</figure>
<figure>
<img src="../figure/xorcircuitschemdraw.png" alt="3.8: A circuit with \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}} and \ensuremath{\mathit{NOT}} gates for computing the \ensuremath{\mathit{XOR}} function." id="andornotcircxorfig" class="margin" /><figcaption>3.8: A circuit with <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> gates for computing the <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> function.</figcaption>
</figure>
<p><em>Boolean circuits</em> provide a precise notion of “composing basic operations together”. A Boolean circuit (see <a href='#boolancircfig'>Figure 3.9</a>) is composed of <em>gates</em> and <em>inputs</em> that are connected by <em>wires</em>. The <em>wires</em> carry a signal that represents either the value <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>. Each gate corresponds to either the <em>OR</em>, <em>AND</em>, or <em>NOT</em> operation. An <em>OR gate</em> has two incoming wires, and one or more outgoing wires. If these two incoming wires carry the signals <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(b\)</span></span> (for <span><span class="math inline">\(a,b \in \{0,1\}\)</span></span>), then the signal on the outgoing wires will be <span><span class="math inline">\(\ensuremath{\mathit{OR}}(a,b)\)</span></span>. <em>AND</em> and <em>NOT</em> gates are defined similarly. The <em>inputs</em> have only outgoing wires. If we set a certain input to a value <span><span class="math inline">\(a\in \{0,1\}\)</span></span>, then this value is propagated on all the wires outgoing from it. We also designate some gates as <em>output gates</em>, and their value corresponds to the result of evaluating the circuit. For example, <a href='#andornotcircxorfig'>Figure 3.8</a> gives such a circuit for the <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> function, following <a href='#xoraonexample'>Subsection 3.2.2</a>. We evaluate an <span><span class="math inline">\(n\)</span></span>-input Boolean circuit <span><span class="math inline">\(C\)</span></span> on an input <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> by placing the bits of <span><span class="math inline">\(x\)</span></span> on the inputs, and then propagating the values on the wires until we reach an output, see <a href='#boolancircfig'>Figure 3.9</a>.</p>
<div id="booleancircimprem" class="remark" title="Physical realization of Boolean circuits" name="Remark 3.4 (Physical realization of Boolean circuits) ">
<p>Boolean circuits are a <em>mathematical model</em> that does not necessarily correspond to a physical object, but they can be implemented physically. In physical implementation of circuits, the signal is <a href="https://goo.gl/gntTQE">often implemented</a> by electric potential, or <em>voltage</em>, on a wire, where for example voltage above a certain level is interpreted as a logical value of <span><span class="math inline">\(1\)</span></span>, and below a certain level is interpreted as a logical value of <span><span class="math inline">\(0\)</span></span>. <a href='#physicalimplementationsec'>Section 3.4</a> discusses physical implementation of Boolean circuits (with examples including using electrical signals such as in silicon-based circuits, but also biological and mechanical implementations as well).</p>
</div>
<figure>
<img src="../figure/booleancircuit.png" alt="3.9: A Boolean Circuit consists of gates that are connected by wires to one another and the inputs. The left side depicts a circuit with 2 inputs and 5 gates, one of which is designated the output gate. The right side depicts the evaluation of this circuit on the input x\in \{0,1\}^2 with x_0=1 and x_1=0. The value of every gate is obtained by applying the corresponding function (\ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, or \ensuremath{\mathit{NOT}}) to values on the wire(s) that enter it. The output of the circuit on a given input is the value of the output gate(s). In this case, the circuit computes the \ensuremath{\mathit{XOR}} function and hence it outputs 1 on the input 10." id="boolancircfig" /><figcaption>3.9: A <em>Boolean Circuit</em> consists of <em>gates</em> that are connected by <em>wires</em> to one another and the <em>inputs</em>. The left side depicts a circuit with <span><span class="math inline">\(2\)</span></span> inputs and <span><span class="math inline">\(5\)</span></span> gates, one of which is designated the output gate. The right side depicts the evaluation of this circuit on the input <span><span class="math inline">\(x\in \{0,1\}^2\)</span></span> with <span><span class="math inline">\(x_0=1\)</span></span> and <span><span class="math inline">\(x_1=0\)</span></span>. The value of every gate is obtained by applying the corresponding function (<span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, or <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>) to values on the wire(s) that enter it. The output of the circuit on a given input is the value of the output gate(s). In this case, the circuit computes the <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> function and hence it outputs <span><span class="math inline">\(1\)</span></span> on the input <span><span class="math inline">\(10\)</span></span>.</figcaption>
</figure>
<div id="allequalex" class="solvedexercise" title="All equal function" name="Solvedexercise 3.3 (All equal function) ">
<p>Define <span><span class="math inline">\(\ensuremath{\mathit{ALLEQ}}:\{0,1\}^4 \rightarrow \{0,1\}\)</span></span> to be the function that on input <span><span class="math inline">\(x\in \{0,1\}^4\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(x_0=x_1=x_2=x_3\)</span></span>. Give a Boolean circuit for computing <span><span class="math inline">\(\ensuremath{\mathit{ALLEQ}}\)</span></span>.</p>
</div>
<div class="solution" data-ref="allequalex" name="Solution 3.3">
<p>Another way to describe the function <span><span class="math inline">\(\ensuremath{\mathit{ALLEQ}}\)</span></span> is that it outputs <span><span class="math inline">\(1\)</span></span> on an input <span><span class="math inline">\(x\in \{0,1\}^4\)</span></span> if and only if <span><span class="math inline">\(x = 0^4\)</span></span> or <span><span class="math inline">\(x=1^4\)</span></span>. We can phrase the condition <span><span class="math inline">\(x=1^4\)</span></span> as <span><span class="math inline">\(x_0 \wedge x_1 \wedge x_2 \wedge x_3\)</span></span> which can be computed using three AND gates. Similarly we can phrase the condition <span><span class="math inline">\(x=0^4\)</span></span> as <span><span class="math inline">\(\overline{x}_0 \wedge \overline{x}_1 \wedge \overline{x}_2 \wedge \overline{x}_3\)</span></span> which can be computed using four NOT gates and three AND gates. The output of <span><span class="math inline">\(\ensuremath{\mathit{ALLEQ}}\)</span></span> is the OR of these two conditions, which results in the circuit of 4 NOT gates, 6 AND gates, and one OR gate presented in <a href='#allequalfig'>Figure 3.10</a>.</p>
</div>
<figure>
<img src="../figure/allequalcirc2.png" alt="3.10: A Boolean circuit for computing the all equal function \ensuremath{\mathit{ALLEQ}}:\{0,1\}^4 \rightarrow \{0,1\} that outputs 1 on x\in \{0,1\}^4 if and only if x_0=x_1=x_2=x_3." id="allequalfig" class="margin" /><figcaption>3.10: A Boolean circuit for computing the <em>all equal</em> function <span><span class="math inline">\(\ensuremath{\mathit{ALLEQ}}:\{0,1\}^4 \rightarrow \{0,1\}\)</span></span> that outputs <span><span class="math inline">\(1\)</span></span> on <span><span class="math inline">\(x\in \{0,1\}^4\)</span></span> if and only if <span><span class="math inline">\(x_0=x_1=x_2=x_3\)</span></span>.</figcaption>
</figure>
<h3 id="boolean-circuits-a-formal-definition" data-number="3.3.1">Boolean circuits: a formal definition</h3>
<p>We defined Boolean circuits informally as obtained by connecting <em>AND</em>, <em>OR</em>, and <em>NOT</em> gates via wires so as to produce an output from an input. However, to be able to prove theorems about the existence or non-existence of Boolean circuits for computing various functions we need to:</p>
<ol type="1">
<li><p>Formally define a Boolean circuit as a mathematical object.</p></li>
<li><p>Formally define what it means for a circuit <span><span class="math inline">\(C\)</span></span> to compute a function <span><span class="math inline">\(f\)</span></span>.</p></li>
</ol>
<p>We now proceed to do so. We will define a Boolean circuit as a labeled <em>Directed Acyclic Graph (DAG)</em>. The <em>vertices</em> of the graph correspond to the gates and inputs of the circuit, and the <em>edges</em> of the graph correspond to the wires. A wire from an input or gate <span><span class="math inline">\(u\)</span></span> to a gate <span><span class="math inline">\(v\)</span></span> in the circuit corresponds to a directed edge between the corresponding vertices. The inputs are vertices with no incoming edges, while each gate has the appropriate number of incoming edges based on the function it computes. (That is, <em>AND</em> and <em>OR</em> gates have two in-neighbors, while <em>NOT</em> gates have one in-neighbor.) The formal definition is as follows (see also <a href='#generalcircuitfig'>Figure 3.11</a>):</p>
<figure>
<img src="../figure/generalcircuit.png" alt="3.11: A Boolean Circuit is a labeled directed acyclic graph (DAG). It has n input vertices, which are marked with X[0],\ldots, X[n-1] and have no incoming edges, and the rest of the vertices are gates. AND, OR, and NOT gates have two, two, and one incoming edges, respectively. If the circuit has m outputs, then m of the gates are known as outputs and are marked with Y[0],\ldots,Y[m-1]. When we evaluate a circuit C on an input x\in \{0,1\}^n, we start by setting the value of the input vertices to x_0,\ldots,x_{n-1} and then propagate the values, assigning to each gate g the result of applying the operation of g to the values of g’s in-neighbors. The output of the circuit is the value assigned to the output gates." id="generalcircuitfig" /><figcaption>3.11: A <em>Boolean Circuit</em> is a labeled directed acyclic graph (DAG). It has <span><span class="math inline">\(n\)</span></span> <em>input</em> vertices, which are marked with <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>, <code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> and have no incoming edges, and the rest of the vertices are <em>gates</em>. <em>AND</em>, <em>OR</em>, and <em>NOT</em> gates have two, two, and one incoming edges, respectively. If the circuit has <span><span class="math inline">\(m\)</span></span> outputs, then <span><span class="math inline">\(m\)</span></span> of the gates are known as <em>outputs</em> and are marked with <code>Y[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>,<code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code>. When we evaluate a circuit <span><span class="math inline">\(C\)</span></span> on an input <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, we start by setting the value of the input vertices to <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span> and then propagate the values, assigning to each gate <span><span class="math inline">\(g\)</span></span> the result of applying the operation of <span><span class="math inline">\(g\)</span></span> to the values of <span><span class="math inline">\(g\)</span></span>’s in-neighbors. The output of the circuit is the value assigned to the output gates.</figcaption>
</figure>
<div id="booleancircdef" class="definition" title="Boolean Circuits" name="Definition 3.5 (Boolean Circuits) ">
<p>Let <span><span class="math inline">\(n,m,s\)</span></span> be positive integers with <span><span class="math inline">\(s \geq m\)</span></span>. A <em>Boolean circuit</em> with <span><span class="math inline">\(n\)</span></span> inputs, <span><span class="math inline">\(m\)</span></span> outputs, and <span><span class="math inline">\(s\)</span></span> gates, is a labeled directed acyclic graph (DAG) <span><span class="math inline">\(G=(V,E)\)</span></span> with <span><span class="math inline">\(s+n\)</span></span> vertices satisfying the following properties:</p>
<ul>
<li><p>Exactly <span><span class="math inline">\(n\)</span></span> of the vertices have no in-neighbors. These vertices are known as <em>inputs</em> and are labeled with the <span><span class="math inline">\(n\)</span></span> labels <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code>, <span><span class="math inline">\(\ldots\)</span></span>, <code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code>. Each input has at least one out-neighbor.</p></li>
<li><p>The other <span><span class="math inline">\(s\)</span></span> vertices are known as <em>gates</em>. Each gate is labeled with <span><span class="math inline">\(\wedge\)</span></span>, <span><span class="math inline">\(\vee\)</span></span> or <span><span class="math inline">\(\neg\)</span></span>. Gates labeled with <span><span class="math inline">\(\wedge\)</span></span> (<em>AND</em>) or <span><span class="math inline">\(\vee\)</span></span> (<em>OR</em>) have two in-neighbors. Gates labeled with <span><span class="math inline">\(\neg\)</span></span> (<em>NOT</em>) have one in-neighbor. We will allow parallel edges.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></li>
<li><p>Exactly <span><span class="math inline">\(m\)</span></span> of the gates are also labeled with the <span><span class="math inline">\(m\)</span></span> labels <code>Y[</code><span><span class="math inline">\(0\)</span></span><code>]</code>, <span><span class="math inline">\(\ldots\)</span></span>, <code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code> (in addition to their label <span><span class="math inline">\(\wedge\)</span></span>/<span><span class="math inline">\(\vee\)</span></span>/<span><span class="math inline">\(\neg\)</span></span>). These are known as <em>outputs</em>.</p></li>
</ul>
<p>The <em>size</em> of a Boolean circuit is the number of gates it contains.</p>
</div>
<div class="pause" name="Pause 3.3.1">
<p>This is a non-trivial mathematical definition, so it is worth taking the time to read it slowly and carefully. As in all mathematical definitions, we are using a known mathematical object — a directed acyclic graph (DAG) — to define a new object, a Boolean circuit. This might be a good time to review some of the basic properties of DAGs and in particular the fact that they can be <em>topologically sorted</em>, see <a href='lec_00_1_math_background.html#topsortsec'>Section 1.6</a>.</p>
</div>
<p>If <span><span class="math inline">\(C\)</span></span> is a circuit with <span><span class="math inline">\(n\)</span></span> inputs and <span><span class="math inline">\(m\)</span></span> outputs, and <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, then we can compute the output of <span><span class="math inline">\(C\)</span></span> on the input <span><span class="math inline">\(x\)</span></span> in the natural way: assign the input vertices <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code>, <span><span class="math inline">\(\ldots\)</span></span>, <code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> the values <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>, apply each gate on the values of its in-neighbors, and then output the values that correspond to the output vertices. Formally, this is defined as follows:</p>
<div id="circuitcomputedef" class="definition" title="Computing a function via a Boolean circuit" name="Definition 3.6 (Computing a function via a Boolean circuit) ">
<p>Let <span><span class="math inline">\(C\)</span></span> be a Boolean circuit with <span><span class="math inline">\(n\)</span></span> inputs and <span><span class="math inline">\(m\)</span></span> outputs. For every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, the <em>output</em> of <span><span class="math inline">\(C\)</span></span> on the input <span><span class="math inline">\(x\)</span></span>, denoted by <span><span class="math inline">\(C(x)\)</span></span>, is defined as the result of the following process:</p>
<p>We let <span><span class="math inline">\(h:V \rightarrow \N\)</span></span> be the <em>minimal layering</em> of <span><span class="math inline">\(C\)</span></span> (aka <em>topological sorting</em>, see <a href='lec_00_1_math_background.html#minimallayeruniquethm'>Theorem 1.26</a>). We let <span><span class="math inline">\(L\)</span></span> be the maximum layer of <span><span class="math inline">\(h\)</span></span>, and for <span><span class="math inline">\(\ell=0,1,\ldots,L\)</span></span> we do the following:</p>
<ul>
<li><p>For every <span><span class="math inline">\(v\)</span></span> in the <span><span class="math inline">\(\ell\)</span></span>-th layer (i.e., <span><span class="math inline">\(v\)</span></span> such that <span><span class="math inline">\(h(v)=\ell\)</span></span>) do:</p>
<ul>
<li><p>If <span><span class="math inline">\(v\)</span></span> is an input vertex labeled with <code>X[</code><span><span class="math inline">\(i\)</span></span><code>]</code> for some <span><span class="math inline">\(i\in [n]\)</span></span>, then we assign to <span><span class="math inline">\(v\)</span></span> the value <span><span class="math inline">\(x_i\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(v\)</span></span> is a gate vertex labeled with <span><span class="math inline">\(\wedge\)</span></span> and with two in-neighbors <span><span class="math inline">\(u,w\)</span></span> then we assign to <span><span class="math inline">\(v\)</span></span> the <em>AND</em> of the values assigned to <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(w\)</span></span>. (Since <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(w\)</span></span> are in-neighbors of <span><span class="math inline">\(v\)</span></span>, they are in a lower layer than <span><span class="math inline">\(v\)</span></span>, and hence their values have already been assigned.)</p></li>
<li><p>If <span><span class="math inline">\(v\)</span></span> is a gate vertex labeled with <span><span class="math inline">\(\vee\)</span></span> and with two in-neighbors <span><span class="math inline">\(u,w\)</span></span> then we assign to <span><span class="math inline">\(v\)</span></span> the OR of the values assigned to <span><span class="math inline">\(u\)</span></span> and <span><span class="math inline">\(w\)</span></span>.</p></li>
<li><p>If <span><span class="math inline">\(v\)</span></span> is a gate vertex labeled with <span><span class="math inline">\(\neg\)</span></span> and with one in-neighbor <span><span class="math inline">\(u\)</span></span> then we assign to <span><span class="math inline">\(v\)</span></span> the negation of the value assigned to <span><span class="math inline">\(u\)</span></span>.</p></li>
</ul></li>
<li><p>The result of this process is the value <span><span class="math inline">\(y\in \{0,1\}^m\)</span></span> such that for every <span><span class="math inline">\(j\in [m]\)</span></span>, <span><span class="math inline">\(y_j\)</span></span> is the value assigned to the vertex with label <code>Y[</code><span><span class="math inline">\(j\)</span></span><code>]</code>.</p></li>
</ul>
<p>Let <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span>. We say that the circuit <span><span class="math inline">\(C\)</span></span> <em>computes</em> <span><span class="math inline">\(f\)</span></span> if for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(C(x)=f(x)\)</span></span>.</p>
</div>
<div id="booleancircuitsremarks" class="remark" title="Boolean circuits nitpicks (optional)" name="Remark 3.7 (Boolean circuits nitpicks (optional)) ">
<p>In phrasing <a href='#booleancircdef'>Definition 3.5</a>, we’ve made some technical choices that are not very important, but will be convenient for us later on. Having parallel edges means an AND or OR gate <span><span class="math inline">\(u\)</span></span> can have both its in-neighbors be the same gate <span><span class="math inline">\(v\)</span></span>. Since <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,a)=\ensuremath{\mathit{OR}}(a,a)=a\)</span></span> for every <span><span class="math inline">\(a\in \{0,1\}\)</span></span>, such parallel edges don’t help in computing new values in circuits with AND/OR/NOT gates. However, we will see circuits with more general sets of gates later on. The condition that every input vertex has at least one out-neighbor is also not very important because we can always add “dummy gates” that touch these inputs. However, it is convenient since it guarantees that (since every gate has at most two in-neighbors) that the number of inputs in a circuit is never larger than twice its size.</p>
</div>
<h3 id="equivalence-of-circuits-and-straight-line-programs" data-number="3.3.2">Equivalence of circuits and straight-line programs</h3>
<p>We have seen two ways to describe how to compute a function <span><span class="math inline">\(f\)</span></span> using <em>AND</em>, <em>OR</em> and <em>NOT</em>:</p>
<ul>
<li><p>A <em>Boolean circuit</em>, defined in <a href='#booleancircdef'>Definition 3.5</a>, computes <span><span class="math inline">\(f\)</span></span> by connecting via wires <em>AND</em>, <em>OR</em>, and <em>NOT</em> gates to the inputs.</p></li>
<li><p>We can also describe such a computation using a <em>straight-line program</em> that has lines of the form <code>foo = AND(bar,blah)</code>, <code>foo = OR(bar,blah)</code> and <code>foo = NOT(bar)</code> where <code>foo</code>, <code>bar</code> and <code>blah</code> are variable names. (We call this a <em>straight-line program</em> since it contains no loops or branching (e.g., if/then) statements.)</p></li>
</ul>
<p>We now formally define the AON-CIRC programming language (“AON” stands for <em>AND</em>/<em>OR</em>/<em>NOT</em>; “CIRC” stands for <em>circuit</em>) which has the above operations, and show that it is equivalent to Boolean circuits.</p>
<div id="AONcircdef" class="definition" title="AON-CIRC Programming language" name="Definition 3.8 (AON-CIRC Programming language) ">
<p>An <em>AON-CIRC program</em> is a string of lines of the form <code>foo = AND(bar,blah)</code>, <code>foo = OR(bar,blah)</code> and <code>foo = NOT(bar)</code> where <code>foo</code>, <code>bar</code> and <code>blah</code> are variable names.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Variables of the form <code>X[</code><span><span class="math inline">\(i\)</span></span><code>]</code> are known as <em>input</em> variables, and variables of the form <code>Y[</code><span><span class="math inline">\(j\)</span></span><code>]</code> are known as <em>output</em> variables. In every line, the variables on the righthand side of the assignment operators must either be input variables or variables that have already been assigned a value.</p>
<p>A valid AON-CIRC program <span><span class="math inline">\(P\)</span></span> includes input variables of the form <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>,<code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> and output variables of the form <code>Y[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>, <code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code> for some <span><span class="math inline">\(n,m \geq 1\)</span></span>. If <span><span class="math inline">\(P\)</span></span> is valid AON-CIRC program and <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, then we define the <em>output of <span><span class="math inline">\(P\)</span></span> on input <span><span class="math inline">\(x\)</span></span></em>, denoted by <span><span class="math inline">\(P(x)\)</span></span>, to be the string <span><span class="math inline">\(y\in \{0,1\}^m\)</span></span> corresponding to the values of the output variables <code>Y[</code><span><span class="math inline">\(0\)</span></span><code>]</code> ,<span><span class="math inline">\(\ldots\)</span></span>, <code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code> in the execution of <span><span class="math inline">\(P\)</span></span> where we initialize the input variables <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>,<code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> to the values <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>.</p>
<p>We say that such an AON-CIRC program <span><span class="math inline">\(P\)</span></span> <em>computes</em> a function <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> if <span><span class="math inline">\(P(x)=f(x)\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>.</p>
</div>
<p>AON-CIRC is not a practical programming language: it was designed for pedagogical purposes only, as a way to model computation as composition of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>. However, AON-CIRC can still be easily implemented on a computer. The following solved exercise gives an example of an AON-CIRC program.</p>
<div id="aonforcmpsolved" class="solvedexercise" title="" name="Solvedexercise 3.4">
<p>Consider the following function <span><span class="math inline">\(\ensuremath{\mathit{CMP}}:\{0,1\}^4 \rightarrow \{0,1\}\)</span></span> that on four input bits <span><span class="math inline">\(a,b,c,d\in \{0,1\}\)</span></span>, outputs <span><span class="math inline">\(1\)</span></span> iff the number represented by <span><span class="math inline">\((a,b)\)</span></span> is larger than the number represented by <span><span class="math inline">\((c,d)\)</span></span>. That is <span><span class="math inline">\(\ensuremath{\mathit{CMP}}(a,b,c,d)=1\)</span></span> iff <span><span class="math inline">\(2a+b&gt;2c+d\)</span></span>.</p>
<p>Write an AON-CIRC program to compute <span><span class="math inline">\(\ensuremath{\mathit{CMP}}\)</span></span>.</p>
</div>
<div class="solution" data-ref="aonforcmpsolved" name="Solution 3.3.2">
<p>Writing such a program is tedious but not truly hard. To compare two numbers we first compare their most significant digit, and then go down to the next digit and so on and so forth. In this case where the numbers have just two binary digits, these comparisons are particularly simple. The number represented by <span><span class="math inline">\((a,b)\)</span></span> is larger than the number represented by <span><span class="math inline">\((c,d)\)</span></span> if and only if one of the following conditions happens:</p>
<ol type="1">
<li>The most significant bit <span><span class="math inline">\(a\)</span></span> of <span><span class="math inline">\((a,b)\)</span></span> is larger than the most significant bit <span><span class="math inline">\(c\)</span></span> of <span><span class="math inline">\((c,d)\)</span></span>.</li>
</ol>
<p>or</p>
<ol start="2" type="1">
<li>The two most significant bits <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(c\)</span></span> are equal, but <span><span class="math inline">\(b&gt;d\)</span></span>.</li>
</ol>
<p>Another way to express the same condition is the following: the number <span><span class="math inline">\((a,b)\)</span></span> is larger than <span><span class="math inline">\((c,d)\)</span></span> iff <span><span class="math inline">\(a&gt;c\)</span></span> <strong>OR</strong> (<span><span class="math inline">\(a\ge c\)</span></span> <strong>AND</strong> <span><span class="math inline">\(b&gt;d\)</span></span>).</p>
<p>For binary digits <span><span class="math inline">\(\alpha,\beta\)</span></span>, the condition <span><span class="math inline">\(\alpha&gt;\beta\)</span></span> is simply that <span><span class="math inline">\(\alpha=1\)</span></span> and <span><span class="math inline">\(\beta=0\)</span></span> or <span><span class="math inline">\(\ensuremath{\mathit{AND}}(\alpha,\ensuremath{\mathit{NOT}}(\beta))=1\)</span></span>, and the condition <span><span class="math inline">\(\alpha\ge\beta\)</span></span> is simply <span><span class="math inline">\(\ensuremath{\mathit{OR}}(\alpha, \ensuremath{\mathit{NOT}}(\beta))=1\)</span></span>. Together these observations can be used to give the following AON-CIRC program to compute <span><span class="math inline">\(\ensuremath{\mathit{CMP}}\)</span></span>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">temp_1 <span class="op">=</span> NOT(X[<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb5-2" title="2">temp_2 <span class="op">=</span> AND(X[<span class="dv">0</span>],temp_1)</a>
<a class="sourceLine" id="cb5-3" title="3">temp_3 <span class="op">=</span> OR(X[<span class="dv">0</span>],temp_1)</a>
<a class="sourceLine" id="cb5-4" title="4">temp_4 <span class="op">=</span> NOT(X[<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb5-5" title="5">temp_5 <span class="op">=</span> AND(X[<span class="dv">1</span>],temp_4)</a>
<a class="sourceLine" id="cb5-6" title="6">temp_6 <span class="op">=</span> AND(temp_5,temp_3)</a>
<a class="sourceLine" id="cb5-7" title="7">Y[<span class="dv">0</span>] <span class="op">=</span> OR(temp_2,temp_6)</a></code></pre></div>
<p>We can also present this 8-line program as a circuit with 8 gates, see <a href='#aoncmpfig'>Figure 3.12</a>.</p>
</div>
<figure>
<img src="../figure/comparecircuit.png" alt="3.12: A circuit for computing the \ensuremath{\mathit{CMP}} function. The evaluation of this circuit on (1,1,1,0) yields the output 1, since the number 3 (represented in binary as 11) is larger than the number 2 (represented in binary as 10)." id="aoncmpfig" class="margin" /><figcaption>3.12: A circuit for computing the <span><span class="math inline">\(\ensuremath{\mathit{CMP}}\)</span></span> function. The evaluation of this circuit on <span><span class="math inline">\((1,1,1,0)\)</span></span> yields the output <span><span class="math inline">\(1\)</span></span>, since the number <span><span class="math inline">\(3\)</span></span> (represented in binary as <span><span class="math inline">\(11\)</span></span>) is larger than the number <span><span class="math inline">\(2\)</span></span> (represented in binary as <span><span class="math inline">\(10\)</span></span>).</figcaption>
</figure>
<p>It turns out that AON-CIRC programs and Boolean circuits have exactly the same power:</p>
<div id="slcircuitequivthm" class="theorem" title="Equivalence of circuits and straight-line programs" name="Theorem 3.9 (Equivalence of circuits and straight-line programs) ">
<p>Let <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> and <span><span class="math inline">\(s \geq m\)</span></span> be some number. Then <span><span class="math inline">\(f\)</span></span> is computable by a Boolean circuit of <span><span class="math inline">\(s\)</span></span> gates if and only if <span><span class="math inline">\(f\)</span></span> is computable by an AON-CIRC program of <span><span class="math inline">\(s\)</span></span> lines.</p>
</div>
<div id="section-3" class="proofidea" data-ref="slcircuitequivthm" name="Proofidea">
<p>The idea is simple - AON-CIRC programs and Boolean circuits are just different ways of describing the exact same computational process. For example, an <em>AND</em> gate in a Boolean circuit corresponding to computing the <em>AND</em> of two previously-computed values. In a AON-CIRC program this will correspond to the line that stores in a variable the <code>AND</code> of two previously-computed variables.</p>
</div>
<div class="pause" name="Pause">
<p>This proof of <a href='#slcircuitequivthm'>Theorem 3.9</a> is simple at heart, but all the details it contains can make it a little cumbersome to read. You might be better off trying to work it out yourself before reading it. Our <a href="https://github.com/boazbk/tcscode">GitHub repository</a> contains a “proof by Python” of <a href='#slcircuitequivthm'>Theorem 3.9</a>: implementation of functions <code>circuit2prog</code> and <code>prog2circuits</code> mapping Boolean circuits to AON-CIRC programs and vice versa.</p>
</div>
<div class="proof" data-ref="slcircuitequivthm" name="Proof 3.3.2">
<p>Let <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span>. Since the theorem is an “if and only if” statement, to prove it we need to show both directions: translating an AON-CIRC program that computes <span><span class="math inline">\(f\)</span></span> into a circuit that computes <span><span class="math inline">\(f\)</span></span>, and translating a circuit that computes <span><span class="math inline">\(f\)</span></span> into an AON-CIRC program that does so.</p>
<p>We start with the first direction. Let <span><span class="math inline">\(P\)</span></span> be an <span><span class="math inline">\(s\)</span></span> line AON-CIRC that computes <span><span class="math inline">\(f\)</span></span>. We define a circuit <span><span class="math inline">\(C\)</span></span> as follows: the circuit will have <span><span class="math inline">\(n\)</span></span> inputs and <span><span class="math inline">\(s\)</span></span> gates. For every <span><span class="math inline">\(i \in [s]\)</span></span>, if the <span><span class="math inline">\(i\)</span></span>-th line has the form <code>foo = AND(bar,blah)</code> then the <span><span class="math inline">\(i\)</span></span>-th gate in the circuit will be an AND gate that is connected to gates <span><span class="math inline">\(j\)</span></span> and <span><span class="math inline">\(k\)</span></span> where <span><span class="math inline">\(j\)</span></span> and <span><span class="math inline">\(k\)</span></span> correspond to the last lines before <span><span class="math inline">\(i\)</span></span> where the variables <code>bar</code> and <code>blah</code> (respectively) where written to. (For example, if <span><span class="math inline">\(i=57\)</span></span> and the last line <code>bar</code> was written to is <span><span class="math inline">\(35\)</span></span> and the last line <code>blah</code> was written to is <span><span class="math inline">\(17\)</span></span> then the two in-neighbors of gate <span><span class="math inline">\(57\)</span></span> will be gates <span><span class="math inline">\(35\)</span></span> and <span><span class="math inline">\(17\)</span></span>.) If either <code>bar</code> or <code>blah</code> is an input variable then we connect the gate to the corresponding input vertex instead. If <code>foo</code> is an output variable of the form <code>Y[</code><span><span class="math inline">\(j\)</span></span><code>]</code> then we add the same label to the corresponding gate to mark it as an output gate. We do the analogous operations if the <span><span class="math inline">\(i\)</span></span>-th line involves an <code>OR</code> or a <code>NOT</code> operation (except that we use the corresponding <em>OR</em> or <em>NOT</em> gate, and in the latter case have only one in-neighbor instead of two). For every input <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, if we run the program <span><span class="math inline">\(P\)</span></span> on <span><span class="math inline">\(x\)</span></span>, then the value written that is computed in the <span><span class="math inline">\(i\)</span></span>-th line is exactly the value that will be assigned to the <span><span class="math inline">\(i\)</span></span>-th gate if we evaluate the circuit <span><span class="math inline">\(C\)</span></span> on <span><span class="math inline">\(x\)</span></span>. Hence <span><span class="math inline">\(C(x)=P(x)\)</span></span> for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>.</p>
<p>For the other direction, let <span><span class="math inline">\(C\)</span></span> be a circuit of <span><span class="math inline">\(s\)</span></span> gates and <span><span class="math inline">\(n\)</span></span> inputs that computes the function <span><span class="math inline">\(f\)</span></span>. We sort the gates according to a topological order and write them as <span><span class="math inline">\(v_0,\ldots,v_{s-1}\)</span></span>. We now can create a program <span><span class="math inline">\(P\)</span></span> of <span><span class="math inline">\(s\)</span></span> lines as follows. For every <span><span class="math inline">\(i\in [s]\)</span></span>, if <span><span class="math inline">\(v_i\)</span></span> is an AND gate with in-neighbors <span><span class="math inline">\(v_j,v_k\)</span></span> then we will add a line to <span><span class="math inline">\(P\)</span></span> of the form <code>temp_</code><span><span class="math inline">\(i\)</span></span> <code>= AND(temp_</code><span><span class="math inline">\(j\)</span></span><code>,temp_</code><span><span class="math inline">\(k\)</span></span><code>)</code>, unless one of the vertices is an input vertex or an output gate, in which case we change this to the form <code>X[.]</code> or <code>Y[.]</code> appropriately. Because we work in topological ordering, we are guaranteed that the in-neighbors <span><span class="math inline">\(v_j\)</span></span> and <span><span class="math inline">\(v_k\)</span></span> correspond to variables that have already been assigned a value. We do the same for OR and NOT gates. Once again, one can verify that for every input <span><span class="math inline">\(x\)</span></span>, the value <span><span class="math inline">\(P(x)\)</span></span> will equal <span><span class="math inline">\(C(x)\)</span></span> and hence the program computes the same function as the circuit. (Note that since <span><span class="math inline">\(C\)</span></span> is a valid circuit, per <a href='#booleancircdef'>Definition 3.5</a>, every input vertex of <span><span class="math inline">\(C\)</span></span> has at least one out-neighbor and there are exactly <span><span class="math inline">\(m\)</span></span> output gates labeled <span><span class="math inline">\(0,\ldots,m-1\)</span></span>; hence all the variables <code>X[0]</code>, <span><span class="math inline">\(\ldots\)</span></span>, <code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> and <code>Y[0]</code> ,<span><span class="math inline">\(\ldots\)</span></span>, <code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code> will appear in the program <span><span class="math inline">\(P\)</span></span>.)</p>
</div>
<figure>
<img src="../figure/aoncircequiv.png" alt="3.13: Two equivalent descriptions of the same AND/OR/NOT computation as both an AON program and a Boolean circuit." id="aoncircequivfig" class="margin" /><figcaption>3.13: Two equivalent descriptions of the same AND/OR/NOT computation as both an AON program and a Boolean circuit.</figcaption>
</figure>
<h2 id="physicalimplementationsec" data-number="3.4">Physical implementations of computing devices (digression)</h2>
<p><em>Computation</em> is an abstract notion that is distinct from its physical <em>implementations</em>. While most modern computing devices are obtained by mapping logical gates to semiconductor based transistors, over history people have computed using a huge variety of mechanisms, including mechanical systems, gas and liquid (known as <em>fluidics</em>), biological and chemical processes, and even living creatures (e.g., see <a href='#crabfig'>Figure 3.14</a> or <a href="https://www.youtube.com/watch?v=czk4xgdhdY4">this video</a> for how crabs or slime mold can be used to do computations).</p>
<p>In this section we will review some of these implementations, both so you can get an appreciation of how it is possible to directly translate Boolean circuits to the physical world, without going through the entire stack of architecture, operating systems, and compilers, as well as to emphasize that silicon-based processors are by no means the only way to perform computation. Indeed, as we will see in <a href='lec_26_quantum_computing.html#quantumchap'>Chapter 22</a>, a very exciting recent line of work involves using different media for computation that would allow us to take advantage of <em>quantum mechanical effects</em> to enable different types of algorithms.</p>
<figure>
<img src="../figure/crab-gate.jpg" alt="3.14: Crab-based logic gates from the paper “Robust soldier-crab ball gate” by Gunji, Nishiyama and Adamatzky. This is an example of an AND gate that relies on the tendency of two swarms of crabs arriving from different directions to combine to a single swarm that continues in the average of the directions." id="crabfig" class="margin" /><figcaption>3.14: Crab-based logic gates from the paper “Robust soldier-crab ball gate” by Gunji, Nishiyama and Adamatzky. This is an example of an AND gate that relies on the tendency of two swarms of crabs arriving from different directions to combine to a single swarm that continues in the average of the directions.</figcaption>
</figure>
<h3 id="transistors" data-number="3.4.1">Transistors</h3>
<p>A <em>transistor</em> can be thought of as an electric circuit with two inputs, known as the <em>source</em> and the <em>gate</em> and an output, known as the <em>sink</em>. The gate controls whether current flows from the source to the sink. In a <em>standard transistor</em>, if the gate is “ON” then current can flow from the source to the sink and if it is “OFF” then it can’t. In a <em>complementary transistor</em> this is reversed: if the gate is “OFF” then current can flow from the source to the sink and if it is “ON” then it can’t.</p>
<figure>
<img src="../figure/transistor_water.png" alt="3.15: We can implement the logic of transistors using water. The water pressure from the gate closes or opens a faucet between the source and the sink." id="transistor-water-fig" class="margin" /><figcaption>3.15: We can implement the logic of transistors using water. The water pressure from the gate closes or opens a faucet between the source and the sink.</figcaption>
</figure>
<p>There are several ways to implement the logic of a transistor. For example, we can use faucets to implement it using water pressure (e.g. <a href='#transistor-water-fig'>Figure 3.15</a>). This might seem as merely a curiosity, but there is a field known as <a href="https://en.wikipedia.org/wiki/Fluidics">fluidics</a> concerned with implementing logical operations using liquids or gasses. Some of the motivations include operating in extreme environmental conditions such as in space or a battlefield, where standard electronic equipment would not survive.</p>
<p>The standard implementations of transistors use electrical current. One of the original implementations used <em>vacuum tubes</em>. As its name implies, a vacuum tube is a tube containing nothing (i.e., a vacuum) and where a priori electrons could freely flow from the source (a wire) to the sink (a plate). However, there is a gate (a grid) between the two, where modulating its voltage can block the flow of electrons.</p>
<p>Early vacuum tubes were roughly the size of lightbulbs (and looked very much like them too). In the 1950’s they were supplanted by <em>transistors</em>, which implement the same logic using <em>semiconductors</em> which are materials that normally do not conduct electricity but whose conductivity can be modified and controlled by inserting impurities (“doping”) and applying an external electric field (this is known as the <em>field effect</em>). In the 1960’s computers started to be implemented using <em>integrated circuits</em> which enabled much greater density. In 1965, Gordon Moore predicted that the number of transistors per integrated circuit would double every year (see <a href='#moorefig'>Figure 3.16</a>), and that this would lead to “such wonders as home computers —or at least terminals connected to a central computer— automatic controls for automobiles, and personal portable communications equipment”. Since then, (adjusted versions of) this so-called “Moore’s law” have been running strong, though exponential growth cannot be sustained forever, and some physical limitations are already <a href="http://www.nature.com/news/the-chips-are-down-for-moore-s-law-1.19338">becoming apparent</a>.</p>
<figure>
<img src="../figure/gordon_moore.png" alt="3.16: The number of transistors per integrated circuits from 1959 till 1965 and a prediction that exponential growth will continue for at least another decade. Figure taken from “Cramming More Components onto Integrated Circuits”, Gordon Moore, 1965" id="moorefig" class="margin" /><figcaption>3.16: The number of transistors per integrated circuits from 1959 till 1965 and a prediction that exponential growth will continue for at least another decade. Figure taken from “Cramming More Components onto Integrated Circuits”, Gordon Moore, 1965</figcaption>
</figure>
<figure>
<img src="../figure/moore_cartoon.png" alt="3.17: Cartoon from Gordon Moore’s article “predicting” the implications of radically improving transistor density." id="moore-cartoon-fig" class="margin" /><figcaption>3.17: Cartoon from Gordon Moore’s article “predicting” the implications of radically improving transistor density.</figcaption>
</figure>
<figure>
<img src="../figure/1200px-Moore&#39;s_Law_over_120_Years.png" alt="3.18: The exponential growth in computing power over the last 120 years. Graph by Steve Jurvetson, extending a prior graph of Ray Kurzweil." id="kurzweil-fig" class="margin" /><figcaption>3.18: The exponential growth in computing power over the last 120 years. Graph by Steve Jurvetson, extending a prior graph of Ray Kurzweil.</figcaption>
</figure>
<h3 id="logical-gates-from-transistors" data-number="3.4.2">Logical gates from transistors</h3>
<p>We can use transistors to implement various Boolean functions such as <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>. For each a two-input gate <span><span class="math inline">\(G:\{0,1\}^2 \rightarrow \{0,1\}\)</span></span>, such an implementation would be a system with two input wires <span><span class="math inline">\(x,y\)</span></span> and one output wire <span><span class="math inline">\(z\)</span></span>, such that if we identify high voltage with “<span><span class="math inline">\(1\)</span></span>” and low voltage with “<span><span class="math inline">\(0\)</span></span>”, then the wire <span><span class="math inline">\(z\)</span></span> will equal to “<span><span class="math inline">\(1\)</span></span>” if and only if applying <span><span class="math inline">\(G\)</span></span> to the values of the wires <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span> is <span><span class="math inline">\(1\)</span></span> (see <a href='#logicgatestransistorsfig'>Figure 3.19</a> and <a href='#transistor-nand-fig'>Figure 3.20</a>). This means that if there exists a AND/OR/NOT circuit to compute a function <span><span class="math inline">\(g:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span>, then we can compute <span><span class="math inline">\(g\)</span></span> in the physical world using transistors as well.</p>
<figure>
<img src="../figure/DTLLogic.PNG" alt="3.19: Implementing logical gates using transistors. Figure taken from Rory Mangles’ website." id="logicgatestransistorsfig" class="margin" /><figcaption>3.19: Implementing logical gates using transistors. Figure taken from <a href="http://www.northdownfarm.co.uk/rory/tim/basiclogic.htm">Rory Mangles’ website</a>.</figcaption>
</figure>
<figure>
<img src="../figure/nand_transistor.png" alt="3.20: Implementing a NAND gate (see ) using transistors." id="transistor-nand-fig" class="margin" /><figcaption>3.20: Implementing a NAND gate (see <a href='#nandsec'>Section 3.5</a>) using transistors.</figcaption>
</figure>
<h3 id="biological-computing" data-number="3.4.3">Biological computing</h3>
<p>Computation can be based on <a href="http://www.nature.com/nrg/journal/v13/n7/full/nrg3197.html">biological or chemical systems</a>. For example the <a href="https://en.wikipedia.org/wiki/Lac_operon"><em>lac</em> operon</a> produces the enzymes needed to digest lactose only if the conditions <span><span class="math inline">\(x \wedge (\neg y)\)</span></span> hold where <span><span class="math inline">\(x\)</span></span> is “lactose is present” and <span><span class="math inline">\(y\)</span></span> is “glucose is present”. Researchers have managed to <a href="http://science.sciencemag.org/content/340/6132/554?iss=6132">create transistors</a>, and from them logic gates, based on DNA molecules (see also <a href='#transcriptorfig'>Figure 3.21</a>). One motivation for DNA computing is to achieve increased parallelism or storage density; another is to create “smart biological agents” that could perhaps be injected into bodies, replicate themselves, and fix or kill cells that were damaged by a disease such as cancer. Computing in biological systems is not restricted, of course, to DNA: even larger systems such as <a href="https://www.cs.princeton.edu/~chazelle/pubs/cacm12-natalg.pdf">flocks of birds</a> can be considered as computational processes.</p>
<figure>
<img src="../figure/transcriptor.jpg" alt="3.21: Performance of DNA-based logic gates. Figure taken from paper of Bonnet et al, Science, 2013." id="transcriptorfig" class="margin" /><figcaption>3.21: Performance of DNA-based logic gates. Figure taken from paper of <a href="http://science.sciencemag.org/content/early/2013/03/27/science.1232758.full">Bonnet et al</a>, Science, 2013.</figcaption>
</figure>
<h3 id="cellular-automata-and-the-game-of-life" data-number="3.4.4">Cellular automata and the game of life</h3>
<p><em>Cellular automata</em> is a model of a system composed of a sequence of <em>cells</em>, each of which can have a finite state. At each step, a cell updates its state based on the states of its <em>neighboring cells</em> and some simple rules. As we will discuss later in this book (see <a href='lec_07_other_models.html#cellularautomatasec'>Section 7.4</a>), cellular automata such as Conway’s “Game of Life” can be used to simulate computation gates .</p>
<figure>
<img src="../figure/game_of_life_and.png" alt="3.22: An AND gate using a “Game of Life” configuration. Figure taken from Jean-Philippe Rennard’s paper." id="gameoflifefig" class="margin" /><figcaption>3.22: An AND gate using a “Game of Life” configuration. Figure taken from <a href="http://www.rennard.org/alife/CollisionBasedRennard.pdf">Jean-Philippe Rennard’s paper</a>.</figcaption>
</figure>
<h3 id="neural-networks" data-number="3.4.5">Neural networks</h3>
<p>One computation device that we all carry with us is our own <em>brain</em>. Brains have served humanity throughout history, doing computations that range from distinguishing prey from predators, through making scientific discoveries and artistic masterpieces, to composing witty 280 character messages. The exact working of the brain is still not fully understood, but one common mathematical model for it is a (very large) <em>neural network</em>.</p>
<p>A neural network can be thought of as a Boolean circuit that instead of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> uses some other gates as the basic basis. For example, one particular basis we can use are <em>threshold gates</em>. For every vector <span><span class="math inline">\(w= (w_0,\ldots,w_{k-1})\)</span></span> of integers and integer <span><span class="math inline">\(t\)</span></span> (some or all of which could be negative), the <em>threshold function corresponding to <span><span class="math inline">\(w,t\)</span></span></em> is the function <span><span class="math inline">\(T_{w,t}:\{0,1\}^k \rightarrow \{0,1\}\)</span></span> that maps <span><span class="math inline">\(x\in \{0,1\}^k\)</span></span> to <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(\sum_{i=0}^{k-1} w_i x_i \geq t\)</span></span>. For example, the threshold function <span><span class="math inline">\(T_{w,t}\)</span></span> corresponding to <span><span class="math inline">\(w=(1,1,1,1,1)\)</span></span> and <span><span class="math inline">\(t=3\)</span></span> is simply the majority function <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_5\)</span></span> on <span><span class="math inline">\(\{0,1\}^5\)</span></span>. Threshold gates can be thought of as an approximation for <em>neuron cells</em> that make up the core of human and animal brains. To a first approximation, a neuron has <span><span class="math inline">\(k\)</span></span> inputs and a single output, and the neurons “fires” or “turns on” its output when those signals pass some threshold.</p>
<p>Many machine learning algorithms use <em>artificial neural networks</em> whose purpose is not to imitate biology but rather to perform some computational tasks, and hence are not restricted to threshold or other biologically-inspired gates. Generally, a neural network is often described as operating on signals that are real numbers, rather than <span><span class="math inline">\(0/1\)</span></span> values, and where the output of a gate on inputs <span><span class="math inline">\(x_0,\ldots,x_{k-1}\)</span></span> is obtained by applying <span><span class="math inline">\(f(\sum_i w_i x_i)\)</span></span> where <span><span class="math inline">\(f:\R \rightarrow \R\)</span></span> is an <a href="https://goo.gl/p9izfA">activation function</a> such as rectified linear unit (ReLU), Sigmoid, or many others (see <a href='#activationfunctionsfig'>Figure 3.23</a>). However, for the purposes of our discussion, all of the above are equivalent (see also <a href='#NANDsfromActivationfunctionex'>Exercise 3.13</a>). In particular we can reduce the setting of real inputs to binary inputs by representing a real number in the binary basis, and multiplying the weight of the bit corresponding to the <span><span class="math inline">\(i^{th}\)</span></span> digit by <span><span class="math inline">\(2^i\)</span></span>.</p>
<figure>
<img src="../figure/activationfuncs.png" alt="3.23: Common activation functions used in Neural Networks, including rectified linear units (ReLU), sigmoids, and hyperbolic tangent. All of those can be thought of as continuous approximations to simple the step function. All of these can be used to compute the NAND gate (see ). This property enables neural networks to (approximately) compute any function that can be computed by a Boolean circuit." id="activationfunctionsfig" class="margin" /><figcaption>3.23: Common activation functions used in Neural Networks, including rectified linear units (ReLU), sigmoids, and hyperbolic tangent. All of those can be thought of as continuous approximations to simple the step function. All of these can be used to compute the NAND gate (see <a href='#NANDsfromActivationfunctionex'>Exercise 3.13</a>). This property enables neural networks to (approximately) compute any function that can be computed by a Boolean circuit.</figcaption>
</figure>
<h3 id="a-computer-made-from-marbles-and-pipes" data-number="3.4.6">A computer made from marbles and pipes</h3>
<p>We can implement computation using many other physical media, without any electronic, biological, or chemical components. Many suggestions for <em>mechanical</em> computers have been put forward, going back at least to Gottfried Leibniz’ computing machines from the 1670s and Charles Babbage’s 1837 plan for a mechanical <a href="https://en.wikipedia.org/wiki/Analytical_Engine">“Analytical Engine”</a>. As one example, <a href='#marblefig'>Figure 3.24</a> shows a simple implementation of a NAND (negation of AND, see <a href='#nandsec'>Section 3.5</a>) gate using marbles going through pipes. We represent a logical value in <span><span class="math inline">\(\{0,1\}\)</span></span> by a pair of pipes, such that there is a marble flowing through exactly one of the pipes. We call one of the pipes the “<span><span class="math inline">\(0\)</span></span> pipe” and the other the “<span><span class="math inline">\(1\)</span></span> pipe”, and so the identity of the pipe containing the marble determines the logical value. A NAND gate corresponds to a mechanical object with two pairs of incoming pipes and one pair of outgoing pipes, such that for every <span><span class="math inline">\(a,b \in \{0,1\}\)</span></span>, if two marbles are rolling toward the object in the <span><span class="math inline">\(a\)</span></span> pipe of the first pair and the <span><span class="math inline">\(b\)</span></span> pipe of the second pair, then a marble will roll out of the object in the <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(a,b)\)</span></span>-pipe of the outgoing pair. In fact, there is even a commercially-available educational game that uses marbles as a basis of computing, see <a href='#turingtumblefig'>Figure 3.26</a>.</p>
<figure>
<img src="../figure/marble.png" alt="3.24: A physical implementation of a NAND gate using marbles. Each wire in a Boolean circuit is modeled by a pair of pipes representing the values 0 and 1 respectively, and hence a gate has four input pipes (two for each logical input) and two output pipes. If one of the input pipes representing the value 0 has a marble in it then that marble will flow to the output pipe representing the value 1. (The dashed line represents a gadget that will ensure that at most one marble is allowed to flow onward in the pipe.) If both the input pipes representing the value 1 have marbles in them, then the first marble will be stuck but the second one will flow onwards to the output pipe representing the value 0." id="marblefig" class="margin" /><figcaption>3.24: A physical implementation of a NAND gate using marbles. Each wire in a Boolean circuit is modeled by a pair of pipes representing the values <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span> respectively, and hence a gate has four input pipes (two for each logical input) and two output pipes. If one of the input pipes representing the value <span><span class="math inline">\(0\)</span></span> has a marble in it then that marble will flow to the output pipe representing the value <span><span class="math inline">\(1\)</span></span>. (The dashed line represents a gadget that will ensure that at most one marble is allowed to flow onward in the pipe.) If both the input pipes representing the value <span><span class="math inline">\(1\)</span></span> have marbles in them, then the first marble will be stuck but the second one will flow onwards to the output pipe representing the value <span><span class="math inline">\(0\)</span></span>.</figcaption>
</figure>
<figure>
<img src="../figure/gadget.png" alt="3.25: A “gadget” in a pipe that ensures that at most one marble can pass through it. The first marble that passes causes the barrier to lift and block new ones." id="gadgetfig" class="margin" /><figcaption>3.25: A “gadget” in a pipe that ensures that at most one marble can pass through it. The first marble that passes causes the barrier to lift and block new ones.</figcaption>
</figure>
<figure>
<img src="../figure/turingtumble.png" alt="3.26: The game “Turing Tumble” contains an implementation of logical gates using marbles." id="turingtumblefig" class="margin" /><figcaption>3.26: The game <a href="https://www.turingtumble.com/">“Turing Tumble”</a> contains an implementation of logical gates using marbles.</figcaption>
</figure>
<h2 id="nandsec" data-number="3.5">The NAND function</h2>
<p>The <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> function is another simple function that is extremely useful for defining computation. It is the function mapping <span><span class="math inline">\(\{0,1\}^2\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span> defined by:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[\ensuremath{\mathit{NAND}}(a,b) = \begin{cases} 0 &amp; a=b=1 \\ 1 &amp; \text{otherwise} \end{cases}\;.\]</span></div></span></p>
<p>As its name implies, <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> is the NOT of AND (i.e., <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(a,b)= \ensuremath{\mathit{NOT}}(\ensuremath{\mathit{AND}}(a,b))\)</span></span>), and so we can clearly compute <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> using <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>. Interestingly, the opposite direction holds as well:</p>
<div id="univnandonethm" class="theorem" title="NAND computes AND,OR,NOT" name="Theorem 3.10 (NAND computes AND,OR,NOT) ">
<p>We can compute <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> by composing only the <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> function.</p>
</div>
<div id="section-4" class="proof" data-ref="univnandonethm" name="Proof">
<p>We start with the following observation. For every <span><span class="math inline">\(a\in \{0,1\}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,a)=a\)</span></span>. Hence, <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(a,a)=\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{AND}}(a,a))=\ensuremath{\mathit{NOT}}(a)\)</span></span>. This means that <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> can compute <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>. By the principle of “double negation”, <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,b)=\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{AND}}(a,b)))\)</span></span>, and hence we can use <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> to compute <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> as well. Once we can compute <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>, we can compute <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> using <a href="https://goo.gl/TH86dH">“De Morgan’s Law”</a>: <span><span class="math inline">\(\ensuremath{\mathit{OR}}(a,b)=\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{AND}}(\ensuremath{\mathit{NOT}}(a),\ensuremath{\mathit{NOT}}(b)))\)</span></span> (which can also be written as <span><span class="math inline">\(a \vee b = \overline{\overline{a} \wedge \overline{b}}\)</span></span>) for every <span><span class="math inline">\(a,b \in \{0,1\}\)</span></span>.</p>
</div>
<div id="section-5" class="pause" name="Pause">
<p><a href='#univnandonethm'>Theorem 3.10</a>’s proof is very simple, but you should make sure that <strong>(i)</strong> you understand the statement of the theorem, and <strong>(ii)</strong> you follow its proof. In particular, you should make sure you understand why De Morgan’s law is true.</p>
</div>
<p>We can use <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> to compute many other functions, as demonstrated in the following exercise.</p>
<div id="majbynandex" class="solvedexercise" title="Compute majority with NAND" name="Solvedexercise 3.5 (Compute majority with NAND) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}: \{0,1\}^3 \rightarrow \{0,1\}\)</span></span> be the function that on input <span><span class="math inline">\(a,b,c\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> iff <span><span class="math inline">\(a+b+c \geq 2\)</span></span>. Show how to compute <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span> using a composition of <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>’s.</p>
</div>
<div class="solution" data-ref="majbynandex" name="Solution">
<p>Recall that <a href='#eqmajandornot'>Equation 3.5</a> states that</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{MAJ}}(x_0,x_1,x_2) = \ensuremath{\mathit{OR}}\left(\, \ensuremath{\mathit{AND}}(x_0,x_1)\;,\; \ensuremath{\mathit{OR}} \bigl( \ensuremath{\mathit{AND}}(x_1,x_2) \;,\; \ensuremath{\mathit{AND}}(x_0,x_2) \bigr) \, \right) \;. \;\;(3.10)
\]</span><a id='eqmajandornotrestated'></a></div></span></p>
<p>We can use <a href='#univnandonethm'>Theorem 3.10</a> to replace all the occurrences of <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> with <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>’s. Specifically, we can use the equivalence <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,b)=\ensuremath{\mathit{NOT}}(\ensuremath{\mathit{NAND}}(a,b))\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}(a,b)=\ensuremath{\mathit{NAND}}(\ensuremath{\mathit{NOT}}(a),\ensuremath{\mathit{NOT}}(b))\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}(a)=\ensuremath{\mathit{NAND}}(a,a)\)</span></span> to replace the righthand side of <a href='#eqmajandornotrestated'>Equation 3.10</a> with an expression involving only <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>, yielding that <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(a,b,c)\)</span></span> is equivalent to the (somewhat unwieldy) expression</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\begin{gathered}
\ensuremath{\mathit{NAND}} \biggl(\, \ensuremath{\mathit{NAND}}\Bigl(\, \ensuremath{\mathit{NAND}}\bigl(\ensuremath{\mathit{NAND}}(a,b),\ensuremath{\mathit{NAND}}(a,c)\bigr), \\
\ensuremath{\mathit{NAND}}\bigl(\ensuremath{\mathit{NAND}}(a,b),\ensuremath{\mathit{NAND}}(a,c)\bigr)\, \Bigr),\\
\ensuremath{\mathit{NAND}}(b,c) \, \biggr)
\end{gathered}
\]</span></div></span></p>
<p>The same formula can also be expressed as a circuit with NAND gates, see <a href='#majnandcircfig'>Figure 3.27</a>.</p>
</div>
<figure>
<img src="../figure/majfromnand.png" alt="3.27: A circuit with NAND gates to compute the Majority function on three bits" id="majnandcircfig" class="margin" /><figcaption>3.27: A circuit with NAND gates to compute the Majority function on three bits</figcaption>
</figure>
<h3 id="nand-circuits" data-number="3.5.1">NAND Circuits</h3>
<p>We define <em>NAND Circuits</em> as circuits in which all the gates are NAND operations. Such a circuit again corresponds to a directed acyclic graph (DAG) since all the gates correspond to the same function (i.e., NAND), we do not even need to label them, and all gates have in-degree exactly two. Despite their simplicity, NAND circuits can be quite powerful.</p>
<div id="xornandexample" class="example" title="$NAND$ circuit for $XOR$" name="Example 3.11 ($NAND$ circuit for $XOR$) ">
<p>Recall the <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> function which maps <span><span class="math inline">\(x_0,x_1 \in \{0,1\}\)</span></span> to <span><span class="math inline">\(x_0 + x_1 \mod 2\)</span></span>. We have seen in <a href='#xoraonexample'>Subsection 3.2.2</a> that we can compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> using <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>, and so by <a href='#univnandonethm'>Theorem 3.10</a> we can compute it using only <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>’s. However, the following is a direct construction of computing <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> by a sequence of NAND operations:</p>
<ol type="1">
<li>Let <span><span class="math inline">\(u = \ensuremath{\mathit{NAND}}(x_0,x_1)\)</span></span>.</li>
<li>Let <span><span class="math inline">\(v = \ensuremath{\mathit{NAND}}(x_0,u)\)</span></span></li>
<li>Let <span><span class="math inline">\(w = \ensuremath{\mathit{NAND}}(x_1,u)\)</span></span>.</li>
<li>The <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> of <span><span class="math inline">\(x_0\)</span></span> and <span><span class="math inline">\(x_1\)</span></span> is <span><span class="math inline">\(y_0 = \ensuremath{\mathit{NAND}}(v,w)\)</span></span>.</li>
</ol>
<p>One can verify that this algorithm does indeed compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> by enumerating all the four choices for <span><span class="math inline">\(x_0,x_1 \in \{0,1\}\)</span></span>. We can also represent this algorithm graphically as a circuit, see <a href='#cornandcircfig'>Figure 3.28</a>.</p>
</div>
<figure>
<img src="../figure/nandcircxor.png" alt="3.28: A circuit with NAND gates to compute the XOR of two bits." id="cornandcircfig" class="margin" /><figcaption>3.28: A circuit with NAND gates to compute the XOR of two bits.</figcaption>
</figure>
<p>In fact, we can show the following theorem:</p>
<div id="NANDuniversamthm" class="theorem" title="NAND is a universal operation" name="Theorem 3.12 (NAND is a universal operation) ">
<p>For every Boolean circuit <span><span class="math inline">\(C\)</span></span> of <span><span class="math inline">\(s\)</span></span> gates, there exists a NAND circuit <span><span class="math inline">\(C&#39;\)</span></span> of at most <span><span class="math inline">\(3s\)</span></span> gates that computes the same function as <span><span class="math inline">\(C\)</span></span>.</p>
</div>
<div id="section-6" class="proofidea" data-ref="NANDuniversamthm" name="Proofidea">
<p>The idea of the proof is to just replace every <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> gate with their NAND implementation following the proof of <a href='#univnandonethm'>Theorem 3.10</a>.</p>
</div>
<div class="proof" data-ref="NANDuniversamthm" name="Proof 3.5.1">
<p>If <span><span class="math inline">\(C\)</span></span> is a Boolean circuit, then since, as we’ve seen in the proof of <a href='#univnandonethm'>Theorem 3.10</a>, for every <span><span class="math inline">\(a,b \in \{0,1\}\)</span></span></p>
<ul>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{NOT}}(a) = \ensuremath{\mathit{NAND}}(a,a)\)</span></span></p></li>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,b) = \ensuremath{\mathit{NAND}}(\ensuremath{\mathit{NAND}}(a,b),\ensuremath{\mathit{NAND}}(a,b))\)</span></span></p></li>
<li><p><span><span class="math inline">\(\ensuremath{\mathit{OR}}(a,b) = \ensuremath{\mathit{NAND}}(\ensuremath{\mathit{NAND}}(a,a),\ensuremath{\mathit{NAND}}(b,b))\)</span></span></p></li>
</ul>
<p>we can replace every gate of <span><span class="math inline">\(C\)</span></span> with at most three <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> gates to obtain an equivalent circuit <span><span class="math inline">\(C&#39;\)</span></span>. The resulting circuit will have at most <span><span class="math inline">\(3s\)</span></span> gates.</p>
</div>
<div id="equivalencemodels" class="bigidea" name="Bigidea 3">
<p>Two models are <em>equivalent in power</em> if they can be used to compute the same set of functions.</p>
</div>
<h3 id="more-examples-of-nand-circuits-optional" data-number="3.5.2">More examples of NAND circuits (optional)</h3>
<p>Here are some more sophisticated examples of NAND circuits:</p>
<p><strong>Incrementing integers.</strong> Consider the task of computing, given as input a string <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> that represents a natural number <span><span class="math inline">\(X\in \N\)</span></span>, the representation of <span><span class="math inline">\(X+1\)</span></span>. That is, we want to compute the function <span><span class="math inline">\(\ensuremath{\mathit{INC}}_n:\{0,1\}^n \rightarrow \{0,1\}^{n+1}\)</span></span> such that for every <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{INC}}_n(x)=y\)</span></span> which satisfies <span><span class="math inline">\(\sum_{i=0}^n y_i 2^i = \left( \sum_{i=0}^{n-1} x_i 2^i \right)+1\)</span></span>. (For simplicity of notation, in this example we use the representation where the least significant digit is first rather than last.)</p>
<p>The increment operation can be very informally described as follows: <em>“Add <span><span class="math inline">\(1\)</span></span> to the least significant bit and propagate the carry”</em>. A little more precisely, in the case of the binary representation, to obtain the increment of <span><span class="math inline">\(x\)</span></span>, we scan <span><span class="math inline">\(x\)</span></span> from the least significant bit onwards, and flip all <span><span class="math inline">\(1\)</span></span>’s to <span><span class="math inline">\(0\)</span></span>’s until we encounter a bit equal to <span><span class="math inline">\(0\)</span></span>, in which case we flip it to <span><span class="math inline">\(1\)</span></span> and stop.</p>
<p>Thus we can compute the increment of <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span> by doing the following:</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = incrementalg>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 13 </span>Compute Increment Function</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  \(x_0,x_1,\ldots,x_{n-1}\) representing the number \(\sum_{i=0}^{n-1} x_i\cdot 2^i\) <span class="ps-comment"><i>#  we use LSB-first representation</i></span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span> \(y \in \{0,1\}^{n+1}\) such that \(\sum_{i=0}^n y_i \cdot 2^i =  \sum_{i=0}^{n-1} x_i\cdot 2^i + 1\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(c_0 \leftarrow 1\) <span class="ps-comment"><i>#  we pretend we have a "carry" of \(1\) initially</i></span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">for</span>{\(i=0,\ldots, n-1\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(y_i \leftarrow XOR(x_i,c_i)\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">if</span>{\(c_i=x_i=1\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> \(c_{i+1}=1\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">else</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> \(c_{i+1}=0\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endif</span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(y_n \leftarrow c_n\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p><a href='#incrementalg'>Algorithm 3.13</a> describes precisely how to compute the increment operation, and can be easily transformed into <em>Python</em> code that performs the same computation, but it does not seem to directly yield a NAND circuit to compute this. However, we can transform this algorithm line by line to a NAND circuit. For example, since for every <span><span class="math inline">\(a\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{NAND}}(a,\ensuremath{\mathit{NOT}}(a))=1\)</span></span>, we can replace the initial statement <span><span class="math inline">\(c_0=1\)</span></span> with <span><span class="math inline">\(c_0 = \ensuremath{\mathit{NAND}}(x_0,\ensuremath{\mathit{NAND}}(x_0,x_0))\)</span></span>. We already know how to compute <span><span class="math inline">\(\ensuremath{\mathit{XOR}}\)</span></span> using NAND and so we can use this to implement the operation <span><span class="math inline">\(y_i \leftarrow \ensuremath{\mathit{XOR}}(x_i,c_i)\)</span></span>. Similarly, we can write the “if” statement as saying <span><span class="math inline">\(c_{i+1} \leftarrow \ensuremath{\mathit{AND}}(c_i,x_i)\)</span></span>, or in other words <span><span class="math inline">\(c_{i+1} \leftarrow \ensuremath{\mathit{NAND}}(\ensuremath{\mathit{NAND}}(c_i,x_i),\ensuremath{\mathit{NAND}}(c_i,x_i))\)</span></span>. Finally, the assignment <span><span class="math inline">\(y_n = c_n\)</span></span> can be written as <span><span class="math inline">\(y_n = \ensuremath{\mathit{NAND}}(\ensuremath{\mathit{NAND}}(c_n,c_n),\ensuremath{\mathit{NAND}}(c_n,c_n))\)</span></span>. Combining these observations yields for every <span><span class="math inline">\(n\in \N\)</span></span>, a <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> circuit to compute <span><span class="math inline">\(\ensuremath{\mathit{INC}}_n\)</span></span>. For example, <a href='#nandincrememntcircfig'>Figure 3.29</a> shows what this circuit looks like for <span><span class="math inline">\(n=4\)</span></span>.</p>
<figure>
<img src="../figure/incrementfromnand.png" alt="3.29: NAND circuit with computing the increment function on 4 bits." id="nandincrememntcircfig" class="margin" /><figcaption>3.29: NAND circuit with computing the <em>increment</em> function on <span><span class="math inline">\(4\)</span></span> bits.</figcaption>
</figure>
<p><strong>From increment to addition.</strong> Once we have the increment operation, we can certainly compute addition by repeatedly incrementing (i.e., compute <span><span class="math inline">\(x+y\)</span></span> by performing <span><span class="math inline">\(\ensuremath{\mathit{INC}}(x)\)</span></span> <span><span class="math inline">\(y\)</span></span> times). However, that would be quite inefficient and unnecessary. With the same idea of keeping track of carries we can implement the “grade-school” addition algorithm and compute the function <span><span class="math inline">\(\ensuremath{\mathit{ADD}}_n:\{0,1\}^{2n} \rightarrow \{0,1\}^{n+1}\)</span></span> that on input <span><span class="math inline">\(x\in \{0,1\}^{2n}\)</span></span> outputs the binary representation of the sum of the numbers represented by <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span> and <span><span class="math inline">\(x_{n+1},\ldots,x_n\)</span></span>:</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = additionfromnand>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 14 </span>Addition using NAND</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  \(u \in \{0,1\}^n\), \(v\in \{0,1\}^n\) representing numbers in LSB-first binary representation.<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>  LSB-first binary representation of \(x+y\).<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(c_0 \leftarrow 0\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">for</span>{\(i=0,\ldots,n-1\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">     Let \(y_i \leftarrow u_i + v_i \mod 2\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">if</span>{\(u_i + v_i + c_i \geq 2\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">     \(c_{i+1}\leftarrow 1\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">else</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">     \(c_{i+1} \leftarrow 0\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">endif</span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"> Let \(y_n \leftarrow c_n\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p>Once again, <a href='#additionfromnand'>Algorithm 3.14</a> can be translated into a NAND circuit. The crucial observation is that the “if/then” statement simply corresponds to <span><span class="math inline">\(c_{i+1} \leftarrow \ensuremath{\mathit{MAJ}}_3(u_i,v_i,v_i)\)</span></span> and we have seen in <a href='#majbynandex'>Solvedexercise 3.5</a> that the function <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_3:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> can be computed using <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>s.</p>
<h3 id="nandcircsec" data-number="3.5.3">The NAND-CIRC Programming language</h3>
<p>Just like we did for Boolean circuits, we can define a programming-language analog of NAND circuits. It is even simpler than the AON-CIRC language since we only have a single operation. We define the <em>NAND-CIRC Programming Language</em> to be a programming language where every line has the following form:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">foo <span class="op">=</span> NAND(bar,blah)</a></code></pre></div>
<p>where <code>foo</code>, <code>bar</code> and <code>blah</code> are variable identifiers.</p>
<div id="NANDprogramexample" class="example" title="Our first NAND-CIRC program" name="Example 3.15 (Our first NAND-CIRC program) ">
<p>Here is an example of a NAND-CIRC program:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">u <span class="op">=</span> NAND(X[<span class="dv">0</span>],X[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb7-2" title="2">v <span class="op">=</span> NAND(X[<span class="dv">0</span>],u)</a>
<a class="sourceLine" id="cb7-3" title="3">w <span class="op">=</span> NAND(X[<span class="dv">1</span>],u)</a>
<a class="sourceLine" id="cb7-4" title="4">Y[<span class="dv">0</span>] <span class="op">=</span> NAND(v,w)</a></code></pre></div>
</div>
<div id="section-7" class="pause" name="Pause">
<p>Do you know what function this program computes? Hint: you have seen it before.</p>
</div>
<p>Formally, just like we did in <a href='#AONcircdef'>Definition 3.8</a> for AON-CIRC, we can define the notion of computation by a NAND-CIRC program in the natural way:</p>
<div id="NANDcomp" class="definition" title="Computing by a NAND-CIRC program" name="Definition 3.16 (Computing by a NAND-CIRC program) ">
<p>Let <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> be some function, and let <span><span class="math inline">\(P\)</span></span> be a NAND-CIRC program. We say that <span><span class="math inline">\(P\)</span></span> <em>computes</em> the function <span><span class="math inline">\(f\)</span></span> if:</p>
<ol type="1">
<li><p><span><span class="math inline">\(P\)</span></span> has <span><span class="math inline">\(n\)</span></span> input variables <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code><span><span class="math inline">\(,\ldots,\)</span></span><code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> and <span><span class="math inline">\(m\)</span></span> output variables <code>Y[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>,<code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code>.</p></li>
<li><p>For every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, if we execute <span><span class="math inline">\(P\)</span></span> when we assign to <code>X[</code><span><span class="math inline">\(0\)</span></span><code>]</code><span><span class="math inline">\(,\ldots,\)</span></span><code>X[</code><span><span class="math inline">\(n-1\)</span></span><code>]</code> the values <span><span class="math inline">\(x_0,\ldots,x_{n-1}\)</span></span>, then at the end of the execution, the output variables <code>Y[</code><span><span class="math inline">\(0\)</span></span><code>]</code>,<span><span class="math inline">\(\ldots\)</span></span>,<code>Y[</code><span><span class="math inline">\(m-1\)</span></span><code>]</code> have the values <span><span class="math inline">\(y_0,\ldots,y_{m-1}\)</span></span> where <span><span class="math inline">\(y=f(x)\)</span></span>.</p></li>
</ol>
</div>
<p>As before we can show that NAND circuits are equivalent to NAND-CIRC programs (see <a href='#progandcircfig'>Figure 3.30</a>):</p>
<div id="NANDcircslequivthm" class="theorem" title="NAND circuits and straight-line program equivalence" name="Theorem 3.17 (NAND circuits and straight-line program equivalence) ">
<p>For every <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> and <span><span class="math inline">\(s \geq m\)</span></span>, <span><span class="math inline">\(f\)</span></span> is computable by a NAND-CIRC program of <span><span class="math inline">\(s\)</span></span> lines if and only if <span><span class="math inline">\(f\)</span></span> is computable by a NAND circuit of <span><span class="math inline">\(s\)</span></span> gates.</p>
</div>
<figure>
<img src="../figure/nandcircuitequiv.png" alt="3.30: A NAND program and the corresponding circuit. Note how every line in the program corresponds to a gate in the circuit." id="progandcircfig" class="margin" /><figcaption>3.30: A NAND program and the corresponding circuit. Note how every line in the program corresponds to a gate in the circuit.</figcaption>
</figure>
<p>We omit the proof of <a href='#NANDcircslequivthm'>Theorem 3.17</a> since it follows along exactly the same lines as the equivalence of Boolean circuits and AON-CIRC program (<a href='#slcircuitequivthm'>Theorem 3.9</a>). Given <a href='#NANDcircslequivthm'>Theorem 3.17</a> and <a href='#NANDuniversamthm'>Theorem 3.12</a>, we know that we can translate every <span><span class="math inline">\(s\)</span></span>-line AON-CIRC program <span><span class="math inline">\(P\)</span></span> into an equivalent NAND-CIRC program of at most <span><span class="math inline">\(3s\)</span></span> lines. In fact, this translation can be easily done by replacing every line of the form <code>foo = AND(bar,blah)</code>, <code>foo = OR(bar,blah)</code> or <code>foo = NOT(bar)</code> with the equivalent 1-3 lines that use the <code>NAND</code> operation. Our <a href="https://github.com/boazbk/tcscode">GitHub repository</a> contains a “proof by code”: a simple Python program <code>AON2NAND</code> that transforms an AON-CIRC into an equivalent NAND-CIRC program.</p>
<div id="NANDturingcompleteness" class="remark" title="Is the NAND-CIRC programming language Turing Complete? (optional note)" name="Remark 3.18 (Is the NAND-CIRC programming language Turing Complete? (optional note)) ">
<p>You might have heard of a term called “Turing Complete” that is sometimes used to describe programming languages. (If you haven’t, feel free to ignore the rest of this remark: we define this term precisely in <a href='lec_07_other_models.html#chapequivalentmodels'>Chapter 7</a>.) If so, you might wonder if the NAND-CIRC programming language has this property. The answer is <strong>no</strong>, or perhaps more accurately, the term “Turing Completeness” is not really applicable for the NAND-CIRC programming language. The reason is that, by design, the NAND-CIRC programming language can only compute <em>finite</em> functions <span><span class="math inline">\(F:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> that take a fixed number of input bits and produce a fixed number of outputs bits. The term “Turing Complete” is only applicable to programming languages for <em>infinite</em> functions that can take inputs of arbitrary length. We will come back to this distinction later on in this book.</p>
</div>
<h2 id="equivalence-of-all-these-models" data-number="3.6">Equivalence of all these models</h2>
<p>If we put together <a href='#slcircuitequivthm'>Theorem 3.9</a>, <a href='#NANDuniversamthm'>Theorem 3.12</a>, and <a href='#NANDcircslequivthm'>Theorem 3.17</a>, we obtain the following result:</p>
<div id="equivalencemodelsthm" class="theorem" title="Equivalence between models of finite computation" name="Theorem 3.19 (Equivalence between models of finite computation) ">
<p>For every sufficiently large <span><span class="math inline">\(s,n,m\)</span></span> and <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span>, the following conditions are all equivalent to one another:</p>
<ul>
<li><p><span><span class="math inline">\(f\)</span></span> can be computed by a Boolean circuit (with <span><span class="math inline">\(\wedge,\vee,\neg\)</span></span> gates) of at most <span><span class="math inline">\(O(s)\)</span></span> gates.</p></li>
<li><p><span><span class="math inline">\(f\)</span></span> can be computed by an AON-CIRC straight-line program of at most <span><span class="math inline">\(O(s)\)</span></span> lines.</p></li>
<li><p><span><span class="math inline">\(f\)</span></span> can be computed by a NAND circuit of at most <span><span class="math inline">\(O(s)\)</span></span> gates.</p></li>
<li><p><span><span class="math inline">\(f\)</span></span> can be computed by a NAND-CIRC straight-line program of at most <span><span class="math inline">\(O(s)\)</span></span> lines.</p></li>
</ul>
</div>
<p>By “<span><span class="math inline">\(O(s)\)</span></span>” we mean that the bound is at most <span><span class="math inline">\(c\cdot s\)</span></span> where <span><span class="math inline">\(c\)</span></span> is a constant that is independent of <span><span class="math inline">\(n\)</span></span>. For example, if <span><span class="math inline">\(f\)</span></span> can be computed by a Boolean circuit of <span><span class="math inline">\(s\)</span></span> gates, then it can be computed by a NAND-CIRC program of at most <span><span class="math inline">\(3s\)</span></span> lines, and if <span><span class="math inline">\(f\)</span></span> can be computed by a NAND circuit of <span><span class="math inline">\(s\)</span></span> gates, then it can be computed by an AON-CIRC program of at most <span><span class="math inline">\(2s\)</span></span> lines.</p>
<div id="section-8" class="proofidea" data-ref="equivalencemodelsthm" name="Proofidea">
<p>We omit the formal proof, which is obtained by combining <a href='#slcircuitequivthm'>Theorem 3.9</a>, <a href='#NANDuniversamthm'>Theorem 3.12</a>, and <a href='#NANDcircslequivthm'>Theorem 3.17</a>. The key observation is that the results we have seen allow us to translate a program/circuit that computes <span><span class="math inline">\(f\)</span></span> in one of the above models into a program/circuit that computes <span><span class="math inline">\(f\)</span></span> in another model by increasing the lines/gates by at most a constant factor (in fact this constant factor is at most <span><span class="math inline">\(3\)</span></span>).</p>
</div>
<p><a href='#slcircuitequivthm'>Theorem 3.9</a> is a special case of a more general result. We can consider even more general models of computation, where instead of AND/OR/NOT or NAND, we use other operations (see <a href='#othergatessec'>Subsection 3.6.1</a> below). It turns out that Boolean circuits are equivalent in power to such models as well. The fact that all these different ways to define computation lead to equivalent models shows that we are “on the right track”. It justifies the seemingly arbitrary choices that we’ve made of using AND/OR/NOT or NAND as our basic operations, since these choices do not affect the power of our computational model. Equivalence results such as <a href='#equivalencemodelsthm'>Theorem 3.19</a> mean that we can easily translate between Boolean circuits, NAND circuits, NAND-CIRC programs and the like. We will use this ability later on in this book, often shifting to the most convenient formulation without making a big deal about it. Hence we will not worry too much about the distinction between, for example, Boolean circuits and NAND-CIRC programs.</p>
<p>In contrast, we will continue to take special care to distinguish between <em>circuits/programs</em> and <em>functions</em> (recall <a href='lec_02_representation.html#functionprogramidea'>Bigidea 2</a>). A function corresponds to a <em>specification</em> of a computational task, and it is a fundamentally different object than a program or a circuit, which corresponds to the <em>implementation</em> of the task.</p>
<h3 id="othergatessec" data-number="3.6.1">Circuits with other gate sets</h3>
<p>There is nothing special about AND/OR/NOT or NAND. For every set of functions <span><span class="math inline">\(\mathcal{G} = \{ G_0,\ldots,G_{k-1} \}\)</span></span>, we can define a notion of circuits that use elements of <span><span class="math inline">\(\mathcal{G}\)</span></span> as gates, and a notion of a “<span><span class="math inline">\(\mathcal{G}\)</span></span> programming language” where every line involves assigning to a variable <code>foo</code> the result of applying some <span><span class="math inline">\(G_i \in \mathcal{G}\)</span></span> to previously defined or input variables. Specifically, we can make the following definition:</p>
<div id="genstraight-lineprogs" class="definition" title="General straight-line programs" name="Definition 3.20 (General straight-line programs) ">
<p>Let <span><span class="math inline">\(\mathcal{F} = \{ f_0,\ldots, f_{t-1} \}\)</span></span> be a finite collection of Boolean functions, such that <span><span class="math inline">\(f_i:\{0,1\}^{k_i} \rightarrow \{0,1\}\)</span></span> for some <span><span class="math inline">\(k_i \in \N\)</span></span>. An <em><span><span class="math inline">\(\mathcal{F}\)</span></span> program</em> is a sequence of lines, each of which assigns to some variable the result of applying some <span><span class="math inline">\(f_i \in \mathcal{F}\)</span></span> to <span><span class="math inline">\(k_i\)</span></span> other variables. As above, we use <code>X[</code><span><span class="math inline">\(i\)</span></span><code>]</code> and <code>Y[</code><span><span class="math inline">\(j\)</span></span><code>]</code> to denote the input and output variables.</p>
<p>We say that <span><span class="math inline">\(\mathcal{F}\)</span></span> is a <em>universal set of operations</em> (also known as a universal gate set) if there exists a <span><span class="math inline">\(\mathcal{F}\)</span></span> program to compute the function <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>.</p>
</div>
<p>AON-CIRC programs correspond to <span><span class="math inline">\(\{AND,\ensuremath{\mathit{OR}},\ensuremath{\mathit{NOT}}\}\)</span></span> programs, NAND-CIRC programs corresponds to <span><span class="math inline">\(\mathcal{F}\)</span></span> programs for the set <span><span class="math inline">\(\mathcal{F}\)</span></span> that only contains the <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> function, but we can also define <span><span class="math inline">\(\{ \ensuremath{\mathit{IF}}, \ensuremath{\mathit{ZERO}}, \ensuremath{\mathit{ONE}}\}\)</span></span> programs (see below), or use any other set.</p>
<p>We can also define <em><span><span class="math inline">\(\mathcal{F}\)</span></span> circuits</em>, which will be directed graphs in which each <em>gate</em> corresponds to applying a function <span><span class="math inline">\(f_i \in \mathcal{F}\)</span></span>, and will each have <span><span class="math inline">\(k_i\)</span></span> incoming wires and a single outgoing wire. (If the function <span><span class="math inline">\(f_i\)</span></span> is not <em>symmetric</em>, in the sense that the order of its input matters then we need to label each wire entering a gate as to which parameter of the function it corresponds to.) As in <a href='#slcircuitequivthm'>Theorem 3.9</a>, we can show that <span><span class="math inline">\(\mathcal{F}\)</span></span> circuits and <span><span class="math inline">\(\mathcal{F}\)</span></span> programs are equivalent. We have seen that for <span><span class="math inline">\(\mathcal{F} = \{ \ensuremath{\mathit{AND}},\ensuremath{\mathit{OR}}, \ensuremath{\mathit{NOT}}\}\)</span></span>, the resulting circuits/programs are equivalent in power to the NAND-CIRC programming language, as we can compute <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> using <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>/<span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> and vice versa. This turns out to be a special case of a general phenomena— the <em>universality</em> of <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> and other gate sets — that we will explore more in depth later in this book.</p>
<div id="IZOcircuits" class="example" title="IF,ZERO,ONE circuits" name="Example 3.21 (IF,ZERO,ONE circuits) ">
<p>Let <span><span class="math inline">\(\mathcal{F} = \{ \ensuremath{\mathit{IF}} , \ensuremath{\mathit{ZERO}}, \ensuremath{\mathit{ONE}} \}\)</span></span> where <span><span class="math inline">\(\ensuremath{\mathit{ZERO}}:\{0,1\} \rightarrow \{0\}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{ONE}}:\{0,1\} \rightarrow \{1\}\)</span></span> are the constant zero and one functions,<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> and <span><span class="math inline">\(\ensuremath{\mathit{IF}}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> is the function that on input <span><span class="math inline">\((a,b,c)\)</span></span> outputs <span><span class="math inline">\(b\)</span></span> if <span><span class="math inline">\(a=1\)</span></span> and <span><span class="math inline">\(c\)</span></span> otherwise. Then <span><span class="math inline">\(\mathcal{F}\)</span></span> is universal.</p>
<p>Indeed, we can demonstrate that <span><span class="math inline">\(\{ \ensuremath{\mathit{IF}}, \ensuremath{\mathit{ZERO}} , \ensuremath{\mathit{ONE}} \}\)</span></span> is universal using the following formula for <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{NAND}}(a,b) = \ensuremath{\mathit{IF}}(a,\ensuremath{\mathit{IF}}(b,\ensuremath{\mathit{ZERO}},\ensuremath{\mathit{ONE}}),\ensuremath{\mathit{ONE}}) \;.
\]</span></div></span></p>
</div>
<p>There are also some sets <span><span class="math inline">\(\mathcal{F}\)</span></span> that are more restricted in power. For example it can be shown that if we use only AND or OR gates (without NOT) then we do <em>not</em> get an equivalent model of computation. The exercises cover several examples of universal and non-universal gate sets.</p>
<h3 id="specvsimplrem" data-number="3.6.2">Specification vs. implementation (again)</h3>
<figure>
<img src="../figure/specvsimpl.png" alt="3.31: It is crucial to distinguish between the specification of a computational task, namely what is the function that is to be computed and the implementation of it, namely the algorithm, program, or circuit that contains the instructions defining how to map an input to an output. The same function could be computed in many different ways." id="specvsimplfig" /><figcaption>3.31: It is crucial to distinguish between the <em>specification</em> of a computational task, namely <em>what</em> is the function that is to be computed and the <em>implementation</em> of it, namely the algorithm, program, or circuit that contains the instructions defining <em>how</em> to map an input to an output. The same function could be computed in many different ways.</figcaption>
</figure>
<p>As we discussed in <a href='lec_02_representation.html#secimplvsspec'>Subsection 2.5.1</a>, one of the most important distinctions in this book is that of <em>specification</em> versus <em>implementation</em> or separating “what” from “how” (see <a href='#specvsimplfig'>Figure 3.31</a>). A <em>function</em> corresponds to the <em>specification</em> of a computational task, that is <em>what</em> output should be produced for every particular input. A <em>program</em> (or circuit, or any other way to specify <em>algorithms</em>) corresponds to the <em>implementation</em> of <em>how</em> to compute the desired output from the input. That is, a program is a set of instructions how to compute the output from the input. Even within the same computational model there can be many different ways to compute the same function. For example, there is more than one NAND-CIRC program that computes the majority function, more than one Boolean circuit to compute the addition function, and so on and so forth.</p>
<p>Confusing specification and implementation (or equivalently <em>functions</em> and <em>programs</em>) is a common mistake, and one that is unfortunately encouraged by the common programming-language terminology of referring to parts of programs as “functions”. However, in both the theory and practice of computer science, it is important to maintain this distinction, and it is particularly important for us in this book.</p>
<div id="section-9" class="recap" name="Recap">
<ul>
<li>An <em>algorithm</em> is a recipe for performing a computation as a sequence of “elementary” or “simple” operations.</li>
<li>One candidate definition for “elementary” operations is the set <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>.</li>
<li>Another candidate definition for an “elementary” operation is the <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> operation. It is an operation that is easily implementable in the physical world in a variety of methods including by electronic transistors.</li>
<li>We can use <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> to compute many other functions, including majority, increment, and others.</li>
<li>There are other equivalent choices, including the sets <span><span class="math inline">\(\{AND,\ensuremath{\mathit{OR}},\ensuremath{\mathit{NOT}}\}\)</span></span> and <span><span class="math inline">\(\{ \ensuremath{\mathit{IF}}, \ensuremath{\mathit{ZERO}}, \ensuremath{\mathit{ONE}} \}\)</span></span>.</li>
<li>We can formally define the notion of a function <span><span class="math inline">\(F:\{0,1\}^n \rightarrow \{0,1\}^m\)</span></span> being computable using the <em>NAND-CIRC Programming language</em>.</li>
<li>For every set of basic operations, the notions of being computable by a circuit and being computable by a straight-line program are equivalent.</li>
</ul>
</div>
<h2 id="exercises" data-number="3.7">Exercises</h2>
<div id="comparenumbersex" class="exercise" title="Compare $4$ bit numbers" name="Exercise 3.1 (Compare $4$ bit numbers) ">
<p>Give a Boolean circuit (with AND/OR/NOT gates) that computes the function <span><span class="math inline">\(\ensuremath{\mathit{CMP}}_8:\{0,1\}^8 \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{CMP}}_8(a_0,a_1,a_2,a_3,b_0,b_1,b_2,b_3)=1\)</span></span> if and only if the number represented by <span><span class="math inline">\(a_0a_1a_2a_3\)</span></span> is larger than the number represented by <span><span class="math inline">\(b_0b_1b_2b_3\)</span></span>.</p>
</div>
<div id="compareasymnumbersex" class="exercise" title="Compare $n$ bit numbers" name="Exercise 3.2 (Compare $n$ bit numbers) ">
<p>Prove that there exists a constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(n\)</span></span> there is a Boolean circuit (with AND/OR/NOT gates) <span><span class="math inline">\(C\)</span></span> of at most <span><span class="math inline">\(c\cdot n\)</span></span> gates that computes the function <span><span class="math inline">\(\ensuremath{\mathit{CMP}}_{2n}:\{0,1\}^{2n} \rightarrow \{0,1\}\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{CMP}}_{2n}(a_0\cdots a_{n-1} b_0 \cdots b_{n-1})=1\)</span></span> if and only if the number represented by <span><span class="math inline">\(a_0 \cdots a_{n-1}\)</span></span> is larger than the number represented by <span><span class="math inline">\(b_0 \cdots b_{n-1}\)</span></span>.</p>
</div>
<div id="ornotex" class="exercise" title="OR,NOT is universal" name="Exercise 3.3 (OR,NOT is universal) ">
<p>Prove that the set <span><span class="math inline">\(\{ \ensuremath{\mathit{OR}} , \ensuremath{\mathit{NOT}} \}\)</span></span> is <em>universal</em>, in the sense that one can compute NAND using these gates.</p>
</div>
<div id="andorex" class="exercise" title="AND,OR is not universal" name="Exercise 3.4 (AND,OR is not universal) ">
<p>Prove that for every <span><span class="math inline">\(n\)</span></span>-bit input circuit <span><span class="math inline">\(C\)</span></span> that contains only AND and OR gates, as well as gates that compute the constant functions <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span>, <span><span class="math inline">\(C\)</span></span> is <em>monotone</em>, in the sense that if <span><span class="math inline">\(x,x&#39; \in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(x_i \leq x&#39;_i\)</span></span> for every <span><span class="math inline">\(i\in [n]\)</span></span>, then <span><span class="math inline">\(C(x) \leq C(x&#39;)\)</span></span>.</p>
<p>Conclude that the set <span><span class="math inline">\(\{ \ensuremath{\mathit{AND}} , \ensuremath{\mathit{OR}}, 0 , 1\}\)</span></span> is <em>not</em> universal.</p>
</div>
<div id="xorex" class="exercise" title="XOR is not universal" name="Exercise 3.5 (XOR is not universal) ">
<p>Prove that for every <span><span class="math inline">\(n\)</span></span>-bit input circuit <span><span class="math inline">\(C\)</span></span> that contains only XOR gates, as well as gates that compute the constant functions <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span>, <span><span class="math inline">\(C\)</span></span> is <em>affine or linear modulo two</em>, in the sense that there exists some <span><span class="math inline">\(a\in \{0,1\}^n\)</span></span> and <span><span class="math inline">\(b\in \{0,1\}\)</span></span> such that for every <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, <span><span class="math inline">\(C(x) = \sum_{i=0}^{n-1}a_ix_i + b \mod 2\)</span></span>.</p>
<p>Conclude that the set <span><span class="math inline">\(\{ \ensuremath{\mathit{XOR}} , 0 , 1\}\)</span></span> is <em>not</em> universal.</p>
</div>
<div id="majnotex" class="exercise" title="MAJ,NOT, 1 is universal" name="Exercise 3.6 (MAJ,NOT, 1 is universal) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> be the majority function. Prove that <span><span class="math inline">\(\{ \ensuremath{\mathit{MAJ}},\ensuremath{\mathit{NOT}}, 1 \}\)</span></span> is a universal set of gates.</p>
</div>
<div id="majnotextwo" class="exercise" title="MAJ,NOT  is not universal" name="Exercise 3.7 (MAJ,NOT  is not universal) ">
<p>Prove that <span><span class="math inline">\(\{ \ensuremath{\mathit{MAJ}},\ensuremath{\mathit{NOT}} \}\)</span></span> is not a universal set. See footnote for hint.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
</div>
<div id="norex" class="exercise" title="NOR is universal" name="Exercise 3.8 (NOR is universal) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{NOR}}:\{0,1\}^2 \rightarrow \{0,1\}\)</span></span> defined as <span><span class="math inline">\(\ensuremath{\mathit{NOR}}(a,b) = \ensuremath{\mathit{NOT}}(\ensuremath{\mathit{OR}}(a,b))\)</span></span>. Prove that <span><span class="math inline">\(\{ \ensuremath{\mathit{NOR}} \}\)</span></span> is a universal set of gates.</p>
</div>
<div id="lookupex" class="exercise" title="Lookup is universal" name="Exercise 3.9 (Lookup is universal) ">
<p>Prove that <span><span class="math inline">\(\{ \ensuremath{\mathit{LOOKUP}}_1,0,1 \}\)</span></span> is a universal set of gates where <span><span class="math inline">\(0\)</span></span> and <span><span class="math inline">\(1\)</span></span> are the constant functions and <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_1:\{0,1\}^3 \rightarrow \{0,1\}\)</span></span> satisfies <span><span class="math inline">\(\ensuremath{\mathit{LOOKUP}}_1(a,b,c)\)</span></span> equals <span><span class="math inline">\(a\)</span></span> if <span><span class="math inline">\(c=0\)</span></span> and equals <span><span class="math inline">\(b\)</span></span> if <span><span class="math inline">\(c=1\)</span></span>.</p>
</div>
<div id="universal-bound" class="exercise" title="Bound on universal basis size (challenge)" name="Exercise 3.10 (Bound on universal basis size (challenge)) ">
<p>Prove that for every subset <span><span class="math inline">\(B\)</span></span> of the functions from <span><span class="math inline">\(\{0,1\}^k\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span>, if <span><span class="math inline">\(B\)</span></span> is universal then there is a <span><span class="math inline">\(B\)</span></span>-circuit of at most <span><span class="math inline">\(O(1)\)</span></span> gates to compute the <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> function (you can start by showing that there is a <span><span class="math inline">\(B\)</span></span> circuit of at most <span><span class="math inline">\(O(k^{16})\)</span></span> gates).<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>
</div>
<div id="nandcircsizeex" class="exercise" title="Size and inputs / outputs" name="Exercise 3.11 (Size and inputs / outputs) ">
<p>Prove that for every NAND circuit of size <span><span class="math inline">\(s\)</span></span> with <span><span class="math inline">\(n\)</span></span> inputs and <span><span class="math inline">\(m\)</span></span> outputs, <span><span class="math inline">\(s \geq \min \{ n/2 , m \}\)</span></span>. See footnote for hint.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>
</div>
<div id="threshold-nand-ex" class="exercise" title="Threshold using NANDs" name="Exercise 3.12 (Threshold using NANDs) ">
<p>Prove that there is some constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(n&gt;1\)</span></span>, and integers <span><span class="math inline">\(a_0,\ldots,a_{n-1},b \in \{-2^n,-2^n+1,\ldots,-1,0,+1,\ldots,2^n\}\)</span></span>, there is a NAND circuit with at most <span><span class="math inline">\(c n^4\)</span></span> gates that computes the <em>threshold</em> function <span><span class="math inline">\(f_{a_0,\ldots,a_{n-1},b}:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> that on input <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> if and only if <span><span class="math inline">\(\sum_{i=0}^{n-1} a_i x_i &gt; b\)</span></span>.</p>
</div>
<div id="NANDsfromActivationfunctionex" class="exercise" title="NANDs from activation functions" name="Exercise 3.13 (NANDs from activation functions) ">
<p>We say that a function <span><span class="math inline">\(f:\mathbb{R}^2 \rightarrow \mathbb{R}\)</span></span> is a <em>NAND approximator</em> if it has the following property: for every <span><span class="math inline">\(a,b \in \mathbb{R}\)</span></span>, if <span><span class="math inline">\(\min\{|a|,|1-a|\}\leq 1/3\)</span></span> and <span><span class="math inline">\(\min \{ |b|,|1-b| \}\leq 1/3\)</span></span> then <span><span class="math inline">\(|f(a,b) - \ensuremath{\mathit{NAND}}(\lfloor a \rceil, \lfloor b \rceil)| \leq 1/3\)</span></span> where we denote by <span><span class="math inline">\(\lfloor x \rceil\)</span></span> the integer closest to <span><span class="math inline">\(x\)</span></span>. That is, if <span><span class="math inline">\(a,b\)</span></span> are within a distance <span><span class="math inline">\(1/3\)</span></span> to <span><span class="math inline">\(\{0,1\}\)</span></span> then we want <span><span class="math inline">\(f(a,b)\)</span></span> to equal the <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span> of the values in <span><span class="math inline">\(\{0,1\}\)</span></span> that are closest to <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(b\)</span></span> respectively. Otherwise, we do not care what the output of <span><span class="math inline">\(f\)</span></span> is on <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(b\)</span></span>.</p>
<p>In this exercise you will show that you can construct a NAND approximator from many common activation functions used in deep neural networks. As a corollary you will obtain that deep neural networks can simulate NAND circuits. Since NAND circuits can also simulate deep neural networks, these two computational models are equivalent to one another.</p>
<ol type="1">
<li><p>Show that there is a NAND approximator <span><span class="math inline">\(f\)</span></span> defined as <span><span class="math inline">\(f(a,b) = L(ReLU(L&#39;(a,b)))\)</span></span> where <span><span class="math inline">\(L&#39;:\mathbb{R}^2 \rightarrow \mathbb{R}\)</span></span> is an <em>affine</em> function (of the form <span><span class="math inline">\(L&#39;(a,b)=\alpha a + \beta b + \gamma\)</span></span> for some <span><span class="math inline">\(\alpha,\beta,\gamma \in \mathbb{R}\)</span></span>), <span><span class="math inline">\(L\)</span></span> is an affine function (of the form <span><span class="math inline">\(L(y) = \alpha y + \beta\)</span></span> for <span><span class="math inline">\(\alpha,\beta \in \mathbb{R}\)</span></span>), and <span><span class="math inline">\(ReLU:\mathbb{R} \rightarrow \mathbb{R}\)</span></span>, is the function defined as <span><span class="math inline">\(ReLU(x) = \max \{0,x \}\)</span></span>.</p></li>
<li><p>Show that there is a NAND approximator <span><span class="math inline">\(f\)</span></span> defined as <span><span class="math inline">\(f(a,b) = L(sigmoid(L&#39;(a,b)))\)</span></span> where <span><span class="math inline">\(L&#39;,L\)</span></span> are affine as above and <span><span class="math inline">\(sigmoid:\mathbb{R} \rightarrow \mathbb{R}\)</span></span> is the function defined as <span><span class="math inline">\(sigmoid(x) = e^x/(e^x+1)\)</span></span>.</p></li>
<li><p>Show that there is a NAND approximator <span><span class="math inline">\(f\)</span></span> defined as <span><span class="math inline">\(f(a,b) = L(tanh(L&#39;(a,b)))\)</span></span> where <span><span class="math inline">\(L&#39;,L\)</span></span> are affine as above and <span><span class="math inline">\(tanh:\mathbb{R} \rightarrow \mathbb{R}\)</span></span> is the function defined as <span><span class="math inline">\(tanh(x) = (e^x-e^{-x})/(e^x+e^{-x})\)</span></span>.</p></li>
<li><p>Prove that for every NAND-circuit <span><span class="math inline">\(C\)</span></span> with <span><span class="math inline">\(n\)</span></span> inputs and one output that computes a function <span><span class="math inline">\(g:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>, if we replace every gate of <span><span class="math inline">\(C\)</span></span> with a NAND-approximator and then invoke the resulting circuit on some <span><span class="math inline">\(x\in \{0,1\}^n\)</span></span>, the output will be a number <span><span class="math inline">\(y\)</span></span> such that <span><span class="math inline">\(|y-g(x)|\leq 1/3\)</span></span>.</p></li>
</ol>
</div>
<div id="majwithNAND" class="exercise" title="Majority with NANDs efficiently" name="Exercise 3.14 (Majority with NANDs efficiently) ">
<p>Prove that there is some constant <span><span class="math inline">\(c\)</span></span> such that for every <span><span class="math inline">\(n&gt;1\)</span></span>, there is a NAND circuit of at most <span><span class="math inline">\(c\cdot n\)</span></span> gates that computes the majority function on <span><span class="math inline">\(n\)</span></span> input bits <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_n:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>. That is <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}_n(x)=1\)</span></span> iff <span><span class="math inline">\(\sum_{i=0}^{n-1}x_i &gt; n/2\)</span></span>. See footnote for hint.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p>
</div>
<div id="outputlastlayer" class="exercise" title="Output at last layer" name="Exercise 3.15 (Output at last layer) ">
<p>Prove that for every <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span>, if there is a Boolean circuit <span><span class="math inline">\(C\)</span></span> of <span><span class="math inline">\(s\)</span></span> gates that computes <span><span class="math inline">\(f\)</span></span> then there is a Boolean circuit <span><span class="math inline">\(C&#39;\)</span></span> of at most <span><span class="math inline">\(s\)</span></span> gates such that in the minimal layering of <span><span class="math inline">\(C&#39;\)</span></span>, the output gate of <span><span class="math inline">\(C&#39;\)</span></span> is placed in the last layer. See footnote for hint.<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p>
</div>
<h2 id="biographical-notes" data-number="3.8">Biographical notes</h2>
<p>The excerpt from Al-Khwarizmi’s book is from “The Algebra of Ben-Musa”, Fredric Rosen, 1831.</p>
<p>Charles Babbage (1791-1871) was a visionary scientist, mathematician, and inventor (see  (<a href="https://scholar.google.com/scholar?hl=en&q=Swade+The+difference+engine+:+Charles+Babbage+and+the+quest+to+build+the+first+computer" target="_blank">Swade, 2002</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=Collier,+MacLachlan+Charles+Babbage:+And+the+engines+of+perfection" target="_blank">Collier, MacLachlan, 2000</a>) ). More than a century before the invention of modern electronic computers, Babbage realized that computation can be in principle mechanized. His first design for a mechanical computer was the <em>difference engine</em> that was designed to do polynomial interpolation. He then designed the <em>analytical engine</em> which was a much more general machine and the first prototype for a programmable general purpose computer. Unfortunately, Babbage was never able to complete the design of his prototypes. One of the earliest people to realize the engine’s potential and far reaching implications was Ada Lovelace (see the notes for <a href='lec_06_loops.html#chaploops'>Chapter 6</a>).</p>
<p>Boolean algebra was first investigated by Boole and DeMorgan in the 1840’s  (<a href="https://scholar.google.com/scholar?hl=en&q=Boole+The+mathematical+analysis+of+logic" target="_blank">Boole, 1847</a>)  (<a href="https://scholar.google.com/scholar?hl=en&q=De+Morgan+Formal+logic:+or,+the+calculus+of+inference,+necessary+and+probable" target="_blank">De Morgan, 1847</a>) . The definition of Boolean circuits and connection to electrical relay circuits was given in Shannon’s Masters Thesis  (<a href="https://scholar.google.com/scholar?hl=en&q=Shannon+A+symbolic+analysis+of+relay+and+switching+circuits" target="_blank">Shannon, 1938</a>) . (Howard Gardener called Shannon’s thesis “possibly the most important, and also the most famous, master’s thesis of the [20th] century”.) Savage’s book  (<a href="https://scholar.google.com/scholar?hl=en&q=Savage+Models+of+computation" target="_blank">Savage, 1998</a>) , like this one, introduces the theory of computation starting with Boolean circuits as the first model. Jukna’s book  (<a href="https://scholar.google.com/scholar?hl=en&q=Jukna+Boolean+function+complexity:+advances+and+frontiers" target="_blank">Jukna, 2012</a>)  contains a modern in-depth exposition of Boolean circuits, see also  (<a href="https://scholar.google.com/scholar?hl=en&q=Wegener+The+complexity+of+Boolean+functions" target="_blank">Wegener, 1987</a>) .</p>
<p>The NAND function was shown to be universal by Sheffer  (<a href="https://scholar.google.com/scholar?hl=en&q=Sheffer+A+set+of+five+independent+postulates+for+Boolean+algebras,+with+application+to+logical+constants" target="_blank">Sheffer, 1913</a>) , though this also appears in the earlier work of Peirce, see  (<a href="https://scholar.google.com/scholar?hl=en&q=Burks+Booke+review:+Charles+S.+Peirce,+The+new+elements+of+mathematics" target="_blank">Burks, 1978</a>) . Whitehead and Russell used NAND as the basis for their logic in their magnum opus <em>Principia Mathematica</em>  (<a href="https://scholar.google.com/scholar?hl=en&q=Whitehead,+Russell+Principia+mathematica" target="_blank">Whitehead, Russell, 1912</a>) . In her Ph.D thesis, Ernst  (<a href="https://scholar.google.com/scholar?hl=en&q=Ernst+Optimal+combinational+multi-level+logic+synthesis" target="_blank">Ernst, 2009</a>)  investigates empirically the minimal NAND circuits for various functions. Nissan and Shocken’s book  (<a href="https://scholar.google.com/scholar?hl=en&q=Nisan,+Schocken+The+elements+of+computing+systems:+building+a+modern+computer+from+first+principles" target="_blank">Nisan, Schocken, 2005</a>)  builds a computing system starting from NAND gates and ending with high level programs and games (“NAND to Tetris”); see also the website <a href="https://www.nand2tetris.org/">nandtotetris.org</a>.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>Having parallel edges means an AND or OR gate <span><span class="math inline">\(u\)</span></span> can have both its in-neighbors be the same gate <span><span class="math inline">\(v\)</span></span>. Since <span><span class="math inline">\(\ensuremath{\mathit{AND}}(a,a)=\ensuremath{\mathit{OR}}(a,a)=a\)</span></span> for every <span><span class="math inline">\(a\in \{0,1\}\)</span></span>, such parallel edges don’t help in computing new values in circuits with AND/OR/NOT gates. However, we will see circuits with more general sets of gates later on.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>We follow the common <a href="https://goo.gl/QyHa3b">programming languages convention</a> of using names such as <code>foo</code>, <code>bar</code>, <code>baz</code>, <code>blah</code> as stand-ins for generic identifiers. A variable identifier in our programming language can be any combination of letters, numbers, underscores, and brackets. The <a href="http://tiny.cc/introtcsappendix">appendix</a> contains a full formal specification of our programming language.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>One can also define these functions as taking a length zero input. This makes no difference for the computational power of the model.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p><em>Hint:</em> Use the fact that <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}(\overline{a},\overline{b},\overline{c}) = \overline{MAJ(a,b,c)}\)</span></span> to prove that every <span><span class="math inline">\(f:\{0,1\}^n \rightarrow \{0,1\}\)</span></span> computable by a circuit with only <span><span class="math inline">\(\ensuremath{\mathit{MAJ}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> gates satisfies <span><span class="math inline">\(f(0,0,\ldots,0) \neq f(1,1,\ldots,1)\)</span></span>. Thanks to Nathan Brunelle and David Evans for suggesting this exercise.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>Thanks to Alec Sun and Simon Fischer for comments on this problem.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p><em>Hint:</em> Use the conditions of <a href='#booleancircdef'>Definition 3.5</a> stipulating that every input vertex has at least one out-neighbor and there are exactly <span><span class="math inline">\(m\)</span></span> output gates. See also <a href='#booleancircuitsremarks'>Remark 3.7</a>.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:7"><p>
<div>
<p>One approach to solve this is using recursion and analyzing it using the so called “Master Theorem”.</p>
</div>
<a href="#fnref:7" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:8"><p>
<div>
<p><em>Hint:</em> Vertices in layers beyond the output can be safely removed without changing the functionality of the circuit.</p>
</div>
<a href="#fnref:8" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:39:23</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_03_computation.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
