<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: Lattice based cryptography</title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: Lattice based cryptography" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#concentration"><i class="fa fa-check"></i><b>0.5</b> Concentration</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_00_1_mathematical-background.html"><a href="lec_00_1_mathematical-background.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>1.1</b> Defining encryptions</a><ul><li class="chapter" data-level="1.1.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.1.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.2</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>1.3</b> Perfect Secrecy</a></li><li class="chapter" data-level="1.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.4</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#advanced-comment-adding-probability-into-the-picture"><i class="fa fa-check"></i><b>1.4.1</b> Advanced comment: Adding probability into the picture</a></li></ul></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#counting-number-of-operations."><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_computational_security.html"><a href="lec_02_computational_security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_pseudorandom-generators.html"><a href="lec_03_pseudorandom-generators.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.4</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path="lec_04_pseudorandom-functions.html"><a href="lec_04_pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path="lec_05_prf-from-prg.html"><a href="lec_05_prf-from-prg.html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the buffer overflow of cryptography</a></li><li class="chapter" data-level="6.6" data-path="lec_06_CCA.html"><a href="lec_06_CCA.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html"><i class="fa fa-check"></i><b>7</b> Hash functions and random oracles</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The bitcoin problem</a><ul><li class="chapter" data-level="7.1.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The currency problem</a></li><li class="chapter" data-level="7.1.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The bitcoin ledger</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From proof of work to consensus on ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision resistance hash functions and creating short unique identifiers</a></li><li class="chapter" data-level="7.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical constructions of cryptographic hash functions</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical random-ish functions</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some history</a></li><li class="chapter" data-level="7.4.3" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#the-nsa-and-hash-functions."><i class="fa fa-check"></i><b>7.4.3</b> The NSA and hash functions.</a></li><li class="chapter" data-level="7.4.4" data-path="lec_07_hash_functions.html"><a href="lec_07_hash_functions.html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs non-cryptographic hash functions:</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_hash_functions_part2.html"><a href="lec_08_hash_functions_part2.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path="lec_00_0_foreword.html"><a href="lec_00_0_foreword.html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path="lec_10_public_key_intro.html"><a href="lec_10_public_key_intro.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_11_concrete_pkc.html"><a href="lec_11_concrete_pkc.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li class="chapter" data-level="12.1" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#an-lwe-based-encryption-scheme"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path="lec_12_lattices.html"><a href="lec_12_lattices.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12a_CCA_public_key.html"><a href="lec_12a_CCA_public_key.html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path="lec_13_handshake.html"><a href="lec_13_handshake.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path="lec_14_zero_knowledge.html"><a href="lec_14_zero_knowledge.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> Bonus features of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic escape velocity</a><ul><li class="chapter" data-level="16.4.1" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path="lec_15_FHE.html"><a href="lec_15_FHE.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption : Construction</a><ul><li class="chapter" data-level="17.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path="lec_16_FHE_part2.html"><a href="lec_16_FHE_part2.html#example-application-private-information-retrieval"><i class="fa fa-check"></i><b>17.6</b> Example application: Private information retrieval</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly too ideal definition</a></li><li class="chapter" data-level="18.2.2" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#malicious-to-honest-but-curious-reduction"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path="lec_17_SFE.html"><a href="lec_17_SFE.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a></li><li class="chapter" data-level="19.3" data-path="lec_18_SFE_part2.html"><a href="lec_18_SFE_part2.html#bottom-line-a-two-party-honest-but-curious-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.3</b> Bottom line: A two party honest but curious two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path="lec_19_quantum.html"><a href="lec_19_quantum.html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path="lec_20_quantum_part2.html"><a href="lec_20_quantum_part2.html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path="lec_21_obfuscation.html"><a href="lec_21_obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path="lec_22_obfuscation_part2.html"><a href="lec_22_obfuscation_part2.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path="lec_23_anonymous.html"><a href="lec_23_anonymous.html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path="lec_24_policy.html"><a href="lec_24_policy.html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path="lec_24_policy.html"><a href="lec_24_policy.html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path="lec_24_policy.html"><a href="lec_24_policy.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path="lec_24_policy.html"><a href="lec_24_policy.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path="lec_25_course_recap.html"><a href="lec_25_course_recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Lattice based cryptography</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/lec_12_lattices.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="lattice-based-cryptography" data-number="12">Lattice based cryptography</h1>
<p>Lattice based public key encryption (and its cousins known as knapsack and coding based encryption) have almost as long a history as discrete logarithm and factoring based schemes. Already in 1976, right after the Diffie-Hellman key exchange was discovered (and before RSA), Ralph Merkle was working on building public key encryption from the NP hard <em>knapsack</em> problem (see <a href="http://cr.yp.to/bib/1988/diffie.pdf">Diffie’s recollection</a>). This can be thought of as the task of solving a linear equation of the form <span><span class="math inline">\(Ax = y\)</span></span> (where <span><span class="math inline">\(A\)</span></span> is a given matrix, <span><span class="math inline">\(y\)</span></span> is a given vector, and the unknown are <span><span class="math inline">\(x\)</span></span>) over the real numbers but with the additional constraint that <span><span class="math inline">\(x\)</span></span> must be either <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>. His proposal evolved into the Merkle-Hellman system proposed in 1978 (which was broken in 1984).</p>
<p>McEliece proposed in 1978 a system based on the difficulty of the decoding problem for general linear codes. This is the task of solving <em>noisy linear equations</em> where one is given <span><span class="math inline">\(A\)</span></span> and <span><span class="math inline">\(y\)</span></span> such that <span><span class="math inline">\(y=Ax+e\)</span></span> for a “small” error vector <span><span class="math inline">\(e\)</span></span>, and needs to recover <span><span class="math inline">\(x\)</span></span>. Crucially, here we work in a finite field, such as working modulo <span><span class="math inline">\(q\)</span></span> for some prime <span><span class="math inline">\(q\)</span></span> (that can even be <span><span class="math inline">\(2\)</span></span>) rather than over the reals or rationals. There are special matrices <span><span class="math inline">\(A^*\)</span></span> for which we know how to solve this problem efficiently: these are known as efficiently decodable <a href="https://goo.gl/vM7Pvv">error correcting codes</a>. McEliece suggested a scheme where the key generator lets <span><span class="math inline">\(A\)</span></span> be a “scrambled” version of a special <span><span class="math inline">\(A^*\)</span></span> (based on the <a href="https://goo.gl/Vd4yye">Goppa algebraic geometric code</a>). So, someone that knows the scrambling could solve the problem, but (hopefully) someone that doesn’t know it wouldn’t. McEliece’s system has so far not been broken.</p>
<p>In a 1996 breakthrough, Ajtai showed a <em>private key</em> scheme based on integer lattices that had a very curious property- its security could be based on the assumption that certain problems were only hard in the <em>worst case</em>, and moreover variants of these problems were known to be NP hard. This re-ignited the hope that we could perhaps realize the old dream of basing crypto on the mere assumption that <span><span class="math inline">\(P\neq \ensuremath{\mathit{NP}}\)</span></span>. Alas, we now understand that there are fundamental barriers to this approach.</p>
<p>Nevertheless, Ajtai’s work attracted significant interest, and within a year both Ajtai and Dwork, as well as Goldreich, Goldwasser and Halevi came up with lattice based constructions for <em>public key</em> encryption (the former based also on <em>worst case</em> assumptions). At about the same time, Hoffstein, Pipher, and Silverman came up with their NTRU public key system which is based on stronger assumptions but offers better performance, and they started a company around it together with Daniel Lieman.</p>
<p>You may note that I haven’t yet said what <em>lattices</em> are; we will do so later, but for now if you simply think of questions involving linear equations modulo some prime <span><span class="math inline">\(q\)</span></span>, you will get enough of the intuition that you need. (The lattice viewpoint is more geometric, and we’ll discuss it more below; it was first used to <em>attack</em> cryptosystems and in particular break the Merkle-Hellman knapsack scheme and many of its variants.)</p>
<p>Lattice based cryptography has captured a lot of attention recently from both theory and practice. In the theory side, many cool new constructions are now based on lattice based cryptography, and chief among them fully homomorphic encryption, as well as indistinguishability obfuscation (though the latter’s security’s foundations are still far less solid). On the applied side, the steady advances in the technology of quantum computers have finally gotten practitioners worried about RSA, Diffie Hellman and Elliptic Curves. While current constructions for quantum computers are nowhere near being able to, say, factor larger numbers that can be done classically (or even than can be done by hand), given that it takes many years to develop new standards and get them deployed, many believe the effort to transition away from these factoring/dlog based schemes should start today (or perhaps should have started several years ago). The NSA has <a href="https://www.nsa.gov/ia/programs/suiteb_cryptography/index.shtml">suggested</a> that it plans to initiate the process to “transition to quantum resistant algorithms in the not too distant future”; see also this <a href="https://cryptome.org/2016/01/CNSA-Suite-and-Quantum-Computing-FAQ.pdf">very interesting FAQ</a> on this topic.</p>
<p>Cryptography has the peculiar/unfortunate feature that if a machine is built that can factor large integers in 20 years, it can still be used to break the communication we transmit <em>today</em>, provided this communication was recorded. So, if you have some data that you expect you’d want still kept secret in 20 years (as many government and commercial entities do), you might have reasons to worry. Currently lattice based cryptography is the only real “game in town” for potentially quantum-resistant public key encryption schemes.</p>
<p>Lattice based cryptography is a huge area, and in this lecture and this course we only touch on few aspects of it. I highly recommend <a href="https://web.eecs.umich.edu/~cpeikert/pubs/lattice-survey.pdf">Chris Peikert’s Survey</a> for a much more in depth treatment of this area.</p>
<h2 id="a-world-without-gaussian-elimination" data-number="12.1">A world without Gaussian elimination</h2>
<p>The general approach people used to get a public key encryption is to obtain a hard computational problem with some mathematical <em>structure</em>. We’ve seen this in the <em>discrete logarithm</em> problem, where the task is to invert the map <span><span class="math inline">\(a \mapsto g^a \pmod{p}\)</span></span>, and the integer factoring problem, where the task is to invert the map <span><span class="math inline">\(a,b \mapsto a\cdot b\)</span></span>. Perhaps the simplest structure to consider is the task of solving linear equations.</p>
<p>Pretend that we didn’t know of Gaussian elimination,<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and that if we picked a “generic” matrix <span><span class="math inline">\(A\)</span></span> then the map <span><span class="math inline">\(x \mapsto Ax\)</span></span> would be hard to invert. (Here and elsewhere, our default interpretation of a vector <span><span class="math inline">\(x\)</span></span> is as a <em>column</em> vector, and hence if <span><span class="math inline">\(x\)</span></span> is <span><span class="math inline">\(n\)</span></span> dimensional and <span><span class="math inline">\(A\)</span></span> is <span><span class="math inline">\(m\times n\)</span></span> then <span><span class="math inline">\(Ax\)</span></span> is <span><span class="math inline">\(m\)</span></span> dimensional. We use <span><span class="math inline">\(x^\top\)</span></span> to denote the row vector obtained by <em>transposing</em> <span><span class="math inline">\(x\)</span></span>.) Could we use that to get a public key encryption scheme?</p>
<p>Here is a concrete approach. Let us fix some prime <span><span class="math inline">\(q\)</span></span> (think of it as polynomial size, e.g., <span><span class="math inline">\(q\)</span></span> is smaller than <span><span class="math inline">\(1024\)</span></span> or so, though people can and sometimes do consider <span><span class="math inline">\(q\)</span></span> of exponential size), and all computation below will be done modulo <span><span class="math inline">\(q\)</span></span>. The secret key is a vector <span><span class="math inline">\(x\in\Z_q^n\)</span></span>, and the public key is <span><span class="math inline">\((A,y)\)</span></span> where <span><span class="math inline">\(A\)</span></span> is a random <span><span class="math inline">\(m\times n\)</span></span> matrix with entries in <span><span class="math inline">\(\Z_q\)</span></span> and <span><span class="math inline">\(y=Ax\)</span></span>. Under our assumption, it is hard to recover the secret key from the public key, but how do we use the public key to encrypt?</p>
<p>The crucial observation is that even if we don’t know how to solve linear equations, we can still combine several equations to get new ones. To keep things simple, let’s consider the case of encrypting a single bit.</p>
<div id="section" class="pause" data-number="12.1" name="Pause">
<p>If you have a CPA secure public key encryption scheme for single bit messages then you can extend it to a CPA secure encryption scheme for messages of any length. Can you see why?</p>
</div>
<p>We think of the public key as the set of equations <span><span class="math inline">\(\langle a_1,x \rangle=y_1,\ldots, \langle a_m,x \rangle=y_m\)</span></span> in the unknown variables <span><span class="math inline">\(x\)</span></span>. The idea is that to encrypt the value <span><span class="math inline">\(0\)</span></span> we will generate a new <em>correct</em> equation on <span><span class="math inline">\(x\)</span></span>, while to encrypt the value <span><span class="math inline">\(1\)</span></span> we will generate an <em>incorrect</em> equation. To decrypt a ciphertext <span><span class="math inline">\((a,\sigma)\in \Z_q^{n+1}\)</span></span>, we think of it as an equation of the form <span><span class="math inline">\(\langle a,x \rangle=\sigma\)</span></span> and output <span><span class="math inline">\(1\)</span></span> if and only if the equation is correct.</p>
<p>How does the encrypting algorithm, that does not know <span><span class="math inline">\(x\)</span></span>, get a correct or incorrect equation on demand? One way would be to simply take two equations <span><span class="math inline">\(\langle a_i,x \rangle=y_i\)</span></span> and <span><span class="math inline">\(\langle a_j,x \rangle=y_j\)</span></span> and add them together to get the equation <span><span class="math inline">\(\langle a_i+a_j,x \rangle=y_i+y_j\)</span></span>. This equation is correct and so one can use it to encrypt <span><span class="math inline">\(0\)</span></span>, while to encrypt <span><span class="math inline">\(1\)</span></span> we simply add some fixed nonzero number <span><span class="math inline">\(\alpha\in\Z_q\)</span></span> to the right hand side to get the incorrect equation <span><span class="math inline">\(\langle a_i+a_j,x \rangle= y_i+y_j + \alpha\)</span></span>. However, even if it’s hard to solve for <span><span class="math inline">\(x\)</span></span> given the equations, an attacker (who also knows the public key <span><span class="math inline">\((A,y)\)</span></span>) can try itself all pairs of equations and do the same thing.</p>
<p>Our solution for this is simple- just add more equations! If the encryptor adds a random subset of equations then there are <span><span class="math inline">\(2^m\)</span></span> possibilities for that, and an attacker can’t guess them all. Thus, at least intuitively, the following encryption scheme would be “secure” in the Gaussian-elimination free world of attackers that haven’t taken freshman linear algebra:</p>
<blockquote>
<p><strong>Scheme LwoE-ENC:</strong> Public key encryption under the hardness of “learning linear equations without errors”.</p>
<ul>
<li><p><em>Key generation</em>: Pick random <span><span class="math inline">\(m\times n\)</span></span> matrix <span><span class="math inline">\(A\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span>, and <span><span class="math inline">\(x\leftarrow_R\Z_q^n\)</span></span>, the secret key is <span><span class="math inline">\(x\)</span></span> and the public key is <span><span class="math inline">\((A,y)\)</span></span> where <span><span class="math inline">\(y=Ax\)</span></span>.</p></li>
<li><p><em>Encryption</em>: To encrypt a message <span><span class="math inline">\(b\in\{0,1\}\)</span></span>, pick <span><span class="math inline">\(w\in\{0,1\}^m\)</span></span> and output <span><span class="math inline">\(w^\top A,\langle w,y \rangle+\alpha b\)</span></span> for some fixed nonzero <span><span class="math inline">\(\alpha\in\Z_q\)</span></span>.</p></li>
<li><p><em>Decryption:</em> To decrypt a ciphertext <span><span class="math inline">\((a,\sigma)\)</span></span>, output <span><span class="math inline">\(0\)</span></span> iff <span><span class="math inline">\(\langle a,x \rangle=\sigma\)</span></span>.</p></li>
</ul>
</blockquote>
<p><br />
</p>
<div id="section-1" class="pause" data-number="12.1" name="Pause">
<p>Please stop here and make sure that you see why this is a valid encryption, and this description corresponds to the previous one; as usual all calculations are done modulo <span><span class="math inline">\(q\)</span></span>.</p>
</div>
<h2 id="security-in-the-real-world." data-number="12.2">Security in the real world.</h2>
<p>Like it or not (and cryptographers typically don’t) Gaussian elimination <em>is</em> possible in the real world and the scheme above is completely insecure. However, the Gaussian elimination algorithm is extremely <em>brittle</em>.<br />
Errors tend to be amplified when you combine equations. This is usually thought of as a bad thing, and numerical analysis is much about dealing with issue. However, from the cryptographic point of view, these errors can be our saving grace and enable us to salvage the security of the ridiculous scheme above.</p>
<p>To see why Gaussian elimination is brittle, let us recall how it works. Think of <span><span class="math inline">\(m=n\)</span></span> for simplicity. Given equations <span><span class="math inline">\(Ax=y\)</span></span> in the unknown variables <span><span class="math inline">\(x\)</span></span>, the goal of Gaussian elimination is to transform them into the equations <span><span class="math inline">\(Ix = y&#39;\)</span></span> where <span><span class="math inline">\(I\)</span></span> is the identity matrix (and hence the solution is simply <span><span class="math inline">\(x=y&#39;\)</span></span>). Recall how we do it: by rearranging and scaling, we can assume that the top left corner of <span><span class="math inline">\(A\)</span></span> is equal to <span><span class="math inline">\(1\)</span></span>, and then we add the first equation to the other equations (scaled appropriately) to zero out the first entry in all the other rows of <span><span class="math inline">\(A\)</span></span> (i.e., make the first column of <span><span class="math inline">\(A\)</span></span> equal to <span><span class="math inline">\((1,0,\ldots,0)\)</span></span>) and continue onwards to the second column and so on and so forth.</p>
<p>Now, suppose that the equations were <em>noisy</em>, in the sense that we added to <span><span class="math inline">\(y\)</span></span> a vector <span><span class="math inline">\(e\in\Z_q^m\)</span></span> such that <span><span class="math inline">\(|e_i|&lt;\delta q\)</span></span> for every <span><span class="math inline">\(i\)</span></span>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Even ignoring the effect of the scaling step, simply adding the first equation to the rest of the equations would typically tend to increase the relative error of equations <span><span class="math inline">\(2,\ldots,m\)</span></span> from <span><span class="math inline">\(\approx \delta\)</span></span> to <span><span class="math inline">\(\approx 2\delta\)</span></span>. Now, when we repeat the process, we increase the error of equations <span><span class="math inline">\(3,\ldots,m\)</span></span> from <span><span class="math inline">\(\approx 2\delta\)</span></span> to <span><span class="math inline">\(\approx 4\delta\)</span></span>, and we see that by the time we’re done dealing with about <span><span class="math inline">\(n/2\)</span></span> variables, the remaining equations have error level roughly <span><span class="math inline">\(2^{n/2}\delta\)</span></span>. So, unless <span><span class="math inline">\(\delta\)</span></span> was truly tiny (and <span><span class="math inline">\(q\)</span></span> truly big, in which case the difference between working in <span><span class="math inline">\(\Z_q\)</span></span> and simply working with integers or rationals disappears), the resulting equations have the form <span><span class="math inline">\(Ix = y&#39; + e&#39;\)</span></span> where <span><span class="math inline">\(e&#39;\)</span></span> is so big that we get no information on <span><span class="math inline">\(x\)</span></span>.</p>
<p>The <em>Learning With Errors (LWE)</em> conjecture is that this is <em>inherent</em>:</p>
<blockquote>
<p><strong>Conjecture (Learning with Errors, Regev 2005):</strong> Let <span><span class="math inline">\(q=q(n)\)</span></span> and <span><span class="math inline">\(\delta=\delta(n)\)</span></span> be some functions. The <em>Learning with Error (LWE) conjecture with respect to <span><span class="math inline">\(q,\delta\)</span></span></em>, is that for every polynomial-time adversary <span><span class="math inline">\(E\)</span></span> and <span><span class="math inline">\(m=poly(n)\)</span></span>, the probability that <span><span class="math inline">\(E(A,Ax+e)=x\)</span></span> is negligible, where <span><span class="math inline">\(A\)</span></span> is a random <span><span class="math inline">\(m\times n\)</span></span> matrix in <span><span class="math inline">\(\Z_q\)</span></span>, <span><span class="math inline">\(x\)</span></span> is random in <span><span class="math inline">\(\Z_q^n,\)</span></span> and <span><span class="math inline">\(e \in \Z_q^m\)</span></span> is a random noise vector with magnitude <span><span class="math inline">\(\delta q\)</span></span>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<p>The <em>LWE conjecture</em> is that for every polynomial <span><span class="math inline">\(p(n)\)</span></span> there is some polynomial <span><span class="math inline">\(q(n)\)</span></span> such that LWE holds with respect to <span><span class="math inline">\(q(n)\)</span></span> and <span><span class="math inline">\(\delta(n)=1/p(n)\)</span></span>.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
</blockquote>
<h2 id="search-to-decision" data-number="12.3">Search to decision</h2>
<p>It turns out that if the LWE is hard, then it is even hard to distinguish between random equations and nearly correct ones:</p>
<figure>
<img src="../figure/lwevecindist.png" alt="13.1: The search to decision reduction () implies that under the LWE conjecture, for every m=poly(n), if we choose and fix a random m\times n matrix A over \Z_q, the distribution Ax+e is indistinguishable from a random vector in \Z_q^m, where x is a random vector in \Z_q^n and e is a random “short” vector in \Z_q^m. The two distributions are indistinguishable even to an adversary that knows A." id="figid" class="margin" /><figcaption>13.1: The search to decision reduction (<a href='#LWEsearchtodecthm'>Theorem 13.1</a>) implies that under the LWE conjecture, for every <span><span class="math inline">\(m=poly(n)\)</span></span>, if we choose and fix a random <span><span class="math inline">\(m\times n\)</span></span> matrix <span><span class="math inline">\(A\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span>, the distribution <span><span class="math inline">\(Ax+e\)</span></span> is indistinguishable from a random vector in <span><span class="math inline">\(\Z_q^m\)</span></span>, where <span><span class="math inline">\(x\)</span></span> is a random vector in <span><span class="math inline">\(\Z_q^n\)</span></span> and <span><span class="math inline">\(e\)</span></span> is a random “short” vector in <span><span class="math inline">\(\Z_q^m\)</span></span>. The two distributions are indistinguishable even to an adversary that knows <span><span class="math inline">\(A\)</span></span>.</figcaption>
</figure>
<div id="LWEsearchtodecthm" class="theorem" title="Search to decision reduction for LWE" data-number="12.3" name="Theorem 13.1 (Search to decision reduction for LWE) ">
<p>If the LWE conjecture is true then for every <span><span class="math inline">\(q=poly(n)\)</span></span> and <span><span class="math inline">\(\delta=1/poly(n)\)</span></span> and <span><span class="math inline">\(m=poly(n)\)</span></span>, the following two distributions are computationally indistinguishable:</p>
<ul>
<li><p><span><span class="math inline">\(\{ (A,Ax+e) \}\)</span></span> where <span><span class="math inline">\(A\)</span></span> is random <span><span class="math inline">\(m\times n\)</span></span> matrix in <span><span class="math inline">\(\Z_q\)</span></span>, <span><span class="math inline">\(x\)</span></span> is random in <span><span class="math inline">\(\Z_q^n\)</span></span> and <span><span class="math inline">\(e\in \Z_q^m\)</span></span> is random noise vector of magnitude <span><span class="math inline">\(\delta\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(\{ (A,y) \}\)</span></span> where <span><span class="math inline">\(A\)</span></span> is random <span><span class="math inline">\(m\times n\)</span></span> matrix in <span><span class="math inline">\(\Z_q\)</span></span> and <span><span class="math inline">\(y\)</span></span> is random in <span><span class="math inline">\(\Z_q^m\)</span></span>.</p></li>
</ul>
</div>
<div id="section-2" class="proof" data-ref="LWEsearchtodecthm" data-number="12.3" name="Proof">
<p>Suppose that we had a decisional adversary <span><span class="math inline">\(D\)</span></span> that succeeds in distinguishing the two distributions above with bias <span><span class="math inline">\(\epsilon\)</span></span>. For example, suppose that <span><span class="math inline">\(D\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p+\epsilon\)</span></span> on inputs from the first distribution, and outputs <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p\)</span></span> on inputs from the second distribution.</p>
<p>We will show how we can use this to obtain a polynomial-time algorithm <span><span class="math inline">\(S\)</span></span> that on input <span><span class="math inline">\(m\)</span></span> noisy equations on <span><span class="math inline">\(x\)</span></span> and a value <span><span class="math inline">\(a\in\ Z_q\)</span></span>, will learn with high probability whether or not the first coordinate of <span><span class="math inline">\(x\)</span></span> equals <span><span class="math inline">\(a\)</span></span>. Clearly, we can repeat this for all the possible <span><span class="math inline">\(q\)</span></span> values of <span><span class="math inline">\(a\)</span></span> to learn the first coordinate exactly, and then continue in this way to learn all coordinates.</p>
<p>Our algorithm <span><span class="math inline">\(S\)</span></span> gets as input the pair <span><span class="math inline">\((A,y)\)</span></span> where <span><span class="math inline">\(y=Ax+e\)</span></span> and we need to decide whether <span><span class="math inline">\(x_1 = a\)</span></span>. Now consider the instance <span><span class="math inline">\((A+(r\|0^m\|\cdots \|0^m),y+ar)\)</span></span>, where <span><span class="math inline">\(r\)</span></span> is a random vector in <span><span class="math inline">\(\Z_q^m\)</span></span> and the matrix <span><span class="math inline">\((r\|0^m\|\cdots \|0^m)\)</span></span> is simply the matrix with first column equal to <span><span class="math inline">\(r\)</span></span> and all other columns equal to <span><span class="math inline">\(0\)</span></span>. If <span><span class="math inline">\(A\)</span></span> is random then <span><span class="math inline">\(A+(r\|0^m\|\cdots \|0^m)\)</span></span> is random as well. Now note that <span><span class="math inline">\(Ax + (r|0^m\cdots \|0^m)x = Ax + x_1 r\)</span></span> and hence if <span><span class="math inline">\(x_1 = a\)</span></span> then we still have an input of the same form <span><span class="math inline">\((A&#39;,A&#39;x+e)\)</span></span>.</p>
<p>In contrast, we claim that if if <span><span class="math inline">\(x_1 \neq a\)</span></span> then the distribution <span><span class="math inline">\((A&#39;,y&#39;)\)</span></span> where <span><span class="math inline">\(A&#39;=A+(r\|0^m\|\cdots \|0^m)\)</span></span> and <span><span class="math inline">\(y&#39;= Ax + e + ar\)</span></span> is identical to the uniform distribution over a random uniformly chosen matrix <span><span class="math inline">\(A&#39;\)</span></span> and a random and independent uniformly chosen vector <span><span class="math inline">\(y&#39;\)</span></span>. Indeed, we can write this distribution as <span><span class="math inline">\((A&#39;,y&#39;)\)</span></span> where <span><span class="math inline">\(A&#39;\)</span></span> is chosen uniformly at random, and <span><span class="math inline">\(y&#39;= A&#39;x + e + (a-x_1)r\)</span></span> where <span><span class="math inline">\(r\)</span></span> is a random and independent vector. (Can you see why?) Since <span><span class="math inline">\(a-x_1 \neq 0\)</span></span>, this amounts to adding a random and independent vector <span><span class="math inline">\(r&#39;\)</span></span> to <span><span class="math inline">\(y&#39;\)</span></span>, which means that the distribution <span><span class="math inline">\((A&#39;,y&#39;)\)</span></span> is uniform and independent.</p>
<p>Hence if we send the input <span><span class="math inline">\((A&#39;,y&#39;)\)</span></span> to our the decision algorithm <span><span class="math inline">\(D\)</span></span>, then we would get <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p+\epsilon\)</span></span> if <span><span class="math inline">\(x_1=a\)</span></span> and an output of <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p\)</span></span> otherwise.</p>
<p>Now the crucial observation is that if our decision algorithm <span><span class="math inline">\(D\)</span></span> requires <span><span class="math inline">\(m\)</span></span> equations to succeed with bias <span><span class="math inline">\(\epsilon\)</span></span>, we can use <span><span class="math inline">\(100mn/\epsilon^2\)</span></span> equations (which is still polynomial) to invoke it <span><span class="math inline">\(100n/\epsilon^2\)</span></span> times. This allows us to distinguish with probability <span><span class="math inline">\(1-2^{-n}\)</span></span> between the case that <span><span class="math inline">\(D\)</span></span> outputs <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p+\epsilon\)</span></span> and the case that it outputs <span><span class="math inline">\(1\)</span></span> with probability <span><span class="math inline">\(p\)</span></span> (this follows from the Chernoff bound; can you see why?). Hence by using polynomially more samples than the decision algorithm <span><span class="math inline">\(D\)</span></span>, we get a search algorithm <span><span class="math inline">\(S\)</span></span> that can actually recover <span><span class="math inline">\(x\)</span></span>.</p>
</div>
<h2 id="an-lwe-based-encryption-scheme" data-number="12.4">An LWE based encryption scheme</h2>
<p>We can now show the secure variant of our original encryption scheme:</p>
<blockquote>
<p><strong>LWE-based encryption LWEENC:</strong></p>
<ul>
<li><p><em>Parameters:</em> Let <span><span class="math inline">\(\delta(n)=1/n^4\)</span></span> and let <span><span class="math inline">\(q=poly(n)\)</span></span> be a prime such that LWE holds w.r.t. <span><span class="math inline">\(q,\delta\)</span></span>. We let <span><span class="math inline">\(m = n^2\log q\)</span></span>.</p></li>
<li><p><em>Key generation:</em> Pick <span><span class="math inline">\(x\in\Z_q^n\)</span></span>. The private key is <span><span class="math inline">\(x\)</span></span> and the public key is <span><span class="math inline">\((A,y)\)</span></span> with <span><span class="math inline">\(y=Ax+e\)</span></span> with <span><span class="math inline">\(e\)</span></span> a <span><span class="math inline">\(\delta\)</span></span>-noise vector and <span><span class="math inline">\(A\)</span></span> a random <span><span class="math inline">\(m\times n\)</span></span> matrix.</p></li>
<li><p><em>Encrypt:</em> To encrypt <span><span class="math inline">\(b\in\{0,1\}\)</span></span> given the key <span><span class="math inline">\((A,y)\)</span></span>, pick <span><span class="math inline">\(w\in\{0,1\}^m\)</span></span> and output <span><span class="math inline">\(w^\top A, \langle w,y \rangle+b\floor{q/2}\)</span></span> (all computations are done in <span><span class="math inline">\(\Z_q\)</span></span>).</p></li>
<li><p><em>Decrypt:</em> To decrypt <span><span class="math inline">\((a,\sigma)\)</span></span>, output <span><span class="math inline">\(0\)</span></span> iff <span><span class="math inline">\(|\langle a,x \rangle-\sigma|&lt;q/10\)</span></span>.</p></li>
</ul>
</blockquote>
<p><br />
</p>
<div id="section-3" class="pause" data-number="12.4" name="Pause">
<p>The scheme LWEENC is also described in <a href='#lweencdescfig'>Figure 13.2</a> with slightly different notation. I highly recommend you stop and verify you understand why the two descriptions are equivalent.</p>
</div>
<figure>
<img src="../figure/lweencdesc.png" alt="13.2: In the encryption scheme LWEENC, the public key is a matrix A&#39;=(A|y), where y=As+e and s is the secret key. To encrypt a bit b we choose a random w \leftarrow_R \{0,1\}^m, and output w^\top A&#39; + (0,\ldots,0,b\floor{\tfrac{q}{2}}). We decrypt c \in \Z_q^{n+1} to zero with key s iff |\langle c,(s,-1) \rangle| \leq q/10 where the inner product is done modulo q." id="lweencdescfig" class="margin" /><figcaption>13.2: In the encryption scheme LWEENC, the public key is a matrix <span><span class="math inline">\(A&#39;=(A|y)\)</span></span>, where <span><span class="math inline">\(y=As+e\)</span></span> and <span><span class="math inline">\(s\)</span></span> is the secret key. To encrypt a bit <span><span class="math inline">\(b\)</span></span> we choose a random <span><span class="math inline">\(w \leftarrow_R \{0,1\}^m\)</span></span>, and output <span><span class="math inline">\(w^\top A&#39; + (0,\ldots,0,b\floor{\tfrac{q}{2}})\)</span></span>. We decrypt <span><span class="math inline">\(c \in \Z_q^{n+1}\)</span></span> to zero with key <span><span class="math inline">\(s\)</span></span> iff <span><span class="math inline">\(|\langle c,(s,-1) \rangle| \leq q/10\)</span></span> where the inner product is done modulo <span><span class="math inline">\(q\)</span></span>.</figcaption>
</figure>
<p>Unlike our typical schemes, here it is not immediately clear that this encryption is valid, in the sense that the decrypting an encryption of <span><span class="math inline">\(b\)</span></span> returns the value <span><span class="math inline">\(b\)</span></span>. But this is the case:</p>
<div id="LWEcorrectlem" class="lemma" data-number="12.4" name="Lemma 13.2">
<p>With high probability, the decryption of the encryption of <span><span class="math inline">\(b\)</span></span> equals <span><span class="math inline">\(b\)</span></span>.</p>
</div>
<div id="section-4" class="proof" data-ref="LWEcorrectlem" data-number="12.4" name="Proof">
<p><span><span class="math inline">\(\langle w^\top A,x \rangle = \langle w,Ax \rangle\)</span></span>. Hence, if <span><span class="math inline">\(y=Ax+e\)</span></span> then <span><span class="math inline">\(\langle w,y \rangle = \langle w^\top A,x \rangle + \langle w,e \rangle\)</span></span>. But since every coordinate of <span><span class="math inline">\(w\)</span></span> is either <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>, <span><span class="math inline">\(|\langle w,e \rangle|&lt;\delta m q &lt; q/10\)</span></span> for our choice of parameters.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> So, we get that if <span><span class="math inline">\(a= w^\top A\)</span></span> and <span><span class="math inline">\(\sigma = \langle w,y \rangle+b\floor{q/2}\)</span></span> then <span><span class="math inline">\(\sigma - \langle a,x \rangle = \langle w,e \rangle + b\floor{q/2}\)</span></span> which will be smaller than <span><span class="math inline">\(q/10\)</span></span> iff <span><span class="math inline">\(b=0\)</span></span>.</p>
</div>
<p>We now prove security of the LWE based encryption:</p>
<div id="LWEENCthm" class="theorem" title="CPA security of LWEENC" data-number="12.4" name="Theorem 13.3 (CPA security of LWEENC) ">
<p>If the LWE conjecture is true then LWEENC is CPA secure.</p>
</div>
<p>For a public key encryption scheme with messages that are just bits, CPA security means that an encryption of <span><span class="math inline">\(0\)</span></span> is indistinguishable from an encryption of <span><span class="math inline">\(1\)</span></span>, even given the public key. Thus <a href='#LWEENCthm'>Theorem 13.3</a> will follow from the following lemma:</p>
<div id="LWEENClem" class="lemma" data-number="12.4" name="Lemma 13.4">
<p>Let <span><span class="math inline">\(q,m,\delta\)</span></span> be set as in LWEENC. Then, assuming the LWE conjecture, the following distributions are computationally indistinguishable:</p>
<ul>
<li><p><span><span class="math inline">\(D\)</span></span>: The distribution over four-tuples of the form <span><span class="math inline">\((A,y,w^\top A,\langle w,y \rangle)\)</span></span> where <span><span class="math inline">\(A\)</span></span> is uniform in <span><span class="math inline">\(\Z_q^{m\times n}\)</span></span>, <span><span class="math inline">\(x\)</span></span> is uniform in <span><span class="math inline">\(\Z_q^n\)</span></span>, <span><span class="math inline">\(e \in Z_q\)</span></span> is chosen with <span><span class="math inline">\(e_i \in \{-\delta q,\ldots,+\delta q\}\)</span></span>, <span><span class="math inline">\(y=Ax+e\)</span></span>, and <span><span class="math inline">\(w\)</span></span> is uniform in <span><span class="math inline">\(\{0,1\}^m\)</span></span>.</p></li>
<li><p><span><span class="math inline">\(\overline{D}\)</span></span>: The distribution over four-tuples <span><span class="math inline">\((A,y&#39;,a,\sigma)\)</span></span> where all entries are uniform: <span><span class="math inline">\(A\)</span></span> is uniform in <span><span class="math inline">\(\Z_q^{m\times n}\)</span></span>, <span><span class="math inline">\(y&#39;\)</span></span> is uniform in <span><span class="math inline">\(\Z_q^m\)</span></span>, <span><span class="math inline">\(a\)</span></span> is uniform in <span><span class="math inline">\(\Z_q^n\)</span></span> and <span><span class="math inline">\(\sigma\)</span></span> is uniform in <span><span class="math inline">\(\Z_q\)</span></span>.</p></li>
</ul>
</div>
<div id="section-5" class="pause" data-number="12.4" name="Pause">
<p>You should stop here and verify that <strong>(i)</strong> You understand the statement of <a href='#LWEENClem'>Lemma 13.4</a> and <strong>(ii)</strong> you understand why this lemma implies <a href='#LWEENCthm'>Theorem 13.3</a>. The idea is that <a href='#LWEENClem'>Lemma 13.4</a> shows that the concatenation of the public key and encryption of <span><span class="math inline">\(0\)</span></span> is indistinguishable from something that is completely random. You can then use it to show that the concatenation of the public key and encryption of <span><span class="math inline">\(1\)</span></span> is indistinguishable from the same thing, and then finish using the hybrid argument.</p>
</div>
<p>We now prove <a href='#LWEENClem'>Lemma 13.4</a>, which will complete the proof of <a href='#LWEENCthm'>Theorem 13.3</a>.</p>
<div id="section-6" class="proof" data-ref="LWEENClem" data-number="12.4" name="Proof">
<p>Define <span><span class="math inline">\(D\)</span></span> to be the distribution <span><span class="math inline">\((A,y,w^\top A,\langle w,y \rangle)\)</span></span> as in the lemma’s statement (i.e., <span><span class="math inline">\(y=Ax+e\)</span></span> for some <span><span class="math inline">\(x\)</span></span>, <span><span class="math inline">\(e\)</span></span> chosen as above). Define <span><span class="math inline">\(D&#39;\)</span></span> to be the distribution <span><span class="math inline">\((A,y&#39;,w^\top A, \langle w,y&#39; \rangle)\)</span></span> where <span><span class="math inline">\(y&#39;\)</span></span> is chosen uniformly in <span><span class="math inline">\(\Z_q^m\)</span></span>. We claim that <span><span class="math inline">\(D&#39;\)</span></span> is computationally indistinguishable from <span><span class="math inline">\(D\)</span></span> under the LWE conjecture. Indeed by <a href='#LWEsearchtodecthm'>Theorem 13.1</a> (search to decision reduction) this conjecture implies that the distribution <span><span class="math inline">\(X\)</span></span> over pairs <span><span class="math inline">\((A,y)\)</span></span> with <span><span class="math inline">\(y=Ax+e\)</span></span> is indistinguishable from the distribution <span><span class="math inline">\(X&#39;\)</span></span> over pairs <span><span class="math inline">\((A,y&#39;)\)</span></span> where <span><span class="math inline">\(y&#39;\)</span></span> is uniform. But if there was some polynomial-time algorithm <span><span class="math inline">\(T\)</span></span> distinguishing <span><span class="math inline">\(D\)</span></span> from <span><span class="math inline">\(D&#39;\)</span></span> then we can design a randomized polynomial-time algorithm <span><span class="math inline">\(T&#39;\)</span></span> distinguishing <span><span class="math inline">\(X\)</span></span> from <span><span class="math inline">\(X&#39;\)</span></span> with the same advantage by setting <span><span class="math inline">\(T&#39;(A,y)=T(A,y,w^\top A,\langle w,y \rangle)\)</span></span> for random <span><span class="math inline">\(w \leftarrow_R \{0,1\}^m\)</span></span>.</p>
<p>We will finish the proof by showing that the distribution <span><span class="math inline">\(D&#39;\)</span></span> is <em>statistically indistinguishable</em> (i.e., has negligible total variation distance) from <span><span class="math inline">\(\overline{D}\)</span></span>. This follows from the following claim:</p>
<p><strong>CLAIM:</strong> Suppose that <span><span class="math inline">\(m &gt; 100 n \log q\)</span></span>. If <span><span class="math inline">\(A&#39;\)</span></span> is a random <span><span class="math inline">\(m\times n+1\)</span></span> matrix in <span><span class="math inline">\(\Z_q^m\)</span></span>, then with probability at least <span><span class="math inline">\(1-2^{-n}\)</span></span> over the choice of <span><span class="math inline">\(A&#39;\)</span></span>, the distribution <span><span class="math inline">\(Z_{A&#39;}\)</span></span> over <span><span class="math inline">\(\Z_q^n\)</span></span> which is obtained by choosing <span><span class="math inline">\(w\)</span></span> at random in <span><span class="math inline">\(\{0,1\}^m\)</span></span> and outputting <span><span class="math inline">\(w^\top A&#39;\)</span></span> has at most <span><span class="math inline">\(2^{-n}\)</span></span> statistical distance from the uniform distribution over <span><span class="math inline">\(\Z_q^{n+1}\)</span></span>.</p>
<p>Note that the randomness used for the distribution <span><span class="math inline">\(Z_{A&#39;}\)</span></span> is only obtained by the choice of <span><span class="math inline">\(w\)</span></span>, and <em>not</em> by the choice of <span><span class="math inline">\(A&#39;\)</span></span> that is fixed. (This passes a basic “sanity check” since <span><span class="math inline">\(w\)</span></span> has <span><span class="math inline">\(m\)</span></span> random bits, while the uniform distribution over <span><span class="math inline">\(\Z_q^n\)</span></span> requires <span><span class="math inline">\(n \log q \ll m\)</span></span> random bits, and hence <span><span class="math inline">\(Z_{A&#39;}\)</span></span> at least has a “fighting chance” in being statistically close to it.) Another way to state the same claim is that the pair <span><span class="math inline">\((A&#39;,w^\top A&#39;)\)</span></span> is statistically indistinguishable from the uniform distribution <span><span class="math inline">\((A&#39;,z)\)</span></span> where <span><span class="math inline">\(z\)</span></span> is a vector chosen independently at random from <span><span class="math inline">\(\Z_q^n\)</span></span>.</p>
<p>The claim completes the proof of the theorem, since letting <span><span class="math inline">\(A&#39;\)</span></span> be the matrix <span><span class="math inline">\((A|y)\)</span></span> and <span><span class="math inline">\(z=(a,\sigma)\)</span></span>, we see that the distribution <span><span class="math inline">\(D&#39;\)</span></span>, as the form <span><span class="math inline">\((A&#39;,z)\)</span></span> where <span><span class="math inline">\(A&#39;\)</span></span> is a uniformly random <span><span class="math inline">\(m\times (n+1)\)</span></span> matrix and <span><span class="math inline">\(z\)</span></span> is sampled from <span><span class="math inline">\(Z_{A&#39;}\)</span></span> (i.e., <span><span class="math inline">\(z=w^\top A&#39;\)</span></span> where <span><span class="math inline">\(w\)</span></span> is uniformly chosen in <span><span class="math inline">\(\{0,1\}^m\)</span></span>). Hence this means that the statistical distance of <span><span class="math inline">\(D&#39;\)</span></span> from <span><span class="math inline">\(\overline{D}\)</span></span> (where all elements are uniform) is <span><span class="math inline">\(O(2^{-n})\)</span></span>. (Please make sure you understand this reasoning!)</p>
<p>We will not do the whole proof of the claim (which uses the mod <span><span class="math inline">\(q\)</span></span> version of the <a href="https://goo.gl/KXpccP">leftover hash lemma</a> which we mentioned before and is also “Wikipedia-able”) but the idea is simple. For every <span><span class="math inline">\(m\times (n+1)\)</span></span> matrix <span><span class="math inline">\(A&#39;\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span>, define <span><span class="math inline">\(h_{A&#39;}:\Z_q^m \rightarrow \Z_q^n\)</span></span> to be the map <span><span class="math inline">\(h_{A&#39;}(w)=w^\top A&#39;\)</span></span>. This collection can be shown to be a “good” hash function collection in some specific technical sense, which in particular implies that for every distribution <span><span class="math inline">\(D\)</span></span> with much more than <span><span class="math inline">\(n\log q\)</span></span> bits of min-entropy, with all but negligible probability over the choice of <span><span class="math inline">\(A&#39;\)</span></span>, <span><span class="math inline">\(h_{A&#39;}(D)\)</span></span> is statistically indistinguishable from the uniform distribution. Now when we choose <span><span class="math inline">\(w\)</span></span> at random in <span><span class="math inline">\(\{0,1\}^m\)</span></span>, it is coming from a distribution with <span><span class="math inline">\(m\)</span></span> bits of entropy. If <span><span class="math inline">\(m \gg (n+1)\log q\)</span></span>, then because the output of this function is so much smaller than <span><span class="math inline">\(m\)</span></span>, we expect it to be completely uniform, and this is what’s shown by the leftover hash lemma.</p>
</div>
<div id="section-7" class="pause" data-number="12.4" name="Pause">
<p>The proof of <a href='#LWEENCthm'>Theorem 13.3</a> is quite subtle and requires some re-reading and thought. To read more about this, you can look at the survey of Oded Regev, <a href="http://www.cims.nyu.edu/~regev/papers/lwesurvey.pdf">“On the Learning with Error Problem”</a> Sections 3 and 4.</p>
</div>
<h2 id="but-what-are-lattices" data-number="12.5">But what are lattices?</h2>
<p>You can think of a lattice as a discrete version of a subspace. A lattice <span><span class="math inline">\(L\)</span></span> is simply a discrete subset of <span><span class="math inline">\(\mathbb{R}^n\)</span></span> such that if <span><span class="math inline">\(u,v\in L\)</span></span> and <span><span class="math inline">\(a,b\)</span></span> are integers then <span><span class="math inline">\(au+bv\in L\)</span></span>.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> A lattice is given by a basis which simply a matrix <span><span class="math inline">\(B\)</span></span> such that every vector <span><span class="math inline">\(u\in L\)</span></span> is obtained as <span><span class="math inline">\(u=Bx\)</span></span> for some vector of integers <span><span class="math inline">\(x\)</span></span>. It can be shown that we can assume without loss of generality that <span><span class="math inline">\(B\)</span></span> is full dimensional and hence it’s an <span><span class="math inline">\(n\)</span></span> by <span><span class="math inline">\(n\)</span></span> invertible matrix. Note that given a basis <span><span class="math inline">\(B\)</span></span> we can generate vectors in <span><span class="math inline">\(L\)</span></span>, as well as test whether a vector <span><span class="math inline">\(v\)</span></span> is in <span><span class="math inline">\(L\)</span></span> by testing if <span><span class="math inline">\(B^{-1}v\)</span></span> is an integer vector. There can be many different bases for the same lattice, and some of them are easier to work with than others (see <a href='#latticebasesfig'>Figure 13.3</a>).</p>
<figure>
<img src="../figure/Lattice-reduction.png" alt="13.3: A lattice is a discrete subspace L \subseteq \R^n that is closed under integer combinations. A basis for the lattice is a minimal set b_1,\ldots,b_m (typically m=n) such that every u \in L is an integer combination of b_1,\ldots,b_m. The same lattice can have different bases. In this figure the lattice is a set of points in \R^2, and the black vectors v_1,v_2 and the ref vectors u_1,u_2 are two alternative bases for it. Generally we consider the basis u_1,u_2 “better” since the vectors are shorter and it is less “skewed”." id="latticebasesfig" class="margin" /><figcaption>13.3: A <em>lattice</em> is a discrete subspace <span><span class="math inline">\(L \subseteq \R^n\)</span></span> that is closed under <em>integer</em> combinations. A <em>basis</em> for the lattice is a minimal set <span><span class="math inline">\(b_1,\ldots,b_m\)</span></span> (typically <span><span class="math inline">\(m=n\)</span></span>) such that every <span><span class="math inline">\(u \in L\)</span></span> is an integer combination of <span><span class="math inline">\(b_1,\ldots,b_m\)</span></span>. The same lattice can have different bases. In this figure the lattice is a set of points in <span><span class="math inline">\(\R^2\)</span></span>, and the black vectors <span><span class="math inline">\(v_1,v_2\)</span></span> and the ref vectors <span><span class="math inline">\(u_1,u_2\)</span></span> are two alternative bases for it. Generally we consider the basis <span><span class="math inline">\(u_1,u_2\)</span></span> “better” since the vectors are shorter and it is less “skewed”.</figcaption>
</figure>
<p>Some classical computational questions on lattices are:</p>
<ul>
<li><p><em>Shortest vector problem:</em> Given a basis <span><span class="math inline">\(B\)</span></span> for <span><span class="math inline">\(L\)</span></span>, find the nonzero vector <span><span class="math inline">\(v\)</span></span> with smallest norm in <span><span class="math inline">\(L\)</span></span>.</p></li>
<li><p><em>Closest vector problem:</em> Given a basis <span><span class="math inline">\(B\)</span></span> for <span><span class="math inline">\(L\)</span></span> and a vector <span><span class="math inline">\(u\)</span></span> that is <em>not</em> in <span><span class="math inline">\(L\)</span></span>, find the closest vector to <span><span class="math inline">\(u\)</span></span> in <span><span class="math inline">\(L\)</span></span>.</p></li>
<li><p><em>Bounded distance decoding:</em> Given a basis <span><span class="math inline">\(B\)</span></span> for <span><span class="math inline">\(L\)</span></span> and a vector <span><span class="math inline">\(u\)</span></span> of the form <span><span class="math inline">\(u=v+e\)</span></span> where <span><span class="math inline">\(v\)</span></span> is in <span><span class="math inline">\(L\)</span></span>, and <span><span class="math inline">\(e\)</span></span> is a particularly short “error” vector (so in particular no other vector in the lattice is within distance <span><span class="math inline">\(\|e\|\)</span></span> to <span><span class="math inline">\(u\)</span></span>), recover <span><span class="math inline">\(v\)</span></span>. Note that this is a special case of the closest vector problem.</p></li>
</ul>
<p>In particular, if <span><span class="math inline">\(V\)</span></span> is a linear subspace of <span><span class="math inline">\(\Z_q^n\)</span></span>, we can think of it also as a lattice <span><span class="math inline">\(\hat{V}\)</span></span> of <span><span class="math inline">\(\mathbb{R}^n\)</span></span> where we simply say that that a vector <span><span class="math inline">\(\hat{u}\)</span></span> is in <span><span class="math inline">\(\hat{V}\)</span></span> if all of <span><span class="math inline">\(\hat{u}\)</span></span>’s coordinates are integers and if we let <span><span class="math inline">\(u_i = \hat{u}_i \pmod{q}\)</span></span> then <span><span class="math inline">\(u\in V\)</span></span>. The learning with error task of recovering <span><span class="math inline">\(x\)</span></span> from <span><span class="math inline">\(Ax+e\)</span></span> can then be thought of as an instance of the bounded distance decoding problem for <span><span class="math inline">\(\hat{V}\)</span></span>.</p>
<p>A natural algorithm to try to solve the <em>closest vector</em> and <em>bounded distance decoding</em> problems is that to take the vector <span><span class="math inline">\(u\)</span></span>, express it in the basis <span><span class="math inline">\(B\)</span></span> by computing <span><span class="math inline">\(w = B^{-1}u\)</span></span>, and then round all the coordinates of <span><span class="math inline">\(w\)</span></span> to obtain an integer vector <span><span class="math inline">\(\tilde{w}\)</span></span> and let <span><span class="math inline">\(v=B\tilde{w}\)</span></span> be a vector in the lattice. If we have an extremely good basis <span><span class="math inline">\(L\)</span></span> for the lattice then <span><span class="math inline">\(v\)</span></span> may indeed be the closest vector in the lattice, but in other more “skewed” bases it can be extremely far from it.</p>
<h2 id="ring-based-lattices" data-number="12.6">Ring based lattices</h2>
<p>One of the biggest issues with lattice based cryptosystem is the key size. In particular, the scheme above uses an <span><span class="math inline">\(m\times n\)</span></span> matrix where each entry takes <span><span class="math inline">\(\log q\)</span></span> bits to describe. (It also encrypts a single bit using a whole vector, but more efficient “multi-bit” variants are known.) Schemes using <em>ideal lattices</em> are an attempt to get more practical variants. These have very similar structure except that the matrix <span><span class="math inline">\(A\)</span></span> chosen is not completely random but rather can be described by a single vector. One common variant is the following: we fix some polynomial <span><span class="math inline">\(p\)</span></span> over <span><span class="math inline">\(\Z_q\)</span></span> with degree <span><span class="math inline">\(n\)</span></span> and then treat vectors in <span><span class="math inline">\(\Z_q^n\)</span></span> as the coefficients of <span><span class="math inline">\(n-1\)</span></span> degree polynomials and always work modulo this polynomial <span><span class="math inline">\(p()\)</span></span>. (By this I mean that for every polynomial <span><span class="math inline">\(t\)</span></span> of degree at least <span><span class="math inline">\(n\)</span></span> we write <span><span class="math inline">\(t\)</span></span> as <span><span class="math inline">\(ps+r\)</span></span> where <span><span class="math inline">\(p\)</span></span> is the polynomial above, <span><span class="math inline">\(s\)</span></span> is some polynomial and <span><span class="math inline">\(r\)</span></span> is the “remainder” polynomial of degree <span><span class="math inline">\(&lt;n\)</span></span>; then <span><span class="math inline">\(t \pmod{p} = r\)</span></span>.) Now for every fixed polynomial <span><span class="math inline">\(t\)</span></span>, the operation <span><span class="math inline">\(A_t\)</span></span> which is defined as <span><span class="math inline">\(s \mapsto ts \pmod{p}\)</span></span> is a linear operation mapping polynomials of degree at most <span><span class="math inline">\(n-1\)</span></span> to polynomials of degree at most <span><span class="math inline">\(n-1\)</span></span>, or put another way, it is a linear map over <span><span class="math inline">\(\Z_q^n\)</span></span>. However, the map <span><span class="math inline">\(A_d\)</span></span> can be described using the <span><span class="math inline">\(n\)</span></span> coefficients of <span><span class="math inline">\(t\)</span></span> as opposed to the <span><span class="math inline">\(n^2\)</span></span> description of a matrix. It also turns out that by using the Fast Fourier Transform we can evaluate this operation in roughly <span><span class="math inline">\(n\)</span></span> steps as opposed to <span><span class="math inline">\(n^2\)</span></span>. The ideal lattice based cryptosystem use matrices of this form to save on key size and computation time. It is still unclear if this structure can be used for attacks; recent papers attacking principal ideal lattices have shown that one needs to be careful about this.</p>
<p>One ideal-lattice based system is the <a href="https://newhopecrypto.org/">“New Hope” cryptosystem</a> (see also <a href="https://eprint.iacr.org/2015/1092.pdf">paper</a>) that has been experimented with by Google. People have also made highly optimized general (non ideal) lattice based constructions, see in particular the <a href="https://frodokem.org/">“Frodo” system</a> (paper <a href="https://eprint.iacr.org/2016/659">here</a>, can you guess what’s behind the name?). Both New Hope and Frodo have been submitted to the <a href="https://csrc.nist.gov/Projects/Post-Quantum-Cryptography">NIST competition</a> to select a “post quantum” public key encryption standard.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>Despite the name, <a href="https://goo.gl/3HNb5U">Gaussian elimination</a> has been known to Chinese mathematicians since 150BC or so, and was popularized in the west through the 1670 notes of Isaac Newton.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>Over <span><span class="math inline">\(\Z_q\)</span></span>, we can think of <span><span class="math inline">\(q-1\)</span></span> also as the number <span><span class="math inline">\(-1\)</span></span>, and so on. Thus if <span><span class="math inline">\(a\in\Z_q\)</span></span>, we define <span><span class="math inline">\(|a|\)</span></span> to be the minimum of <span><span class="math inline">\(a\)</span></span> and <span><span class="math inline">\(q-a\)</span></span>. This ensures the absolute value satisfies the natural property of <span><span class="math inline">\(|a|=|-a|\)</span></span>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>One can think of <span><span class="math inline">\(e\)</span></span> as chosen by simply letting every coordinate be chosen at random in <span><span class="math inline">\(\{ -\delta q, -\delta q + 1 , \ldots, +\delta q \}\)</span></span>. For technical reasons, we sometimes consider other distributions and in particular the <em>discrete Gaussian</em> distribution which is obtained by letting every coordinate of <span><span class="math inline">\(e\)</span></span> be an independent Gaussian random variable with standard deviation <span><span class="math inline">\(\delta q\)</span></span>, conditioned on it being an integer. (A closely related distribution is obtained by picking such a Gaussian random variable and then rounding it to the nearest integer.)</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>People sometimes also consider variants where both <span><span class="math inline">\(p(n)\)</span></span> and <span><span class="math inline">\(q(n)\)</span></span> can be as large as exponential.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>In fact, due to the fact that the <em>signs</em> of the error vector’s entries are different, we expect the errors to have significant cancellations and hence we would expect <span><span class="math inline">\(|\langle w,e \rangle|\)</span></span> to only be roughly of magnitude <span><span class="math inline">\(\sqrt{m}\delta q\)</span></span>, but this is not crucial for our discussions.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>By discrete we mean that points in <span><span class="math inline">\(L\)</span></span> are isolated. One formal way to define it is that there is some <span><span class="math inline">\(\epsilon&gt;0\)</span></span> such that every distinct <span><span class="math inline">\(u,v \in L\)</span></span> are of distance at least <span><span class="math inline">\(\epsilon\)</span></span> from one another.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=Lattice based cryptography+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 01/03/2020 14:36:25</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/lec_12_lattices.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
