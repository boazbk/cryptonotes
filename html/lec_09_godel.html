<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Theoretical Computer Science: Is every theorem provable?</title>
  <meta name="description" content="Textbook on Theoretical Computer Science by Boaz Barak">

  <meta property="og:title" content="Introduction to Theoretical Computer Science: Is every theorem provable?" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://introtcs.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="github-repo" content="boazbk/tcs" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Theoretical Computer Science" />
  <meta name="twitter:description" content="Textbook on Theoretical Computer Science by Boaz Barak" />
  <meta name="twitter:image" content="https://introtcs.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->



<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">Introduction to Theoretical Computer Science</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html"><i class="fa fa-check"></i><b>p</b> Preface</a><ul><li class="chapter" data-level="p.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-the-student"><i class="fa fa-check"></i><b>p.1</b> To the student</a><ul><li class="chapter" data-level="p.1.1" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#is-the-effort-worth-it"><i class="fa fa-check"></i><b>p.1.1</b> Is the effort worth it?</a></li></ul></li><li class="chapter" data-level="p.2" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#to-potential-instructors"><i class="fa fa-check"></i><b>p.2</b> To potential instructors</a></li><li class="chapter" data-level="p.3" data-path="lec_00_0_preface.html"><a href="lec_00_0_preface.html#acknowledgements"><i class="fa fa-check"></i><b>p.3</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="0" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html"><i class="fa fa-check"></i><b>0</b> Introduction</a><ul><li class="chapter" data-level="0.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#integer-multiplication-an-example-of-an-algorithm"><i class="fa fa-check"></i><b>0.1</b> Integer multiplication: an example of an algorithm</a></li><li class="chapter" data-level="0.2" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#karatsubasec"><i class="fa fa-check"></i><b>0.2</b> Extended Example: A faster way to multiply (optional)</a></li><li class="chapter" data-level="0.3" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#algsbeyondarithmetic"><i class="fa fa-check"></i><b>0.3</b> Algorithms beyond arithmetic</a></li><li class="chapter" data-level="0.4" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#on-the-importance-of-negative-results."><i class="fa fa-check"></i><b>0.4</b> On the importance of negative results.</a></li><li class="chapter" data-level="0.5" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#roadmapsec"><i class="fa fa-check"></i><b>0.5</b> Roadmap to the rest of this book</a><ul><li class="chapter" data-level="0.5.1" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#dependencies-between-chapters"><i class="fa fa-check"></i><b>0.5.1</b> Dependencies between chapters</a></li></ul></li><li class="chapter" data-level="0.6" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path="lec_01_introduction.html"><a href="lec_01_introduction.html#bnotesintrosec"><i class="fa fa-check"></i><b>0.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a><ul><li class="chapter" data-level="1.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#manualbackground"><i class="fa fa-check"></i><b>1.1</b> This chapter: a reader’s manual</a></li><li class="chapter" data-level="1.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secmathoverview"><i class="fa fa-check"></i><b>1.2</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="1.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#reading-mathematical-texts"><i class="fa fa-check"></i><b>1.3</b> Reading mathematical texts</a><ul><li class="chapter" data-level="1.3.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#definitions"><i class="fa fa-check"></i><b>1.3.1</b> Definitions</a></li><li class="chapter" data-level="1.3.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#assertions-theorems-lemmas-claims"><i class="fa fa-check"></i><b>1.3.2</b> Assertions: Theorems, lemmas, claims</a></li><li class="chapter" data-level="1.3.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs"><i class="fa fa-check"></i><b>1.3.3</b> Proofs</a></li></ul></li><li class="chapter" data-level="1.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#basic-discrete-math-objects"><i class="fa fa-check"></i><b>1.4</b> Basic discrete math objects</a><ul><li class="chapter" data-level="1.4.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#sets"><i class="fa fa-check"></i><b>1.4.1</b> Sets</a></li><li class="chapter" data-level="1.4.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#specialsets"><i class="fa fa-check"></i><b>1.4.2</b> Special sets</a></li><li class="chapter" data-level="1.4.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#functionsec"><i class="fa fa-check"></i><b>1.4.3</b> Functions</a></li><li class="chapter" data-level="1.4.4" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#graphsec"><i class="fa fa-check"></i><b>1.4.4</b> Graphs</a></li><li class="chapter" data-level="1.4.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifiers"><i class="fa fa-check"></i><b>1.4.5</b> Logic operators and quantifiers</a></li><li class="chapter" data-level="1.4.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secquantifierssums"><i class="fa fa-check"></i><b>1.4.6</b> Quantifiers for summations and products</a></li><li class="chapter" data-level="1.4.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#boundvarsec"><i class="fa fa-check"></i><b>1.4.7</b> Parsing formulas: bound and free variables</a></li><li class="chapter" data-level="1.4.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#secbigohnotation"><i class="fa fa-check"></i><b>1.4.8</b> Asymptotics and Big-O notation</a></li><li class="chapter" data-level="1.4.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-rules-of-thumb-for-big-o-notation"><i class="fa fa-check"></i><b>1.4.9</b> Some rules of thumb for Big-O notation</a></li></ul></li><li class="chapter" data-level="1.5" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofsbackgroundsec"><i class="fa fa-check"></i><b>1.5</b> Proofs</a><ul><li class="chapter" data-level="1.5.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proofs-and-programs"><i class="fa fa-check"></i><b>1.5.1</b> Proofs and programs</a></li><li class="chapter" data-level="1.5.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proof-writing-style"><i class="fa fa-check"></i><b>1.5.2</b> Proof writing style</a></li><li class="chapter" data-level="1.5.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#patterns-in-proofs"><i class="fa fa-check"></i><b>1.5.3</b> Patterns in proofs</a></li></ul></li><li class="chapter" data-level="1.6" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#topsortsec"><i class="fa fa-check"></i><b>1.6</b> Extended example: Topological Sorting</a><ul><li class="chapter" data-level="1.6.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#inductionsec"><i class="fa fa-check"></i><b>1.6.1</b> Mathematical induction</a></li><li class="chapter" data-level="1.6.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#proving-the-result-by-induction"><i class="fa fa-check"></i><b>1.6.2</b> Proving the result by induction</a></li><li class="chapter" data-level="1.6.3" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#minimality-and-uniqueness"><i class="fa fa-check"></i><b>1.6.3</b> Minimality and uniqueness</a></li></ul></li><li class="chapter" data-level="1.7" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notationsec"><i class="fa fa-check"></i><b>1.7</b> This book: notation and conventions</a><ul><li class="chapter" data-level="1.7.1" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#conventionsec"><i class="fa fa-check"></i><b>1.7.1</b> Variable name conventions</a></li><li class="chapter" data-level="1.7.2" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#some-idioms"><i class="fa fa-check"></i><b>1.7.2</b> Some idioms</a></li></ul></li><li class="chapter" data-level="1.8" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li><li class="chapter" data-level="1.9" data-path="lec_00_1_math_background.html"><a href="lec_00_1_math_background.html#notesmathchap"><i class="fa fa-check"></i><b>1.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path="lec_02_representation.html"><a href="lec_02_representation.html"><i class="fa fa-check"></i><b>2</b> Computation and Representation</a><ul><li class="chapter" data-level="2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-representations"><i class="fa fa-check"></i><b>2.1</b> Defining representations</a><ul><li class="chapter" data-level="2.1.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-natural-numbers"><i class="fa fa-check"></i><b>2.1.1</b> Representing natural numbers</a></li><li class="chapter" data-level="2.1.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#meaning-of-representations-discussion"><i class="fa fa-check"></i><b>2.1.2</b> Meaning of representations (discussion)</a></li></ul></li><li class="chapter" data-level="2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representations-beyond-natural-numbers"><i class="fa fa-check"></i><b>2.2</b> Representations beyond natural numbers</a><ul><li class="chapter" data-level="2.2.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#repnegativeintegerssec"><i class="fa fa-check"></i><b>2.2.1</b> Representing (potentially negative) integers</a></li><li class="chapter" data-level="2.2.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#twoscomplement"><i class="fa fa-check"></i><b>2.2.2</b> Two’s complement representation (optional)</a></li><li class="chapter" data-level="2.2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#rational-numbers-and-representing-pairs-of-strings"><i class="fa fa-check"></i><b>2.2.3</b> Rational numbers, and representing pairs of strings</a></li></ul></li><li class="chapter" data-level="2.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-real-numbers"><i class="fa fa-check"></i><b>2.3</b> Representing real numbers</a><ul><li class="chapter" data-level="2.3.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#cantorsec"><i class="fa fa-check"></i><b>2.3.1</b> Can we represent reals exactly?</a></li></ul></li><li class="chapter" data-level="2.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-objects-beyond-numbers"><i class="fa fa-check"></i><b>2.4</b> Representing objects beyond numbers</a><ul><li class="chapter" data-level="2.4.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#finite-representations"><i class="fa fa-check"></i><b>2.4.1</b> Finite representations</a></li><li class="chapter" data-level="2.4.2" data-path="lec_02_representation.html"><a href="lec_02_representation.html#prefixfreesec"><i class="fa fa-check"></i><b>2.4.2</b> Prefix-free encoding</a></li><li class="chapter" data-level="2.4.3" data-path="lec_02_representation.html"><a href="lec_02_representation.html#making-representations-prefix-free"><i class="fa fa-check"></i><b>2.4.3</b> Making representations prefix-free</a></li><li class="chapter" data-level="2.4.4" data-path="lec_02_representation.html"><a href="lec_02_representation.html#proof-by-python-optional"><i class="fa fa-check"></i><b>2.4.4</b> Proof by Python (optional)</a></li><li class="chapter" data-level="2.4.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-letters-and-text"><i class="fa fa-check"></i><b>2.4.5</b> Representing letters and text</a></li><li class="chapter" data-level="2.4.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-vectors-matrices-images"><i class="fa fa-check"></i><b>2.4.6</b> Representing vectors, matrices, images</a></li><li class="chapter" data-level="2.4.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-graphs"><i class="fa fa-check"></i><b>2.4.7</b> Representing graphs</a></li><li class="chapter" data-level="2.4.8" data-path="lec_02_representation.html"><a href="lec_02_representation.html#representing-lists-and-nested-lists"><i class="fa fa-check"></i><b>2.4.8</b> Representing lists and nested lists</a></li><li class="chapter" data-level="2.4.9" data-path="lec_02_representation.html"><a href="lec_02_representation.html#notation"><i class="fa fa-check"></i><b>2.4.9</b> Notation</a></li></ul></li><li class="chapter" data-level="2.5" data-path="lec_02_representation.html"><a href="lec_02_representation.html#defining-computational-tasks-as-mathematical-functions"><i class="fa fa-check"></i><b>2.5</b> Defining computational tasks as mathematical functions</a><ul><li class="chapter" data-level="2.5.1" data-path="lec_02_representation.html"><a href="lec_02_representation.html#secimplvsspec"><i class="fa fa-check"></i><b>2.5.1</b> Distinguish functions from programs!</a></li></ul></li><li class="chapter" data-level="2.6" data-path="lec_02_representation.html"><a href="lec_02_representation.html#exercises"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li><li class="chapter" data-level="2.7" data-path="lec_02_representation.html"><a href="lec_02_representation.html#bibnotesrepres"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="3" data-path="lec_03_computation.html"><a href="lec_03_computation.html"><i class="fa fa-check"></i><b>3</b> Defining computation</a><ul><li class="chapter" data-level="3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#defining-computation"><i class="fa fa-check"></i><b>3.1</b> Defining computation</a></li><li class="chapter" data-level="3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#computing-using-and-or-and-not."><i class="fa fa-check"></i><b>3.2</b> Computing using AND, OR, and NOT.</a><ul><li class="chapter" data-level="3.2.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#some-properties-of-and-and-or"><i class="fa fa-check"></i><b>3.2.1</b> Some properties of AND and OR</a></li><li class="chapter" data-level="3.2.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#xoraonexample"><i class="fa fa-check"></i><b>3.2.2</b> Extended example: Computing \ensuremath{\mathit{XOR}} from \ensuremath{\mathit{AND}}, \ensuremath{\mathit{OR}}, and \ensuremath{\mathit{NOT}}</a></li><li class="chapter" data-level="3.2.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#informally-defining-basic-operations-and-algorithms"><i class="fa fa-check"></i><b>3.2.3</b> Informally defining basic operations and algorithms</a></li></ul></li><li class="chapter" data-level="3.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#booleancircuitfig"><i class="fa fa-check"></i><b>3.3</b> Boolean Circuits</a><ul><li class="chapter" data-level="3.3.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#boolean-circuits-a-formal-definition"><i class="fa fa-check"></i><b>3.3.1</b> Boolean circuits: a formal definition</a></li><li class="chapter" data-level="3.3.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-circuits-and-straight-line-programs"><i class="fa fa-check"></i><b>3.3.2</b> Equivalence of circuits and straight-line programs</a></li></ul></li><li class="chapter" data-level="3.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#physicalimplementationsec"><i class="fa fa-check"></i><b>3.4</b> Physical implementations of computing devices (digression)</a><ul><li class="chapter" data-level="3.4.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#transistors"><i class="fa fa-check"></i><b>3.4.1</b> Transistors</a></li><li class="chapter" data-level="3.4.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#logical-gates-from-transistors"><i class="fa fa-check"></i><b>3.4.2</b> Logical gates from transistors</a></li><li class="chapter" data-level="3.4.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biological-computing"><i class="fa fa-check"></i><b>3.4.3</b> Biological computing</a></li><li class="chapter" data-level="3.4.4" data-path="lec_03_computation.html"><a href="lec_03_computation.html#cellular-automata-and-the-game-of-life"><i class="fa fa-check"></i><b>3.4.4</b> Cellular automata and the game of life</a></li><li class="chapter" data-level="3.4.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#neural-networks"><i class="fa fa-check"></i><b>3.4.5</b> Neural networks</a></li><li class="chapter" data-level="3.4.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#a-computer-made-from-marbles-and-pipes"><i class="fa fa-check"></i><b>3.4.6</b> A computer made from marbles and pipes</a></li></ul></li><li class="chapter" data-level="3.5" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandsec"><i class="fa fa-check"></i><b>3.5</b> The NAND function</a><ul><li class="chapter" data-level="3.5.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nand-circuits"><i class="fa fa-check"></i><b>3.5.1</b> NAND Circuits</a></li><li class="chapter" data-level="3.5.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#more-examples-of-nand-circuits-optional"><i class="fa fa-check"></i><b>3.5.2</b> More examples of NAND circuits (optional)</a></li><li class="chapter" data-level="3.5.3" data-path="lec_03_computation.html"><a href="lec_03_computation.html#nandcircsec"><i class="fa fa-check"></i><b>3.5.3</b> The NAND-CIRC Programming language</a></li></ul></li><li class="chapter" data-level="3.6" data-path="lec_03_computation.html"><a href="lec_03_computation.html#equivalence-of-all-these-models"><i class="fa fa-check"></i><b>3.6</b> Equivalence of all these models</a><ul><li class="chapter" data-level="3.6.1" data-path="lec_03_computation.html"><a href="lec_03_computation.html#othergatessec"><i class="fa fa-check"></i><b>3.6.1</b> Circuits with other gate sets</a></li><li class="chapter" data-level="3.6.2" data-path="lec_03_computation.html"><a href="lec_03_computation.html#specvsimplrem"><i class="fa fa-check"></i><b>3.6.2</b> Specification vs. implementation (again)</a></li></ul></li><li class="chapter" data-level="3.7" data-path="lec_03_computation.html"><a href="lec_03_computation.html#exercises"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li><li class="chapter" data-level="3.8" data-path="lec_03_computation.html"><a href="lec_03_computation.html#biographical-notes"><i class="fa fa-check"></i><b>3.8</b> Biographical notes</a></li></ul></li><li class="chapter" data-level="4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html"><i class="fa fa-check"></i><b>4</b> Syntactic sugar, and computing every function</a><ul><li class="chapter" data-level="4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secsyntacticsugar"><i class="fa fa-check"></i><b>4.1</b> Some examples of syntactic sugar</a><ul><li class="chapter" data-level="4.1.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#user-defined-procedures"><i class="fa fa-check"></i><b>4.1.1</b> User-defined procedures</a></li><li class="chapter" data-level="4.1.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#functionsynsugarthmpython"><i class="fa fa-check"></i><b>4.1.2</b> Proof by Python (optional)</a></li><li class="chapter" data-level="4.1.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#ifstatementsec"><i class="fa fa-check"></i><b>4.1.3</b> Conditional statements</a></li></ul></li><li class="chapter" data-level="4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#addexample"><i class="fa fa-check"></i><b>4.2</b> Extended example: Addition and Multiplication (optional)</a></li><li class="chapter" data-level="4.3" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seclookupfunc"><i class="fa fa-check"></i><b>4.3</b> The LOOKUP function</a><ul><li class="chapter" data-level="4.3.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#constructing-a-nand-circ-program-for-lookup"><i class="fa fa-check"></i><b>4.3.1</b> Constructing a NAND-CIRC program for \ensuremath{\mathit{LOOKUP}}</a></li></ul></li><li class="chapter" data-level="4.4" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputeallfunctions"><i class="fa fa-check"></i><b>4.4</b> Computing every function</a><ul><li class="chapter" data-level="4.4.1" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#proof-of-nands-universality"><i class="fa fa-check"></i><b>4.4.1</b> Proof of NAND’s Universality</a></li><li class="chapter" data-level="4.4.2" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#tight-upper-bound"><i class="fa fa-check"></i><b>4.4.2</b> Improving by a factor of n (optional)</a></li></ul></li><li class="chapter" data-level="4.5" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#seccomputalternative"><i class="fa fa-check"></i><b>4.5</b> Computing every function: An alternative proof</a></li><li class="chapter" data-level="4.6" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#secdefinesizeclasses"><i class="fa fa-check"></i><b>4.6</b> The class \ensuremath{\mathit{SIZE}}(T)</a></li><li class="chapter" data-level="4.7" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#exercises"><i class="fa fa-check"></i><b>4.7</b> Exercises</a></li><li class="chapter" data-level="4.8" data-path="lec_03a_computing_every_function.html"><a href="lec_03a_computing_every_function.html#computeeveryfunctionbibnotes"><i class="fa fa-check"></i><b>4.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html"><i class="fa fa-check"></i><b>5</b> Code as data, data as code</a><ul><li class="chapter" data-level="5.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#representprogramsec"><i class="fa fa-check"></i><b>5.1</b> Representing programs as strings</a></li><li class="chapter" data-level="5.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#countingcircuitsec"><i class="fa fa-check"></i><b>5.2</b> Counting programs, and lower bounds on the size of NAND-CIRC programs</a><ul><li class="chapter" data-level="5.2.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#size-hierarchy-theorem-optional"><i class="fa fa-check"></i><b>5.2.1</b> Size hierarchy theorem (optional)</a></li></ul></li><li class="chapter" data-level="5.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#listoftuplesrepsec"><i class="fa fa-check"></i><b>5.3</b> The tuples representation</a><ul><li class="chapter" data-level="5.3.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#stringrepresentationrpgoramsec"><i class="fa fa-check"></i><b>5.3.1</b> From tuples to strings</a></li></ul></li><li class="chapter" data-level="5.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4</b> A NAND-CIRC interpreter in NAND-CIRC</a><ul><li class="chapter" data-level="5.4.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#efficient-universal-programs"><i class="fa fa-check"></i><b>5.4.1</b> Efficient universal programs</a></li><li class="chapter" data-level="5.4.2" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-nand-circ-interpeter-in-pseudocode"><i class="fa fa-check"></i><b>5.4.2</b> A NAND-CIRC interpeter in pseudocode</a></li><li class="chapter" data-level="5.4.3" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#nandevalpythonsec"><i class="fa fa-check"></i><b>5.4.3</b> A NAND interpreter in Python</a></li><li class="chapter" data-level="5.4.4" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#constructing-the-nand-circ-interpreter-in-nand-circ"><i class="fa fa-check"></i><b>5.4.4</b> Constructing the NAND-CIRC interpreter in NAND-CIRC</a></li></ul></li><li class="chapter" data-level="5.5" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#a-python-interpreter-in-nand-circ-discussion"><i class="fa fa-check"></i><b>5.5</b> A Python interpreter in NAND-CIRC (discussion)</a></li><li class="chapter" data-level="5.6" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#PECTTsec"><i class="fa fa-check"></i><b>5.6</b> The physical extended Church-Turing thesis (discussion)</a><ul><li class="chapter" data-level="5.6.1" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#attempts-at-refuting-the-pectt"><i class="fa fa-check"></i><b>5.6.1</b> Attempts at refuting the PECTT</a></li></ul></li><li class="chapter" data-level="5.7" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#recap-of-part-i-finite-computation"><i class="fa fa-check"></i><b>5.7</b> Recap of Part I: Finite Computation</a></li><li class="chapter" data-level="5.8" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#exercises"><i class="fa fa-check"></i><b>5.8</b> Exercises</a></li><li class="chapter" data-level="5.9" data-path="lec_04_code_and_data.html"><a href="lec_04_code_and_data.html#bibnotescodeasdata"><i class="fa fa-check"></i><b>5.9</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="6" data-path="lec_06_loops.html"><a href="lec_06_loops.html"><i class="fa fa-check"></i><b>6</b> Loops and infinity</a><ul><li class="chapter" data-level="6.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines"><i class="fa fa-check"></i><b>6.1</b> Turing Machines</a><ul><li class="chapter" data-level="6.1.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turingmachinepalindrome"><i class="fa fa-check"></i><b>6.1.1</b> Extended example: A Turing machine for palindromes</a></li><li class="chapter" data-level="6.1.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-a-formal-definition"><i class="fa fa-check"></i><b>6.1.2</b> Turing machines: a formal definition</a></li><li class="chapter" data-level="6.1.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#computable-functions"><i class="fa fa-check"></i><b>6.1.3</b> Computable functions</a></li><li class="chapter" data-level="6.1.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#infinite-loops-and-partial-functions"><i class="fa fa-check"></i><b>6.1.4</b> Infinite loops and partial functions</a></li></ul></li><li class="chapter" data-level="6.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#turing-machines-as-programming-languages"><i class="fa fa-check"></i><b>6.2</b> Turing machines as programming languages</a><ul><li class="chapter" data-level="6.2.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#the-nand-tm-programming-language"><i class="fa fa-check"></i><b>6.2.1</b> The NAND-TM Programming language</a></li><li class="chapter" data-level="6.2.2" data-path="lec_06_loops.html"><a href="lec_06_loops.html#sneak-peak-nand-tm-vs-turing-machines"><i class="fa fa-check"></i><b>6.2.2</b> Sneak peak: NAND-TM vs Turing machines</a></li><li class="chapter" data-level="6.2.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#examples"><i class="fa fa-check"></i><b>6.2.3</b> Examples</a></li></ul></li><li class="chapter" data-level="6.3" data-path="lec_06_loops.html"><a href="lec_06_loops.html#equivalence-of-turing-machines-and-nand-tm-programs"><i class="fa fa-check"></i><b>6.3</b> Equivalence of Turing machines and NAND-TM programs</a><ul><li class="chapter" data-level="6.3.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#specification-vs-implementation-again"><i class="fa fa-check"></i><b>6.3.1</b> Specification vs implementation (again)</a></li></ul></li><li class="chapter" data-level="6.4" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nand-tm-syntactic-sugar"><i class="fa fa-check"></i><b>6.4</b> NAND-TM syntactic sugar</a><ul><li class="chapter" data-level="6.4.1" data-path="lec_06_loops.html"><a href="lec_06_loops.html#nandtminnerloopssec"><i class="fa fa-check"></i><b>6.4.1</b> GOTO and inner loops</a></li></ul></li><li class="chapter" data-level="6.5" data-path="lec_06_loops.html"><a href="lec_06_loops.html#uniformity-and-nand-vs-nand-tm-discussion"><i class="fa fa-check"></i><b>6.5</b> Uniformity, and NAND vs NAND-TM (discussion)</a></li><li class="chapter" data-level="6.6" data-path="lec_06_loops.html"><a href="lec_06_loops.html#exercises"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li><li class="chapter" data-level="6.7" data-path="lec_06_loops.html"><a href="lec_06_loops.html#chaploopnotes"><i class="fa fa-check"></i><b>6.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html"><i class="fa fa-check"></i><b>7</b> Equivalent models of computation</a><ul><li class="chapter" data-level="7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ram-machines-and-nand-ram"><i class="fa fa-check"></i><b>7.1</b> RAM machines and NAND-RAM</a></li><li class="chapter" data-level="7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#nandtmgorydetailssec"><i class="fa fa-check"></i><b>7.2</b> The gory details (optional)</a><ul><li class="chapter" data-level="7.2.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#indexed-access-in-nand-tm"><i class="fa fa-check"></i><b>7.2.1</b> Indexed access in NAND-TM</a></li><li class="chapter" data-level="7.2.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#two-dimensional-arrays-in-nand-tm"><i class="fa fa-check"></i><b>7.2.2</b> Two dimensional arrays in NAND-TM</a></li><li class="chapter" data-level="7.2.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#all-the-rest"><i class="fa fa-check"></i><b>7.2.3</b> All the rest</a></li></ul></li><li class="chapter" data-level="7.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turing-equivalence-discussion"><i class="fa fa-check"></i><b>7.3</b> Turing equivalence (discussion)</a><ul><li class="chapter" data-level="7.3.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-best-of-both-worlds-paradigm"><i class="fa fa-check"></i><b>7.3.1</b> The Best of both worlds paradigm</a></li><li class="chapter" data-level="7.3.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lets-talk-about-abstractions."><i class="fa fa-check"></i><b>7.3.2</b> Let’s talk about abstractions.</a></li><li class="chapter" data-level="7.3.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingcompletesec"><i class="fa fa-check"></i><b>7.3.3</b> Turing completeness and equivalence, a formal definition (optional)</a></li></ul></li><li class="chapter" data-level="7.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#cellularautomatasec"><i class="fa fa-check"></i><b>7.4</b> Cellular automata</a><ul><li class="chapter" data-level="7.4.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#one-dimensional-cellular-automata-are-turing-complete"><i class="fa fa-check"></i><b>7.4.1</b> One dimensional cellular automata are Turing complete</a></li><li class="chapter" data-level="7.4.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#turingmachinesconfigsec"><i class="fa fa-check"></i><b>7.4.2</b> Configurations of Turing machines and the next-step function</a></li></ul></li><li class="chapter" data-level="7.5" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacalculussec"><i class="fa fa-check"></i><b>7.5</b> Lambda calculus and functional programming languages</a><ul><li class="chapter" data-level="7.5.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#applying-functions-to-functions"><i class="fa fa-check"></i><b>7.5.1</b> Applying functions to functions</a></li><li class="chapter" data-level="7.5.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#curryingsec"><i class="fa fa-check"></i><b>7.5.2</b> Obtaining multi-argument functions via Currying</a></li><li class="chapter" data-level="7.5.3" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#formal-description-of-the-λ-calculus."><i class="fa fa-check"></i><b>7.5.3</b> Formal description of the λ calculus.</a></li><li class="chapter" data-level="7.5.4" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#infiniteloopslambda"><i class="fa fa-check"></i><b>7.5.4</b> Infinite loops in the λ calculus</a></li></ul></li><li class="chapter" data-level="7.6" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6</b> The Enhanced λ calculus</a><ul><li class="chapter" data-level="7.6.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#computing-a-function-in-the-enhanced-λ-calculus"><i class="fa fa-check"></i><b>7.6.1</b> Computing a function in the enhanced λ calculus</a></li><li class="chapter" data-level="7.6.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#enhanced-λ-calculus-is-turing-complete"><i class="fa fa-check"></i><b>7.6.2</b> Enhanced λ calculus is Turing-complete</a></li></ul></li><li class="chapter" data-level="7.7" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#lambdacacluluspuresec"><i class="fa fa-check"></i><b>7.7</b> From enhanced to pure λ calculus</a><ul><li class="chapter" data-level="7.7.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#list-processing"><i class="fa fa-check"></i><b>7.7.1</b> List processing</a></li><li class="chapter" data-level="7.7.2" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#ycombinatorsec"><i class="fa fa-check"></i><b>7.7.2</b> The Y combinator, or recursion without recursion</a></li></ul></li><li class="chapter" data-level="7.8" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#churchturingdiscussionsec"><i class="fa fa-check"></i><b>7.8</b> The Church-Turing Thesis (discussion)</a><ul><li class="chapter" data-level="7.8.1" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#different-models-of-computation"><i class="fa fa-check"></i><b>7.8.1</b> Different models of computation</a></li></ul></li><li class="chapter" data-level="7.9" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#exercises"><i class="fa fa-check"></i><b>7.9</b> Exercises</a></li><li class="chapter" data-level="7.10" data-path="lec_07_other_models.html"><a href="lec_07_other_models.html#othermodelsbibnotes"><i class="fa fa-check"></i><b>7.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="8" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html"><i class="fa fa-check"></i><b>8</b> Universality and uncomputability</a><ul><li class="chapter" data-level="8.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#universality-or-a-meta-circular-evaluator"><i class="fa fa-check"></i><b>8.1</b> Universality or a meta-circular evaluator</a><ul><li class="chapter" data-level="8.1.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#representtmsec"><i class="fa fa-check"></i><b>8.1.1</b> Proving the existence of a universal Turing Machine</a></li><li class="chapter" data-level="8.1.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#implications-of-universality-discussion"><i class="fa fa-check"></i><b>8.1.2</b> Implications of universality (discussion)</a></li></ul></li><li class="chapter" data-level="8.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-every-function-computable"><i class="fa fa-check"></i><b>8.2</b> Is every function computable?</a></li><li class="chapter" data-level="8.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltingsec"><i class="fa fa-check"></i><b>8.3</b> The Halting problem</a><ul><li class="chapter" data-level="8.3.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-the-halting-problem-really-hard-discussion"><i class="fa fa-check"></i><b>8.3.1</b> Is the Halting problem really hard? (discussion)</a></li><li class="chapter" data-level="8.3.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#haltalternativesec"><i class="fa fa-check"></i><b>8.3.2</b> A direct proof of the uncomputability of \ensuremath{\mathit{HALT}} (optional)</a></li></ul></li><li class="chapter" data-level="8.4" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#reductionsuncompsec"><i class="fa fa-check"></i><b>8.4</b> Reductions</a><ul><li class="chapter" data-level="8.4.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#example-halting-on-the-zero-problem"><i class="fa fa-check"></i><b>8.4.1</b> Example: Halting on the zero problem</a></li></ul></li><li class="chapter" data-level="8.5" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#rices-theorem-and-the-impossibility-of-general-software-verification"><i class="fa fa-check"></i><b>8.5</b> Rice’s Theorem and the impossibility of general software verification</a><ul><li class="chapter" data-level="8.5.1" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#ricethmsec"><i class="fa fa-check"></i><b>8.5.1</b> Rice’s Theorem</a></li><li class="chapter" data-level="8.5.2" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#halting-and-rices-theorem-for-other-turing-complete-models"><i class="fa fa-check"></i><b>8.5.2</b> Halting and Rice’s Theorem for other Turing-complete models</a></li><li class="chapter" data-level="8.5.3" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#is-software-verification-doomed-discussion"><i class="fa fa-check"></i><b>8.5.3</b> Is software verification doomed? (discussion)</a></li></ul></li><li class="chapter" data-level="8.6" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#exercises"><i class="fa fa-check"></i><b>8.6</b> Exercises</a></li><li class="chapter" data-level="8.7" data-path="lec_08_uncomputability.html"><a href="lec_08_uncomputability.html#uncomputablebibnotes"><i class="fa fa-check"></i><b>8.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html"><i class="fa fa-check"></i><b>9</b> Restricted computational models</a><ul><li class="chapter" data-level="9.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#turing-completeness-as-a-bug"><i class="fa fa-check"></i><b>9.1</b> Turing completeness as a bug</a></li><li class="chapter" data-level="9.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-expressions"><i class="fa fa-check"></i><b>9.2</b> Regular expressions</a></li><li class="chapter" data-level="9.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#deterministic-finite-automata-and-efficient-matching-of-regular-expressions-optional"><i class="fa fa-check"></i><b>9.3</b> Deterministic finite automata, and efficient matching of regular expressions (optional)</a><ul><li class="chapter" data-level="9.3.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#matching-regular-expressions-using-constant-memory"><i class="fa fa-check"></i><b>9.3.1</b> Matching regular expressions using constant memory</a></li><li class="chapter" data-level="9.3.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#secdfa"><i class="fa fa-check"></i><b>9.3.2</b> Deterministic Finite Automata</a></li><li class="chapter" data-level="9.3.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#regular-functions-are-closed-under-complement"><i class="fa fa-check"></i><b>9.3.3</b> Regular functions are closed under complement</a></li></ul></li><li class="chapter" data-level="9.4" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-regular-expressions"><i class="fa fa-check"></i><b>9.4</b> Limitations of regular expressions</a></li><li class="chapter" data-level="9.5" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#other-semantic-properties-of-regular-expressions"><i class="fa fa-check"></i><b>9.5</b> Other semantic properties of regular expressions</a></li><li class="chapter" data-level="9.6" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#seccfg"><i class="fa fa-check"></i><b>9.6</b> Context free grammars</a><ul><li class="chapter" data-level="9.6.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#context-free-grammars-as-a-computational-model"><i class="fa fa-check"></i><b>9.6.1</b> Context-free grammars as a computational model</a></li><li class="chapter" data-level="9.6.2" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#the-power-of-context-free-grammars"><i class="fa fa-check"></i><b>9.6.2</b> The power of context free grammars</a></li><li class="chapter" data-level="9.6.3" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#limitations-of-context-free-grammars-optional"><i class="fa fa-check"></i><b>9.6.3</b> Limitations of context-free grammars (optional)</a></li></ul></li><li class="chapter" data-level="9.7" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#semantic-properties-of-context-free-languages"><i class="fa fa-check"></i><b>9.7</b> Semantic properties of context free languages</a><ul><li class="chapter" data-level="9.7.1" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#uncomputability-of-context-free-grammar-equivalence-optional"><i class="fa fa-check"></i><b>9.7.1</b> Uncomputability of context-free grammar equivalence (optional)</a></li></ul></li><li class="chapter" data-level="9.8" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#summary-of-semantic-properties-for-regular-expressions-and-context-free-grammars"><i class="fa fa-check"></i><b>9.8</b> Summary of semantic properties for regular expressions and context-free grammars</a></li><li class="chapter" data-level="9.9" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#exercises"><i class="fa fa-check"></i><b>9.9</b> Exercises</a></li><li class="chapter" data-level="9.10" data-path="lec_08a_restricted_models.html"><a href="lec_08a_restricted_models.html#bibliographical-notes"><i class="fa fa-check"></i><b>9.10</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="10" data-path="lec_09_godel.html"><a href="lec_09_godel.html"><i class="fa fa-check"></i><b>10</b> Is every theorem provable?</a><ul><li class="chapter" data-level="10.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofdef"><i class="fa fa-check"></i><b>10.1</b> Hilbert’s Program and Gödel’s Incompleteness Theorem</a><ul><li class="chapter" data-level="10.1.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#godelproofsystemssec"><i class="fa fa-check"></i><b>10.1.1</b> Defining Proof Systems</a></li></ul></li><li class="chapter" data-level="10.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#gödels-incompleteness-theorem-computational-variant"><i class="fa fa-check"></i><b>10.2</b> Gödel’s Incompleteness Theorem: Computational variant</a></li><li class="chapter" data-level="10.3" data-path="lec_09_godel.html"><a href="lec_09_godel.html#quantified-integer-statements"><i class="fa fa-check"></i><b>10.3</b> Quantified integer statements</a></li><li class="chapter" data-level="10.4" data-path="lec_09_godel.html"><a href="lec_09_godel.html#diophantine-equations-and-the-mrdp-theorem"><i class="fa fa-check"></i><b>10.4</b> Diophantine equations and the MRDP Theorem</a></li><li class="chapter" data-level="10.5" data-path="lec_09_godel.html"><a href="lec_09_godel.html#hardness-of-quantified-integer-statements"><i class="fa fa-check"></i><b>10.5</b> Hardness of quantified integer statements</a><ul><li class="chapter" data-level="10.5.1" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-1-quantified-mixed-statements-and-computation-histories"><i class="fa fa-check"></i><b>10.5.1</b> Step 1: Quantified mixed statements and computation histories</a></li><li class="chapter" data-level="10.5.2" data-path="lec_09_godel.html"><a href="lec_09_godel.html#step-2-reducing-mixed-statements-to-integer-statements"><i class="fa fa-check"></i><b>10.5.2</b> Step 2: Reducing mixed statements to integer statements</a></li></ul></li><li class="chapter" data-level="10.6" data-path="lec_09_godel.html"><a href="lec_09_godel.html#exercises"><i class="fa fa-check"></i><b>10.6</b> Exercises</a></li><li class="chapter" data-level="10.7" data-path="lec_09_godel.html"><a href="lec_09_godel.html#bibliographical-notes"><i class="fa fa-check"></i><b>10.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="11" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html"><i class="fa fa-check"></i><b>11</b> Efficient computation</a><ul><li class="chapter" data-level="11.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#problems-on-graphs"><i class="fa fa-check"></i><b>11.1</b> Problems on graphs</a><ul><li class="chapter" data-level="11.1.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-shortest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.1</b> Finding the shortest path in a graph</a></li><li class="chapter" data-level="11.1.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-longest-path-in-a-graph"><i class="fa fa-check"></i><b>11.1.2</b> Finding the longest path in a graph</a></li><li class="chapter" data-level="11.1.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#mincutsec"><i class="fa fa-check"></i><b>11.1.3</b> Finding the minimum cut in a graph</a></li><li class="chapter" data-level="11.1.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#linerprogsec"><i class="fa fa-check"></i><b>11.1.4</b> Min-Cut Max-Flow and Linear programming</a></li><li class="chapter" data-level="11.1.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-the-maximum-cut-in-a-graph"><i class="fa fa-check"></i><b>11.1.5</b> Finding the maximum cut in a graph</a></li><li class="chapter" data-level="11.1.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#a-note-on-convexity"><i class="fa fa-check"></i><b>11.1.6</b> A note on convexity</a></li></ul></li><li class="chapter" data-level="11.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#beyond-graphs"><i class="fa fa-check"></i><b>11.2</b> Beyond graphs</a><ul><li class="chapter" data-level="11.2.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#sat"><i class="fa fa-check"></i><b>11.2.1</b> SAT</a></li><li class="chapter" data-level="11.2.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-linear-equations"><i class="fa fa-check"></i><b>11.2.2</b> Solving linear equations</a></li><li class="chapter" data-level="11.2.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#solving-quadratic-equations"><i class="fa fa-check"></i><b>11.2.3</b> Solving quadratic equations</a></li></ul></li><li class="chapter" data-level="11.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#more-advanced-examples"><i class="fa fa-check"></i><b>11.3</b> More advanced examples</a><ul><li class="chapter" data-level="11.3.1" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#determinant-of-a-matrix"><i class="fa fa-check"></i><b>11.3.1</b> Determinant of a matrix</a></li><li class="chapter" data-level="11.3.2" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#permanent-of-a-matrix"><i class="fa fa-check"></i><b>11.3.2</b> Permanent of a matrix</a></li><li class="chapter" data-level="11.3.3" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-zero-sum-equilibrium"><i class="fa fa-check"></i><b>11.3.3</b> Finding a zero-sum equilibrium</a></li><li class="chapter" data-level="11.3.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#finding-a-nash-equilibrium"><i class="fa fa-check"></i><b>11.3.4</b> Finding a Nash equilibrium</a></li><li class="chapter" data-level="11.3.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#primality-testing"><i class="fa fa-check"></i><b>11.3.5</b> Primality testing</a></li><li class="chapter" data-level="11.3.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#integer-factoring"><i class="fa fa-check"></i><b>11.3.6</b> Integer factoring</a></li></ul></li><li class="chapter" data-level="11.4" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#our-current-knowledge"><i class="fa fa-check"></i><b>11.4</b> Our current knowledge</a></li><li class="chapter" data-level="11.5" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#exercises"><i class="fa fa-check"></i><b>11.5</b> Exercises</a></li><li class="chapter" data-level="11.6" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#effalgnotes"><i class="fa fa-check"></i><b>11.6</b> Bibliographical notes</a></li><li class="chapter" data-level="11.7" data-path="lec_10_efficient_alg.html"><a href="lec_10_efficient_alg.html#further-explorations"><i class="fa fa-check"></i><b>11.7</b> Further explorations</a></li></ul></li><li class="chapter" data-level="12" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html"><i class="fa fa-check"></i><b>12</b> Modeling running time</a><ul><li class="chapter" data-level="12.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#formally-defining-running-time"><i class="fa fa-check"></i><b>12.1</b> Formally defining running time</a><ul><li class="chapter" data-level="12.1.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#polynomial-and-exponential-time"><i class="fa fa-check"></i><b>12.1.1</b> Polynomial and Exponential Time</a></li></ul></li><li class="chapter" data-level="12.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#modeling-running-time-using-ram-machines-nand-ram"><i class="fa fa-check"></i><b>12.2</b> Modeling running time using RAM Machines / NAND-RAM</a></li><li class="chapter" data-level="12.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#ECTTsec"><i class="fa fa-check"></i><b>12.3</b> Extended Church-Turing Thesis (discussion)</a></li><li class="chapter" data-level="12.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#efficient-universal-machine-a-nand-ram-interpreter-in-nand-ram"><i class="fa fa-check"></i><b>12.4</b> Efficient universal machine: a NAND-RAM interpreter in NAND-RAM</a><ul><li class="chapter" data-level="12.4.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#timed-universal-turing-machine"><i class="fa fa-check"></i><b>12.4.1</b> Timed Universal Turing Machine</a></li></ul></li><li class="chapter" data-level="12.5" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#the-time-hierarchy-theorem"><i class="fa fa-check"></i><b>12.5</b> The time hierarchy theorem</a></li><li class="chapter" data-level="12.6" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#nonuniformcompsec"><i class="fa fa-check"></i><b>12.6</b> Non uniform computation</a><ul><li class="chapter" data-level="12.6.1" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#obliviousnandtm"><i class="fa fa-check"></i><b>12.6.1</b> Oblivious NAND-TM programs</a></li><li class="chapter" data-level="12.6.2" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#unrollloopsec"><i class="fa fa-check"></i><b>12.6.2</b> Unrolling the loop: algorithmic transformation of Turing Machines to circuits</a></li><li class="chapter" data-level="12.6.3" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#can-uniform-algorithms-simulate-non-uniform-ones"><i class="fa fa-check"></i><b>12.6.3</b> Can uniform algorithms simulate non uniform ones?</a></li><li class="chapter" data-level="12.6.4" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#uniform-vs.-nonuniform-computation-a-recap"><i class="fa fa-check"></i><b>12.6.4</b> Uniform vs. Nonuniform computation: A recap</a></li></ul></li><li class="chapter" data-level="12.7" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#exercises"><i class="fa fa-check"></i><b>12.7</b> Exercises</a></li><li class="chapter" data-level="12.8" data-path="lec_11_running_time.html"><a href="lec_11_running_time.html#bibnotesrunningtime"><i class="fa fa-check"></i><b>12.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="13" data-path="lec_12_NP.html"><a href="lec_12_NP.html"><i class="fa fa-check"></i><b>13</b> Polynomial-time reductions</a><ul><li class="chapter" data-level="13.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#formaldefdecisionexamplessec"><i class="fa fa-check"></i><b>13.1</b> Formal definitions of problems</a></li><li class="chapter" data-level="13.2" data-path="lec_12_NP.html"><a href="lec_12_NP.html#polytimeredsec"><i class="fa fa-check"></i><b>13.2</b> Polynomial-time reductions</a></li><li class="chapter" data-level="13.3" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-zero-one-equations"><i class="fa fa-check"></i><b>13.3</b> Reducing 3SAT to zero one equations</a><ul><li class="chapter" data-level="13.3.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#quadratic-equations"><i class="fa fa-check"></i><b>13.3.1</b> Quadratic equations</a></li></ul></li><li class="chapter" data-level="13.4" data-path="lec_12_NP.html"><a href="lec_12_NP.html#the-independent-set-problem"><i class="fa fa-check"></i><b>13.4</b> The independent set problem</a></li><li class="chapter" data-level="13.5" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-independent-set-to-maximum-cut"><i class="fa fa-check"></i><b>13.5</b> Reducing Independent Set to Maximum Cut</a></li><li class="chapter" data-level="13.6" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reducing-3sat-to-longest-path"><i class="fa fa-check"></i><b>13.6</b> Reducing 3SAT to Longest Path</a><ul><li class="chapter" data-level="13.6.1" data-path="lec_12_NP.html"><a href="lec_12_NP.html#summary-of-relations"><i class="fa fa-check"></i><b>13.6.1</b> Summary of relations</a></li></ul></li><li class="chapter" data-level="13.7" data-path="lec_12_NP.html"><a href="lec_12_NP.html#exercises"><i class="fa fa-check"></i><b>13.7</b> Exercises</a></li><li class="chapter" data-level="13.8" data-path="lec_12_NP.html"><a href="lec_12_NP.html#reductionsbibnotes"><i class="fa fa-check"></i><b>13.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="14" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html"><i class="fa fa-check"></i><b>14</b> NP, NP completeness, and the Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-class-mathbfnp"><i class="fa fa-check"></i><b>14.1</b> The class \mathbf{NP}</a><ul><li class="chapter" data-level="14.1.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#examples-of-functions-in-mathbfnp"><i class="fa fa-check"></i><b>14.1.1</b> Examples of functions in \mathbf{NP}</a></li><li class="chapter" data-level="14.1.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#basic-facts-about-mathbfnp"><i class="fa fa-check"></i><b>14.1.2</b> Basic facts about \mathbf{NP}</a></li></ul></li><li class="chapter" data-level="14.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-mathbfnp-to-3sat-the-cook-levin-theorem"><i class="fa fa-check"></i><b>14.2</b> From \mathbf{NP} to 3SAT: The Cook-Levin Theorem</a><ul><li class="chapter" data-level="14.2.1" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#what-does-this-mean"><i class="fa fa-check"></i><b>14.2.1</b> What does this mean?</a></li><li class="chapter" data-level="14.2.2" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-cook-levin-theorem-proof-outline"><i class="fa fa-check"></i><b>14.2.2</b> The Cook-Levin Theorem: Proof outline</a></li></ul></li><li class="chapter" data-level="14.3" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-nandsat-problem-and-why-it-is-mathbfnp-hard."><i class="fa fa-check"></i><b>14.3</b> The \ensuremath{\mathit{NANDSAT}} Problem, and why it is \mathbf{NP} hard.</a></li><li class="chapter" data-level="14.4" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#the-3nand-problem"><i class="fa fa-check"></i><b>14.4</b> The 3\ensuremath{\mathit{NAND}} problem</a></li><li class="chapter" data-level="14.5" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#from-3nand-to-3sat"><i class="fa fa-check"></i><b>14.5</b> From 3\ensuremath{\mathit{NAND}} to 3\ensuremath{\mathit{SAT}}</a></li><li class="chapter" data-level="14.6" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#wrapping-up"><i class="fa fa-check"></i><b>14.6</b> Wrapping up</a></li><li class="chapter" data-level="14.7" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#exercises"><i class="fa fa-check"></i><b>14.7</b> Exercises</a></li><li class="chapter" data-level="14.8" data-path="lec_13_Cook_Levin.html"><a href="lec_13_Cook_Levin.html#bibliographical-notes"><i class="fa fa-check"></i><b>14.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="15" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html"><i class="fa fa-check"></i><b>15</b> What if P equals NP?</a><ul><li class="chapter" data-level="15.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#search-to-decision-reduction"><i class="fa fa-check"></i><b>15.1</b> Search-to-decision reduction</a></li><li class="chapter" data-level="15.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#optimizationsection"><i class="fa fa-check"></i><b>15.2</b> Optimization</a><ul><li class="chapter" data-level="15.2.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-supervised-learning"><i class="fa fa-check"></i><b>15.2.1</b> Example: Supervised learning</a></li><li class="chapter" data-level="15.2.2" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#example-breaking-cryptosystems"><i class="fa fa-check"></i><b>15.2.2</b> Example: Breaking cryptosystems</a></li></ul></li><li class="chapter" data-level="15.3" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#finding-mathematical-proofs"><i class="fa fa-check"></i><b>15.3</b> Finding mathematical proofs</a></li><li class="chapter" data-level="15.4" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#quantifier-elimination-advanced"><i class="fa fa-check"></i><b>15.4</b> Quantifier elimination (advanced)</a><ul><li class="chapter" data-level="15.4.1" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#selfimprovingsat"><i class="fa fa-check"></i><b>15.4.1</b> Application: self improving algorithm for 3\ensuremath{\mathit{SAT}}</a></li></ul></li><li class="chapter" data-level="15.5" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#approximating-counting-problems-and-posterior-sampling-advanced-optional"><i class="fa fa-check"></i><b>15.5</b> Approximating counting problems and posterior sampling (advanced, optional)</a></li><li class="chapter" data-level="15.6" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-does-all-of-this-imply"><i class="fa fa-check"></i><b>15.6</b> What does all of this imply?</a></li><li class="chapter" data-level="15.7" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#can-mathbfp-neq-mathbfnp-be-neither-true-nor-false"><i class="fa fa-check"></i><b>15.7</b> Can \mathbf{P} \neq \mathbf{NP} be neither true nor false?</a></li><li class="chapter" data-level="15.8" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#is-mathbfpmathbfnp-in-practice"><i class="fa fa-check"></i><b>15.8</b> Is \mathbf{P}=\mathbf{NP} in practice?</a></li><li class="chapter" data-level="15.9" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#what-if-mathbfp-neq-mathbfnp"><i class="fa fa-check"></i><b>15.9</b> What if \mathbf{P} \neq \mathbf{NP}?</a></li><li class="chapter" data-level="15.10" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#exercises"><i class="fa fa-check"></i><b>15.10</b> Exercises</a></li><li class="chapter" data-level="15.11" data-path="lec_14_PvsNP.html"><a href="lec_14_PvsNP.html#bibliographical-notes"><i class="fa fa-check"></i><b>15.11</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="16" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html"><i class="fa fa-check"></i><b>16</b> Space bounded computation</a><ul><li class="chapter" data-level="16.1" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#lecture-summary"><i class="fa fa-check"></i><b>16.1</b> Lecture summary</a></li><li class="chapter" data-level="16.2" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#exercises"><i class="fa fa-check"></i><b>16.2</b> Exercises</a></li><li class="chapter" data-level="16.3" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#bibliographical-notes"><i class="fa fa-check"></i><b>16.3</b> Bibliographical notes</a></li><li class="chapter" data-level="16.4" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#further-explorations"><i class="fa fa-check"></i><b>16.4</b> Further explorations</a></li><li class="chapter" data-level="16.5" data-path="lec_14a_space_complexity.html"><a href="lec_14a_space_complexity.html#acknowledgements"><i class="fa fa-check"></i><b>16.5</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="17" data-path="lec_15_probability.html"><a href="lec_15_probability.html"><i class="fa fa-check"></i><b>17</b> Probability Theory 101</a><ul><li class="chapter" data-level="17.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-coins"><i class="fa fa-check"></i><b>17.1</b> Random coins</a><ul><li class="chapter" data-level="17.1.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#random-variables"><i class="fa fa-check"></i><b>17.1.1</b> Random variables</a></li><li class="chapter" data-level="17.1.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#distributions-over-strings"><i class="fa fa-check"></i><b>17.1.2</b> Distributions over strings</a></li><li class="chapter" data-level="17.1.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>17.1.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="17.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#correlations-and-independence"><i class="fa fa-check"></i><b>17.2</b> Correlations and independence</a><ul><li class="chapter" data-level="17.2.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#independent-random-variables"><i class="fa fa-check"></i><b>17.2.1</b> Independent random variables</a></li><li class="chapter" data-level="17.2.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>17.2.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="17.3" data-path="lec_15_probability.html"><a href="lec_15_probability.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>17.3</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="17.3.1" data-path="lec_15_probability.html"><a href="lec_15_probability.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>17.3.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="17.3.2" data-path="lec_15_probability.html"><a href="lec_15_probability.html#the-chernoff-bound"><i class="fa fa-check"></i><b>17.3.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="17.4" data-path="lec_15_probability.html"><a href="lec_15_probability.html#exercises"><i class="fa fa-check"></i><b>17.4</b> Exercises</a></li><li class="chapter" data-level="17.5" data-path="lec_15_probability.html"><a href="lec_15_probability.html#bibliographical-notes"><i class="fa fa-check"></i><b>17.5</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="18" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html"><i class="fa fa-check"></i><b>18</b> Probabilistic computation</a><ul><li class="chapter" data-level="18.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#finding-approximately-good-maximum-cuts."><i class="fa fa-check"></i><b>18.1</b> Finding approximately good maximum cuts.</a><ul><li class="chapter" data-level="18.1.1" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#amplifying-the-success-of-randomized-algorithms"><i class="fa fa-check"></i><b>18.1.1</b> Amplifying the success of randomized algorithms</a></li><li class="chapter" data-level="18.1.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#success-amplification"><i class="fa fa-check"></i><b>18.1.2</b> Success amplification</a></li><li class="chapter" data-level="18.1.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#two-sided-amplification"><i class="fa fa-check"></i><b>18.1.3</b> Two-sided amplification</a></li><li class="chapter" data-level="18.1.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#what-does-this-mean"><i class="fa fa-check"></i><b>18.1.4</b> What does this mean?</a></li><li class="chapter" data-level="18.1.5" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#solving-sat-through-randomization"><i class="fa fa-check"></i><b>18.1.5</b> Solving SAT through randomization</a></li><li class="chapter" data-level="18.1.6" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bipartite-matching."><i class="fa fa-check"></i><b>18.1.6</b> Bipartite matching.</a></li></ul></li><li class="chapter" data-level="18.2" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#exercises"><i class="fa fa-check"></i><b>18.2</b> Exercises</a></li><li class="chapter" data-level="18.3" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#bibliographical-notes"><i class="fa fa-check"></i><b>18.3</b> Bibliographical notes</a></li><li class="chapter" data-level="18.4" data-path="lec_16_randomized_alg.html"><a href="lec_16_randomized_alg.html#acknowledgements"><i class="fa fa-check"></i><b>18.4</b> Acknowledgements</a></li></ul></li><li class="chapter" data-level="19" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html"><i class="fa fa-check"></i><b>19</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modeling-randomized-computation"><i class="fa fa-check"></i><b>19.1</b> Modeling randomized computation</a><ul><li class="chapter" data-level="19.1.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#an-alternative-view-random-coins-as-an-extra-input"><i class="fa fa-check"></i><b>19.1.1</b> An alternative view: random coins as an extra input</a></li><li class="chapter" data-level="19.1.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#successamptwosided"><i class="fa fa-check"></i><b>19.1.2</b> Success amplification of two-sided error algorithms</a></li></ul></li><li class="chapter" data-level="19.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfbpp-and-mathbfnp-completeness"><i class="fa fa-check"></i><b>19.2</b> \mathbf{BPP} and \mathbf{NP} completeness</a></li><li class="chapter" data-level="19.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#the-power-of-randomization"><i class="fa fa-check"></i><b>19.3</b> The power of randomization</a><ul><li class="chapter" data-level="19.3.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#solving-mathbfbpp-in-exponential-time"><i class="fa fa-check"></i><b>19.3.1</b> Solving \mathbf{BPP} in exponential time</a></li><li class="chapter" data-level="19.3.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#simulating-randomized-algorithms-by-circuits"><i class="fa fa-check"></i><b>19.3.2</b> Simulating randomized algorithms by circuits</a></li></ul></li><li class="chapter" data-level="19.4" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#derandomization"><i class="fa fa-check"></i><b>19.4</b> Derandomization</a><ul><li class="chapter" data-level="19.4.1" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.1</b> Pseudorandom generators</a></li><li class="chapter" data-level="19.4.2" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#optimalprgconj"><i class="fa fa-check"></i><b>19.4.2</b> From existence to constructivity</a></li><li class="chapter" data-level="19.4.3" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#usefulness-of-pseudorandom-generators"><i class="fa fa-check"></i><b>19.4.3</b> Usefulness of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="19.5" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#mathbfpmathbfnp-and-mathbfbpp-vs-mathbfp"><i class="fa fa-check"></i><b>19.5</b> \mathbf{P}=\mathbf{NP} and \mathbf{BPP} vs \mathbf{P}</a></li><li class="chapter" data-level="19.6" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#non-constructive-existence-of-pseudorandom-generators-advanced-optional"><i class="fa fa-check"></i><b>19.6</b> Non-constructive existence of pseudorandom generators (advanced, optional)</a></li><li class="chapter" data-level="19.7" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#exercises"><i class="fa fa-check"></i><b>19.7</b> Exercises</a></li><li class="chapter" data-level="19.8" data-path="lec_17_model_rand.html"><a href="lec_17_model_rand.html#modelrandbibnotes"><i class="fa fa-check"></i><b>19.8</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="20" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html"><i class="fa fa-check"></i><b>20</b> Cryptography</a><ul><li class="chapter" data-level="20.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#classical-cryptosystems"><i class="fa fa-check"></i><b>20.1</b> Classical cryptosystems</a></li><li class="chapter" data-level="20.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-encryption"><i class="fa fa-check"></i><b>20.2</b> Defining encryption</a></li><li class="chapter" data-level="20.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>20.3</b> Defining security of encryption</a></li><li class="chapter" data-level="20.4" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#perfect-secrecy"><i class="fa fa-check"></i><b>20.4</b> Perfect secrecy</a><ul><li class="chapter" data-level="20.4.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#example-perfect-secrecy-in-the-battlefield"><i class="fa fa-check"></i><b>20.4.1</b> Example: Perfect secrecy in the battlefield</a></li><li class="chapter" data-level="20.4.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#constructing-perfectly-secret-encryption"><i class="fa fa-check"></i><b>20.4.2</b> Constructing perfectly secret encryption</a></li></ul></li><li class="chapter" data-level="20.5" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>20.5</b> Necessity of long keys</a></li><li class="chapter" data-level="20.6" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy"><i class="fa fa-check"></i><b>20.6</b> Computational secrecy</a><ul><li class="chapter" data-level="20.6.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#stream-ciphers-or-the-derandomized-one-time-pad"><i class="fa fa-check"></i><b>20.6.1</b> Stream ciphers or the derandomized one-time pad</a></li></ul></li><li class="chapter" data-level="20.7" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#computational-secrecy-and-mathbfnp"><i class="fa fa-check"></i><b>20.7</b> Computational secrecy and \mathbf{NP}</a></li><li class="chapter" data-level="20.8" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#public-key-cryptography"><i class="fa fa-check"></i><b>20.8</b> Public key cryptography</a><ul><li class="chapter" data-level="20.8.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#defining-public-key-encryption"><i class="fa fa-check"></i><b>20.8.1</b> Defining public key encryption</a></li><li class="chapter" data-level="20.8.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>20.8.2</b> Diffie-Hellman key exchange</a></li></ul></li><li class="chapter" data-level="20.9" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#other-security-notions"><i class="fa fa-check"></i><b>20.9</b> Other security notions</a></li><li class="chapter" data-level="20.10" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#magic"><i class="fa fa-check"></i><b>20.10</b> Magic</a><ul><li class="chapter" data-level="20.10.1" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#zero-knowledge-proofs"><i class="fa fa-check"></i><b>20.10.1</b> Zero knowledge proofs</a></li><li class="chapter" data-level="20.10.2" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#fully-homomorphic-encryption"><i class="fa fa-check"></i><b>20.10.2</b> Fully homomorphic encryption</a></li><li class="chapter" data-level="20.10.3" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#multiparty-secure-computation"><i class="fa fa-check"></i><b>20.10.3</b> Multiparty secure computation</a></li></ul></li><li class="chapter" data-level="20.11" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#exercises"><i class="fa fa-check"></i><b>20.11</b> Exercises</a></li><li class="chapter" data-level="20.12" data-path="lec_19_cryptography.html"><a href="lec_19_cryptography.html#bibliographical-notes"><i class="fa fa-check"></i><b>20.12</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="21" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html"><i class="fa fa-check"></i><b>21</b> Proofs and algorithms</a><ul><li class="chapter" data-level="21.1" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#exercises"><i class="fa fa-check"></i><b>21.1</b> Exercises</a></li><li class="chapter" data-level="21.2" data-path="lec_24_proofs.html"><a href="lec_24_proofs.html#bibliographical-notes"><i class="fa fa-check"></i><b>21.2</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="22" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html"><i class="fa fa-check"></i><b>22</b> Quantum computing</a><ul><li class="chapter" data-level="22.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>22.1</b> The double slit experiment</a></li><li class="chapter" data-level="22.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes"><i class="fa fa-check"></i><b>22.2</b> Quantum amplitudes</a><ul><li class="chapter" data-level="22.2.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#linear-algebra-quick-review"><i class="fa fa-check"></i><b>22.2.1</b> Linear algebra quick review</a></li></ul></li><li class="chapter" data-level="22.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#bellineqsec"><i class="fa fa-check"></i><b>22.3</b> Bell’s Inequality</a></li><li class="chapter" data-level="22.4" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-weirdness"><i class="fa fa-check"></i><b>22.4</b> Quantum weirdness</a></li><li class="chapter" data-level="22.5" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>22.5</b> Quantum computing and computation - an executive summary.</a></li><li class="chapter" data-level="22.6" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems"><i class="fa fa-check"></i><b>22.6</b> Quantum systems</a><ul><li class="chapter" data-level="22.6.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-amplitudes-1"><i class="fa fa-check"></i><b>22.6.1</b> Quantum amplitudes</a></li><li class="chapter" data-level="22.6.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-systems-an-executive-summary"><i class="fa fa-check"></i><b>22.6.2</b> Quantum systems: an executive summary</a></li></ul></li><li class="chapter" data-level="22.7" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#analysis-of-bells-inequality-optional"><i class="fa fa-check"></i><b>22.7</b> Analysis of Bell’s Inequality (optional)</a></li><li class="chapter" data-level="22.8" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-computation"><i class="fa fa-check"></i><b>22.8</b> Quantum computation</a><ul><li class="chapter" data-level="22.8.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-circuits"><i class="fa fa-check"></i><b>22.8.1</b> Quantum circuits</a></li><li class="chapter" data-level="22.8.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#qnand-circ-programs-optional"><i class="fa fa-check"></i><b>22.8.2</b> QNAND-CIRC programs (optional)</a></li><li class="chapter" data-level="22.8.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#uniform-computation"><i class="fa fa-check"></i><b>22.8.3</b> Uniform computation</a></li></ul></li><li class="chapter" data-level="22.9" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>22.9</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="22.10" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-hearing-the-shape-of-prime-factors"><i class="fa fa-check"></i><b>22.10</b> Shor’s Algorithm: Hearing the shape of prime factors</a><ul><li class="chapter" data-level="22.10.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#period-finding"><i class="fa fa-check"></i><b>22.10.1</b> Period finding</a></li><li class="chapter" data-level="22.10.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#shors-algorithm-a-birds-eye-view"><i class="fa fa-check"></i><b>22.10.2</b> Shor’s Algorithm: A bird’s eye view</a></li></ul></li><li class="chapter" data-level="22.11" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-advanced-optional"><i class="fa fa-check"></i><b>22.11</b> Quantum Fourier Transform (advanced, optional)</a><ul><li class="chapter" data-level="22.11.1" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantum-fourier-transform-over-the-boolean-cube-simons-algorithm"><i class="fa fa-check"></i><b>22.11.1</b> Quantum Fourier Transform over the Boolean Cube: Simon’s Algorithm</a></li><li class="chapter" data-level="22.11.2" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-fourier-to-period-finding-simons-algorithm-advanced-optional"><i class="fa fa-check"></i><b>22.11.2</b> From Fourier to Period finding: Simon’s Algorithm (advanced, optional)</a></li><li class="chapter" data-level="22.11.3" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#from-simon-to-shor-advanced-optional"><i class="fa fa-check"></i><b>22.11.3</b> From Simon to Shor (advanced, optional)</a></li></ul></li><li class="chapter" data-level="22.12" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#exercises"><i class="fa fa-check"></i><b>22.12</b> Exercises</a></li><li class="chapter" data-level="22.13" data-path="lec_26_quantum_computing.html"><a href="lec_26_quantum_computing.html#quantumbibnotessec"><i class="fa fa-check"></i><b>22.13</b> Bibliographical notes</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Is every theorem provable?</a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/tcs/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/introtcs/lec_09_godel.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 id="godelchap" data-number="10">Is every theorem provable?</h1>
<div id="section" class="objectives" name="Objectives">
<ul>
<li>More examples of uncomputable functions that are not as tied to computation.</li>
<li>Gödel’s incompleteness theorem - a result that shook the world of mathematics in the early 20th century.</li>
</ul>
</div>
<blockquote>
<p><em>“Take any definite unsolved problem, such as … the existence of an infinite number of prime numbers of the form <span><span class="math inline">\(2^n + 1\)</span></span>. However unapproachable these problems may seem to us and however helpless we stand before them, we have, nevertheless, the firm conviction that their solution must follow by a finite number of purely logical processes…”</em><br />
<em>“…This conviction of the solvability of every mathematical problem is a powerful incentive to the worker. We hear within us the perpetual call: There is the problem. Seek its solution. You can find it by pure reason, for in mathematics there is no ignorabimus.”</em>, David Hilbert, 1900.</p>
</blockquote>
<blockquote>
<p><em>“The meaning of a statement is its method of verification.”</em>, Moritz Schlick, 1938 (aka “The verification principle” of logical positivism)</p>
</blockquote>
<p>The problems shown uncomputable in <a href='lec_08_uncomputability.html#chapcomputable'>Chapter 8</a>, while natural and important, still intimately involved NAND-TM programs or other computing mechanisms in their definitions. One could perhaps hope that as long as we steer clear of functions whose inputs are themselves programs, we can avoid the “curse of uncomputability”. Alas, we have no such luck.</p>
<p>In this chapter we will see an example of a natural and seemingly “computation free” problem that nevertheless turns out to be uncomputable: solving Diophantine equations. As a corollary, we will see one of the most striking results of 20th century mathematics: <em>Gödel’s Incompleteness Theorem</em>, which showed that there are some mathematical statements (in fact, in number theory) that are <em>inherently unprovable</em>. We will actually start with the latter result, and then show the former.</p>
<figure>
<img src="../figure/godelstructure.png" alt="10.1: Outline of the results of this chapter. One version of Gödel’s Incompleteness Theorem is an immediate concsequence of the uncomputability of the Halting problem. To obtain the theorem as originally stated (for statements about the integers) we first prove that the \ensuremath{\mathit{QMS}} problem of determining truth of quantified statements involving both integers and strings is uncomputable. We do so using the notion of Turing Machine configurations but there are alternative approaches to do so as well, see ." id="godelstructurefig" /><figcaption>10.1: Outline of the results of this chapter. One version of Gödel’s Incompleteness Theorem is an immediate concsequence of the uncomputability of the Halting problem. To obtain the theorem as originally stated (for statements about the integers) we first prove that the <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> problem of determining truth of quantified statements involving both integers and strings is uncomputable. We do so using the notion of <em>Turing Machine configurations</em> but there are alternative approaches to do so as well, see <a href='#alternativeproofs'>Remark 10.14</a>.</figcaption>
</figure>
<h2 id="godelproofdef" data-number="10.1">Hilbert’s Program and Gödel’s Incompleteness Theorem</h2>
<blockquote>
<p><em>“And what are these …vanishing increments? They are neither finite quantities, nor quantities infinitely small, nor yet nothing. May we not call them the ghosts of departed quantities?”</em>, George Berkeley, Bishop of Cloyne, 1734.</p>
</blockquote>
<p>The 1700’s and 1800’s were a time of great discoveries in mathematics but also of several crises. The discovery of calculus by Newton and Leibnitz in the late 1600’s ushered a golden age of problem solving. Many longstanding challenges succumbed to the new tools that were discovered, and mathematicians got ever better at doing some truly impressive calculations. However, the rigorous foundations behind these calculations left much to be desired. Mathematicians manipulated infinitesimal quantities and infinite series cavalierly, and while most of the time they ended up with the correct results, there were a few strange examples (such as trying to calculate the value of the infinite series <span><span class="math inline">\(1-1+1-1+1+\ldots\)</span></span>) which seemed to give out different answers depending on the method of calculation. This led to a growing sense of unease in the foundations of the subject which was addressed in the works of mathematicians such as Cauchy, Weierstrass, and Riemann, who eventually placed analysis on firmer foundations, giving rise to the <span><span class="math inline">\(\epsilon\)</span></span>’s and <span><span class="math inline">\(\delta\)</span></span>’s that students taking honors calculus grapple with to this day.</p>
<p>In the beginning of the 20th century, there was an effort to replicate this effort, in greater rigor, to all parts of mathematics. The hope was to show that all the true results of mathematics can be obtained by starting with a number of axioms, and deriving theorems from them using logical rules of inference. This effort was known as the <em>Hilbert program</em>, named after the influential mathematician David Hilbert.</p>
<p>Alas, it turns out the results we’ve seen dealt a devastating blow to this program, as was shown by Kurt Gödel in 1931:</p>
<div id="godethmtakeone" class="theorem" title="Gödel&#39;s Incompleteness Theorem:  informal version" name="Theorem 10.3 (Gödel&#39;s Incompleteness Theorem:  informal version) ">
<p>For every sound proof system <span><span class="math inline">\(V\)</span></span> for sufficiently rich mathematical statements, there is a mathematical statement that is <em>true</em> but is not <em>provable</em> in <span><span class="math inline">\(V\)</span></span>.</p>
</div>
<h3 id="godelproofsystemssec" data-number="10.1.1">Defining “Proof Systems”</h3>
<p>Before proving <a href='#godethmtakeone'>Theorem 10.3</a>, we need to define “proof systems” and even formally define the notion of a “mathematical statement”. In geometry and other areas of mathematics, proof systems are often defined by starting with some basic assumptions or <em>axioms</em> and then deriving more statements by using <em>inference rules</em> such as the famous <a href="https://en.wikipedia.org/wiki/Modus_ponens">Modus Ponens</a>, but what axioms shall we use? What rules? We will use an extremely general notion of proof systems, not even restricting ourselves to ones that have the form of axioms and inference.</p>
<p><strong>Mathematical statements.</strong> At the highest level, a mathematical statement is simply a piece of text, which we can think of as a <em>string</em> <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>. Mathematical statements contain assertions whose truth does not depend on any empirical fact, but rather only on properties of abstract objects. For example, the following is a mathematical statement:<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<blockquote>
<p><em>“The number <span><span class="math inline">\(2\)</span></span>,<span><span class="math inline">\(696\)</span></span>,<span><span class="math inline">\(635\)</span></span>,<span><span class="math inline">\(869\)</span></span>,<span><span class="math inline">\(504\)</span></span>,<span><span class="math inline">\(783\)</span></span>,<span><span class="math inline">\(333\)</span></span>,<span><span class="math inline">\(238\)</span></span>,<span><span class="math inline">\(805\)</span></span>,<span><span class="math inline">\(675\)</span></span>,<span><span class="math inline">\(613\)</span></span>, <span><span class="math inline">\(588\)</span></span>,<span><span class="math inline">\(278\)</span></span>,<span><span class="math inline">\(597\)</span></span>,<span><span class="math inline">\(832\)</span></span>,<span><span class="math inline">\(162\)</span></span>,<span><span class="math inline">\(617\)</span></span>,<span><span class="math inline">\(892\)</span></span>,<span><span class="math inline">\(474\)</span></span>,<span><span class="math inline">\(670\)</span></span>,<span><span class="math inline">\(798\)</span></span>,<span><span class="math inline">\(113\)</span></span> is prime”.</em></p>
</blockquote>
<p>Mathematical statements do not have to involve numbers. They can assert properties of any other mathematical object including sets, strings, functions, graphs and yes, even <em>programs</em>. Thus, another example of a mathematical statement is the following:<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<blockquote>
<div class="quote" name="Quote 10.1.1">
<p>The following Python function halts on every positive integer <code>n</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> f(n):</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">if</span> n<span class="op">==</span><span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">return</span> f(<span class="dv">3</span><span class="op">*</span>n<span class="op">+</span><span class="dv">1</span>) <span class="cf">if</span> n <span class="op">%</span> <span class="dv">2</span> <span class="cf">else</span> f(n<span class="op">//</span><span class="dv">2</span>)</a></code></pre></div>
</div>
</blockquote>
<p><br />
</p>
<p><strong>Proof systems.</strong> A <em>proof</em> for a statement <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> is another piece of text <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span> that certifies the truth of the statement asserted in <span><span class="math inline">\(x\)</span></span>. The conditions for a valid proof system are:</p>
<ol type="1">
<li><p><em>(Effectiveness)</em> Given a statement <span><span class="math inline">\(x\)</span></span> and a proof <span><span class="math inline">\(w\)</span></span>, there is an algorithm to verify whether or not <span><span class="math inline">\(w\)</span></span> is a valid proof for <span><span class="math inline">\(x\)</span></span>. (For example, by going line by line and checking that each line follows from the preceding ones using one of the allowed inference rules.)</p></li>
<li><p><em>(Soundness)</em> If there is a valid proof <span><span class="math inline">\(w\)</span></span> for <span><span class="math inline">\(x\)</span></span> then <span><span class="math inline">\(x\)</span></span> is true.</p></li>
</ol>
<p>These are quite minimal requirements for a proof system. Requirement 2 (soundness) is the very definition of a proof system: you shouldn’t be able to prove things that are not true. Requirement 1 is also essential. If there is no set of rules (i.e., an algorithm) to check that a proof is valid then in what sense is it a proof system? We could replace it with a system where the “proof” for a statement <span><span class="math inline">\(x\)</span></span> is “trust me: it’s true”.</p>
<p>We formally define proof systems as an algorithm <span><span class="math inline">\(V\)</span></span> where <span><span class="math inline">\(V(x,w)=1\)</span></span> holds if the string <span><span class="math inline">\(w\)</span></span> is a valid proof for the statement <span><span class="math inline">\(x\)</span></span>. Even if <span><span class="math inline">\(x\)</span></span> is true, the string <span><span class="math inline">\(w\)</span></span> does not have to be a valid proof for it (there are plenty of wrong proofs for true statements such as <code>4=2+2</code>) but if <span><span class="math inline">\(w\)</span></span> is a valid proof for <span><span class="math inline">\(x\)</span></span> then <span><span class="math inline">\(x\)</span></span> must be true.</p>
<div id="proofsystemsdef" class="definition" title="Proof systems" name="Definition 10.2 (Proof systems) ">
<p>Let <span><span class="math inline">\(\mathcal{T} \subseteq \{0,1\}^*\)</span></span> be some set (which we consider the “true” statements). A <em>proof system</em> for <span><span class="math inline">\(\mathcal{T}\)</span></span> is an algorithm <span><span class="math inline">\(V\)</span></span> that satisfies:</p>
<ol type="1">
<li><p><em>(Effectiveness)</em> For every <span><span class="math inline">\(x,w \in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(V(x,w)\)</span></span> halts with an output of either <span><span class="math inline">\(0\)</span></span> or <span><span class="math inline">\(1\)</span></span>.</p></li>
<li><p><em>(Soundness)</em> For every <span><span class="math inline">\(x\not\in \mathcal{T}\)</span></span> and <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(V(x,w)=0\)</span></span>.</p></li>
</ol>
<p>A true statement <span><span class="math inline">\(x\in \mathcal{T}\)</span></span> is <em>unprovable</em> (with respect to <span><span class="math inline">\(V\)</span></span>) if for every <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(V(x,w)=0\)</span></span>. We say that <span><span class="math inline">\(V\)</span></span> is <em>complete</em> if there does not exist a true statement <span><span class="math inline">\(x\)</span></span> that is unprovable with respect to <span><span class="math inline">\(v\)</span></span>.</p>
</div>
<div id="proofsystems" class="bigidea" name="Bigidea 14">
<p>A <em>proof</em> is just a string of text whose meaning is given by a <em>verification algorithm</em>.</p>
</div>
<h2 id="gödels-incompleteness-theorem-computational-variant" data-number="10.2">Gödel’s Incompleteness Theorem: Computational variant</h2>
<p>Our first formalization of <a href='#godethmtakeone'>Theorem 10.3</a> involves statements about Turing machines. We let <span><span class="math inline">\(\mathcal{H}\)</span></span> be the set of strings <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> that have the form “Turing machine <span><span class="math inline">\(M\)</span></span> halts on the zero input”.</p>
<div id="godethmtakeone" class="theorem" title="Gödel&#39;s Incompleteness Theorem: computational variant" name="Theorem 10.3 (Gödel&#39;s Incompleteness Theorem: computational variant) ">
<p>There does not exist a complete proof system for <span><span class="math inline">\(\mathcal{H}\)</span></span>.</p>
</div>
<div id="section-1" class="proofidea" data-ref="godethmtakeone" name="Proofidea">
<p>If we had such a complete and sound proof system then we could solve the <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> problem. On input a Turing machine <span><span class="math inline">\(M\)</span></span>, we would search all purported proofs <span><span class="math inline">\(w\)</span></span> and halt as soon as we find a proof of either “<span><span class="math inline">\(M\)</span></span> halts on zero” or “<span><span class="math inline">\(M\)</span></span> does not halt on zero”. If the system is sound and complete then we will eventually find such a proof, and it will provide us with the correct output.</p>
</div>
<div class="proof" data-ref="godethmtakeone" name="Proof 10.2">
<p>Assume for the sake of contradiction that there was such a proof system <span><span class="math inline">\(V\)</span></span>. We will use <span><span class="math inline">\(V\)</span></span> to build an algorithm <span><span class="math inline">\(A\)</span></span> that computes <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>, hence contradicting <a href='lec_08_uncomputability.html#haltonzero-thm'>Theorem 8.10</a>. Our algorithm <span><span class="math inline">\(A\)</span></span> will will work as follows:</p>
<div  class="pseudocodeoutput">
<div class="ps-root">
<div class="ps-algorithm with-caption" id = haltingfromproog>
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 4 </span>Halting from proofs</p>
<div class="ps-algorithmic"><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Input:</span>  Turing Machine \(M\)<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">Output:</span>   \(1\)  \(M\) if halts on the <span class="ps-keyword">Input:</span> \(0\);  \(0\) otherwise.<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">for</span>{\(n=1,2,3,\ldots\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">for</span>{\(w\in \{0,1\}^n\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">       <span class="ps-keyword">if</span>{\(V(\text{"\)M\( halts on \)0\("},w)=1\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">         <span class="ps-keyword">return</span> \(1\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">       <span class="ps-keyword">endif</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">       <span class="ps-keyword">if</span>{\(V(\text{"\)M\( does not halt on \)0\("},w)=1\)} 
                <div class="ps-block" style="margin-left:1.2em;">
                <p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">         <span class="ps-keyword">return</span> \(0\)
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">       <span class="ps-keyword">endif</span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">    <span class="ps-keyword">endfor</span>
</div><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"><span class="ps-keyword">endfor</span><p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;"></div>
</div>
</div>
</div>
<p>If <span><span class="math inline">\(M\)</span></span> halts on <span><span class="math inline">\(0\)</span></span> then under our assumption there exists <span><span class="math inline">\(w\)</span></span> that proves this fact, and so when Algorithm <span><span class="math inline">\(A\)</span></span> reaches <span><span class="math inline">\(n=|w|\)</span></span> we will eventually find this <span><span class="math inline">\(w\)</span></span> and output <span><span class="math inline">\(1\)</span></span>, unless we already halted before. But we cannot halt before and output a wrong answer because it would contradict the soundness of the proof system. Similarly, this shows that if <span><span class="math inline">\(M\)</span></span> does <em>not</em> halt on <span><span class="math inline">\(0\)</span></span> then (since we assume there is a proof of this fact too) our algorithm <span><span class="math inline">\(A\)</span></span> will eventually halt and output <span><span class="math inline">\(0\)</span></span>.</p>
</div>
<div id="godelstmtrem" class="remark" title="The Gödel statement (optional)" name="Remark 10.5 (The Gödel statement (optional)) ">
<p>One can extract from the proof of <a href='#godethmtakeone'>Theorem 10.3</a> a procedure that for every proof system <span><span class="math inline">\(V\)</span></span>, yields a true statement <span><span class="math inline">\(x^*\)</span></span> that cannot be proven in <span><span class="math inline">\(V\)</span></span>. But Gödel’s proof gave a very explicit description of such a statement <span><span class="math inline">\(x^*\)</span></span> which is closely related to the <a href="https://en.wikipedia.org/wiki/Liar_paradox">“Liar’s paradox”</a>. That is, Gödel’s statement <span><span class="math inline">\(x^*\)</span></span> was designed to be true if and only if <span><span class="math inline">\(\forall_{w\in \{0,1\}^*} V(x,w)=0\)</span></span>. In other words, it satisfied the following property</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
x^* \text{ is true} \Leftrightarrow \text{$x^*$ does not have a proof in $V$} \;\;(10.1)
\]</span><a id='godeleq'></a></div></span></p>
<p>One can see that if <span><span class="math inline">\(x^*\)</span></span> is true, then it does not have a proof, but it is false then (assuming the proof system is sound) then it cannot have a proof, and hence <span><span class="math inline">\(x^*\)</span></span> must be both true and unprovable. One might wonder how is it possible to come up with an <span><span class="math inline">\(x^*\)</span></span> that satisfies a condition such as <a href='#godeleq'>Equation 10.1</a> where the same string <span><span class="math inline">\(x^*\)</span></span> appears on both the righthand side and the lefthand side of the equation. The idea is that the proof of <a href='#godethmtakeone'>Theorem 10.3</a> yields a way to transform every statement <span><span class="math inline">\(x\)</span></span> into a statement <span><span class="math inline">\(F(x)\)</span></span> that is true if and only if <span><span class="math inline">\(x\)</span></span> does not have a proof in <span><span class="math inline">\(V\)</span></span>. Thus <span><span class="math inline">\(x^*\)</span></span> needs to be a <em>fixed point</em> of <span><span class="math inline">\(F\)</span></span>: a sentence such that <span><span class="math inline">\(x^* = F(x^*)\)</span></span>. It turns out that <a href="https://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem">we can always find</a> such a fixed point of <span><span class="math inline">\(F\)</span></span>. We’ve already seen this phenomenon in the <span><span class="math inline">\(\lambda\)</span></span> calculus, where the <span><span class="math inline">\(Y\)</span></span> combinator maps every <span><span class="math inline">\(F\)</span></span> into a fixed point <span><span class="math inline">\(Y F\)</span></span> of <span><span class="math inline">\(F\)</span></span>. This is very related to the idea of programs that can print their own code. Indeed, Scott Aaronson likes to describe Gödel’s statement as follows:</p>
<blockquote>
<p>The following sentence repeated twice, the second time in quotes, is not provable in the formal system <span><span class="math inline">\(V\)</span></span>. “The following sentence repeated twice, the second time in quotes, is not provable in the formal system <span><span class="math inline">\(V\)</span></span>.”</p>
</blockquote>
<p>In the argument above we actually showed that <span><span class="math inline">\(x^*\)</span></span> is <em>true</em>, under the assumption that <span><span class="math inline">\(V\)</span></span> is sound. Since <span><span class="math inline">\(x^*\)</span></span> is true and does not have a proof in <span><span class="math inline">\(V\)</span></span>, this means that we cannot carry the above argument in the system <span><span class="math inline">\(V\)</span></span>, which means that <span><span class="math inline">\(V\)</span></span> cannot prove its own soundness (or even consistency: that there is no proof of both a statement and its negation). Using this idea, it’s not hard to get Gödel’s second incompleteness theorem, which says that every sufficiently rich <span><span class="math inline">\(V\)</span></span> cannot prove its own consistency. That is, if we formalize the statement <span><span class="math inline">\(c^*\)</span></span> that is true if and only if <span><span class="math inline">\(V\)</span></span> is consistent (i.e., <span><span class="math inline">\(V\)</span></span> cannot prove both a statement and the statement’s negation), then <span><span class="math inline">\(c^*\)</span></span> cannot be proven in <span><span class="math inline">\(V\)</span></span>.</p>
</div>
<h2 id="quantified-integer-statements" data-number="10.3">Quantified integer statements</h2>
<p>There is something “unsatisfying” about <a href='#godethmtakeone'>Theorem 10.3</a>. Sure, it shows there are statements that are unprovable, but they don’t feel like “real” statements about math. After all, they talk about <em>programs</em> rather than numbers, matrices, or derivatives, or whatever it is they teach in math courses. It turns out that we can get an analogous result for statements such as “there are no positive integers <span><span class="math inline">\(x\)</span></span> and <span><span class="math inline">\(y\)</span></span> such that <span><span class="math inline">\(x^2 - 2 = y^7\)</span></span>”, or “there are positive integers <span><span class="math inline">\(x,y,z\)</span></span> such that <span><span class="math inline">\(x^2 + y^6 = z^{11}\)</span></span>” that only talk about <em>natural numbers</em>. It doesn’t get much more “real math” than this. Indeed, the 19th century mathematician Leopold Kronecker famously said that “God made the integers, all else is the work of man.” (By the way, the status of the above two statements is <a href="https://goo.gl/qsU9zy">unknown</a>.)</p>
<p>To make this more precise, let us define the notion of <em>quantified integer statements</em>:</p>
<div id="QIS-def" class="definition" title="Quantified integer statements" name="Definition 10.6 (Quantified integer statements) ">
<p>A <em>quantified integer statement</em> is a well-formed statement with no unbound variables involving integers, variables, the operators <span><span class="math inline">\(&gt;,&lt;,\times,+,-,=\)</span></span>, the logical operations <span><span class="math inline">\(\neg\)</span></span> (NOT), <span><span class="math inline">\(\wedge\)</span></span> (AND), and <span><span class="math inline">\(\vee\)</span></span> (OR), as well as quantifiers of the form <span><span class="math inline">\(\exists_{x\in\N}\)</span></span> and <span><span class="math inline">\(\forall_{y\in\N}\)</span></span> where <span><span class="math inline">\(x,y\)</span></span> are variable names.</p>
</div>
<p>We often care deeply about determining the truth of quantified integer statements. For example, the statement that <a href="https://goo.gl/fvkuqj">Fermat’s Last Theorem</a> is true for <span><span class="math inline">\(n=3\)</span></span> can be phrased as the quantified integer statement</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\neg \exists_{a\in\N} \exists_{b\in\N} \exists_{c\in\N} (a&gt;0) \wedge (b&gt;0) \wedge (c&gt;0) \wedge \left( a\times a \times a  + b \times b \times b = c\times c \times c \right) \;.
\]</span></div></span></p>
<p>The <a href="https://goo.gl/GRiVz3">twin prime conjecture</a>, that states that there is an infinite number of numbers <span><span class="math inline">\(p\)</span></span> such that both <span><span class="math inline">\(p\)</span></span> and <span><span class="math inline">\(p+2\)</span></span> are primes can be phrased as the quantified integer statement <span>
<div class='myequationbox'><span class="math display">\[
\forall_{n\in\N} \exists_{p\in\N} (p&gt;n) \wedge \ensuremath{\mathit{PRIME}}(p) \wedge \ensuremath{\mathit{PRIME}}(p+2)
\]</span></div></span> where we replace an instance of <span><span class="math inline">\(\ensuremath{\mathit{PRIME}}(q)\)</span></span> with the statement <span><span class="math inline">\((q&gt;1) \wedge \forall_{a\in \N} \forall_{b\in\N} (a=1) \vee (a=q) \vee \neg (a\times b =q)\)</span></span>.</p>
<p>The claim (mentioned in Hilbert’s quote above) that are infinitely many primes of the form <span><span class="math inline">\(p=2^n+1\)</span></span> can be phrased as follows:</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\begin{gathered}
\forall_{n\in\N}\exists_{p\in\N} (p&gt;n) \wedge \ensuremath{\mathit{PRIME}}(p) \wedge \\
\left(\forall_{k\in\N}  (k \neq 2 \; \wedge \; \ensuremath{\mathit{PRIME}}(k)) \Rightarrow \neg \ensuremath{\mathit{DIVIDES}}(k,p-1)\right)
\end{gathered}
\;\;(10.4)
\]</span><a id='eqinfprimespowertwoplusone'></a></div></span> where <span><span class="math inline">\(\ensuremath{\mathit{DIVIDES}}(a,b)\)</span></span> is the statement <span><span class="math inline">\(\exists_{c\in\N} b\times c = a\)</span></span>. In English, this corresponds to the claim that for every <span><span class="math inline">\(n\)</span></span> there is some <span><span class="math inline">\(p&gt;n\)</span></span> such that all of <span><span class="math inline">\(p-1\)</span></span>’s prime factors are equal to <span><span class="math inline">\(2\)</span></span>.</p>
<div id="synsugarqisrem" class="remark" title="Syntactic sugar for quantified integer statements" name="Remark 10.7 (Syntactic sugar for quantified integer statements) ">
<p>To make our statements more readable, we often use syntactic sugar and so write <span><span class="math inline">\(x \neq y\)</span></span> as shorthand for <span><span class="math inline">\(\neg(x=y)\)</span></span>, and so on. Similarly, the “implication operator” <span><span class="math inline">\(a \Rightarrow b\)</span></span> is “syntactic sugar” or shorthand for <span><span class="math inline">\(\neg a \vee b\)</span></span>, and the “if and only if operator” <span><span class="math inline">\(a \Leftrightarrow\)</span></span> is shorthand for <span><span class="math inline">\((a \Rightarrow b) \wedge (b \Rightarrow a\)</span></span>). We will also allow ourselves the use of “macros”: plugging in one quantified integer statement in another, as we did with <span><span class="math inline">\(\ensuremath{\mathit{DIVIDES}}\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{PRIME}}\)</span></span> above.</p>
</div>
<p>Much of number theory is concerned with determining the truth of quantified integer statements. Since our experience has been that, given enough time (which could sometimes be several centuries) humanity has managed to do so for the statements that it cared enough about, one could (as Hilbert did) hope that eventually we would be able to prove or disprove all such statements. Alas, this turns out to be impossible:</p>
<div id="godelthmqis" class="theorem" title="Gödel&#39;s Incompleteness Theorem for quantified integer statements" name="Theorem 10.8 (Gödel&#39;s Incompleteness Theorem for quantified integer statements) ">
<p>Let <span><span class="math inline">\(V:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> a computable purported verification procedure for quantified integer statements. Then either:</p>
<ul>
<li><em><span><span class="math inline">\(V\)</span></span> is not sound:</em> There exists a false statement <span><span class="math inline">\(x\)</span></span> and a string <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span> such that <span><span class="math inline">\(V(x,w)=1\)</span></span>.</li>
</ul>
<p><em>or</em></p>
<ul>
<li><em><span><span class="math inline">\(V\)</span></span> is not complete:</em> There exists a true statement <span><span class="math inline">\(x\)</span></span> such that for every <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(V(x,w)=0\)</span></span>.</li>
</ul>
</div>
<p><a href='#godelthmqis'>Theorem 10.8</a> is a direct corollary of the following result, just as <a href='#godethmtakeone'>Theorem 10.3</a> was a direct corollary of the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>:</p>
<div id="QIS-thm" class="theorem" title="Uncomputability of quantified integer statements" name="Theorem 10.9 (Uncomputability of quantified integer statements) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{QIS}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that given a (string representation of) a quantified integer statement outputs <span><span class="math inline">\(1\)</span></span> if it is true and <span><span class="math inline">\(0\)</span></span> if it is false. Then <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span> is uncomputable.</p>
</div>
<p>Since a quantified integer statement is simply a sequence of symbols, we can easily represent it as a string. For simplicity we will assume that <em>every</em> string represents some quantified integer statement, by mapping strings that do not correspond to such a statement to an arbitrary statement such as <span><span class="math inline">\(\exists_{x\in \N} x=1\)</span></span>.</p>
<div class="pause" name="Pause 10.3">
<p>Please stop here and make sure you understand why the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span> (i.e., <a href='#QIS-thm'>Theorem 10.9</a>) means that there is no sound and complete proof system for proving quantified integer statements (i.e., <a href='#godelthmqis'>Theorem 10.8</a>). This follows in the same way that <a href='#godethmtakeone'>Theorem 10.3</a> followed from the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span>, but working out the details is a great exercise (see <a href='#godelfromqisex'>Exercise 10.1</a>)</p>
</div>
<p>In the rest of this chapter, we will show the proof of <a href='#godelthmqis'>Theorem 10.8</a>, following the outline illustrated in <a href='#godelstructurefig'>Figure 10.1</a>.</p>
<h2 id="diophantine-equations-and-the-mrdp-theorem" data-number="10.4">Diophantine equations and the MRDP Theorem</h2>
<p>Many of the functions people wanted to compute over the years involved solving equations. These have a much longer history than mechanical computers. The Babylonians already knew how to solve some quadratic equations in 2000BC, and the formula for all quadratics appears in the <a href="https://en.wikipedia.org/wiki/Bakhshali_manuscript">Bakhshali Manuscript</a> that was composed in India around the 3rd century. During the Renaissance, Italian mathematicians discovered generalization of these formulas for cubic and quartic (degrees <span><span class="math inline">\(3\)</span></span> and <span><span class="math inline">\(4\)</span></span>) equations. Many of the greatest minds of the 17th and 18th century, including Euler, Lagrange, Leibniz and Gauss worked on the problem of finding such a formula for <em>quintic</em> equations to no avail, until in the 19th century Ruffini, Abel and Galois showed that no such formula exists, along the way giving birth to <em>group theory</em>.</p>
<p>However, the fact that there is no closed-form formula does not mean we can not solve such equations. People have been solving higher degree equations numerically for ages. The Chinese manuscript <a href="https://en.wikipedia.org/wiki/The_Nine_Chapters_on_the_Mathematical_Art">Jiuzhang Suanshu</a> from the first century mentions such approaches. Solving polynomial equations is by no means restricted only to ancient history or to students’ homework. The <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a> method is the workhorse powering many of the machine learning tools that have revolutionized Computer Science over the last several years.</p>
<figure>
<img src="../figure/elliptic_curve.png" alt="10.2: Diophantine equations such as finding a positive integer solution to the equation a(a+b)(a+c)+b(b+a)(b+c)+c(c+a)(c+b)=4(a+b)(a+c)(b+c) (depicted more compactly and whimsically above) can be surprisingly difficult. There are many equations for which we do not know if they have a solution, and there is no algorithm to solve them in general. The smallest solution for this equation has 80 digits! See this Quora post for more information, including the credits for this image." id="ellipticcurvefig" class="margin" /><figcaption>10.2: Diophantine equations such as finding a positive integer solution to the equation <span><span class="math inline">\(a(a+b)(a+c)+b(b+a)(b+c)+c(c+a)(c+b)=4(a+b)(a+c)(b+c)\)</span></span> (depicted more compactly and whimsically above) can be surprisingly difficult. There are many equations for which we do not know if they have a solution, and there is no algorithm to solve them in general. The smallest solution for this equation has <span><span class="math inline">\(80\)</span></span> digits! See this <a href="https://www.quora.com/How-do-you-find-the-positive-integer-solutions-to-frac-x-y+z-+-frac-y-z+x-+-frac-z-x+y-4">Quora post</a> for more information, including the credits for this image.</figcaption>
</figure>
<p>But there are some equations that we simply do not know how to solve <em>by any means</em>. For example, it took more than 200 years until people succeeded in proving that the equation <span><span class="math inline">\(a^{11} + b^{11} = c^{11}\)</span></span> has no solution in integers.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> The notorious difficulty of so called <em>Diophantine equations</em> (i.e., finding <em>integer</em> roots of a polynomial) motivated the mathematician David Hilbert in 1900 to include the question of finding a general procedure for solving such equations in his famous list of twenty-three open problems for mathematics of the 20th century. I don’t think Hilbert doubted that such a procedure exists. After all, the whole history of mathematics up to this point involved the discovery of ever more powerful methods, and even impossibility results such as the inability to trisect an angle with a straightedge and compass, or the non-existence of an algebraic formula for quintic equations, merely pointed out to the need to use more general methods.</p>
<p>Alas, this turned out not to be the case for Diophantine equations. In 1970, Yuri Matiyasevich, building on a decades long line of work by Martin Davis, Hilary Putnam and Julia Robinson, showed that there is simply <em>no method</em> to solve such equations in general:</p>
<div id="MRDP-thm" class="theorem" title="MRDP Theorem" name="Theorem 10.10 (MRDP Theorem) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{DIO}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that takes as input a string describing a <span><span class="math inline">\(100\)</span></span>-variable polynomial with integer coefficients <span><span class="math inline">\(P(x_0,\ldots,x_{99})\)</span></span> and outputs <span><span class="math inline">\(1\)</span></span> if and only if there exists <span><span class="math inline">\(z_0,\ldots,z_{99} \in \N\)</span></span> s.t. <span><span class="math inline">\(P(z_0,\ldots,z_{99})=0\)</span></span>.</p>
<p>Then <span><span class="math inline">\(\ensuremath{\mathit{DIO}}\)</span></span> is uncomputable.</p>
</div>
<p>As usual, we assume some standard way to express numbers and text as binary strings. The constant <span><span class="math inline">\(100\)</span></span> is of course arbitrary; the problem is known to be uncomputable even for polynomials of degree four and at most 58 variables. In fact the number of variables can be reduced to nine, at the expense of the polynomial having a larger (but still constant) degree. See <a href="https://www.jstor.org/stable/2273588">Jones’s paper</a> for more about this issue.</p>
<div id="codevsstaticrem" class="remark" title="Active code vs static data" name="Remark 10.11 (Active code vs static data) ">
<p>The difficulty in finding a way to distinguish between “code” such as NAND-TM programs, and “static content” such as polynomials is just another manifestation of the phenomenon that <em>code</em> is the same as <em>data</em>. While a fool-proof solution for distinguishing between the two is inherently impossible, finding heuristics that do a reasonable job keeps many firewall and anti-virus manufacturers very busy (and finding ways to bypass these tools keeps many hackers busy as well).</p>
</div>
<h2 id="hardness-of-quantified-integer-statements" data-number="10.5">Hardness of quantified integer statements</h2>
<p>We will not prove the MRDP Theorem (<a href='#MRDP-thm'>Theorem 10.10</a>). However, as we mentioned, we will prove the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span> (i.e., <a href='#QIS-thm'>Theorem 10.9</a>), which is a special case of the MRDP Theorem. The reason is that a Diophantine equation is a special case of a quantified integer statement where the only quantifier is <span><span class="math inline">\(\exists\)</span></span>. This means that deciding the truth of quantified integer statements is a potentially harder problem than solving Diophantine equations, and so it is potentially <em>easier</em> to prove that <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span> is uncomputable.</p>
<div class="pause" name="Pause 10.5">
<p>If you find the last sentence confusing, it is worthwhile to reread it until you are sure you follow its logic. We are so accustomed to trying to find <em>solutions</em> for problems that it can sometimes be hard to follow the arguments for showing that problems are <em>uncomputable</em>.</p>
</div>
<p>Our proof of the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span> (i.e. <a href='#QIS-thm'>Theorem 10.9</a>) will, as usual, go by reduction from the Halting problem, but we will do so in two steps:</p>
<ol type="1">
<li><p>We will first use a reduction from the Halting problem to show that deciding the truth of <em>quantified mixed statements</em> is uncomputable. Quantified mixed statements involve both strings and integers. Since quantified mixed statements are a more general concept than quantified integer statements, it is <em>easier</em> to prove the uncomputability of deciding their truth.</p></li>
<li><p>We will then reduce the problem of quantified mixed statements to quantifier integer statements.</p></li>
</ol>
<h3 id="step-1-quantified-mixed-statements-and-computation-histories" data-number="10.5.1">Step 1: Quantified mixed statements and computation histories</h3>
<p>We define <em>quantified mixed statements</em> as statements involving not just integers and the usual arithmetic operators, but also <em>string variables</em> as well.</p>
<div id="QMS-def" class="definition" title="Quantified mixed statements" name="Definition 10.12 (Quantified mixed statements) ">
<p>A <em>quantified mixed statement</em> is a well-formed statement with no unbound variables involving integers, variables, the operators <span><span class="math inline">\(&gt;,&lt;,\times,+,-,=\)</span></span>, the logical operations <span><span class="math inline">\(\neg\)</span></span> (NOT), <span><span class="math inline">\(\wedge\)</span></span> (AND), and <span><span class="math inline">\(\vee\)</span></span> (OR), as well as quantifiers of the form <span><span class="math inline">\(\exists_{x\in\N}\)</span></span>, <span><span class="math inline">\(\exists_{a\in\{0,1\}^*}\)</span></span>, <span><span class="math inline">\(\forall_{y\in\N}\)</span></span>, <span><span class="math inline">\(\forall_{b\in\{0,1\}^*}\)</span></span> where <span><span class="math inline">\(x,y,a,b\)</span></span> are variable names. These also include the operator <span><span class="math inline">\(|a|\)</span></span> which returns the length of a string valued variable <span><span class="math inline">\(a\)</span></span>, as well as the operator <span><span class="math inline">\(a_i\)</span></span> where <span><span class="math inline">\(a\)</span></span> is a string-valued variable and <span><span class="math inline">\(i\)</span></span> is an integer valued expression which is true if <span><span class="math inline">\(i\)</span></span> is smaller than the length of <span><span class="math inline">\(a\)</span></span> and the <span><span class="math inline">\(i^{th}\)</span></span> coordinate of <span><span class="math inline">\(a\)</span></span> is <span><span class="math inline">\(1\)</span></span>, and is false otherwise.</p>
</div>
<p>For example, the true statement that for every string <span><span class="math inline">\(a\)</span></span> there is a string <span><span class="math inline">\(b\)</span></span> that corresponds to <span><span class="math inline">\(a\)</span></span> in reverse order can be phrased as the following quantified mixed statement <span>
<div class='myequationbox'><span class="math display">\[
\forall_{a\in\{0,1\}^*} \exists_{b\in \{0,1\}^*}  (|a|=|b|)
\wedge (\forall_{i\in\N} i &lt; |a| \Rightarrow (a_i \Leftrightarrow b_{|a|-i}) \;.
\]</span></div></span></p>
<p>Quantified mixed statements are more general than quantified integer statements, and so the following theorem is potentially easier to prove than <a href='#QIS-thm'>Theorem 10.9</a>:</p>
<div id="QMS-thm" class="theorem" title="Uncomputability of quantified mixed statements" name="Theorem 10.13 (Uncomputability of quantified mixed statements) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{QMS}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the function that given a (string representation of) a quantified mixed statement outputs <span><span class="math inline">\(1\)</span></span> if it is true and <span><span class="math inline">\(0\)</span></span> if it is false. Then <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> is uncomputable.</p>
</div>
<div id="section-2" class="proofidea" data-ref="QMS-thm" name="Proofidea">
<p>The idea behind the proof is similar to that used in showing that one-dimensional cellular automata are Turing complete (<a href='lec_07_other_models.html#onedimcathm'>Theorem 7.7</a>) as well as showing that equivalence (or even “fullness”) of context free grammars is uncomputable (<a href='lec_08a_restricted_models.html#fullnesscfgdef'>Theorem 9.27</a>). We use the notion of a <em>configuration</em> of a NAND-TM program as in <a href='lec_07_other_models.html#configtmdef'>Definition 7.8</a>. Such a configuration can be thought of as a string <span><span class="math inline">\(\alpha\)</span></span> over some large-but-finite alphabet <span><span class="math inline">\(\Sigma\)</span></span> describing its current state, including the values of all arrays, scalars, and the index variable <code>i</code>. It can be shown that if <span><span class="math inline">\(\alpha\)</span></span> is the configuration at a certain step of the execution and <span><span class="math inline">\(\beta\)</span></span> is the configuration at the next step, then <span><span class="math inline">\(\beta_j = \alpha_j\)</span></span> for all <span><span class="math inline">\(j\)</span></span> outside of <span><span class="math inline">\(\{i-1,i,i+1\}\)</span></span> where <span><span class="math inline">\(i\)</span></span> is the value of <code>i</code>. In particular, every value <span><span class="math inline">\(\beta_j\)</span></span> is simply a function of <span><span class="math inline">\(\alpha_{j-1,j,j+1}\)</span></span>. Using these observations we can write a <em>quantified mixed statement</em> <span><span class="math inline">\(\ensuremath{\mathit{NEXT}}(\alpha,\beta)\)</span></span> that will be true if and only if <span><span class="math inline">\(\beta\)</span></span> is the configuration encoding the next step after <span><span class="math inline">\(\alpha\)</span></span>. Since a program <span><span class="math inline">\(P\)</span></span> halts on input <span><span class="math inline">\(x\)</span></span> if and only if there is a sequence of configurations <span><span class="math inline">\(\alpha^0,\ldots,\alpha^{t-1}\)</span></span> (known as a <em>computation history</em>) starting with the initial configuration with input <span><span class="math inline">\(x\)</span></span> and ending in a halting configuration, we can define a quantified mixed statement to determine if there is such a statement by taking a universal quantifier over all strings <span><span class="math inline">\(H\)</span></span> (for <em>history</em>) that encode a tuple <span><span class="math inline">\((\alpha^0,\alpha^1,\ldots,\alpha^{t-1})\)</span></span> and then checking that <span><span class="math inline">\(\alpha^0\)</span></span> and <span><span class="math inline">\(\alpha^{t-1}\)</span></span> are valid starting and halting configurations, and that <span><span class="math inline">\(\ensuremath{\mathit{NEXT}}(\alpha^j,\alpha^{j+1})\)</span></span> is true for every <span><span class="math inline">\(j\in \{0,\ldots,t-2\}\)</span></span>.</p>
</div>
<div class="proof" data-ref="QMS-thm" name="Proof 10.5.1">
<p>The proof is obtained by a reduction from the Halting problem. Specifically, we will use the notion of a <em>configuration</em> of a Turing Machines (<a href='lec_07_other_models.html#configtmdef'>Definition 7.8</a>) that we have seen in the context of proving that one dimensional cellular automata are Turing complete. We need the following facts about configurations:</p>
<ul>
<li><p>For every Turing Machine <span><span class="math inline">\(M\)</span></span>, there is a finite alphabet <span><span class="math inline">\(\Sigma\)</span></span>, and a <em>configuration</em> of <span><span class="math inline">\(M\)</span></span> is a string <span><span class="math inline">\(\alpha \in \Sigma^*\)</span></span>.</p></li>
<li><p>A configuration <span><span class="math inline">\(\alpha\)</span></span> encodes all the state of the program at a particular iteration, including the array, scalar, and index variables.</p></li>
<li><p>If <span><span class="math inline">\(\alpha\)</span></span> is a configuration, then <span><span class="math inline">\(\beta = \ensuremath{\mathit{NEXT}}_P(\alpha)\)</span></span> denotes the configuration of the computation after one more iteration. <span><span class="math inline">\(\beta\)</span></span> is a string over <span><span class="math inline">\(\Sigma\)</span></span> of length either <span><span class="math inline">\(|\alpha|\)</span></span> or <span><span class="math inline">\(|\alpha|+1\)</span></span>, and every coordinate of <span><span class="math inline">\(\beta\)</span></span> is a function of just three coordinates in <span><span class="math inline">\(\alpha\)</span></span>. That is, for every <span><span class="math inline">\(j\in \{0,\ldots,|\beta|-1\}\)</span></span>, <span><span class="math inline">\(\beta_j = \ensuremath{\mathit{MAP}}_P(\alpha_{j-1},\alpha_j,\alpha_{j+1})\)</span></span> where <span><span class="math inline">\(\ensuremath{\mathit{MAP}}_P:\Sigma^3 \rightarrow \Sigma\)</span></span> is some function depending on <span><span class="math inline">\(P\)</span></span>.</p></li>
<li><p>There are simple conditions to check whether a string <span><span class="math inline">\(\alpha\)</span></span> is a valid starting configuration corresponding to an input <span><span class="math inline">\(x\)</span></span>, as well as to check whether a string <span><span class="math inline">\(\alpha\)</span></span> is a halting configuration. In particular these conditions can be phrased as quantified mixed statements.</p></li>
<li><p>A program <span><span class="math inline">\(M\)</span></span> halts on input <span><span class="math inline">\(x\)</span></span> if and only if there exists a sequence of configurations <span><span class="math inline">\(H = (\alpha^0,\alpha^1,\ldots,\alpha^{T-1})\)</span></span> such that <strong>(i)</strong> <span><span class="math inline">\(\alpha^0\)</span></span> is a valid starting configuration of <span><span class="math inline">\(M\)</span></span> with input <span><span class="math inline">\(x\)</span></span>, <strong>(ii)</strong> <span><span class="math inline">\(\alpha^{T-1}\)</span></span> is a valid halting configuration of <span><span class="math inline">\(P\)</span></span>, and <strong>(iii)</strong> <span><span class="math inline">\(\alpha^{i+1} = \ensuremath{\mathit{NEXT}}_P(\alpha^i)\)</span></span> for every <span><span class="math inline">\(i\in \{0,\ldots,T-2\}\)</span></span>.</p></li>
</ul>
<p>We can encode such a sequence <span><span class="math inline">\(H\)</span></span> of configuration as a binary string. For concreteness, we let <span><span class="math inline">\(\ell = \lceil \log (|\Sigma|+1) \rceil\)</span></span> and encode each symbol <span><span class="math inline">\(\sigma\)</span></span> in <span><span class="math inline">\(\Sigma \cup \{ &quot;;&quot; \}\)</span></span> by a string in <span><span class="math inline">\(\{0,1\}^\ell\)</span></span>. We use “<span><span class="math inline">\(;\)</span></span>” as a “separator” symbol, and so encode <span><span class="math inline">\(H = (\alpha^0,\alpha^1,\ldots,\alpha^{T-1})\)</span></span> as the concatenation of the encodings of each configuration, using “<span><span class="math inline">\(;\)</span></span>” to separate the encoding of <span><span class="math inline">\(\alpha^i\)</span></span> and <span><span class="math inline">\(\alpha^{i+1}\)</span></span> for every <span><span class="math inline">\(i\in [T]\)</span></span>. In particular for every Turing Machine <span><span class="math inline">\(M\)</span></span>, <span><span class="math inline">\(M\)</span></span> halts on the input <span><span class="math inline">\(0\)</span></span> if and only if the following statement <span><span class="math inline">\(\varphi_M\)</span></span> is true</p>
<p><span>
<div class='myequationbox'><span class="math display">\[
\exists_{H \in \{0,1\}^*} \text{$H$ encodes halting configuration sequence starting with input $0$} \;.
\]</span></div></span></p>
<p>If we can encode the statement <span><span class="math inline">\(\varphi_M\)</span></span> as a mixed-integer statement then, since <span><span class="math inline">\(\varphi_M\)</span></span> is true if and only if <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(M)=1\)</span></span>, this would reduce the task of computing <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> to computing <span><span class="math inline">\(\ensuremath{\mathit{MIS}}\)</span></span>, and hence imply (using <a href='lec_08_uncomputability.html#haltonzero-thm'>Theorem 8.10</a> ) that <span><span class="math inline">\(\ensuremath{\mathit{MIS}}\)</span></span> is uncomputable, completing the proof. Indeed, <span><span class="math inline">\(\varphi_M\)</span></span> can be encoded as a mixed-integer statement for the following reasons:</p>
<ol type="1">
<li><p>Let <span><span class="math inline">\(\alpha,\beta \in \{0,1\}^*\)</span></span> be two strings that encode configurations of <span><span class="math inline">\(M\)</span></span>. We can define a quantified mixed predicate <span><span class="math inline">\(\ensuremath{\mathit{NEXT}}(\alpha,\beta)\)</span></span> that is true if and only if <span><span class="math inline">\(\beta = \ensuremath{\mathit{NEXT}}_M(\beta)\)</span></span> (i.e., <span><span class="math inline">\(\beta\)</span></span> encodes the configuration obtained by proceeding from <span><span class="math inline">\(\alpha\)</span></span> in one computational step). Indeed <span><span class="math inline">\(\ensuremath{\mathit{NEXT}}(\alpha,\beta)\)</span></span> is true if <strong>for every</strong> <span><span class="math inline">\(i \in \{0,\ldots,|\beta|\}\)</span></span> which is a multiple of <span><span class="math inline">\(\ell\)</span></span>, <span><span class="math inline">\(\beta_{i,\ldots,i+\ell-1} = \ensuremath{\mathit{MAP}}_M(\alpha_{i-\ell,\cdots,i+2\ell-1})\)</span></span> where <span><span class="math inline">\(\ensuremath{\mathit{MAP}}_M:\{0,1\}^{3\ell} \rightarrow \{0,1\}^\ell\)</span></span> is the finite function above (identifying elements of <span><span class="math inline">\(\Sigma\)</span></span> with their encoding in <span><span class="math inline">\(\{0,1\}^\ell\)</span></span>). Since <span><span class="math inline">\(\ensuremath{\mathit{MAP}}_M\)</span></span> is a finite function, we can express it using the logical operations <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>,<span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span> (for example by computing <span><span class="math inline">\(\ensuremath{\mathit{MAP}}_M\)</span></span> with <span><span class="math inline">\(\ensuremath{\mathit{NAND}}\)</span></span>’s).</p></li>
<li><p>Using the above we can now write the condition that <strong>for every</strong> substring of <span><span class="math inline">\(H\)</span></span> that has the form <span><span class="math inline">\(\alpha \ensuremath{\mathit{ENC}}(;) \beta\)</span></span> with <span><span class="math inline">\(\alpha,\beta \in \{0,1\}^\ell\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{ENC}}(;)\)</span></span> being the encoding of the separator “<span><span class="math inline">\(;\)</span></span>”, it holds that <span><span class="math inline">\(\ensuremath{\mathit{NEXT}}(\alpha,\beta)\)</span></span> is true.</p></li>
<li><p>Finally, if <span><span class="math inline">\(\alpha^0\)</span></span> is a binary string encoding the initial configuration of <span><span class="math inline">\(M\)</span></span> on input <span><span class="math inline">\(0\)</span></span>, checking that the first <span><span class="math inline">\(|\alpha^0|\)</span></span> bits of <span><span class="math inline">\(H\)</span></span> equal <span><span class="math inline">\(\alpha_0\)</span></span> can be expressed using <span><span class="math inline">\(\ensuremath{\mathit{AND}}\)</span></span>,<span><span class="math inline">\(\ensuremath{\mathit{OR}}\)</span></span>, and <span><span class="math inline">\(\ensuremath{\mathit{NOT}}\)</span></span>’s. Similarly checking that the last configuration encoded by <span><span class="math inline">\(H\)</span></span> corresponds to a state in which <span><span class="math inline">\(M\)</span></span> will halt can also be expressed as a quantified statement.</p></li>
</ol>
<p>Together the above yields a computable procedure that maps every Turing Machine <span><span class="math inline">\(M\)</span></span> into a quantified mixed statement <span><span class="math inline">\(\varphi_M\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}(M)=1\)</span></span> if and only if <span><span class="math inline">\(\ensuremath{\mathit{QMS}}(\varphi_M)=1\)</span></span>. This reduces computing <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> to computing <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span>, and hence the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{HALTONZERO}}\)</span></span> implies the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span>.</p>
</div>
<div id="alternativeproofs" class="remark" title="Alternative proofs" name="Remark 10.14 (Alternative proofs) ">
<p>There are several other ways to show that <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> is uncomputable. For example, we can express the condition that a 1-dimensional cellular automaton eventually writes a “<span><span class="math inline">\(1\)</span></span>” to a given cell from a given initial configuration as a quantified mixed statement over a string encoding the history of all configurations. We can then use the fact that cellular automatons can simulate Turing machines (<a href='lec_07_other_models.html#onedimcathm'>Theorem 7.7</a>) to reduce the halting problem to <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span>. We can also use other well known uncomputable problems such as tiling or the <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">post correspondence problem</a>. <a href='#postcorrespondenceproblemex'>Exercise 10.5</a> and <a href='#puzzleex'>Exercise 10.6</a> explore two alternative proofs of <a href='#QMS-thm'>Theorem 10.13</a>.</p>
</div>
<h3 id="step-2-reducing-mixed-statements-to-integer-statements" data-number="10.5.2">Step 2: Reducing mixed statements to integer statements</h3>
<p>We now show how to prove <a href='#QIS-thm'>Theorem 10.9</a> using <a href='#QMS-thm'>Theorem 10.13</a>. The idea is again a proof by reduction. We will show a transformation of every quantifier mixed statement <span><span class="math inline">\(\varphi\)</span></span> into a quantified <em>integer</em> statement <span><span class="math inline">\(\xi\)</span></span> that does not use string-valued variables such that <span><span class="math inline">\(\varphi\)</span></span> is true if and only if <span><span class="math inline">\(\xi\)</span></span> is true.</p>
<p>To remove string-valued variables from a statement, we encode every string by a pair integer. We will show that we can encode a string <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span> by a pair of numbers <span><span class="math inline">\((X,n)\in \N\)</span></span> s.t.</p>
<ul>
<li><p><span><span class="math inline">\(n=|x|\)</span></span></p></li>
<li><p>There is a quantified integer statement <span><span class="math inline">\(\ensuremath{\mathit{COORD}}(X,i)\)</span></span> that for every <span><span class="math inline">\(i&lt;n\)</span></span>, will be true if <span><span class="math inline">\(x_i=1\)</span></span> and will be false otherwise.</p></li>
</ul>
<p>This will mean that we can replace a “for all” quantifier over strings such as <span><span class="math inline">\(\forall_{x\in \{0,1\}^*}\)</span></span> with a pair of quantifiers over <em>integers</em> of the form <span><span class="math inline">\(\forall_{X\in \N}\forall_{n\in\N}\)</span></span> (and similarly replace an existential quantifier of the form <span><span class="math inline">\(\exists_{x\in \{0,1\}^*}\)</span></span> with a pair of quantifiers <span><span class="math inline">\(\exists_{X\in \N}\exists_{n\in\N}\)</span></span>) . We can then replace all calls to <span><span class="math inline">\(|x|\)</span></span> by <span><span class="math inline">\(n\)</span></span> and all calls to <span><span class="math inline">\(x_i\)</span></span> by <span><span class="math inline">\(\ensuremath{\mathit{COORD}}(X,i)\)</span></span>. This means that if we are able to define <span><span class="math inline">\(\ensuremath{\mathit{COORD}}\)</span></span> via a quantified integer statement, then we obtain a proof of <a href='#QIS-thm'>Theorem 10.9</a>, since we can use it to map every mixed quantified statement <span><span class="math inline">\(\varphi\)</span></span> to an equivalent quantified integer statement <span><span class="math inline">\(\xi\)</span></span> such that <span><span class="math inline">\(\xi\)</span></span> is true if and only if <span><span class="math inline">\(\varphi\)</span></span> is true, and hence <span><span class="math inline">\(\ensuremath{\mathit{QMS}}(\varphi)=\ensuremath{\mathit{QIS}}(\xi)\)</span></span>. Such a procedure implies that the task of computing <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> reduces to the task of computing <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span>, which means that the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> implies the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span>.</p>
<p>The above shows that proof of <a href='#QIS-thm'>Theorem 10.9</a> all boils down to finding the right encoding of strings as integers, and the right way to implement <span><span class="math inline">\(\ensuremath{\mathit{COORD}}\)</span></span> as a quantified integer statement. To achieve this we use the following technical result :</p>
<div id="primeseq" class="lemma" title="Constructible prime sequence" name="Lemma 10.15 (Constructible prime sequence) ">
<p>There is a sequence of prime numbers <span><span class="math inline">\(p_0 &lt; p_1 &lt; p_2 &lt; \cdots\)</span></span> such that there is a quantified integer statement <span><span class="math inline">\(\ensuremath{\mathit{PSEQ}}(p,i)\)</span></span> that is true if and only if <span><span class="math inline">\(p=p_i\)</span></span>.</p>
</div>
<p>Using <a href='#primeseq'>Lemma 10.15</a> we can encode a <span><span class="math inline">\(x\in\{0,1\}^*\)</span></span> by the numbers <span><span class="math inline">\((X,n)\)</span></span> where <span><span class="math inline">\(X = \prod_{x_i=1} p_i\)</span></span> and <span><span class="math inline">\(n=|x|\)</span></span>. We can then define the statement <span><span class="math inline">\(\ensuremath{\mathit{COORD}}(X,i)\)</span></span> as <span>
<div class='myequationbox'><span class="math display">\[
\ensuremath{\mathit{COORD}}(X,i) = \exists_{p\in\N}  \ensuremath{\mathit{PSEQ}}(p,i) \wedge \ensuremath{\mathit{DIVIDES}}(p,X) 
\]</span></div></span> where <span><span class="math inline">\(\ensuremath{\mathit{DIVIDES}}(a,b)\)</span></span>, as before, is defined as <span><span class="math inline">\(\exists_{c\in\N} a\times c = b\)</span></span>. Note that indeed if <span><span class="math inline">\(X,n\)</span></span> encodes the string <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, then for every <span><span class="math inline">\(i&lt;n\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{COORD}}(X,i)=x_i\)</span></span>, since <span><span class="math inline">\(p_i\)</span></span> divides <span><span class="math inline">\(X\)</span></span> if and only if <span><span class="math inline">\(x_i=1\)</span></span>.</p>
<p>Thus all that is left to conclude the proof of <a href='#QIS-thm'>Theorem 10.9</a> is to prove <a href='#primeseq'>Lemma 10.15</a>, which we now proceed to do.</p>
<div class="proof" data-ref="primeseq" name="Proof 10.5.2">
<p>The sequence of prime numbers we consider is the following: We fix <span><span class="math inline">\(C\)</span></span> to be a sufficiently large constant (<span><span class="math inline">\(C=2^{2^{34}}\)</span></span> <a href="https://arxiv.org/pdf/1401.4233.pdf">will do</a>) and define <span><span class="math inline">\(p_i\)</span></span> to be the smallest prime number that is in the interval <span><span class="math inline">\([(i+C)^3+1,(i+C+1)^3-1]\)</span></span>. It is known that there exists such a prime number for every <span><span class="math inline">\(i\in\N\)</span></span>. Given this, the definition of <span><span class="math inline">\(\ensuremath{\mathit{PSEQ}}(p,i)\)</span></span> is simple: <span>
<div class='myequationbox'><span class="math display">\[
(p &gt; (i+C)\times (i+C)\times (i+C)  ) \wedge (p &lt; (i+C+1)\times(i+C+1)\times (i+C+1) )\wedge
\left(\forall_{p&#39;} \neg \ensuremath{\mathit{PRIME}}(p&#39;) \vee (p&#39; \leq i) \vee (p&#39; \geq p) \right) \;,
\]</span></div></span> We leave it to the reader to verify that <span><span class="math inline">\(\ensuremath{\mathit{PSEQ}}(p,i)\)</span></span> is true iff <span><span class="math inline">\(p=p_i\)</span></span>.</p>
</div>
<p>To sum up we have shown that for every quantified mixed statement <span><span class="math inline">\(\varphi\)</span></span>, we can compute a quantified integer statement <span><span class="math inline">\(\xi\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{QMS}}(\varphi)=1\)</span></span> if and only if <span><span class="math inline">\(\ensuremath{\mathit{QIS}}(\xi)=1\)</span></span>. Hence the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> (<a href='#QMS-thm'>Theorem 10.13</a>) implies the uncomputability of <span><span class="math inline">\(\ensuremath{\mathit{QIS}}\)</span></span>, completing the proof of <a href='#QIS-thm'>Theorem 10.9</a>, and so also the proof of Gödel’s Incompleteness Theorem for quantified integer statements (<a href='#godelthmqis'>Theorem 10.8</a>).</p>
<div id="section-3" class="recap" name="Recap">
<ul>
<li>Uncomputable functions include also functions that seem to have nothing to do with NAND-TM programs or other computational models such as determining the satisfiability of diophantine equations.</li>
<li>This also implies that for any sound proof system (and in particular every finite axiomatic system) <span><span class="math inline">\(S\)</span></span>, there are interesting statements <span><span class="math inline">\(X\)</span></span> (namely of the form “<span><span class="math inline">\(F(x)=0\)</span></span>” for an uncomputable function <span><span class="math inline">\(F\)</span></span>) such that <span><span class="math inline">\(S\)</span></span> is not able to prove either <span><span class="math inline">\(X\)</span></span> or its negation.</li>
</ul>
</div>
<h2 id="exercises" data-number="10.6">Exercises</h2>
<div id="godelfromqisex" class="exercise" title="Gödel&#39;s Theorem from uncomputability of $QIS$" name="Exercise 10.1 (Gödel&#39;s Theorem from uncomputability of $QIS$) ">
<p>Prove <a href='#godelthmqis'>Theorem 10.8</a> using <a href='#QIS-thm'>Theorem 10.9</a></p>
</div>
<div id="proofsanduncomputex" class="exercise" title="Proof systems and uncomputability" name="Exercise 10.2 (Proof systems and uncomputability) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{FINDPROOF}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the following function. On input a Turing machine <span><span class="math inline">\(V\)</span></span> (which we think of as the verifying algorithm for a proof system) and a string <span><span class="math inline">\(x\in \{0,1\}^*\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{FINDPROOF}}(V,x)=1\)</span></span> if and only if there exists <span><span class="math inline">\(w\in \{0,1\}^*\)</span></span> such that <span><span class="math inline">\(V(x,w)=1\)</span></span>.</p>
<ol type="1">
<li><p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{FINDPROOF}}\)</span></span> is uncomputable.</p></li>
<li><p>Prove that there exists a Turing machine <span><span class="math inline">\(V\)</span></span> such that <span><span class="math inline">\(V\)</span></span> <em>halts on every input <span><span class="math inline">\(x,v\)</span></span></em> but the function <span><span class="math inline">\(\ensuremath{\mathit{FINDPROOF}}_V\)</span></span> defined as <span><span class="math inline">\(\ensuremath{\mathit{FINDPROOF}}_V(x) = \ensuremath{\mathit{FINDPROOF}}(V,x)\)</span></span> is uncomputable. See footnote for hint.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p></li>
</ol>
</div>
<div id="floorexpressionex" class="exercise" title="Expression for floor" name="Exercise 10.3 (Expression for floor) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{FSQRT}}(n,m) = \forall_{j \in \N} ((j \times j)&gt;m) \vee (j \leq n)\)</span></span>. Prove that <span><span class="math inline">\(\ensuremath{\mathit{FSQRT}}(n,m)\)</span></span> is true if and only if <span><span class="math inline">\(n =\floor{\sqrt{m}}\)</span></span>.</p>
</div>
<div id="godelthemex" class="exercise" title="axiomatic proof systems" name="Exercise 10.4 (axiomatic proof systems) ">
<p>For every representation of logical statements as strings, we can define an axiomatic proof system to consist of a finite set of strings <span><span class="math inline">\(A\)</span></span> and a finite set of rules <span><span class="math inline">\(I_0,\ldots,I_{m-1}\)</span></span> with <span><span class="math inline">\(I_j: (\{0,1\}^*)^{k_j} \rightarrow \{0,1\}^*\)</span></span> such that a proof <span><span class="math inline">\((s_1,\ldots,s_n)\)</span></span> that <span><span class="math inline">\(s_n\)</span></span> is true is valid if for every <span><span class="math inline">\(i\)</span></span>, either <span><span class="math inline">\(s_i \in A\)</span></span> or is some <span><span class="math inline">\(j\in [m]\)</span></span> and are <span><span class="math inline">\(i_1,\ldots,i_{k_j} &lt; i\)</span></span> such that <span><span class="math inline">\(s_i = I_j(s_{i_1},\ldots,i_{k_j})\)</span></span>. A system is <em>sound</em> if whenever there is no false <span><span class="math inline">\(s\)</span></span> such that there is a proof that <span><span class="math inline">\(s\)</span></span> is true Prove that for every uncomputable function <span><span class="math inline">\(F:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> and every sound axiomatic proof system <span><span class="math inline">\(S\)</span></span> (that is characterized by a finite number of axioms and inference rules), there is some input <span><span class="math inline">\(x\)</span></span> for which the proof system <span><span class="math inline">\(S\)</span></span> is not able to prove neither that <span><span class="math inline">\(F(x)=0\)</span></span> nor that <span><span class="math inline">\(F(x) \neq 0\)</span></span>.</p>
</div>
<figure>
<img src="../figure/puzzleprob.png" alt="10.3: In the puzzle problem, the input can be thought of as a finite collection \Sigma of types of puzzle pieces and the goal is to find out whether or not find a way to arrange pieces from these types in a rectangle. Formally, we model the input as a pair of functions match_{\leftrightarrow},match_{\updownarrow}:\Sigma^2 \rightarrow \{0,1\} that such that match_{\leftrightarrow}(left,right)=1 (respectively match_{\updownarrow}(up,down)=1 ) if the pair of pieces are compatible when placed in their respective positions. We assume \Sigma contains a special symbol \varnothing corresponding to having no piece, and an arrangement of puzzle pieces by an (m-2)\times(n-2) rectangle is modeled by a string x\in \Sigma^{m\cdot n} whose ``outer coordinates’’ are \emptyset and such that for every i \in [n-1],j \in [m-1], match_{\updownarrow}(x_{i,j},x_{i+1,j})=1 and match_{\leftrightarrow}(x_{i,j},x_{i,j+1})=1." id="puzzleprobfig" class="margin" /><figcaption>10.3: In the <em>puzzle problem</em>, the input can be thought of as a finite collection <span><span class="math inline">\(\Sigma\)</span></span> of <em>types of puzzle pieces</em> and the goal is to find out whether or not find a way to arrange pieces from these types in a rectangle. Formally, we model the input as a pair of functions <span><span class="math inline">\(match_{\leftrightarrow},match_{\updownarrow}:\Sigma^2 \rightarrow \{0,1\}\)</span></span> that such that <span><span class="math inline">\(match_{\leftrightarrow}(left,right)=1\)</span></span> (respectively <span><span class="math inline">\(match_{\updownarrow}(up,down)=1\)</span></span> ) if the pair of pieces are compatible when placed in their respective positions. We assume <span><span class="math inline">\(\Sigma\)</span></span> contains a special symbol <span><span class="math inline">\(\varnothing\)</span></span> corresponding to having no piece, and an arrangement of puzzle pieces by an <span><span class="math inline">\((m-2)\times(n-2)\)</span></span> rectangle is modeled by a string <span><span class="math inline">\(x\in \Sigma^{m\cdot n}\)</span></span> whose ``outer coordinates’’ are <span><span class="math inline">\(\emptyset\)</span></span> and such that for every <span><span class="math inline">\(i \in [n-1],j \in [m-1]\)</span></span>, <span><span class="math inline">\(match_{\updownarrow}(x_{i,j},x_{i+1,j})=1\)</span></span> and <span><span class="math inline">\(match_{\leftrightarrow}(x_{i,j},x_{i,j+1})=1\)</span></span>.</figcaption>
</figure>
<div id="postcorrespondenceproblemex" class="exercise" title="Post Corrrespondence Problem" name="Exercise 10.5 (Post Corrrespondence Problem) ">
<p>In the <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Post Correspondence Problem</a> the input is a set <span><span class="math inline">\(S = \{ (\alpha^0,\beta^0), \ldots, (\beta^{c-1},\beta^{c-1}) \}\)</span></span> where each <span><span class="math inline">\(\alpha^i\)</span></span> and <span><span class="math inline">\(\beta^j\)</span></span> is a string in <span><span class="math inline">\(\{0,1\}^*\)</span></span>. We say that <span><span class="math inline">\(\ensuremath{\mathit{PCP}}(S)=1\)</span></span> if and only if there exists a list <span><span class="math inline">\((\alpha_0,\beta_0),\ldots,(\alpha_{n-1},\beta_{n-1})\)</span></span> of pairs in <span><span class="math inline">\(S\)</span></span> such that <span>
<div class='myequationbox'><span class="math display">\[
\alpha_0 \alpha_1 \cdots \alpha_{m-1} = \beta_0 \beta_1 \cdots \beta_{m-1} \;.
\]</span></div></span> (We can think of each pair <span><span class="math inline">\((\alpha,\beta) \in S\)</span></span> as a “domino tile” and the question is whether we can stack a list of such tiles so that the top and the bottom yield the same string.) It can be shown that the <span><span class="math inline">\(\ensuremath{\mathit{PCP}}\)</span></span> is uncomputable by a fairly straightforward though somewhat tedious proof (see for example the Wikipedia page for the Post Correspondence Problem or Section 5.2 in  (<a href="https://scholar.google.com/scholar?hl=en&q=Sipser+Introduction+to+the+theory+of+computation" target="_blank">Sipser, 1997</a>) ).</p>
<p>Use this fact to provide a direct proof that <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span> is uncomputable by showing that there exists a computable map <span><span class="math inline">\(R:\{0,1\}^* \rightarrow \{0,1\}^*\)</span></span> such that <span><span class="math inline">\(\ensuremath{\mathit{PCP}}(S) = \ensuremath{\mathit{QMS}}(R(S))\)</span></span> for every string <span><span class="math inline">\(S\)</span></span> encoding an instance of the post correspondence problem.</p>
</div>
<div id="puzzleex" class="exercise" title="Uncomputability of puzzle" name="Exercise 10.6 (Uncomputability of puzzle) ">
<p>Let <span><span class="math inline">\(\ensuremath{\mathit{PUZZLE}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> be the problem of determining, given a finite collection of types of “puzzle pieces”, whether it is possible to put them together in a rectangle, see <a href='#puzzleprobfig'>Figure 10.3</a>. Formally, we think of such a collection as a finite set <span><span class="math inline">\(\Sigma\)</span></span> (see <a href='#puzzleprobfig'>Figure 10.3</a>). We model the criteria as to which pieces “fit together” by a pair of finite function <span><span class="math inline">\(match_{\updownarrow}, match_{\leftrightarrow}:\Sigma^2 \rightarrow \{0,1\}\)</span></span> such that a piece <span><span class="math inline">\(a\)</span></span> fits above a piece <span><span class="math inline">\(b\)</span></span> if and only if <span><span class="math inline">\(match_{\updownarrow}(a,b)=1\)</span></span> and a piece <span><span class="math inline">\(c\)</span></span> fits to the left of a piece <span><span class="math inline">\(d\)</span></span> if and only if <span><span class="math inline">\(match_{\leftrightarrow}(c,d)=1\)</span></span>. To model the “straight edge” pieces that can be placed next to a “blank spot” we assume that <span><span class="math inline">\(\Sigma\)</span></span> contains the symbol <span><span class="math inline">\(\varnothing\)</span></span> and the matching functions are defined accordingly. A <em>square tiling</em> of <span><span class="math inline">\(\Sigma\)</span></span> is an <span><span class="math inline">\(m\times n\)</span></span> long string <span><span class="math inline">\(x \in \Sigma^{mn}\)</span></span>, such that for every <span><span class="math inline">\(i\in \{1,\ldots,m-2 \}\)</span></span> and <span><span class="math inline">\(j\in \{1,\ldots,n-2 \}\)</span></span>, <span><span class="math inline">\(match(x_{i,j},x_{i-1,j},x_{i+1,j},x_{i,j-1},x_{i,j+1})=1\)</span></span> (i.e., every “internal pieve” fits in with the pieces adjacent to it). We also require all of the “outer pieces” (i.e., <span><span class="math inline">\(x_{i,j}\)</span></span> where <span><span class="math inline">\(i\in \{0,m-1\}\)</span></span> of <span><span class="math inline">\(j\in \{0,n-1\}\)</span></span>) are “blank” or equal to <span><span class="math inline">\(\varnothing\)</span></span>. The function <span><span class="math inline">\(\ensuremath{\mathit{PUZZLE}}\)</span></span> takes as input a string describing the set <span><span class="math inline">\(\Sigma\)</span></span> and the function <span><span class="math inline">\(match\)</span></span> and outputs <span><span class="math inline">\(1\)</span></span> if and only if there is some square tiling of <span><span class="math inline">\(\Sigma\)</span></span>: some not all blank string <span><span class="math inline">\(x\in \Sigma^{mn}\)</span></span> satisfying the above condition.</p>
<ol type="1">
<li><p>Prove that <span><span class="math inline">\(\ensuremath{\mathit{PUZZLE}}\)</span></span> is uncomputable.</p></li>
<li><p>Give a reduction from <span><span class="math inline">\(\ensuremath{\mathit{PUZZLE}}\)</span></span> to <span><span class="math inline">\(\ensuremath{\mathit{QMS}}\)</span></span>.</p></li>
</ol>
</div>
<div id="MRDPexe" class="exercise" title="MRDP exercise" name="Exercise 10.7 (MRDP exercise) ">
<p>The MRDP theorem states that the problem of determining, given a <span><span class="math inline">\(k\)</span></span>-variable polynomial <span><span class="math inline">\(p\)</span></span> with integer coefficients, whether there exists integers <span><span class="math inline">\(x_0,\ldots,x_{k-1}\)</span></span> such that <span><span class="math inline">\(p(x_0,\ldots,x_{k-1})=0\)</span></span> is uncomputable. Consider the following <em>quadratic integer equation problem</em>: the input is a list of polynomials <span><span class="math inline">\(p_0,\ldots,p_{m-1}\)</span></span> over <span><span class="math inline">\(k\)</span></span> variables with integer coefficients, where each of the polynomials is of degree at most two (i.e., it is a <em>quadratic</em> function). The goal is to determine whether there exist integers <span><span class="math inline">\(x_0,\ldots,x_{k-1}\)</span></span> that solve the equations <span><span class="math inline">\(p_0(x)= \cdots = p_{m-1}(x)=0\)</span></span>.</p>
<p>Use the MRDP Theorem to prove that this problem is uncomputable. That is, show that the function <span><span class="math inline">\(\ensuremath{\mathit{QUADINTEQ}}:\{0,1\}^* \rightarrow \{0,1\}\)</span></span> is uncomputable, where this function gets as input a string describing the polynomials <span><span class="math inline">\(p_0,\ldots,p_{m-1}\)</span></span> (each with integer coefficients and degree at most two), and outputs <span><span class="math inline">\(1\)</span></span> if and only if there exists <span><span class="math inline">\(x_0,\ldots,x_{k-1} \in \mathbb{Z}\)</span></span> such that for every <span><span class="math inline">\(i\in [m]\)</span></span>, <span><span class="math inline">\(p_i(x_0,\ldots,x_{k-1})=0\)</span></span>. See footnote for hint<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>
</div>
<div id="buseybeaverex" class="exercise" title="The Busy Beaver problem" name="Exercise 10.8 (The Busy Beaver problem) ">
<p>In this question we define the NAND-TM variant of the <a href="https://www.scottaaronson.com/writings/bignumbers.html">busy beaver function</a>.</p>
<ol type="1">
<li><p>We define the function <span><span class="math inline">\(T:\{0,1\}^* \rightarrow \mathbb{N}\)</span></span> as follows: for every string <span><span class="math inline">\(P\in \{0,1\}^*\)</span></span>, if <span><span class="math inline">\(P\)</span></span> represents a NAND-TM program such that when <span><span class="math inline">\(P\)</span></span> is executed on the input <span><span class="math inline">\(0\)</span></span> (i.e., the string of length 1 that is simply <span><span class="math inline">\(0\)</span></span>), a total of <span><span class="math inline">\(M\)</span></span> lines are executed before the program halts, then <span><span class="math inline">\(T(P)=M\)</span></span>. Otherwise (if <span><span class="math inline">\(P\)</span></span> does not represent a NAND-TM program, or it is a program that does not halt on <span><span class="math inline">\(0\)</span></span>), <span><span class="math inline">\(T(P)=0\)</span></span>. Prove that <span><span class="math inline">\(T\)</span></span> is uncomputable.</p></li>
<li><p>Let <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(n)\)</span></span> denote the number <span><span class="math inline">\(\underbrace{2^{2^{2^{{\iddots}^2}}}}_{n\text{ times}}\)</span></span> (that is, a “tower of powers of two” of height <span><span class="math inline">\(n\)</span></span>). To get a sense of how fast this function grows, <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(1)=2\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(2)=2^2=4\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(3)=2^{2^2}=16\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(4) = 2^{16} = 65536\)</span></span> and <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(5) = 2^{65536}\)</span></span> which is about <span><span class="math inline">\(10^{20000}\)</span></span>. <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(6)\)</span></span> is already a number that is too big to write even in scientific notation. Define <span><span class="math inline">\(\ensuremath{\mathit{NBB}}:\mathbb{N} \rightarrow \mathbb{N}\)</span></span> (for “NAND-TM Busy Beaver”) to be the function <span><span class="math inline">\(\ensuremath{\mathit{NBB}}(n) = \max_{P\in \{0,1\}^n} T(P)\)</span></span> where <span><span class="math inline">\(T:\mathbb{N} \rightarrow \mathbb{N}\)</span></span> is the function defined in Item 1. Prove that <span><span class="math inline">\(\ensuremath{\mathit{NBB}}\)</span></span> grows <em>faster</em> than <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}\)</span></span>, in the sense that <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(n) = o(\ensuremath{\mathit{NBB}}(n))\)</span></span> (i.e., for every <span><span class="math inline">\(\epsilon&gt;0\)</span></span>, there exists <span><span class="math inline">\(n_0\)</span></span> such that for every <span><span class="math inline">\(n&gt;n_0\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}(n) &lt; \epsilon \cdot \ensuremath{\mathit{NBB}}(n)\)</span></span>.).<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p></li>
</ol>
</div>
<h2 id="bibliographical-notes" data-number="10.7">Bibliographical notes</h2>
<p>As mentioned before, Gödel, Escher, Bach  (<a href="https://scholar.google.com/scholar?hl=en&q=Hofstadter+GoÌˆdel,+Escher,+Bach+:+an+eternal+golden+braid" target="_blank">Hofstadter, 1999</a>)  is a highly recommended book covering Gödel’s Theorem. A classic popular science book about Fermat’s Last Theorem is  (<a href="https://scholar.google.com/scholar?hl=en&q=Singh+Fermat's+enigma+:+the+quest+to+solve+the+world's+greatest+mathematical+problem" target="_blank">Singh, 1997</a>) .</p>
<p>Cantor’s are used for both Turing and Gödel’s theorems. In a twist of fate, using techniques originating from the works of Gödel and Turing, Paul Cohen showed in 1963 that Cantor’s <em>Continuum Hypothesis</em> is independent of the axioms of set theory, which means that neither it nor its negation is provable from these axioms and hence in some sense can be considered as “neither true nor false” (see  (<a href="https://scholar.google.com/scholar?hl=en&q=Cohen+Set+theory+and+the+continuum+hypothesis" target="_blank">Cohen, 2008</a>) ). The <a href="https://goo.gl/9ieBVq">Continuum Hypothesis</a> is the conjecture that for every subset <span><span class="math inline">\(S\)</span></span> of <span><span class="math inline">\(\mathbb{R}\)</span></span>, either there is a one-to-one and onto map between <span><span class="math inline">\(S\)</span></span> and <span><span class="math inline">\(\N\)</span></span> or there is a one-to-one and onto map between <span><span class="math inline">\(S\)</span></span> and <span><span class="math inline">\(\mathbb{R}\)</span></span>. It was conjectured by Cantor and listed by Hilbert in 1900 as one of the most important problems in mathematics. See also the non-conventional survey of Shelah  (<a href="https://scholar.google.com/scholar?hl=en&q=Shelah+Logical+dreams" target="_blank">Shelah, 2003</a>) . See <a href="https://gowers.wordpress.com/2017/09/19/two-infinities-that-are-surprisingly-equal/">here</a> for recent progress on a related question.</p>
<p>Thanks to Alex Lombardi for pointing out an embarrassing mistake in the description of Fermat’s Last Theorem. (I said that it was open for exponent 11 before Wiles’ work.)</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>This happens to be a <em>false</em> statement.</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>It is <a href="https://goo.gl/Lx8HYv">unknown</a> whether this statement is true or false.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>This is a special case of what’s known as “Fermat’s Last Theorem” which states that <span><span class="math inline">\(a^n + b^n = c^n\)</span></span> has no solution in integers for <span><span class="math inline">\(n&gt;2\)</span></span>. This was conjectured in 1637 by Pierre de Fermat but only proven by Andrew Wiles in 1991. The case <span><span class="math inline">\(n=11\)</span></span> (along with all other so called “regular prime exponents”) was established by Kummer in 1850.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p><em>Hint:</em> think of <span><span class="math inline">\(x\)</span></span> as saying “Turing Machine <span><span class="math inline">\(M\)</span></span> halts on input <span><span class="math inline">\(u\)</span></span>” and <span><span class="math inline">\(w\)</span></span> being a proof that is the number of steps that it will take for this to happen. Can you find an always-halting <span><span class="math inline">\(V\)</span></span> that will verify such statements?</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>You can replace the equation <span><span class="math inline">\(y=x^4\)</span></span> with the pair of equations <span><span class="math inline">\(y=z^2\)</span></span> and <span><span class="math inline">\(z=x^2\)</span></span>. Also, you can replace the equation <span><span class="math inline">\(w = x^6\)</span></span> with the three equations <span><span class="math inline">\(w=yu\)</span></span>, <span><span class="math inline">\(y = x^4\)</span></span> and <span><span class="math inline">\(u=x^2\)</span></span>.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:6"><p>
<div>
<p>You will not need to use very specific properties of the <span><span class="math inline">\(\ensuremath{\mathit{TOWER}}\)</span></span> function in this exercise. For example, <span><span class="math inline">\(\ensuremath{\mathit{NBB}}(n)\)</span></span> also grows faster than the <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackerman function</a>. You might find <a href="https://www.scottaaronson.com/blog/?p=3445">Aaronson’s blog post</a> on the same topic to be quite interesting, and relevant to this book at large. If you like it then you might also enjoy <a href="https://terrytao.wordpress.com/2010/10/10/the-cosmic-distance-ladder-ver-4-1/">this piece by Terence Tao</a>.</p>
</div>
<a href="#fnref:6" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/tcs/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/tcs/issues?q=Defining Computation+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/tcs" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 12/02/2019 21:38:21</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/introtcs/lec_09_godel.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
