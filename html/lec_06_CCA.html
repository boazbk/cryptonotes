<!DOCTYPE html>
<html  lang="en">

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An intensive introduction to cryptography: </title>
  <meta name="description" content="Lecture notes on Cryptography by Boaz Barak">

  <meta property="og:title" content="An intensive introduction to cryptography: " />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://intensecrypto.org/" />
  <meta property="og:image" content="icons/cover.png" />
  <meta property="og:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="github-repo" content="boazbk/crypto" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An intensive introduction to cryptography" />
  <meta name="twitter:description" content="Lecture notes on Cryptography by Boaz Barak" />
  <meta name="twitter:image" content="https://intensecrypto.org/icons/cover.png" />

<meta name="author" content="Boaz Barak">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="icons/apple-touch-icon-120x120.png">
  <link rel="shortcut icon" href="icons/favicon.ico" type="image/x-icon">

<!-- Boaz: resources -->

<!-- <script src="https://kit.fontawesome.com/ab08ce82a8.js"></script> -->

<link rel="stylesheet" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">


<!-- KaTeX -->


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
  integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
  integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload='renderMathInElement(document.body, {  throwOnError: false, macros: { "\\N": "\\mathbb{N}", "\\R": "\\mathbb{R}", "\\Z": "\\mathbb{Z}","\\E": "\\mathbb{E}","\\val": "\\mathrm{val}", "\\label": "\\;\\;\\;\\;\\;\\;\\;\\;","\\floor": "\\lfloor #1 \\rfloor","\\ceil": "\\lceil #1 \\rceil", "\\ensuremath": "#1"}});'>
</script>




<!-- KaTeX -->
<!-- pseudocode -->
<link rel="stylesheet" href="css/pseudocode.css">
<!-- <script src="js/pseudocode.min.js"></script> -->


<!-- Gitbook resources -->

  <script src="js/jquery.min.js"></script>
  <link href="css/style.css" rel="stylesheet" />
  
  <link href="css/plugin-table.css" rel="stylesheet" />
  <link href="css/plugin-bookdown.css" rel="stylesheet" />
  <link href="css/plugin-highlight.css" rel="stylesheet" />
  <link href="css/plugin-search.css" rel="stylesheet" />
  <link href="css/plugin-fontsettings.css" rel="stylesheet" />
  <link href="css/moregitbook.css" rel="stylesheet" />

  <link href="css/resmisc.css" rel="stylesheet" />





<!-- Boaz: end resources -->



<!--bookdown:link_prev-->
<!--bookdown:link_next-->




<!-- bigfoot-->

<link href="css/bigfoot-default.css" rel="stylesheet" />
<script type="text/javascript" src="js/bigfoot.js"></script>

<script type="text/javascript">
    var bigfoot = jQuery.bigfoot(
        {
            deleteOnUnhover: false,
            preventPageScroll: false,
            hoverDelay: 250
        }
    );
</script>

<!-- end bigfoot -->


</head>

<body>



<!--bookdown:title:start-->
<!--bookdown:title:end-->


<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul class="summary">
<li><a href="./">An intensive introduction to cryptography</a></li>
<li class="divider"></li><li class="chapter" data-level="p" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>p</b> Foreword and Syllabus</a><ul><li class="chapter" data-level="p.1" data-path=".html"><a href=".html#syllabus"><i class="fa fa-check"></i><b>p.1</b> Syllabus</a><ul><li class="chapter" data-level="p.1.1" data-path=".html"><a href=".html#prerequisites"><i class="fa fa-check"></i><b>p.1.1</b> Prerequisites</a></li></ul></li><li class="chapter" data-level="p.2" data-path=".html"><a href=".html#why-is-cryptography-hard"><i class="fa fa-check"></i><b>p.2</b> Why is cryptography hard?</a></li></ul></li><li class="chapter" data-level="0" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>0</b> Mathematical Background</a><ul><li class="chapter" data-level="0.1" data-path=".html"><a href=".html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>0.1</b> A quick overview of mathematical prerequisites</a></li><li class="chapter" data-level="0.2" data-path=".html"><a href=".html#mathematical-proofs"><i class="fa fa-check"></i><b>0.2</b> Mathematical Proofs</a><ul><li class="chapter" data-level="0.2.1" data-path=".html"><a href=".html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>0.2.1</b> Example: The existence of infinitely many primes.</a></li></ul></li><li class="chapter" data-level="0.3" data-path=".html"><a href=".html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>0.3</b> Probability and Sample spaces</a><ul><li class="chapter" data-level="0.3.1" data-path=".html"><a href=".html#random-variables"><i class="fa fa-check"></i><b>0.3.1</b> Random variables</a></li><li class="chapter" data-level="0.3.2" data-path=".html"><a href=".html#distributions-over-strings"><i class="fa fa-check"></i><b>0.3.2</b> Distributions over strings</a></li><li class="chapter" data-level="0.3.3" data-path=".html"><a href=".html#more-general-sample-spaces."><i class="fa fa-check"></i><b>0.3.3</b> More general sample spaces.</a></li></ul></li><li class="chapter" data-level="0.4" data-path=".html"><a href=".html#correlations-and-independence"><i class="fa fa-check"></i><b>0.4</b> Correlations and independence</a><ul><li class="chapter" data-level="0.4.1" data-path=".html"><a href=".html#independent-random-variables"><i class="fa fa-check"></i><b>0.4.1</b> Independent random variables</a></li><li class="chapter" data-level="0.4.2" data-path=".html"><a href=".html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>0.4.2</b> Collections of independent random variables.</a></li></ul></li><li class="chapter" data-level="0.5" data-path=".html"><a href=".html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>0.5</b> Concentration and tail bounds</a><ul><li class="chapter" data-level="0.5.1" data-path=".html"><a href=".html#chebyshevs-inequality"><i class="fa fa-check"></i><b>0.5.1</b> Chebyshev’s Inequality</a></li><li class="chapter" data-level="0.5.2" data-path=".html"><a href=".html#the-chernoff-bound"><i class="fa fa-check"></i><b>0.5.2</b> The Chernoff bound</a></li></ul></li><li class="chapter" data-level="0.6" data-path=".html"><a href=".html#exercises"><i class="fa fa-check"></i><b>0.6</b> Exercises</a></li><li class="chapter" data-level="0.7" data-path=".html"><a href=".html#exercises-1"><i class="fa fa-check"></i><b>0.7</b> Exercises</a></li></ul></li><li class="chapter" data-level="1" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul><li class="chapter" data-level="1.1" data-path=".html"><a href=".html#some-history"><i class="fa fa-check"></i><b>1.1</b> Some history</a></li><li class="chapter" data-level="1.2" data-path=".html"><a href=".html#defining-encryptions"><i class="fa fa-check"></i><b>1.2</b> Defining encryptions</a></li><li class="chapter" data-level="1.3" data-path=".html"><a href=".html#defining-security-of-encryption"><i class="fa fa-check"></i><b>1.3</b> Defining security of encryption</a><ul><li class="chapter" data-level="1.3.1" data-path=".html"><a href=".html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>1.3.1</b> Generating randomness in actual cryptographic systems</a></li></ul></li><li class="chapter" data-level="1.4" data-path=".html"><a href=".html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>1.4</b> Defining the secrecy requirement.</a></li><li class="chapter" data-level="1.5" data-path=".html"><a href=".html#perfect-secrecy"><i class="fa fa-check"></i><b>1.5</b> Perfect Secrecy</a><ul><li class="chapter" data-level="1.5.1" data-path=".html"><a href=".html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>1.5.1</b> Achieving perfect secrecy</a></li></ul></li><li class="chapter" data-level="1.6" data-path=".html"><a href=".html#necessity-of-long-keys"><i class="fa fa-check"></i><b>1.6</b> Necessity of long keys</a><ul><li class="chapter" data-level="1.6.1" data-path=".html"><a href=".html#amplifying-success-probability"><i class="fa fa-check"></i><b>1.6.1</b> Amplifying success probability</a></li></ul></li><li class="chapter" data-level="1.7" data-path=".html"><a href=".html#bibliographical-notes"><i class="fa fa-check"></i><b>1.7</b> Bibliographical notes</a></li></ul></li><li class="chapter" data-level="2" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>2</b> Computational Security</a><ul><li><ul><li class="chapter" data-level="2.0.1" data-path=".html"><a href=".html#proof-by-reduction"><i class="fa fa-check"></i><b>2.0.1</b> Proof by reduction</a></li></ul></li><li class="chapter" data-level="2.1" data-path=".html"><a href=".html#the-asymptotic-approach"><i class="fa fa-check"></i><b>2.1</b> The asymptotic approach</a><ul><li class="chapter" data-level="2.1.1" data-path=".html"><a href=".html#countoperation"><i class="fa fa-check"></i><b>2.1.1</b> Counting number of operations.</a></li></ul></li><li class="chapter" data-level="2.2" data-path=".html"><a href=".html#our-first-conjecture"><i class="fa fa-check"></i><b>2.2</b> Our first conjecture</a></li><li class="chapter" data-level="2.3" data-path=".html"><a href=".html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>2.3</b> Why care about the cipher conjecture?</a></li><li class="chapter" data-level="2.4" data-path=".html"><a href=".html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>2.4</b> Prelude: Computational Indistinguishability</a></li><li class="chapter" data-level="2.5" data-path=".html"><a href=".html#the-length-extension-theorem"><i class="fa fa-check"></i><b>2.5</b> The Length Extension Theorem</a><ul><li class="chapter" data-level="2.5.1" data-path=".html"><a href=".html#appendix-the-computational-model"><i class="fa fa-check"></i><b>2.5.1</b> Appendix: The computational model</a></li></ul></li></ul></li><li class="chapter" data-level="3" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>3</b> Pseudorandomness</a><ul><li><ul><li class="chapter" data-level="3.0.1" data-path=".html"><a href=".html#unpredictability-an-alternative-approach-for-proving-the-length-extension-theorem"><i class="fa fa-check"></i><b>3.0.1</b> Unpredictability: an alternative approach for proving the length extension theorem</a></li></ul></li><li class="chapter" data-level="3.1" data-path=".html"><a href=".html#stream-ciphers"><i class="fa fa-check"></i><b>3.1</b> Stream ciphers</a></li><li class="chapter" data-level="3.2" data-path=".html"><a href=".html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>3.2</b> What do pseudorandom generators actually look like?</a><ul><li class="chapter" data-level="3.2.1" data-path=".html"><a href=".html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>3.2.1</b> Attempt 0: The counter generator</a></li><li class="chapter" data-level="3.2.2" data-path=".html"><a href=".html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>3.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li><li class="chapter" data-level="3.2.3" data-path=".html"><a href=".html#from-insecurity-to-security"><i class="fa fa-check"></i><b>3.2.3</b> From insecurity to security</a></li><li class="chapter" data-level="3.2.4" data-path=".html"><a href=".html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>3.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li></ul></li><li class="chapter" data-level="3.3" data-path=".html"><a href=".html#successful-examples"><i class="fa fa-check"></i><b>3.3</b> Successful examples</a><ul><li class="chapter" data-level="3.3.1" data-path=".html"><a href=".html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>3.3.1</b> Case Study 1: Subset Sum Generator</a></li><li class="chapter" data-level="3.3.2" data-path=".html"><a href=".html#case-study-2-rc4"><i class="fa fa-check"></i><b>3.3.2</b> Case Study 2: RC4</a></li></ul></li><li class="chapter" data-level="3.4" data-path=".html"><a href=".html#case-study-3-b.b.s."><i class="fa fa-check"></i><b>3.4</b> Case Study 3: B.B.S.</a></li><li class="chapter" data-level="3.5" data-path=".html"><a href=".html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>3.5</b> Non-constructive existence of pseudorandom generators</a></li></ul></li><li class="chapter" data-level="4" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>4</b> Pseudorandom functions</a><ul><li class="chapter" data-level="4.1" data-path=".html"><a href=".html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>4.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a><ul><li class="chapter" data-level="4.1.1" data-path=".html"><a href=".html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>4.1.1</b> How do pseudorandom functions help in the login problem?</a></li></ul></li><li class="chapter" data-level="4.2" data-path=".html"><a href=".html#message-authentication-codes"><i class="fa fa-check"></i><b>4.2</b> Message Authentication Codes</a></li><li class="chapter" data-level="4.3" data-path=".html"><a href=".html#macs-from-prfs"><i class="fa fa-check"></i><b>4.3</b> MACs from PRFs</a></li><li class="chapter" data-level="4.4" data-path=".html"><a href=".html#input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>4.4</b> Input length extension for MACs and PRFs</a></li><li class="chapter" data-level="4.5" data-path=".html"><a href=".html#aside-natural-proofs"><i class="fa fa-check"></i><b>4.5</b> Aside: natural proofs</a></li></ul></li><li class="chapter" data-level="5" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions from pseudorandom generators</a><ul><li class="chapter" data-level="5.1" data-path=".html"><a href=".html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>5.1</b> Securely encrypting many messages - chosen plaintext security</a></li><li class="chapter" data-level="5.2" data-path=".html"><a href=".html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>5.2</b> Pseudorandom permutations / block ciphers</a></li><li class="chapter" data-level="5.3" data-path=".html"><a href=".html#encryption-modes"><i class="fa fa-check"></i><b>5.3</b> Encryption modes</a></li><li class="chapter" data-level="5.4" data-path=".html"><a href=".html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>5.4</b> Optional, Aside: Broadcast Encryption</a></li></ul></li><li class="chapter" data-level="6" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>6</b> Chosen Ciphertext Security</a><ul><li class="chapter" data-level="6.1" data-path=".html"><a href=".html#short-recap"><i class="fa fa-check"></i><b>6.1</b> Short recap</a></li><li class="chapter" data-level="6.2" data-path=".html"><a href=".html#going-beyond-cpa"><i class="fa fa-check"></i><b>6.2</b> Going beyond CPA</a><ul><li class="chapter" data-level="6.2.1" data-path=".html"><a href=".html#example-the-wired-equivalence-protocol-wep"><i class="fa fa-check"></i><b>6.2.1</b> Example: The Wired Equivalence Protocol (WEP)</a></li><li class="chapter" data-level="6.2.2" data-path=".html"><a href=".html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>6.2.2</b> Chosen ciphertext security</a></li></ul></li><li class="chapter" data-level="6.3" data-path=".html"><a href=".html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>6.3</b> Constructing CCA secure encryption</a></li><li class="chapter" data-level="6.4" data-path=".html"><a href=".html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>6.4</b> (Simplified) GCM encryption</a></li><li class="chapter" data-level="6.5" data-path=".html"><a href=".html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>6.5</b> Padding, chopping, and their pitfalls: the "buffer overflow" of cryptography</a></li><li class="chapter" data-level="6.6" data-path=".html"><a href=".html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>6.6</b> Chosen ciphertext attack as implementing metaphors</a></li></ul></li><li class="chapter" data-level="7" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>7</b> Hash Functions and Random Oracles</a><ul><li class="chapter" data-level="7.1" data-path=".html"><a href=".html#the-bitcoin-problem"><i class="fa fa-check"></i><b>7.1</b> The "Bitcoin" Problem</a><ul><li class="chapter" data-level="7.1.1" data-path=".html"><a href=".html#the-currency-problem"><i class="fa fa-check"></i><b>7.1.1</b> The Currency Problem</a></li><li class="chapter" data-level="7.1.2" data-path=".html"><a href=".html#bitcoin-architecture"><i class="fa fa-check"></i><b>7.1.2</b> Bitcoin Architecture</a></li></ul></li><li class="chapter" data-level="7.2" data-path=".html"><a href=".html#the-bitcoin-ledger"><i class="fa fa-check"></i><b>7.2</b> The Bitcoin Ledger</a><ul><li class="chapter" data-level="7.2.1" data-path=".html"><a href=".html#from-proof-of-work-to-consensus-on-ledger"><i class="fa fa-check"></i><b>7.2.1</b> From Proof of Work to Consensus on Ledger</a></li></ul></li><li class="chapter" data-level="7.3" data-path=".html"><a href=".html#collision-resistance-hash-functions-and-creating-short-unique-identifiers"><i class="fa fa-check"></i><b>7.3</b> Collision Resistance Hash Functions and Creating Short "Unique" Identifiers</a></li><li class="chapter" data-level="7.4" data-path=".html"><a href=".html#practical-constructions-of-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4</b> Practical Constructions of Cryptographic Hash Functions</a><ul><li class="chapter" data-level="7.4.1" data-path=".html"><a href=".html#practical-random-ish-functions"><i class="fa fa-check"></i><b>7.4.1</b> Practical Random-ish Functions</a></li><li class="chapter" data-level="7.4.2" data-path=".html"><a href=".html#some-history"><i class="fa fa-check"></i><b>7.4.2</b> Some History</a></li><li class="chapter" data-level="7.4.3" data-path=".html"><a href=".html#the-nsa-and-hash-functions"><i class="fa fa-check"></i><b>7.4.3</b> The NSA and Hash Functions</a></li><li class="chapter" data-level="7.4.4" data-path=".html"><a href=".html#cryptographic-vs-non-cryptographic-hash-functions"><i class="fa fa-check"></i><b>7.4.4</b> Cryptographic vs Non-Cryptographic Hash Functions</a></li></ul></li></ul></li><li class="chapter" data-level="8" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>8</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a><ul><li class="chapter" data-level="8.1" data-path=".html"><a href=".html#keys-from-passwords"><i class="fa fa-check"></i><b>8.1</b> Keys from passwords</a></li><li class="chapter" data-level="8.2" data-path=".html"><a href=".html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>8.2</b> Merkle trees and verifying storage.</a></li><li class="chapter" data-level="8.3" data-path=".html"><a href=".html#proofs-of-retrievability"><i class="fa fa-check"></i><b>8.3</b> Proofs of Retrievability</a></li><li class="chapter" data-level="8.4" data-path=".html"><a href=".html#entropy-extraction"><i class="fa fa-check"></i><b>8.4</b> Entropy extraction</a><ul><li class="chapter" data-level="8.4.1" data-path=".html"><a href=".html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>8.4.1</b> Forward and backward secrecy</a></li></ul></li></ul></li><li class="chapter" data-level="9" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>9</b> Private key crypto recap</a><ul><li><ul><li class="chapter" data-level="9.0.1" data-path=".html"><a href=".html#attacks-on-private-key-cryptosystems"><i class="fa fa-check"></i><b>9.0.1</b> Attacks on private key cryptosystems</a></li></ul></li></ul></li><li class="chapter" data-level="10" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a><ul><li class="chapter" data-level="10.1" data-path=".html"><a href=".html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li><li class="chapter" data-level="10.2" data-path=".html"><a href=".html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a><ul><li class="chapter" data-level="10.2.1" data-path=".html"><a href=".html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li></ul></li><li class="chapter" data-level="10.3" data-path=".html"><a href=".html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a><ul><li class="chapter" data-level="10.3.1" data-path=".html"><a href=".html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li><li class="chapter" data-level="10.3.2" data-path=".html"><a href=".html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li><li class="chapter" data-level="10.3.3" data-path=".html"><a href=".html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li><li class="chapter" data-level="10.3.4" data-path=".html"><a href=".html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li><li class="chapter" data-level="10.3.5" data-path=".html"><a href=".html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li></ul></li><li class="chapter" data-level="10.4" data-path=".html"><a href=".html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li><li class="chapter" data-level="10.5" data-path=".html"><a href=".html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li><li class="chapter" data-level="10.6" data-path=".html"><a href=".html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a><ul><li class="chapter" data-level="10.6.1" data-path=".html"><a href=".html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li></ul></li></ul></li><li class="chapter" data-level="11" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a><ul><li class="chapter" data-level="11.1" data-path=".html"><a href=".html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a><ul><li class="chapter" data-level="11.1.1" data-path=".html"><a href=".html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li><li class="chapter" data-level="11.1.2" data-path=".html"><a href=".html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li><li class="chapter" data-level="11.1.3" data-path=".html"><a href=".html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li><li class="chapter" data-level="11.1.4" data-path=".html"><a href=".html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li><li class="chapter" data-level="11.1.5" data-path=".html"><a href=".html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li><li class="chapter" data-level="11.1.6" data-path=".html"><a href=".html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li><li class="chapter" data-level="11.1.7" data-path=".html"><a href=".html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li></ul></li><li class="chapter" data-level="11.2" data-path=".html"><a href=".html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a><ul><li class="chapter" data-level="11.2.1" data-path=".html"><a href=".html#extending-to-more-than-one-hardcore-bit"><i class="fa fa-check"></i><b>11.2.1</b> Extending to more than one hardcore bit</a></li></ul></li></ul></li><li class="chapter" data-level="12" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a><ul><li><ul><li class="chapter" data-level="12.0.1" data-path=".html"><a href=".html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li></ul></li><li class="chapter" data-level="12.1" data-path=".html"><a href=".html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li><li class="chapter" data-level="12.2" data-path=".html"><a href=".html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li><li class="chapter" data-level="12.3" data-path=".html"><a href=".html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li><li class="chapter" data-level="12.4" data-path=".html"><a href=".html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li><li class="chapter" data-level="12.5" data-path=".html"><a href=".html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li><li class="chapter" data-level="12.6" data-path=".html"><a href=".html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li></ul></li><li class="chapter" data-level="13" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>13</b> Chosen ciphertext security for public key encryption</a></li><li class="chapter" data-level="14" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>14</b> Establishing secure connections over insecure channels</a><ul><li class="chapter" data-level="14.1" data-path=".html"><a href=".html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>14.1</b> Cryptography’s obsession with adjectives.</a></li><li class="chapter" data-level="14.2" data-path=".html"><a href=".html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>14.2</b> Basic Key Exchange protocol</a></li><li class="chapter" data-level="14.3" data-path=".html"><a href=".html#authenticated-key-exchange"><i class="fa fa-check"></i><b>14.3</b> Authenticated key exchange</a><ul><li class="chapter" data-level="14.3.1" data-path=".html"><a href=".html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>14.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li></ul></li><li class="chapter" data-level="14.4" data-path=".html"><a href=".html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>14.4</b> Chosen ciphertext attack security for public key cryptography</a></li><li class="chapter" data-level="14.5" data-path=".html"><a href=".html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>14.5</b> CCA secure public key encryption in the Random Oracle Model</a><ul><li class="chapter" data-level="14.5.1" data-path=".html"><a href=".html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.1</b> Defining secure authenticated key exchange</a></li><li class="chapter" data-level="14.5.2" data-path=".html"><a href=".html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>14.5.2</b> The compiler approach for authenticated key exchange</a></li></ul></li><li class="chapter" data-level="14.6" data-path=".html"><a href=".html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>14.6</b> Password authenticated key exchange.</a></li><li class="chapter" data-level="14.7" data-path=".html"><a href=".html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>14.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li><li class="chapter" data-level="14.8" data-path=".html"><a href=".html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>14.8</b> Heartbleed and logjam attacks</a></li></ul></li><li class="chapter" data-level="15" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>15</b> Zero knowledge proofs</a><ul><li class="chapter" data-level="15.1" data-path=".html"><a href=".html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>15.1</b> Applications for zero knowledge proofs.</a><ul><li class="chapter" data-level="15.1.1" data-path=".html"><a href=".html#nuclear-disarmament"><i class="fa fa-check"></i><b>15.1.1</b> Nuclear disarmament</a></li><li class="chapter" data-level="15.1.2" data-path=".html"><a href=".html#voting"><i class="fa fa-check"></i><b>15.1.2</b> Voting</a></li><li class="chapter" data-level="15.1.3" data-path=".html"><a href=".html#more-applications"><i class="fa fa-check"></i><b>15.1.3</b> More applications</a></li></ul></li><li class="chapter" data-level="15.2" data-path=".html"><a href=".html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>15.2</b> Defining and constructing zero knowledge proofs</a></li><li class="chapter" data-level="15.3" data-path=".html"><a href=".html#defining-zero-knowledge"><i class="fa fa-check"></i><b>15.3</b> Defining zero knowledge</a></li><li class="chapter" data-level="15.4" data-path=".html"><a href=".html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>15.4</b> Zero knowledge proof for Hamiltonicity.</a><ul><li class="chapter" data-level="15.4.1" data-path=".html"><a href=".html#why-is-this-interesting"><i class="fa fa-check"></i><b>15.4.1</b> Why is this interesting?</a></li></ul></li><li class="chapter" data-level="15.5" data-path=".html"><a href=".html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>15.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a><ul><li class="chapter" data-level="15.5.1" data-path=".html"><a href=".html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>15.5.1</b> "Bonus features" of zero knowledge</a></li></ul></li></ul></li><li class="chapter" data-level="16" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Introduction and bootstrapping</a><ul><li class="chapter" data-level="16.1" data-path=".html"><a href=".html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>16.1</b> Defining fully homomorphic encryption</a><ul><li class="chapter" data-level="16.1.1" data-path=".html"><a href=".html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>16.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li></ul></li><li class="chapter" data-level="16.2" data-path=".html"><a href=".html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Example: An XOR homomorphic encryption</a><ul><li class="chapter" data-level="16.2.1" data-path=".html"><a href=".html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>16.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li></ul></li><li class="chapter" data-level="16.3" data-path=".html"><a href=".html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>16.3</b> From linear homomorphism to full homomorphism</a></li><li class="chapter" data-level="16.4" data-path=".html"><a href=".html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>16.4</b> Bootstrapping: Fully Homomorphic "escape velocity"</a><ul><li class="chapter" data-level="16.4.1" data-path=".html"><a href=".html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>16.4.1</b> Radioactive legos analogy</a></li><li class="chapter" data-level="16.4.2" data-path=".html"><a href=".html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>16.4.2</b> Proving the bootstrapping theorem</a></li></ul></li></ul></li><li class="chapter" data-level="17" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>17</b> Fully homomorphic encryption: Construction</a><ul><li class="chapter" data-level="17.1" data-path=".html"><a href=".html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>17.1</b> Prelude: from vectors to matrices</a></li><li class="chapter" data-level="17.2" data-path=".html"><a href=".html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>17.2</b> Real world partially homomorphic encryption</a></li><li class="chapter" data-level="17.3" data-path=".html"><a href=".html#noise-management-via-encoding"><i class="fa fa-check"></i><b>17.3</b> Noise management via encoding</a></li><li class="chapter" data-level="17.4" data-path=".html"><a href=".html#putting-it-all-together"><i class="fa fa-check"></i><b>17.4</b> Putting it all together</a></li><li class="chapter" data-level="17.5" data-path=".html"><a href=".html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>17.5</b> Analysis of our scheme</a><ul><li class="chapter" data-level="17.5.1" data-path=".html"><a href=".html#correctness"><i class="fa fa-check"></i><b>17.5.1</b> Correctness</a></li><li class="chapter" data-level="17.5.2" data-path=".html"><a href=".html#cpa-security"><i class="fa fa-check"></i><b>17.5.2</b> CPA Security</a></li><li class="chapter" data-level="17.5.3" data-path=".html"><a href=".html#homomorphism"><i class="fa fa-check"></i><b>17.5.3</b> Homomorphism</a></li><li class="chapter" data-level="17.5.4" data-path=".html"><a href=".html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>17.5.4</b> Shallow decryption circuit</a></li></ul></li><li class="chapter" data-level="17.6" data-path=".html"><a href=".html#advanced-topics"><i class="fa fa-check"></i><b>17.6</b> Advanced topics:</a><ul><li class="chapter" data-level="17.6.1" data-path=".html"><a href=".html#fully-homomorphic-encryption-for-approximate-computation-over-the-real-numbers-ckks"><i class="fa fa-check"></i><b>17.6.1</b> Fully homomorphic encryption for approximate computation over the real numbers: CKKS</a></li><li class="chapter" data-level="17.6.2" data-path=".html"><a href=".html#bandwidth-efficient-fully-homomorphic-encryption-gh"><i class="fa fa-check"></i><b>17.6.2</b> Bandwidth efficient fully homomorphic encryption GH</a></li><li class="chapter" data-level="17.6.3" data-path=".html"><a href=".html#using-fully-homomorphic-encryption-to-achieve-private-information-retrieval."><i class="fa fa-check"></i><b>17.6.3</b> Using fully homomorphic encryption to achieve private information retrieval.</a></li></ul></li></ul></li><li class="chapter" data-level="18" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a><ul><li class="chapter" data-level="18.1" data-path=".html"><a href=".html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>18.1</b> Ideal vs. Real Model Security.</a></li><li class="chapter" data-level="18.2" data-path=".html"><a href=".html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>18.2</b> Formally defining secure multiparty computation</a><ul><li class="chapter" data-level="18.2.1" data-path=".html"><a href=".html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>18.2.1</b> First attempt: a slightly "too ideal" definition</a></li><li class="chapter" data-level="18.2.2" data-path=".html"><a href=".html#allowing-for-aborts"><i class="fa fa-check"></i><b>18.2.2</b> Allowing for aborts</a></li><li class="chapter" data-level="18.2.3" data-path=".html"><a href=".html#some-comments"><i class="fa fa-check"></i><b>18.2.3</b> Some comments:</a></li></ul></li><li class="chapter" data-level="18.3" data-path=".html"><a href=".html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>18.3</b> Example: Second price auction using bitcoin</a><ul><li class="chapter" data-level="18.3.1" data-path=".html"><a href=".html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>18.3.1</b> Another example: distributed and threshold cryptography</a></li></ul></li><li class="chapter" data-level="18.4" data-path=".html"><a href=".html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>18.4</b> Proving the fundamental theorem:</a></li><li class="chapter" data-level="18.5" data-path=".html"><a href=".html#hbctomalred"><i class="fa fa-check"></i><b>18.5</b> Malicious to honest but curious reduction</a><ul><li class="chapter" data-level="18.5.1" data-path=".html"><a href=".html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>18.5.1</b> Handling probabilistic strategies:</a></li></ul></li></ul></li><li class="chapter" data-level="19" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>19</b> Multiparty secure computation II: Construction using Fully Homomorphic Encryption</a><ul><li class="chapter" data-level="19.1" data-path=".html"><a href=".html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li><li class="chapter" data-level="19.2" data-path=".html"><a href=".html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>19.2</b> Achieving circuit privacy in a fully homomorphic encryption</a><ul><li class="chapter" data-level="19.2.1" data-path=".html"><a href=".html#bottom-line-a-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>19.2.1</b> Bottom line: A two party secure computation protocol</a></li></ul></li><li class="chapter" data-level="19.3" data-path=".html"><a href=".html#beyond-two-parties"><i class="fa fa-check"></i><b>19.3</b> Beyond two parties</a></li></ul></li><li class="chapter" data-level="20" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography I</a><ul><li><ul><li class="chapter" data-level="20.0.1" data-path=".html"><a href=".html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>20.0.1</b> Quantum computing and computation - an executive summary.</a></li></ul></li><li class="chapter" data-level="20.1" data-path=".html"><a href=".html#quantum-101"><i class="fa fa-check"></i><b>20.1</b> Quantum 101</a><ul><li class="chapter" data-level="20.1.1" data-path=".html"><a href=".html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>20.1.1</b> Physically realizing quantum computation</a></li><li class="chapter" data-level="20.1.2" data-path=".html"><a href=".html#bra-ket-notation"><i class="fa fa-check"></i><b>20.1.2</b> Bra-ket notation</a></li><li class="chapter" data-level="20.1.3" data-path=".html"><a href=".html#bells-inequality"><i class="fa fa-check"></i><b>20.1.3</b> Bell’s Inequality</a></li></ul></li><li class="chapter" data-level="20.2" data-path=".html"><a href=".html#grovers-algorithm"><i class="fa fa-check"></i><b>20.2</b> Grover’s Algorithm</a></li></ul></li><li class="chapter" data-level="21" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>21</b> Quantum computing and cryptography II</a><ul><li class="chapter" data-level="21.1" data-path=".html"><a href=".html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>21.1</b> From order finding to factoring and discrete log</a></li><li class="chapter" data-level="21.2" data-path=".html"><a href=".html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>21.2</b> Finding periods of a function: Simon’s Algorithm</a></li><li class="chapter" data-level="21.3" data-path=".html"><a href=".html#from-simon-to-shor"><i class="fa fa-check"></i><b>21.3</b> From Simon to Shor</a><ul><li class="chapter" data-level="21.3.1" data-path=".html"><a href=".html#the-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.1</b> The Fourier transform over \Z_m</a><ul><li class="chapter" data-level="21.3.1.1" data-path=".html"><a href=".html#fast-fourier-transform."><i class="fa fa-check"></i><b>21.3.1.1</b> Fast Fourier Transform.</a></li></ul></li><li class="chapter" data-level="21.3.2" data-path=".html"><a href=".html#quantum-fourier-transform-over-z_m"><i class="fa fa-check"></i><b>21.3.2</b> Quantum Fourier Transform over \Z_m</a></li></ul></li><li class="chapter" data-level="21.4" data-path=".html"><a href=".html#shors-order-finding-algorithm."><i class="fa fa-check"></i><b>21.4</b> Shor’s Order-Finding Algorithm.</a><ul><li class="chapter" data-level="21.4.1" data-path=".html"><a href=".html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>21.4.1</b> Analysis: the case that r|m</a><ul><li class="chapter" data-level="21.4.1.1" data-path=".html"><a href=".html#the-general-case"><i class="fa fa-check"></i><b>21.4.1.1</b> The general case</a></li></ul></li></ul></li><li class="chapter" data-level="21.5" data-path=".html"><a href=".html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>21.5</b> Rational approximation of real numbers</a><ul><li class="chapter" data-level="21.5.1" data-path=".html"><a href=".html#quantum-cryptography"><i class="fa fa-check"></i><b>21.5.1</b> Quantum cryptography</a></li></ul></li></ul></li><li class="chapter" data-level="22" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>22</b> Software Obfuscation</a><ul><li class="chapter" data-level="22.1" data-path=".html"><a href=".html#witness-encryption"><i class="fa fa-check"></i><b>22.1</b> Witness encryption</a></li><li class="chapter" data-level="22.2" data-path=".html"><a href=".html#deniable-encryption"><i class="fa fa-check"></i><b>22.2</b> Deniable encryption</a></li><li class="chapter" data-level="22.3" data-path=".html"><a href=".html#functional-encryption"><i class="fa fa-check"></i><b>22.3</b> Functional encryption</a></li><li class="chapter" data-level="22.4" data-path=".html"><a href=".html#the-software-patch-problem"><i class="fa fa-check"></i><b>22.4</b> The software patch problem</a></li><li class="chapter" data-level="22.5" data-path=".html"><a href=".html#software-obfuscation-1"><i class="fa fa-check"></i><b>22.5</b> Software obfuscation</a></li><li class="chapter" data-level="22.6" data-path=".html"><a href=".html#applications-of-obfuscation"><i class="fa fa-check"></i><b>22.6</b> Applications of obfuscation</a></li><li class="chapter" data-level="22.7" data-path=".html"><a href=".html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>22.7</b> Impossibility of obfuscation</a><ul><li class="chapter" data-level="22.7.1" data-path=".html"><a href=".html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>22.7.1</b> Proof of impossibility of VBB obfuscation</a></li></ul></li><li class="chapter" data-level="22.8" data-path=".html"><a href=".html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>22.8</b> Indistinguishability obfuscation</a></li></ul></li><li class="chapter" data-level="23" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>23</b> More obfuscation, exotic encryptions</a><ul><li class="chapter" data-level="23.1" data-path=".html"><a href=".html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>23.1</b> Slower, weaker, less securer</a></li><li class="chapter" data-level="23.2" data-path=".html"><a href=".html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>23.2</b> How to get IBE from pairing based assumptions.</a></li><li class="chapter" data-level="23.3" data-path=".html"><a href=".html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>23.3</b> Beyond pairing based cryptography</a></li></ul></li><li class="chapter" data-level="24" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>24</b> Anonymous communication</a><ul><li class="chapter" data-level="24.1" data-path=".html"><a href=".html#steganography"><i class="fa fa-check"></i><b>24.1</b> Steganography</a></li><li class="chapter" data-level="24.2" data-path=".html"><a href=".html#anonymous-routing"><i class="fa fa-check"></i><b>24.2</b> Anonymous routing</a></li><li class="chapter" data-level="24.3" data-path=".html"><a href=".html#tor"><i class="fa fa-check"></i><b>24.3</b> Tor</a></li><li class="chapter" data-level="24.4" data-path=".html"><a href=".html#telex"><i class="fa fa-check"></i><b>24.4</b> Telex</a></li><li class="chapter" data-level="24.5" data-path=".html"><a href=".html#riposte"><i class="fa fa-check"></i><b>24.5</b> Riposte</a></li></ul></li><li class="chapter" data-level="25" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>25</b> Ethical, moral, and policy dimensions to cryptography</a><ul><li class="chapter" data-level="25.1" data-path=".html"><a href=".html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>25.1</b> Reading prior to lecture:</a></li><li class="chapter" data-level="25.2" data-path=".html"><a href=".html#case-studies."><i class="fa fa-check"></i><b>25.2</b> Case studies.</a><ul><li class="chapter" data-level="25.2.1" data-path=".html"><a href=".html#the-snowden-revelations"><i class="fa fa-check"></i><b>25.2.1</b> The Snowden revelations</a></li><li class="chapter" data-level="25.2.2" data-path=".html"><a href=".html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>25.2.2</b> FBI vs Apple case</a></li><li class="chapter" data-level="25.2.3" data-path=".html"><a href=".html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>25.2.3</b> Juniper backdoor case and the OPM break-in</a></li></ul></li></ul></li><li class="chapter" data-level="26" data-path=".html"><a href=".html"><i class="fa fa-check"></i><b>26</b> Course recap</a><ul><li class="chapter" data-level="26.1" data-path=".html"><a href=".html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>26.1</b> Some things we did not cover</a></li><li class="chapter" data-level="26.2" data-path=".html"><a href=".html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>26.2</b> What I hope you learned</a></li></ul></li><li class="divider"></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-header" role="navigation">
      <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
      </h1>
    </div>

    <div class="book-body">
      <div class="body-inner">


        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->

<div  class="section level2">

<!-- link to pdf version -->


<!-- start of header referring to comments -->
<div><p></p><p style="color:#871640;"><i class="fas fa-wrench"></i> See any bugs/typos/confusing explanations? <a href="https://github.com/boazbk/crypto/issues/new">Open a GitHub issue</a>. You can also <a href="#commentform">comment below</a> <i class="fas fa-wrench"></i></p></div>



<div><p style="color:#871640;">&#x2605; See also the <a id="pdflink" href='https://files.boazbarak.org/crypto/.pdf'><b>PDF version of this chapter</b></a> (better formatting/references) &#x2605;</p></div>

<!-- end of header referring to comments -->

<!--- start of actual content -->

<h1 data-number="6" id="chosen-ciphertext-security">Chosen Ciphertext Security</h1>
<h2 data-number="6.1" id="short-recap">Short recap</h2>
<p>Let’s start by reviewing what we have learned so far:</p>
<ul>
<li><p>We can mathematically define security for encryption schemes. A natural definition is <em>perfect secrecy</em>: no matter what Eve does, she can’t learn anything about the plaintext that she didn’t know before. Unfortunately this requires the key to be as long as the message, thus placing a severe limitation on the usability of it.</p></li>
<li><p>To get around this, we need to consider computational considerations. A basic object is a <em>pseudorandom generator</em> and we considered the <em>PRG Conjecture</em> which stipulates the existence of an efficiently computable function <span><span class="math inline">\(G:\{0,1\}^n\rightarrow\{0,1\}^{n+1}\)</span></span> such that <span><span class="math inline">\(G(U_n)\approx U_{n+1}\)</span></span> (where <span><span class="math inline">\(U_m\)</span></span> denotes the uniform distribution on <span><span class="math inline">\(\{0,1\}^m\)</span></span> and <span><span class="math inline">\(\approx\)</span></span> denotes computational indistinguishability).</p></li>
<li><p>We showed that the PRG conjecture implies a pseudorandom generator of any polynomial output length which in particular via the stream cipher construction implies a computationally secure encryption with plaintext arbitrarily larger than the key. (The only restriction is that the plaintext is of polynomial size which is needed anyway if we want to actually be able to read and write it.)</p></li>
<li><p>We then showed that the PRG conjecture actually implies a stronger object known as a <em>pseudorandom function (PRF) function collection</em>: this is a collection <span><span class="math inline">\(\{ f_s \}\)</span></span> of functions such that if we choose <span><span class="math inline">\(s\)</span></span> at random and fix it, and give an adversary a black box computing <span><span class="math inline">\(i \mapsto f_s(i)\)</span></span> then she can’t tell the difference between this and a blackbox computing a random function.</p></li>
<li><p>Pseudorandom functions turn out to be useful for <em>identification protocols</em>, <em>message authentication codes</em> and this strong notion of security of encryption known as <em>chosen plaintext attack (CPA) security</em> where we are allowed to encrypt <em>many messages of Eve’s choice</em> and still require that the next message hides all information except for what Eve already knew before.</p></li>
</ul>
<h2 data-number="6.2" id="going-beyond-cpa">Going beyond CPA</h2>
<p>It may seem that we have finally nailed down the security definition for encryption. After all, what could be stronger than allowing Eve unfettered access to the encryption function? Clearly an encryption satisfying this property will hide the contents of the message in all practical circumstances. Or will it?</p>
<div id="section" class="pause" data-number="6.2" name="Pause">
<p>Please stop and play an ominous sound track at this point.</p>
</div>
<h3 data-number="6.2.1" id="example-the-wired-equivalence-protocol-wep">Example: The Wired Equivalence Protocol (WEP)</h3>
<p>The WEP is perhaps one of the most inaccurately named protocols of all times. It was invented in 1999 for the purpose of securing Wi-Fi networks so that they would have virtually the same level of security as wired networks, but already early on several security flaws were pointed out. In particular in 2001, Fluhrer, Mantin, and Shamir showed how the RC4 flaws we mentioned in prior lecture can be used to completely break WEP in less than one minute. Yet, the protocol lingered on and for many years after was still the most widely used WiFi encryption protocol as many routers had it as the default option. In 2007 the WEP was blamed for a hack stealing 45 million credit card numbers from T.J. Maxx. In 2012 (after 11 years of attacks!) it was estimated that it is still used in about a quarter of encrypted wireless networks, and in 2014 it was still the default option on many Verizon home routers. (I don’t know of more recent surveys.) Here we will talk about a different flaw of WEP that is in fact shared by many other protocols, including the first versions of the secure socket layer (SSL) protocol that is used to protect all encrypted web traffic.</p>
<p>To avoid superfluous details we will consider a highly abstract (and somewhat inaccurate) version of WEP that still demonstrates our main point. In this protocol Alice (the user) sends to Bob (the access point) an IP packet that she wants routed somewhere on the internet.</p>
<p>Thus we can think of the message Alice sends to Bob as a string <span><span class="math inline">\(m\in\{0,1\}^\ell\)</span></span> of the form <span><span class="math inline">\(m=(m_1,m_2)\)</span></span> where <span><span class="math inline">\(m_1\)</span></span> is the IP address this packet needs to be routed to and <span><span class="math inline">\(m_2\)</span></span> is the actual message that needs to be delivered. In the WEP protocol, the message that Alice sends to Bob has the form<br />
<span><span class="math inline">\(E_k(m\|\ensuremath{\mathit{CRC}}(m))\)</span></span> (where <span><span class="math inline">\(\|\)</span></span> denotes concatenation and <span><span class="math inline">\(\ensuremath{\mathit{CRC}}(m)\)</span></span> is some cyclic redundancy code). The actual encryption WEP used was RC4, but for us it doesn’t really matter. What does matter is that the encryption has the form <span><span class="math inline">\(E_k(m&#39;) = pad \oplus m&#39;\)</span></span> where <span><span class="math inline">\(pad\)</span></span> is computed as some function of the key. In particular the attack we will describe works even if we use our stronger CPA secure PRF-based scheme where <span><span class="math inline">\(pad=f_k(r)\)</span></span> for some random (or counter) <span><span class="math inline">\(r\)</span></span> that is sent out separately.</p>
<p>Now the security of the encryption means that an adversary seeing the ciphertext <span><span class="math inline">\(c=E_k(m\|crc(m))\)</span></span> will not be able to know <span><span class="math inline">\(m\)</span></span>, but since this is traveling over the air, the adversary could “spoof” the signal and send a different ciphertext <span><span class="math inline">\(c&#39;\)</span></span> to Bob. In particular, if the adversary knows the IP address <span><span class="math inline">\(m_1\)</span></span> that Alice was using (e.g., for example, the adversary can guess that Alice is probably one of the billions of people that visit the website boazbarak.org on a regular basis) then she can XOR the ciphertext with a string of her choosing and hence convert the ciphertext <span><span class="math inline">\(c = pad \oplus (m_1,m_2,\ensuremath{\mathit{CRC}}(m_1,m_2))\)</span></span> into the ciphertext <span><span class="math inline">\(c&#39; = c \oplus x\)</span></span> where <span><span class="math inline">\(x=(x_1,x_2,x_3)\)</span></span> is computed so that <span><span class="math inline">\(x_1 \oplus m_1\)</span></span> is equal to the adversary’s own IP address!</p>
<p>So, the adversary doesn’t need to decrypt the message- by spoofing the ciphertext she can ensure that Bob (who is an access point, and whose job is to decrypt and then deliver packets) simply delivers it unencrypted straight into her hands. One issue is that Eve modifies <span><span class="math inline">\(m_1\)</span></span> then it is unlikely that the CRC code will still check out, and hence Bob would reject the packet. However, <a href="https://goo.gl/5aqEHB">CRC 32</a> - the CRC algorithm used by WEP - is <em>linear</em> modulo <span><span class="math inline">\(2\)</span></span>, which means that for every pair of strings <span><span class="math inline">\(x_1,x_2\)</span></span>, <span><span class="math inline">\(\ensuremath{\mathit{CRC}}(m_1\oplus x_1,m_2 \oplus m_2)=\ensuremath{\mathit{CRC}}(m_1,m_2)\oplus \ensuremath{\mathit{CRC}}(x_1,x_2)\)</span></span>. This means that if the original ciphertext <span><span class="math inline">\(c\)</span></span> was an encryption of the message <span><span class="math inline">\(m=(m_1,m_2,\ensuremath{\mathit{CRC}}(m_1,m_2))\)</span></span> then <span><span class="math inline">\(c&#39;=c \oplus (x_1,0,\ensuremath{\mathit{CRC}}(x_1,0))\)</span></span> will be an encryption of the message <span><span class="math inline">\(m&#39;=(m_1 \oplus x_1, m_2, \ensuremath{\mathit{CRC}}(x_1\oplus m_1,m_2))\)</span></span> (where <span><span class="math inline">\(0\)</span></span> denotes a string of zeroes of the same length as <span><span class="math inline">\(m_2\)</span></span>, and hence <span><span class="math inline">\(m_2 \oplus 0 = m_2\)</span></span>). Therefore by XOR’ing <span><span class="math inline">\(c\)</span></span> with <span><span class="math inline">\((x_1,0,\ensuremath{\mathit{CRC}}(x_1,0))\)</span></span>, the adversary Mallory can ensure that Bob will deliver the message <span><span class="math inline">\(m_2\)</span></span> to the IP address <span><span class="math inline">\(m_1 \oplus x_1\)</span></span> of her choice (see <a href='lec_06_CCA.html#WEPattackfig'>Figure 6.1</a>).</p>
<figure>
<img src="../figure/wep-attack.jpg" id="WEPattackfig" style="width:90.0%" alt="" /><figcaption>6.1: The attack on the WEP protocol allowing the adversary Mallory to read encrypted messages even when Alice uses a CPA secure encryption.</figcaption>
</figure>
<h3 data-number="6.2.2" id="chosen-ciphertext-security-1">Chosen ciphertext security</h3>
<p>This is not an isolated example but in fact an instance of a general pattern of many breaks in practical protocols. Some examples of protocols broken through similar means include <a href="http://www.nds.rub.de/media/nds/veroeffentlichungen/2011/10/22/HowToBreakXMLenc.pdf">XML encryption</a>, <a href="https://www.cs.columbia.edu/~smb/papers/badesp.pdf">IPSec</a> (see also <a href="https://eprint.iacr.org/2005/416">here</a>) as well as JavaServer Faces, Ruby on Rails, ASP.NET, and the Steam gaming client (see the Wikipedia page on <a href="https://goo.gl/b5aKYg">Padding Oracle Attacks</a>).</p>
<p>The point is that often our adversaries can be <em>active</em> and modify the communication between sender and receiver, which in effect gives them access not just to choose <em>plaintexts</em> of their choice to encrypt but even to have some impact on the <em>ciphertexts</em> that are decrypted. This motivates the following notion of security (see also <a href='lec_06_CCA.html#CCAgamefig'>Figure 6.2</a>):</p>
<div id="CCAdef" class="definition" title="CCA security" data-number="6.2.2" name="Definition 6.1 (CCA security) ">
<p>An encryption scheme <span><span class="math inline">\((E,D)\)</span></span> is <em>chosen ciphertext attack (CCA) secure</em> if every efficient adversary <em>Mallory</em> wins in the following game with probability at most <span><span class="math inline">\(1/2+ negl(n)\)</span></span>:<br />
* Mallory gets <span><span class="math inline">\(1^n\)</span></span> where <span><span class="math inline">\(n\)</span></span> is the length of the key<br />
* For <span><span class="math inline">\(poly(n)\)</span></span> rounds, Mallory gets access to the functions <span><span class="math inline">\(m \mapsto E_k(m)\)</span></span> and <span><span class="math inline">\(c \mapsto D_k(c)\)</span></span>.<br />
* Mallory chooses a pair of messages <span><span class="math inline">\(\{ m_0,m_1 \}\)</span></span>, a secret <span><span class="math inline">\(b\)</span></span> is chosen at random in <span><span class="math inline">\(\{0,1\}\)</span></span>, and Mallory gets <span><span class="math inline">\(c^* = E_k(m_b)\)</span></span>.<br />
* Mallory now gets another <span><span class="math inline">\(poly(n)\)</span></span> rounds of access to the functions <span><span class="math inline">\(m \mapsto E_k(m)\)</span></span> and <span><span class="math inline">\(c \mapsto D_k(c)\)</span></span> except that she is not allowed to query <span><span class="math inline">\(c^*\)</span></span> to her second oracle.<br />
* Mallory outputs <span><span class="math inline">\(b&#39;\)</span></span> and <em>wins</em> if <span><span class="math inline">\(b&#39;=b\)</span></span>.</p>
</div>
<figure>
<img src="../figure/cca-game.jpg" id="CCAgamefig" class="margin" alt="" /><figcaption>6.2: The CCA security game.</figcaption>
</figure>
<p>This might seems a rather strange definition so let’s try to digest it slowly. Most people, once they understand what the definition says, don’t like it that much. There are two natural objections to it:</p>
<ul>
<li><strong>This definition seems to be too strong:</strong> There is no way we would let Mallory play with a <em>decryption box</em> - that basically amounts to letting her break the encryption scheme. Sure, she could have some impact on the ciphertexts that Bob decrypts and observe some resulting side effects, but there is a long way from that to giving her oracle access to the decryption algorithm.</li>
</ul>
<p>The response to this is that it is very hard to model what is the “realistic” information Mallory might get about the ciphertexts she might cause Bob to decrypt. The goal of a security definition is not to capture exactly the attack scenarios that occur in real life but rather to be <em>sufficiently conservative</em> so that these real life attacks could be modeled in our game. Therefore, having a too strong definition is not a bad thing (as long as it can be achieved!). The WEP example shows that the definition does capture a practical issue in security and similar attacks on practical protocols have been shown time and again (see for example the discussion of “padding attacks” in Section 3.7.2 of the Katz Lindell book.)</p>
<ul>
<li><strong>This definition seems to be too weak:</strong> What justification do we have for not allowing Mallory to make the query <span><span class="math inline">\(c^*\)</span></span> to the decryption box? After all she is an adversary so she could do whatever she wants. The answer is that the definition would be clearly impossible to achieve if Mallory could simply get the decryption of <span><span class="math inline">\(c^*\)</span></span> and learn whether it was an encryption of <span><span class="math inline">\(m_0\)</span></span> or <span><span class="math inline">\(m_1\)</span></span>. So this restriction is the absolutely minimal one we could make without causing the notion to be obviously impossible. Perhaps surprisingly, it turns out that once we make this minimal restriction, we can in fact construct CCA-secure encryptions.</li>
</ul>
<p><strong>What does CCA have to do with WEP?</strong> The CCA security game is somewhat strange, and it might not be immediately clear whether it has anything to do with the attack we described on the WEP protocol. However, it turns out that using a CCA secure encryption <em>would</em> have prevented that attack. The key is the following claim:</p>
<div id="ccaweplem" class="lemma" data-number="6.2.2" name="Lemma 6.2">
<p>Suppose that <span><span class="math inline">\((E,D)\)</span></span> is a CCA secure encryption. Then, there is no efficient algorithm that given an encryption <span><span class="math inline">\(c\)</span></span> of the plaintext <span><span class="math inline">\((m_1,m_2)\)</span></span> outputs a ciphertext <span><span class="math inline">\(c&#39;\)</span></span> that decrypts to <span><span class="math inline">\((m&#39;_1,m_2)\)</span></span> where <span><span class="math inline">\(m&#39;_1\neq m_1\)</span></span>.</p>
</div>
<p>In particular <a href='lec_06_CCA.html#ccaweplem'>Lemma 6.2</a> rules out the attack of transforming <span><span class="math inline">\(c\)</span></span> that encrypts a message starting with a some address <span><span class="math inline">\(\ensuremath{\mathit{IP}}\)</span></span> to a ciphertext that starts with a different address <span><span class="math inline">\(\ensuremath{\mathit{IP}}&#39;\)</span></span>. Let us now sketch its proof.</p>
<div id="section-1" class="proof" data-ref="ccaweplem" data-number="6.2.2" name="Proof">
<p>We’ll show that such if we had an adversary <span><span class="math inline">\(M&#39;\)</span></span> that violates the conclusion of the claim, then there is an adversary <span><span class="math inline">\(M\)</span></span> that can win in the CCA game.</p>
<p>The proof is simple and relies on the crucial fact that the CCA game allows <span><span class="math inline">\(M\)</span></span> to query the decryption box on <em>any</em> ciphertext of her choice, as long as it’s not <em>exactly identical</em> to the challenge cipertext <span><span class="math inline">\(c^*\)</span></span>. In particular, if <span><span class="math inline">\(M&#39;\)</span></span> is able to morph an encryption <span><span class="math inline">\(c\)</span></span> of <span><span class="math inline">\(m\)</span></span> to some encryption <span><span class="math inline">\(c&#39;\)</span></span> of some different <span><span class="math inline">\(m&#39;\)</span></span> that agrees with <span><span class="math inline">\(m\)</span></span> on some set of bits, then <span><span class="math inline">\(M\)</span></span> can do the following: in the security game, use <span><span class="math inline">\(m_0\)</span></span> to be some random message and <span><span class="math inline">\(m_1\)</span></span> to be this plaintext <span><span class="math inline">\(m\)</span></span>. Then, when receiving <span><span class="math inline">\(c^*\)</span></span>, apply <span><span class="math inline">\(M&#39;\)</span></span> to it to obtain a ciphertext <span><span class="math inline">\(c&#39;\)</span></span> (note that if the plaintext differs then the ciphertext must differ also; can you see why?) ask the decryption box to decrypt it and output <span><span class="math inline">\(1\)</span></span> if the resulting message agrees with <span><span class="math inline">\(m\)</span></span> in the corresponding set of bits (otherwise output a random bit). If <span><span class="math inline">\(M&#39;\)</span></span> was successful with probability <span><span class="math inline">\(\epsilon\)</span></span>, then <span><span class="math inline">\(M\)</span></span> would win in the CCA game with probability at least <span><span class="math inline">\(1/2 + \epsilon/10\)</span></span> or so.</p>
</div>
<div id="section-2" class="pause" data-number="6.2.2" name="Pause">
<p>The proof above is rather sketchy. However it is not very difficult and proving <a href='lec_06_CCA.html#ccaweplem'>Lemma 6.2</a> on your own is an excellent way to ensure familiarity with the definition of CCA security.</p>
</div>
<h2 data-number="6.3" id="constructing-cca-secure-encryption">Constructing CCA secure encryption</h2>
<p>The definition of CCA seems extremely strong, so perhaps it is not surprising that it is useful, but can we actually construct it? The WEP attack shows that the CPA secure encryption we saw before (i.e., <span><span class="math inline">\(E_k(m)=(r,f_k(r)\oplus m)\)</span></span>) is <em>not</em> CCA secure. We will see other examples of <em>non</em> CCA secure encryptions in the exercises. So, how <em>do</em> we construct such a scheme? The WEP attack actually already hints of the crux of CCA security. We want to ensure that Mallory is not able to modify the challenge ciphertext <span><span class="math inline">\(c^*\)</span></span> to some related <span><span class="math inline">\(c&#39;\)</span></span>. Another way to say it is that we need to ensure the <em>integrity</em> of messages to achieve their <em>confidentiality</em> if we want to handle <em>active</em> adversaries that might modify messages on the channel. Since in in a great many practical scenarios, an adversary might be able to do so, this is an important message that deserves to be repeated:</p>
<blockquote>
<p><em>To ensure confidentiality, you need integrity.</em></p>
</blockquote>
<p>This is a lesson that has been time and again been shown and many protocols have been broken due to the mistaken belief that if we only care about <em>secrecy</em>, it is enough to use only <em>encryption</em> (and one that is only CPA secure) and there is no need for <em>authentication</em>. <a href="http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html">Matthew Green</a> writes this more provocatively as</p>
<blockquote>
<p><em>Nearly all of the symmetric encryption modes you learned about in school, textbooks, and Wikipedia are (potentially) insecure.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></em></p>
</blockquote>
<p>exactly because these basic modes only ensure security for <em>passive</em> eavesdropping adversaries and do not ensure chosen ciphertext security which is the “gold standard” for online applications. (For symmetric encryption people often use the name “authenticated encryption” in practice rather than CCA security; those are not identical but are extremely related notions.)</p>
<p>All of this suggests that Message Authentication Codes might help us get CCA security. This turns out to be the case. But one needs to take some care exactly <em>how</em> to use MAC’s to get CCA security. At this point, you might want to stop and think how you would do this…</p>
<div id="section-3" class="pause" data-number="6.3" name="Pause">
<p>You should stop here and try to think how you would implement a CCA secure encryption by combining MAC’s with a CPA secure encryption.</p>
</div>
<div id="section-4" class="pause" data-number="6.3" name="Pause">
<p>If you didn’t stop before, then you should really stop and think now.</p>
</div>
<p>OK, so now that you had a chance to think about this on your own, we will describe one way that works to achieve CCA security from MACs. We will explore other approaches that may or may not work in the exercises.</p>
<div id="CCAfromCPAMACthm" class="theorem" title="CCA from CPA and MAC" data-number="6.3" name="Theorem 6.3 (CCA from CPA and MAC) ">
<p>Let <span><span class="math inline">\((E,D)\)</span></span> be CPA-secure encryption scheme and <span><span class="math inline">\((S,V)\)</span></span> be a CMA-secure MAC with <span><span class="math inline">\(n\)</span></span> bit keys and a canonical verification algorithm.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Then the following encryption <span><span class="math inline">\((E&#39;,D&#39;)\)</span></span> with keys <span><span class="math inline">\(2n\)</span></span> bits is CCA secure:<br />
* <span><span class="math inline">\(E&#39;_{k_1,k_2}(m)\)</span></span> is obtained by computing <span><span class="math inline">\(c=E_{k_1}(m)\)</span></span> , <span><span class="math inline">\(\sigma = S_{k_2}(c)\)</span></span> and outputting <span><span class="math inline">\((c,\sigma)\)</span></span>.<br />
* <span><span class="math inline">\(D&#39;_{k_1,k_2}(c,\sigma)\)</span></span> outputs nothing (e.g., an error message) if <span><span class="math inline">\(V_{k_2}(c,\sigma)\neq 1\)</span></span>, and otherwise outputs <span><span class="math inline">\(D_{k_1}(c)\)</span></span>.</p>
</div>
<div id="section-5" class="proof" data-ref="CCAfromCPAMACthm" data-number="6.3" name="Proof">
<p>Suppose, for the sake of contradiction, that there exists an adversary <span><span class="math inline">\(M&#39;\)</span></span> that wins the CCA game for the scheme <span><span class="math inline">\((E&#39;,D&#39;)\)</span></span> with probability at least <span><span class="math inline">\(1/2+\epsilon\)</span></span>. We consider the following two cases:</p>
<p><strong>Case I:</strong> With probability at least <span><span class="math inline">\(\epsilon/10\)</span></span>, at some point during the CCA game, <span><span class="math inline">\(M&#39;\)</span></span> sends to its decryption box a ciphertext <span><span class="math inline">\((c,\sigma)\)</span></span> that is not identical to one of the ciphertexts it previously obtained from its encryption box, and obtains from it a non-error response.</p>
<p><strong>Case II:</strong> The event above happens with probability smaller than <span><span class="math inline">\(\epsilon/10\)</span></span>.</p>
<p>We will derive a contradiction in either case. In the first case, we will use <span><span class="math inline">\(M&#39;\)</span></span> to obtain an adversary that breaks the MAC <span><span class="math inline">\((S,V)\)</span></span>, while in the second case, we will use <span><span class="math inline">\(M&#39;\)</span></span> to obtain an adversary that breaks the CPA-security of <span><span class="math inline">\((E,D)\)</span></span>.</p>
<p>Let’s start with Case I: When this case holds, we will build an adversary <span><span class="math inline">\(F\)</span></span> (for “forger”) for the MAC <span><span class="math inline">\((S,V)\)</span></span>, we can assume the adversary <span><span class="math inline">\(F\)</span></span> has access to the both signing and verification algorithms as black boxes for some unknown key <span><span class="math inline">\(k_2\)</span></span> that is chosen at random and fixed.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> <span><span class="math inline">\(F\)</span></span> will choose <span><span class="math inline">\(k_1\)</span></span> on its own, and will also choose at random a number <span><span class="math inline">\(i_0\)</span></span> from <span><span class="math inline">\(1\)</span></span> to <span><span class="math inline">\(T\)</span></span>, where <span><span class="math inline">\(T\)</span></span> is the total number of queries that <span><span class="math inline">\(M&#39;\)</span></span> makes to the decryption box. <span><span class="math inline">\(F\)</span></span> will run the entire CCA game with <span><span class="math inline">\(M&#39;\)</span></span>, using <span><span class="math inline">\(k_1\)</span></span> and its access to the black boxes to execute the decryption and decryption boxes, all the way until just before <span><span class="math inline">\(M&#39;\)</span></span> makes the <span><span class="math inline">\(i_0^{th}\)</span></span> query <span><span class="math inline">\((c,\sigma)\)</span></span> to its decryption box. At that point, <span><span class="math inline">\(F\)</span></span> will output <span><span class="math inline">\((c,\sigma)\)</span></span>. We claim that with probability at least <span><span class="math inline">\(\epsilon/(10T)\)</span></span>, our forger will succeed in the CMA game in the sense that <strong>(i)</strong> the query <span><span class="math inline">\((c,\sigma)\)</span></span> will pass verification, and <strong>(ii)</strong> the message <span><span class="math inline">\(c\)</span></span> was not previously queried before to the signing oracle.</p>
<p>Indeed, because we are in Case I, with probability <span><span class="math inline">\(\epsilon/10\)</span></span>, in this game <em>some</em> query that <span><span class="math inline">\(M&#39;\)</span></span> makes will be one that was not asked before and hence was <em>not</em> queried by <span><span class="math inline">\(F\)</span></span> to its signing oracle, and moreover, the returned message is not an error message, and hence the signature passes verification. Since <span><span class="math inline">\(i_0\)</span></span> is random, with probability <span><span class="math inline">\(\epsilon/(10T)\)</span></span> this query will be at the <span><span class="math inline">\(i_0^{th}\)</span></span> round. Let us assume that this above event <span><span class="math inline">\(\ensuremath{\mathit{GOOD}}\)</span></span> happened in which the <span><span class="math inline">\(i_0\)</span></span>-th query to the decryption box is a pair <span><span class="math inline">\((c,\sigma)\)</span></span> that both passes verification and the pair <span><span class="math inline">\((c,\sigma)\)</span></span> was not returned before by the encryption oracle. Since we pass (canonical) verification, we know that <span><span class="math inline">\(\sigma=S_{k_2}(c)\)</span></span>, and because all encryption queries return pairs of the form <span><span class="math inline">\((c&#39;,S_{k_2}(\sigma&#39;))\)</span></span>, this means that no such query returned <span><span class="math inline">\(c\)</span></span> as its first element either. In other words, when the event <span><span class="math inline">\(\ensuremath{\mathit{GOOD}}\)</span></span> happens the <span><span class="math inline">\(i_0\)</span></span>-the query contains a pair <span><span class="math inline">\((c,\sigma)\)</span></span> such that <span><span class="math inline">\(c\)</span></span> was not queried before to the signature box, but <span><span class="math inline">\((c,\sigma)\)</span></span> passes verification. This is the definition of breaking <span><span class="math inline">\((S,V)\)</span></span> in a chosen message attack, and hence we obtain a contradiction to the CMA security of <span><span class="math inline">\((S,V)\)</span></span>.</p>
<p>Now for Case II: In this case, we will build an adversary <span><span class="math inline">\(Eve\)</span></span> for CPA-game in the original scheme <span><span class="math inline">\((E,D)\)</span></span>. As you might expect, the adversary <span><span class="math inline">\(Eve\)</span></span> will choose by herself the key <span><span class="math inline">\(k_2\)</span></span> for the MAC scheme, and attempt to play the CCA security game with <span><span class="math inline">\(M&#39;\)</span></span>. When <span><span class="math inline">\(M&#39;\)</span></span> makes <em>encryption queries</em> this should not be a problem- <span><span class="math inline">\(Eve\)</span></span> can forward the plaintext <span><span class="math inline">\(m\)</span></span> to its encryption oracle to get <span><span class="math inline">\(c=E_{k_1}(m)\)</span></span> and then compute <span><span class="math inline">\(\sigma = S_{k_2}(c)\)</span></span> since she knows the signing key <span><span class="math inline">\(k_2\)</span></span>.</p>
<p>However, what does <span><span class="math inline">\(Eve\)</span></span> do when <span><span class="math inline">\(M&#39;\)</span></span> makes <em>decryption</em> queries? That is, suppose that <span><span class="math inline">\(M&#39;\)</span></span> sends a query of the form <span><span class="math inline">\((c,\sigma)\)</span></span> to its decryption box. To simulate the algorithm <span><span class="math inline">\(D&#39;\)</span></span>, <span><span class="math inline">\(Eve\)</span></span> will need access to a <em>decryption box</em> for <span><span class="math inline">\(D\)</span></span>, but she doesn’t get such a box in the CPA game (This is a subtle point- please pause here and reflect on it until you are sure you understand it!)</p>
<p>To handle this issue <span><span class="math inline">\(Eve\)</span></span> will follow the common approach of “winging it and hoping for the best”. When <span><span class="math inline">\(M&#39;\)</span></span> sends a query of the form <span><span class="math inline">\((c,\sigma)\)</span></span>, <span><span class="math inline">\(Eve\)</span></span> will first check if it happens to be the case that <span><span class="math inline">\((c,\sigma)\)</span></span> was returned before as an answer to an encryption query <span><span class="math inline">\(m\)</span></span>. In this case <span><span class="math inline">\(Eve\)</span></span> will breathe a sigh of relief and simply return <span><span class="math inline">\(m\)</span></span> to <span><span class="math inline">\(M&#39;\)</span></span> as the answer. (This is obviously correct: if <span><span class="math inline">\((c,\sigma)\)</span></span> is the encryption of <span><span class="math inline">\(m\)</span></span> then <span><span class="math inline">\(m\)</span></span> is the decryption of <span><span class="math inline">\((c,\sigma)\)</span></span>.) However, if the query <span><span class="math inline">\((c,\sigma)\)</span></span> has not been returned before as an answer, then <span><span class="math inline">\(Eve\)</span></span> is in a bit of a pickle. The way out of it is for her to simply return “error” and hope that everything will work out. The crucial observation is that because we are in case II things <em>will</em> work out. After all, the only way <span><span class="math inline">\(Eve\)</span></span> makes a mistake is if she returns an error message where the original decryption box would not have done so, but this happens with probability at most <span><span class="math inline">\(\epsilon/10\)</span></span>. Hence, if <span><span class="math inline">\(M&#39;\)</span></span> has success <span><span class="math inline">\(1/2+\epsilon\)</span></span> in the CCA game, then even if it’s the case that <span><span class="math inline">\(M&#39;\)</span></span> always outputs the wrong answer when <span><span class="math inline">\(Eve\)</span></span> makes this mistake, we will still get success at least <span><span class="math inline">\(1/2+0.9\epsilon\)</span></span>. Since <span><span class="math inline">\(\epsilon\)</span></span> is non negligible, this would contradict the CPA security of <span><span class="math inline">\((E,D)\)</span></span> thereby concluding the proof of the theorem.</p>
</div>
<div id="section-6" class="pause" data-number="6.3" name="Pause">
<p>This proof is emblematic of a general principle for proving CCA security. The idea is to show that the decryption box is completely “useless” for the adversary, since the only way to get a non error response from it is to feed it with a ciphertext that was received from the encryption box.</p>
</div>
<h2 data-number="6.4" id="simplified-gcm-encryption">(Simplified) GCM encryption</h2>
<p>The construction above works as a generic construction, but it is somewhat costly in the sense that we need to evaluate both the block cipher and the MAC. In particular, if messages have <span><span class="math inline">\(t\)</span></span> blocks, then we would need to invoke two cryptographic operations (a block cipher encryption and a MAC computation) per block. The <a href="https://goo.gl/uz6WgS">GCM (Galois Counter Mode)</a> is a way around this. We are going to describe a simplified version of this mode. For simplicity, assume that the number of blocks <span><span class="math inline">\(t\)</span></span> is fixed and known (though many of the annoying but important details in block cipher modes of operations involve dealing with padding to multiple of blocks and dealing with variable block size).</p>
<p>A <a href="https://goo.gl/jLpNtU">universal hash function collection</a> is a family of functions <span><span class="math inline">\(\{ h:\{0,1\}^\ell\rightarrow\{0,1\}^n \}\)</span></span> such that for every <span><span class="math inline">\(x \neq x&#39; \in \{0,1\}^\ell\)</span></span>, the random variables <span><span class="math inline">\(h(x)\)</span></span> and <span><span class="math inline">\(h(x&#39;)\)</span></span> (taken over the choice of a random <span><span class="math inline">\(h\)</span></span> from this family) are pairwise independent in <span><span class="math inline">\(\{0,1\}^{2n}\)</span></span>. That is, for every two potential outputs <span><span class="math inline">\(y,y&#39;\in \{0,1\}^n\)</span></span>, <span>
<div class='myequationbox'><span class="math display">\[
\Pr_h[ h(x)=y \;\wedge\; h(x&#39;)=y&#39;]=2^{-2n} \;\;(6.1)
\]</span><a id='equnivhash'></a></div></span></p>
<p>Universal hash functions have rather efficient constructions, and in particular if we relax the definition to allow <em>almost universal</em> hash functions (where we replace the <span><span class="math inline">\(2^{-2n}\)</span></span> factor in the righthand side of <a href='lec_06_CCA.html#equnivhash'>Equation 6.1</a> by a slightly bigger, though still negligible quantity) then the constructions become extremely efficient and the size of the description of <span><span class="math inline">\(h\)</span></span> is only related to <span><span class="math inline">\(n\)</span></span>, no matter how big <span><span class="math inline">\(\ell\)</span></span> is.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
<p>Our encryption scheme is defined as follow. The key is <span><span class="math inline">\((k,h)\)</span></span> where <span><span class="math inline">\(k\)</span></span> is an index to a pseudorandom permutation <span><span class="math inline">\(\{ p_k \}\)</span></span> and <span><span class="math inline">\(h\)</span></span> is the key for a <em>universal hash function</em>.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> To encrypt a message <span><span class="math inline">\(m = (m_1,\ldots,m_t) \in \{0,1\}^{nt}\)</span></span> do the following:</p>
<ul>
<li><p>Choose <span><span class="math inline">\(\ensuremath{\mathit{IV}}\)</span></span> at random in <span><span class="math inline">\([2^n]\)</span></span>.</p></li>
<li><p>Let <span><span class="math inline">\(z_i = E(k,\ensuremath{\mathit{IV}}+i)\)</span></span> for <span><span class="math inline">\(i=1,\ldots,t+1\)</span></span>.</p></li>
<li><p>Let <span><span class="math inline">\(c_i = z_i \oplus m_i\)</span></span>.</p></li>
<li><p>Let <span><span class="math inline">\(c_{t+1} = h(c_1,\ldots,c_t) \oplus z_{t+1}\)</span></span>.</p></li>
<li><p>Output <span><span class="math inline">\((\ensuremath{\mathit{IV}},c_1,\ldots,c_{t+1})\)</span></span>.</p></li>
</ul>
<p>The communication overhead includes one additional output block plus the IV (whose transmission can often be avoided or reduced, depending on the settings; see the notion of “nonce based encryption”). This is fairly minimal. The additional computational cost on top of <span><span class="math inline">\(t\)</span></span> block-cipher evaluation is the application of <span><span class="math inline">\(h(\cdot)\)</span></span>. For the particular choice of <span><span class="math inline">\(h\)</span></span> used in Galois Counter Mode, this function <span><span class="math inline">\(h\)</span></span> can be evaluated very efficiently- at a cost of a single multiplication in the Galois field of size <span><span class="math inline">\(2^{128}\)</span></span> per block (one can think of it as some very particular operation that maps two <span><span class="math inline">\(128\)</span></span> bit strings to a single one, and can be carried out quite efficiently). We leave it as an (excellent!) exercise to prove that the resulting scheme is CCA secure.</p>
<h2 data-number="6.5" id="padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography">Padding, chopping, and their pitfalls: the “buffer overflow” of cryptography</h2>
<p>In this course we typically focus on the simplest case where messages have a <em>fixed size</em>. But in fact, in real life we often need to chop long messages into blocks, or pad messages so that their length becomes an integral multiple of the block size. Moreover, there are several subtle ways to get this wrong, and these have been used in several practical attacks.</p>
<p><strong>Chopping into blocks:</strong> A block cipher a-priori provides a way to encrypt a message of length <span><span class="math inline">\(n\)</span></span>, but we often have much longer messages and need to “chop” them into blocks. This is where the <em>block cipher modes</em> discussed in the previous lecture come in. However, the basic popular modes such as CBC and OFB do <em>not</em> provide security against chosen ciphertext attack, and in fact typically make it easy to <em>extend</em> a ciphertext with an additional block or to <em>remove</em> the last block from a ciphertext, both being operations which should not be feasible in a CCA secure encryption.</p>
<p><strong>Padding:</strong> Oftentimes messages are not an integer multiple of the block size and hence need to be <em>padded</em>. The <em>padding</em> is typically a map that takes the last partial block of the message (i.e., a string <span><span class="math inline">\(m\)</span></span> of length in <span><span class="math inline">\(\{0,\ldots,n-1\}\)</span></span>) and maps it into a full block (i.e., a string <span><span class="math inline">\(m\in\{0,1\}^n\)</span></span>). The map needs to be invertible which in particular means that if the message is already an integer multiple of the block size we will need to add an extra block. (Since we have to map all the <span><span class="math inline">\(1+2+\ldots+2^{n-1}\)</span></span> messages of length <span><span class="math inline">\(1,\ldots,n-1\)</span></span> into the <span><span class="math inline">\(2^n\)</span></span> messages of length <span><span class="math inline">\(n\)</span></span> in a one-to-one fashion.) One approach for doing so is to pad an <span><span class="math inline">\(n&#39;&lt;n\)</span></span> length message with the string <span><span class="math inline">\(10^{n-n&#39;-1}\)</span></span>. Sometimes people use a different padding which involves encoding the length of the pad.</p>
<h2 data-number="6.6" id="chosen-ciphertext-attack-as-implementing-metaphors">Chosen ciphertext attack as implementing metaphors</h2>
<p>The classical “metaphor” for an encryption is a sealed envelope, but as we have seen in the WEP, this metaphor can lead you astray. If you placed a message <span><span class="math inline">\(m\)</span></span> in a sealed envelope, you should not be able to modify it to the message <span><span class="math inline">\(m \oplus m&#39;\)</span></span> without opening the envelope, and yet this is exactly what happens in the canonical CPA secure encryption <span><span class="math inline">\(E_k(m)=(r,f_k(r) \oplus m)\)</span></span>. CCA security comes much closer to realizing the metaphor, and hence is considered as the “gold standard” of secure encryption. This is important even if you do not intend to write poetry about encryption. <em>Formal verification</em> of computer programs is an area that is growing in importance given that computer programs become both more complex and more mission critical. Cryptographic protocols can fail in subtle ways, and even published proofs of security can turn out to have bugs in them. Hence there is a line of research dedicated to finding ways to <em>automatically</em> prove security of cryptographic protocols. Much of these line of research is based on simple models to describe protocols that are known as <em>Dolev Yao models</em>, based on the first paper that proposed such models. These models define an <em>algebraic</em> form of security, where rather than thinking of messages, keys, and ciphertexts as binary string, we think of them as abstract entities. There are certain rules for manipulating these symbols. For example, given a key <span><span class="math inline">\(k\)</span></span> and a message <span><span class="math inline">\(m\)</span></span> you can create the ciphertext <span><span class="math inline">\(\{ m \}_k\)</span></span>, which you can decrypt back to <span><span class="math inline">\(m\)</span></span> using the same key. However the assumption is that any information that cannot be obtained by such manipulation is unknown.</p>
<p>Translating a proof of security in this algebra to a proof for real world adversaries is highly non trivial. However, to have even a fighting chance, the encryption scheme needs to be as strong as possible, and in particular it turns out that security notions such as CCA play a crucial role.</p>
<div id="footnotediv" class="footnotes">
<ol>
<li class="footnote" id="fn:1"><p>
<div>
<p>I also like the part where Green says about a block cipher mode that “if OCB was your kid, he’d play three sports and be on his way to Harvard.” We will have an exercise about a simplified version of the GCM mode (which perhaps only plays a single sport and is on its way to …). You can read about OCB in Exercise 9.14 in the Boneh-Shoup book; it uses the notion of a “tweakable block cipher” which simply means that given a single key <span><span class="math inline">\(k\)</span></span>, you actually get a set <span><span class="math inline">\(\{ p_{k,1},\ldots,p_{k,t} \}\)</span></span> of permutations that are indistinguishable from <span><span class="math inline">\(t\)</span></span> independent random permutation (the set <span><span class="math inline">\(\{1,\ldots, t\}\)</span></span> is called the set of “tweaks” and we sometimes index it using strings instead of numbers).</p>
</div>
<a href="#fnref:1" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:2"><p>
<div>
<p>By a <em>canonical verification algorithm</em> we mean that <span><span class="math inline">\(V_k(m,\sigma)=1\)</span></span> iff <span><span class="math inline">\(S_k(m)=\sigma\)</span></span>.</p>
</div>
<a href="#fnref:2" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:3"><p>
<div>
<p>Since we use a MAC with canonical verification, access to the signature algorithm implies access to the verification algorithm.</p>
</div>
<a href="#fnref:3" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:4"><p>
<div>
<p>In <span><span class="math inline">\(\epsilon\)</span></span>-almost universal hash functions we require that for every <span><span class="math inline">\(y,y&#39;\in \{0,1\}^{n}\)</span></span>, and <span><span class="math inline">\(x\neq x&#39; \in \{0,1\}^\ell\)</span></span>, the probability that <span><span class="math inline">\(h(x)= h(x&#39;)\)</span></span> is at most <span><span class="math inline">\(\epsilon\)</span></span>. It can be easily shown that the analysis below extends to <span><span class="math inline">\(\epsilon\)</span></span> almost universal hash functions as long as <span><span class="math inline">\(\epsilon\)</span></span> is negligible, but we will leave verifying this to the reader.</p>
</div>
<a href="#fnref:4" title="return to article"> ↩</a><p></li>
<li class="footnote" id="fn:5"><p>
<div>
<p>In practice the key <span><span class="math inline">\(h\)</span></span> is derived from the key <span><span class="math inline">\(k\)</span></span> by applying the PRP to some particular input.</p>
</div>
<a href="#fnref:5" title="return to article"> ↩</a><p></li>
</ol>
</div>
<!--bookdown:body:end-->


<!-- end of  actual content -->

<!-- start of comments -->


<a name="commentform"></a>
<h2 id="comments" class="nocount">Comments</h2>

<p>Comments are posted on the <a href="https://github.com/boazbk/crypto/issues">GitHub repository</a> using the <a href="https://utteranc.es">utteranc.es</a> app.
A GitHub login is required to comment.
If you don't want to authorize the app to post on your behalf, you can also comment directly on the <a href="https://github.com/boazbk/crypto/issues?q=+in%3Atitle">GitHub issue for this page</a>.


<p>


<script src="https://utteranc.es/client.js" 
repo="boazbk/crypto" 
issue-term="title" 
label="comments"
theme="github-light" 
crossorigin="anonymous" async>
  </script>


<!-- end of comments -->

<p>Compiled on 07/22/2020 10:34:40</p>

<p>Copyright 2019, Boaz Barak.


<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License"
    style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is
licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons
  Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

<p>Produced using <a href="https://pandoc.org/">pandoc</a> and <a href="http://scorreia.com/software/panflute/">panflute</a> with templates derived from <a href="https://www.gitbook.com/">gitbook</a> and <a href="https://bookdown.org/">bookdown</a>.</p>



</div>


            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->



    </div>
  </div>
<!--bookdown:config-->
<script src="js/app.min.js"></script>
<script src="js/lunr.js"></script>
<script src="js/plugin-search.js"></script>
<script src="js/plugin-sharing.js"></script>
<script src="js/plugin-fontsettings.js"></script>
<script src="js/fullscreen.js"></script>
<script src="js/plugin-bookdown.js"></script>
<script src="js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"history": {
"link": null,
"text": null
},
"download": ["https://files.boazbarak.org/crypto/.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>


</body>

</html>
